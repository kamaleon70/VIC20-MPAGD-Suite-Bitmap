ca65 V2.13.3 - (C) Copyright 1998-2012 Ullrich von Bassewitz
Main file   : game.asm
Current file: game.asm

000000r 1               ;----------------------------------------------
000000r 1               ; Common AGD engine
000000r 1               ; VIC20 conversion by Kees van Oss 2024
000000r 1               ;----------------------------------------------
000000r 1               
000000r 1               .segment "ZEROPAGE"
000000r 1               	.include "game.cfg"
000000r 2               ; Flags saved by AGD Compiler
000000r 2               
000000r 2               mflag = 1 ;
000000r 2               pflag = 0 ;
000000r 2               sflag = 0 ;
000000r 2               dflag = 0 ;
000000r 2               cflag = 0 ;
000000r 2               oflag = 1 ;
000000r 2               lflag = 0 ;
000000r 2               bflag = 0 ;
000000r 2               rflag = 0 ;
000000r 2               kflag = 0 ;
000000r 2               
000000r 1               	.include "engine-zp.inc"
000000r 2               ;----------------------------------------------------------------------
000000r 2               ; AGD 6502 Engine Zero Page Variables
000000r 2               ;----------------------------------------------------------------------
000000r 2               
000000r 2               ; Variables start here.
000000r 2               
000000r 2  xx           scno:	.res 1			; present screen number.
000001r 2  xx           numlif:	.res 1			; number of lives.
000002r 2               
000002r 2  xx           vara:	.res 1			; general-purpose variable.
000003r 2  xx           varb:	.res 1			; general-purpose variable.
000004r 2  xx           varc:	.res 1			; general-purpose variable.
000005r 2  xx           vard:	.res 1			; general-purpose variable.
000006r 2  xx           vare:	.res 1			; general-purpose variable.
000007r 2  xx           varf:	.res 1			; general-purpose variable.
000008r 2  xx           varg:	.res 1			; general-purpose variable.
000009r 2  xx           varh:	.res 1			; general-purpose variable.
00000Ar 2  xx           vari:	.res 1			; general-purpose variable.
00000Br 2  xx           varj:	.res 1			; general-purpose variable.
00000Cr 2  xx           vark:	.res 1			; general-purpose variable.
00000Dr 2  xx           varl:	.res 1			; general-purpose variable.
00000Er 2  xx           varm:	.res 1			; general-purpose variable.
00000Fr 2  xx           varn:	.res 1			; general-purpose variable.
000010r 2  xx           varo:	.res 1			; general-purpose variable.
000011r 2  xx           varp:	.res 1			; general-purpose variable.
000012r 2  xx           varq:	.res 1			; general-purpose variable.
000013r 2  xx           varr:	.res 1			; general-purpose variable.
000014r 2  xx           vars:	.res 1			; general-purpose variable.
000015r 2  xx           vart:	.res 1			; general-purpose variable.
000016r 2  xx           varu:	.res 1			; general-purpose variable.
000017r 2  xx           varv:	.res 1			; general-purpose variable.
000018r 2  xx           varw:	.res 1			; general-purpose variable.
000019r 2  xx           varz:	.res 1			; general-purpose variable.
00001Ar 2               
00001Ar 2  xx           charx:	.res 1			; cursor x position.
00001Br 2  xx           chary:	.res 1			; cursor y position.
00001Cr 2               
00001Cr 2  xx           clock:	.res 1			; last clock reading.
00001Dr 2  xx           varrnd:	.res 1	        ; last random number.
00001Er 2  xx           varobj:	.res 1  	    ; last object number.
00001Fr 2  xx           varopt:	.res 1     		; last option chosen from menu.
000020r 2  xx           varblk:	.res 1  		; block type.
000021r 2  xx           nexlev:	.res 1			; next level flag.
000022r 2  xx           restfl:	.res 1			; restart screen flag.
000023r 2  xx           deadf:	.res 1			; dead flag.
000024r 2  xx           gamwon:	.res 1			; game won flag.
000025r 2  xx           dispx:	.res 1			; cursor x position.
000026r 2  xx           dispy:	.res 1			; cursor y position.
000027r 2               
000027r 2  xx           contrl:	.res 1			; control = keyboard, 1 = Kempston, 2 = Sinclair, 3 = Mouse.
000028r 2  xx           joyval:	.res 1			; joystick reading.
000029r 2  xx           frmno:	.res 1			; selected frame.
00002Ar 2               
00002Ar 2               ;----------------------------------------------------
00002Ar 2               ; Missing vars
00002Ar 2               ;----------------------------------------------------
00002Ar 2               
00002Ar 2  xx           loopa:		.res 1
00002Br 2  xx           loopb:		.res 1
00002Cr 2  xx           loopc:		.res 1
00002Dr 2  xx xx        FontPtr:    .res 2
00002Fr 2               
00002Fr 2               ; Local vars
00002Fr 2               
00002Fr 2  xx xx        scraddr:    .res 2
000031r 2  xx xx        fntaddr:    .res 2
000033r 2  xx xx        tileaddr:   .res 2
000035r 2  xx xx        bufaddr:    .res 2
000037r 2               
000037r 2  xx xx        tmp:        .res 2
000039r 2  xx xx        scr_l:      .res 2
00003Br 2  xx xx        scr_r:      .res 2
00003Dr 2  xx xx        scr_txt:    .res 2
00003Fr 2               
00003Fr 2  xx           xtmp:	    .res 1
000040r 2  xx           spcnt:	    .res 1
000041r 2  xx xx        spptr:	    .res 2		; spawned sprite pointer.
000043r 2  xx           seed:	    .res 1		; seed for random numbers.
000044r 2               
000044r 2  xx           ccnt:       .res 1
000045r 2  xx           flag:	    .res 1
000046r 2  xx           rcol:	    .res 1
000047r 2  xx           rrow:	    .res 1
000048r 2               
000048r 2  xx           combyt:	    .res 1		; byte type compressed.
000049r 2  xx           comcnt:	    .res 1		; compression counter.
00004Ar 2  xx           prtmod:	    .res 1      ; print mode, 0 = standard, 1 = double-height.
00004Br 2  xx           qscnt:	    .res 1
00004Cr 2               
00004Cr 2  xx           sprptr:	    .res 1      ; not a ptr
00004Dr 2  xx           sprcnt:	    .res 1
00004Er 2               
00004Er 2  xx xx        skptr:	    .res 2		; search pointer.
000050r 2  xx           sktptr:	    .res 1      ; not a ptr
000051r 2  xx           tmproom:	.res 1
000052r 2  xx xx        ogptr:	    .res 2		; original sprite pointer.
000054r 2               
000054r 2  xx xx xx     spr:	    .res 3      ; static sprite data
000057r 2  xx           vsync_count:.res 1
000058r 2  xx           colpatt:	.res 1
000059r 2  xx           sprtmp:     .res 1
00005Ar 2  xx           sprtmp2:    .res 1
00005Br 2  xx           sprshft:    .res 1
00005Cr 2               
00005Cr 2  xx           spriteink:  .res 1
00005Dr 2  xx           colour_byte:.res 1
00005Er 2  xx           colour_xor: .res 1
00005Fr 2  xx           objcol:	    .res 1
000060r 2               
000060r 2               .if mflag
000060r 2  xx xx        TmpAddr:	.res 2
000062r 2  xx           bwid:	    .res 1     ; box/menu width.
000063r 2  xx           blen:	    .res 1     ; box/menu height.
000064r 2  xx           btop:	    .res 1     ; box coordinates.
000065r 2  xx           blft:	    .res 1
000066r 2               .endif
000066r 2               
000066r 2               .if pflag
000066r 2               shrctr:	    .res 1
000066r 2               explcnt:	.res 1
000066r 2               seed3:	    .res 1
000066r 2               .endif
000066r 2               
000066r 2               .if aflag
000066r 2               pbptr:      .res 2
000066r 2               .endif
000066r 2               
000066r 2  xx           tmp1:       .res 1
000067r 2  xx           tmp2:       .res 1
000068r 2               
000068r 1               	.include "z80-zp.inc"
000068r 2               ;ws	 = $60
000068r 2               
000068r 2  xx           z80_f: .res 1;	 = ws+$00
000069r 2  xx           z80_a: .res 1;	 = ws+$01
00006Ar 2               z80_af	 = z80_f
00006Ar 2               
00006Ar 2  xx           z80_c: .res 1;	 = ws+$02
00006Br 2  xx           z80_b: .res 1;	 = ws+$03
00006Cr 2               z80_bc	 = z80_c
00006Cr 2               
00006Cr 2  xx           z80_e: .res 1;	 = ws+$04
00006Dr 2  xx           z80_d: .res 1;	 = ws+$05
00006Er 2               z80_de	 = z80_e
00006Er 2               
00006Er 2  xx           z80_l: .res 1;	 = ws+$06
00006Fr 2  xx           z80_h: .res 1;	 = ws+$07
000070r 2               z80_hl	 = z80_l
000070r 2               
000070r 2  xx           z80_x: .res 1;    = ws+$08
000071r 2  xx           z80_i: .res 1;    = ws+$09
000072r 2               z80_ix	 = z80_x
000072r 2               
000072r 2  xx xx        z80_iy: .res 2;	 = ws+$0a
000074r 2               
000074r 2  xx           z80_fp: .res 1;	 = ws+$0c
000075r 2  xx           z80_ap: .res 1;	 = ws+$0d
000076r 2               
000076r 2  xx           z80_cp: .res 1;	 = ws+$0e
000077r 2  xx           z80_bp: .res 1;	 = ws+$0f
000078r 2               z80_bcp	 = z80_cp
000078r 2               
000078r 2  xx           z80_ep: .res 1;	 = ws+$10
000079r 2  xx           z80_dp: .res 1;	 = ws+$11
00007Ar 2               z80_dep	 = z80_ep
00007Ar 2               
00007Ar 2  xx           z80_lp: .res 1;	 = ws+$12
00007Br 2  xx           z80_hp: .res 1;	 = ws+$13
00007Cr 2               z80_hlp	 = z80_lp
00007Cr 2               
00007Cr 2  xx xx        z80_sp: .res 2;   = ws+$14
00007Er 2               
00007Er 2  xx           z80_reg0: .res 1; = ws+$16
00007Fr 2  xx           z80_reg1: .res 1; = ws+$17
000080r 2  xx           z80_reg2: .res 1; = ws+$18
000081r 2  xx           z80_reg3: .res 1; = ws+$19
000082r 2               
000082r 2               ;z80_r: .res 1;	 = ws+$1a
000082r 2               
000082r 1               
000082r 1               ;----------------------------------------------
000082r 1               ; BASIC header
000082r 1               ;----------------------------------------------
000082r 1               
000082r 1               .segment "BASIC"
000000r 1               
000000r 1  rr rr        	.word load
000002r 1  rr rr        load:   .word @end
000004r 1  02 00        	.word 2
000006r 1  9E           	.byte $9e
000007r 1  rr           	.byte .lobyte(main/1000 .mod 10) + $30
000008r 1  rr           	.byte .lobyte(main/100 .mod 10) + $30
000009r 1  rr           	.byte .lobyte(main/10 .mod 10) + $30
00000Ar 1  rr           	.byte .lobyte(main/1 .mod 10) + $30
00000Br 1  00           	.byte 0
00000Cr 1  00 00        @end:   .word 0
00000Er 1               
00000Er 1               ;----------------------------------------------
00000Er 1               
00000Er 1               .segment "CODE"
000000r 1               main:
000000r 1               	.include "game.inc"
000000r 2               .include "testmenu.inc"
000000r 3               ; Game engine code --------------------------------------------------------------
000000r 3               
000000r 3               ; Arcade Game Designer.
000000r 3               ; (C) 2008 Jonathan Cauldwell.
000000r 3               ; ZX Spectrum Next Engine v0.1.
000000r 3               
000000r 3               ; Conditional compilation flags
000000r 3               ; Code is installed if flag is set
000000r 3               ; Flags are set in commandline assembly or by the compiler
000000r 3               
000000r 3               ; Flags set by AGD compiler
000000r 3               ;	mflag  			; MENU + INV
000000r 3               ;	pflag 			; particle engine
000000r 3               ;	sflag 			; scrollytext
000000r 3               ;	dflag 			; digging mode
000000r 3               ;	cflag			; collectable blocks
000000r 3               ;	oflag			; objects
000000r 3               ;	lflag			; ladders
000000r 3               ;
000000r 3               ; Flags set manually
000000r 3               ;	aflag			; adventure mode
000000r 3               ;	bflag			; big sprites (16x24)
000000r 3               ;	fflag			; floppy version (skip #0axx)
000000r 3               ;	gflag			; graphic colour mode
000000r 3               ;	hflag			; hidden sprite mode
000000r 3               ;	iflag			; invert mode
000000r 3               
000000r 3               swrflag = 0
000000r 3               
000000r 3               .if mflag
000000r 3               	.out "- MEN/INV enabled"
000000r 3               .endif
000000r 3               .if pflag
000000r 3               	.out "- Particles enabled"
000000r 3               .endif
000000r 3               .if sflag
000000r 3               	.out "- Scrolling enabled"
000000r 3               .endif
000000r 3               .if dflag
000000r 3               	.out "- Digging enabled"
000000r 3               .endif
000000r 3               .if cflag
000000r 3               	.out "- Collectable blocks enabled"
000000r 3               .endif
000000r 3               .if oflag
000000r 3               	.out "- Objects enabled"
000000r 3               .endif
000000r 3               .if lflag
000000r 3               	.out "- Ladders enabled"
000000r 3               .endif
000000r 3               .if aflag
000000r 3               	.out "- Adventure mode enabled"
000000r 3               .endif
000000r 3               .if bflag
000000r 3               	.out "- Big Sprites (16x24) enabled"
000000r 3               .endif
000000r 3               .if gflag
000000r 3               	.out "- Colourmode enabled"
000000r 3               .endif
000000r 3               .if hflag
000000r 3               	.out "- Hidden sprites/foregroundblocks enabled"
000000r 3               .endif
000000r 3               .if iflag
000000r 3               	.out "- Invert mode enabled"
000000r 3               .endif
000000r 3               .if rflag
000000r 3               	.out "- RAM saving sprites enabled"
000000r 3               .endif
000000r 3               .if xflag
000000r 3               	.out "- Metablocks 16x6"
000000r 3               .endif
000000r 3               
000000r 3               ;------------------------------------------------------------
000000r 3               ; VIC20 check for PAL or NTSC
000000r 3               ;------------------------------------------------------------
000000r 3               
000000r 3               .if modelflag
000000r 3               	ScrWidth	= 22	; PAL settings
000000r 3               	ScrHeight	= 22
000000r 3               	CentreX		= 4
000000r 3               	CentreY		= 28
000000r 3               	timervalue	= 43450	; = 40000 * 1,108/1,02
000000r 3               	.out "- PAL"
000000r 3               .else
000000r 3               	ScrWidth	= 22	; NTSC settings
000000r 3               	ScrHeight	= 22
000000r 3               	CentreX		= 4
000000r 3               	CentreY		= 27
000000r 3               	timervalue	= 25000
000000r 3                	.out "- NTSC"
000000r 3               .endif
000000r 3               .out ""
000000r 3               
000000r 3               ;------------------------------------------------------------
000000r 3               ; Constants MPAGD
000000r 3               ;------------------------------------------------------------
000000r 3               
000000r 3               ; Global definitions
000000r 3               
000000r 3               	FONT 		= font
000000r 3               	MAP 		= MapAddr		; properties map buffer (3x256 bytes)
000000r 3               	SCADTB_lb	= MAP + $300		; Screen address table
000000r 3               	SCADTB_hb	= SCADTB_lb + $100
000000r 3               	SHRAPN 		= SCADTB_hb + $100	; shrapnel table (55x6 bytes)
000000r 3               	COLATTTB_lb	= SHRAPN + 55*6		; Colour attribute address table
000000r 3               	COLATTTB_hb	= COLATTTB_lb + 11
000000r 3               
000000r 3               ; Block characteristics.
000000r 3               
000000r 3               	PLATFM	= 1		; platform.
000000r 3               	WALL	= PLATFM + 1	; solid wall.
000000r 3               	LADDER	= WALL + 1	; ladder.
000000r 3               	FODDER	= LADDER + 1	; fodder block.
000000r 3               	DEADLY	= FODDER + 1	; deadly block.
000000r 3               	CUSTOM	= DEADLY + 1	; custom block.
000000r 3               	WATER	= CUSTOM + 1	; water block.
000000r 3                       COLECT	= WATER + 1	; collectable block.
000000r 3                       NUMTYP	= COLECT + 1	; number of types.
000000r 3               
000000r 3               ; Sprites.
000000r 3               
000000r 3               .if bflag
000000r 3               	SPR_HGT	= 24		; Sprite height
000000r 3               	SPR_WID = 16		; Sprite width
000000r 3               	NUMSPR	= 8		; number of sprites.
000000r 3               .else				; 16x16 sprites
000000r 3               	SPR_HGT = 16		; Sprite height
000000r 3               	SPR_WID = 16		; Sprite width
000000r 3               	NUMSPR	= 12		; number of sprites.
000000r 3               .endif
000000r 3               	TABSIZ = 17			; size of each entry.
000000r 3               	SPRBUF = NUMSPR * TABSIZ; size of entire table.
000000r 3               	NMESIZ = 4			; bytes stored in nmetab for each sprite.
000000r 3               
000000r 3               ; Sprite table variable offsets.
000000r 3               
000000r 3               	var_Type = 0		; sprite type
000000r 3               	var_Image = 1		; sprite time number
000000r 3               	var_Frame = 2		; sprite frame
000000r 3               	var_Y = 3			; sprite y coordinate
000000r 3               	var_X = 4			; sprite X coordinate
000000r 3               
000000r 3               	var_newType = 5		; sprite new type
000000r 3               	var_newImage = 6	; sprite new image number
000000r 3               	var_newFrame = 7	; sprite new frame
000000r 3               	var_newY = 8		; sprite new y coordinate
000000r 3               	var_newX = 9		; sprite new x coordinate
000000r 3               
000000r 3               	var_Direction = 10	; sprite direction
000000r 3               	var_Param1 = 11		; sprite parameter 1
000000r 3               	var_Param2 = 12		; sprite parameter 2
000000r 3               
000000r 3               	var_jumpLo = 13		; sprite jump ptr low
000000r 3               	var_jumpHi = 14		; sprite jump ptr high
000000r 3               	var_dataLo = 15		; sprite data ptr low
000000r 3               	var_dataHi = 16		; sprite data ptr high
000000r 3               
000000r 3               ; Particle engine.
000000r 3               
000000r 3               	NUMSHR = 55			; pieces of shrapnel.
000000r 3               	SHRSIZ = 6			; bytes per particle.
000000r 3               
000000r 3               .if iflag
000000r 3               	TxtInvert   = $ff	; Invert byte for character printing
000000r 3               	ScrFillByte = $ff	; Screen fill byte for CLS
000000r 3               .else
000000r 3               	TxtInvert   = $00	; Invert byte for character printing
000000r 3               	ScrFillByte = $00	; Screen fill byte for CLS
000000r 3               .endif
000000r 3               
000000r 3               	ASCII_NEWLINE = 13
000000r 3               
000000r 3               ;===============================================================
000000r 3               ; Game starts here
000000r 3               ;===============================================================
000000r 3               
000000r 3               ;--------------------------------------------------------------
000000r 3               ; If a font is required...
000000r 3               ;--------------------------------------------------------------
000000r 3               
000000r 3               start:
000000r 3  20 rr rr     	jsr game	 		; start the game.
000003r 3  60           	rts
000004r 3               
000004r 3               ; Don't change the order of these four.
000004r 3               ; Menu routine relies on winlft following wintop.
000004r 3               
000004r 3  00           wintop:	.byte WINDOWTOP		; top of window.
000005r 3  00           winlft:	.byte WINDOWLFT		; left edge.
000006r 3  16           winhgt:	.byte WINDOWHGT		; window height.
000007r 3  16           winwid:	.byte WINDOWWID		; window width.
000008r 3  06           numob:	.byte NUMOBJ		; number of objects in game.
000009r 3               
000009r 3               ; Pixel versions of wintop, winlft, winhgt, winwid.
000009r 3               
000009r 3  00           wntopx:	.byte (8 * WINDOWTOP)
00000Ar 3  00           wnlftx:	.byte (8 * WINDOWLFT)
00000Br 3  A0           wnbotx:	.byte ((WINDOWTOP * 8) + (WINDOWHGT * 8) - 16)
00000Cr 3  9E           wnrgtx:	.byte ((WINDOWLFT * 8) + (WINDOWWID * 8) - 16)-2
00000Dr 3               
00000Dr 3               ; Make sure pointers are arranged in the same order as the data itself.
00000Dr 3               
00000Dr 3  rr rr        frmptr:	.word frmlst        ; sprite frames.
00000Fr 3               
00000Fr 3               ; Assorted game routines which can go in contended memory.
00000Fr 3               
00000Fr 3               ;--------------------------------------------------------------
00000Fr 3               ; Modify for inventory.
00000Fr 3               ; called by the INV command
00000Fr 3               ;
00000Fr 3               ; Input:
00000Fr 3               ;  X   = message nr with objects seperated with ,
00000Fr 3               ;
00000Fr 3               ; Output:
00000Fr 3               ;  OPT = selected line nr of INV menu
00000Fr 3               ;--------------------------------------------------------------
00000Fr 3               
00000Fr 3               .if mflag
00000Fr 3               minve:
00000Fr 3               .if xflag
00000Fr 3               	lda #WINDOWHGT
00000Fr 3               	asl a
00000Fr 3               	sta winhgt
00000Fr 3               	lda #WINDOWWID
00000Fr 3               	asl a
00000Fr 3               	sta winwid
00000Fr 3               .endif
00000Fr 3  A9 rr        	lda #<(invdis)		; routine address.
000011r 3  8D rr rr     	sta mod0+1		; set up menu routine.
000014r 3  8D rr rr     	sta mod2+1		; set up count routine.
000017r 3  A9 rr        	lda #>(invdis)
000019r 3  8D rr rr     	sta mod0+2
00001Cr 3  8D rr rr     	sta mod2+2
00001Fr 3  A9 rr        	lda #<(fopt)		; find option from available objects.
000021r 3  8D rr rr     	sta mod1+1		; set up routine.
000024r 3  A9 rr        	lda #>(fopt)
000026r 3  8D rr rr     	sta mod1+1+1
000029r 3  4C rr rr     	jmp dbox		; do menu routine.
00002Cr 3               
00002Cr 3               ;--------------------------------------------------------------
00002Cr 3               ; Modify for menu.
00002Cr 3               ; called by the MENU command
00002Cr 3               ;
00002Cr 3               ; Input:
00002Cr 3               ;  X   = message nr with menu items seperated with ,
00002Cr 3               ;
00002Cr 3               ; Output:
00002Cr 3               ;  OPT = selected line nr of MENU menu
00002Cr 3               ;--------------------------------------------------------------
00002Cr 3               
00002Cr 3               mmenu:
00002Cr 3  A9 rr        	lda #<(always)		; routine address.
00002Er 3  8D rr rr     	sta mod0+1		; set up routine.
000031r 3  8D rr rr     	sta mod2+1		; set up count routine.
000034r 3  A9 rr        	lda #>(always)
000036r 3  8D rr rr     	sta mod0+2
000039r 3  8D rr rr     	sta mod2+2
00003Cr 3               
00003Cr 3  A9 rr        	lda #<(fstd)		; standard option selection.
00003Er 3  8D rr rr     	sta mod1+1		; set up routine.
000041r 3  A9 rr        	lda #>(fstd)
000043r 3  8D rr rr     	sta mod1+2
000046r 3               
000046r 3               ; Drop through into box routine.
000046r 3               
000046r 3               ;--------------------------------------------------------------
000046r 3               ; Work out size of box for message or menu.
000046r 3               ;--------------------------------------------------------------
000046r 3               
000046r 3               dbox:
000046r 3  A9 rr        	lda #<msgdat		; pointer to messages.
000048r 3  85 rr        	sta z80_l
00004Ar 3  A9 rr        	lda #>msgdat
00004Cr 3  85 rr        	sta z80_h
00004Er 3               
00004Er 3  20 rr rr     	jsr getwrd		; get message number.
000051r 3               
000051r 3  A5 rr        	lda z80_h		; store pointer to message.
000053r 3  85 rr        	sta TmpAddr
000055r 3  A5 rr        	lda z80_l
000057r 3  85 rr        	sta TmpAddr+1
000059r 3               
000059r 3  A9 01        	lda #1			; height.
00005Br 3  85 rr        	sta z80_d
00005Dr 3  A9 00        	lda #0			; start at object zero.
00005Fr 3  85 rr        	sta combyt		; store number of object in combyt.
000061r 3  85 rr        	sta z80_e		; maximum width.
000063r 3               dbox5:
000063r 3  A9 00        	lda #0			; this line"s width.
000065r 3  85 rr        	sta z80_b
000067r 3               mod2:
000067r 3  20 rr rr     	jsr always		; item in player"s possession?
00006Ar 3  C9 FF        	cmp #255
00006Cr 3  D0 02        	bne dbox6		; not in inventory, skip this line.
00006Er 3  E6 rr        	inc z80_d		; add to tally.
000070r 3               dbox6:
000070r 3  A0 00        	ldy #0			; get character.
000072r 3  B1 rr        	lda (z80_hl),y
000074r 3  85 rr        	sta z80_a
000076r 3  E6 rr        	inc z80_l		; next character.
000078r 3  D0 02        	bne :+
00007Ar 3  E6 rr        	inc z80_h
00007Cr 3               :
00007Cr 3  A5 rr        	lda z80_a		; reached end of line?
00007Er 3  C9 2C        	cmp #','
000080r 3  F0 0D        	beq dbox3		; yes.
000082r 3  C9 0D        	cmp #ASCII_NEWLINE
000084r 3  F0 09        	beq dbox3		; yes.
000086r 3  E6 rr        	inc z80_b		; add to this line"s width.
000088r 3  A5 rr        	lda z80_a
00008Ar 3  30 10        	bmi dbox4		; end of message? yes, end count.
00008Cr 3  4C rr rr     	jmp dbox6		; repeat until we find the end.
00008Fr 3               dbox3:
00008Fr 3  A5 rr        	lda z80_e		; maximum line width.
000091r 3  C5 rr        	cmp z80_b		; have we exceeded longest so far?
000093r 3  10 CE        	bpl dbox5		; no, carry on looking.
000095r 3  A5 rr        	lda z80_b		; make this the widest so far.
000097r 3  85 rr        	sta z80_e
000099r 3  4C rr rr     	jmp dbox5		; keep looking.
00009Cr 3               dbox4:
00009Cr 3  A5 rr        	lda z80_e		; maximum line width.
00009Er 3  C5 rr        	cmp z80_b		; have we exceeded longest so far?
0000A0r 3  10 04        	bpl dbox8		; no, carry on looking.
0000A2r 3  A5 rr        	lda z80_b		; final line is the longest so far.
0000A4r 3  85 rr        	sta z80_e
0000A6r 3               dbox8:
0000A6r 3  C6 rr        	dec z80_d		; decrement items found.
0000A8r 3  D0 07        	bne :+			; total was zero.
0000AAr 3  A9 FF        	lda #255
0000ACr 3  85 rr        	sta varopt
0000AEr 3  4C rr rr     	jmp dbox15
0000B1r 3               :
0000B1r 3  A5 rr        	lda z80_e		; longest line.
0000B3r 3  D0 03        	bne :+			; was it zero?
0000B5r 3  4C rr rr     	jmp dbox15		; total was zero.
0000B8r 3               :
0000B8r 3  85 rr        	sta bwid		; set up size.
0000BAr 3  A5 rr        	lda z80_d
0000BCr 3  85 rr        	sta blen
0000BEr 3               
0000BEr 3               ;--------------------------------------------------------------
0000BEr 3               ; That's set up our box size.
0000BEr 3               ;--------------------------------------------------------------
0000BEr 3               
0000BEr 3  AD rr rr     	lda winhgt		; window height in characters.
0000C1r 3  38           	sec
0000C2r 3  E5 rr        	sbc z80_d		; subtract height of box.
0000C4r 3  4A           	lsr a			; divide by 2.
0000C5r 3  18           	clc
0000C6r 3  6D rr rr     	adc wintop		; add top edge of window.
0000C9r 3  85 rr        	sta btop		; set up box top.
0000CBr 3               
0000CBr 3  AD rr rr     	lda winwid		; window width in characters.
0000CEr 3  38           	sec
0000CFr 3  E5 rr        	sbc z80_e		; subtract box width.
0000D1r 3  4A           	lsr a			; divide by 2.
0000D2r 3  18           	clc
0000D3r 3  6D rr rr     	adc winlft		; add left edge of window.
0000D6r 3  85 rr        	sta blft		; box left.
0000D8r 3               
0000D8r 3  A9 rr        	lda #<(FONT-256)		; font.
0000DAr 3  8D rr rr     	sta grbase		; set up for text display.
0000DDr 3  A9 rr        	lda #>(FONT-256)
0000DFr 3  8D rr rr     	sta grbase+1
0000E2r 3               
0000E2r 3  A5 rr        	lda TmpAddr+1		; restore message pointer.
0000E4r 3  85 rr        	sta z80_l
0000E6r 3  A5 rr        	lda TmpAddr
0000E8r 3  85 rr        	sta z80_h
0000EAr 3               
0000EAr 3  A5 rr        	lda btop		; box top.
0000ECr 3  85 rr        	sta dispy		; set display coordinate.
0000EEr 3  A9 00        	lda #0			; start at object zero.
0000F0r 3  85 rr        	sta combyt		; store number of object in combyt.
0000F2r 3               dbox2:
0000F2r 3  A5 rr        	lda combyt		; get object number.
0000F4r 3  85 rr        	sta z80_a
0000F6r 3               mod0:
0000F6r 3  20 rr rr     	jsr always		; check inventory for display.
0000F9r 3  C9 FF        	cmp #255
0000FBr 3  F0 03        	beq :+
0000FDr 3  4C rr rr     	jmp dbox13		; not in inventory, skip this line.
000100r 3               :
000100r 3  A5 rr        	lda blft		; box left.
000102r 3  85 rr        	sta dispx		; set left display position.
000104r 3  A5 rr        	lda bwid		; box width.
000106r 3  85 rr        	sta z80_b		; store width.
000108r 3               dbox0:
000108r 3  A0 00        	ldy #0			; get character.
00010Ar 3  B1 rr        	lda (z80_hl),y
00010Cr 3  C9 2C        	cmp #','		; end of line?
00010Er 3  F0 59        	beq dbox1		; yes, next one.
000110r 3  C9 0D        	cmp #ASCII_NEWLINE			; end of line?
000112r 3  F0 55        	beq dbox1		; yes, next one.
000114r 3               
000114r 3  C9 8D        	cmp #141			; end of line?
000116r 3  D0 05        	bne :+
000118r 3  C6 rr        	dec bwid
00011Ar 3  4C rr rr     	jmp dbox7		; yes, next one.
00011Dr 3               :
00011Dr 3  C6 rr        	dec z80_b		; one less to display.
00011Fr 3  29 7F        	and #127		; remove terminator.
000121r 3               
000121r 3  20 rr rr     	jsr pchr		; display on screen.
000124r 3               
000124r 3  A0 00        	ldy #0
000126r 3  B1 rr        	lda (z80_hl),y		; get character.
000128r 3  85 rr        	sta z80_a
00012Ar 3  E6 rr        	inc z80_l		; next character.
00012Cr 3  D0 02        	bne :+
00012Er 3  E6 rr        	inc z80_h
000130r 3               :
000130r 3  A5 rr        	lda z80_a
000132r 3  C9 80        	cmp #128		; end of message?
000134r 3  30 03        	bmi :+
000136r 3  4C rr rr     	jmp dbox7		; yes, job done.
000139r 3               :
000139r 3  A5 rr        	lda z80_b		; chars remaining.
00013Br 3  F0 03        	beq :+			; are any left?
00013Dr 3  4C rr rr     	jmp dbox0		; yes, continue.
000140r 3               :
000140r 3               ;---------------------------------------------------
000140r 3               ; Reached limit of characters per line.
000140r 3               ;---------------------------------------------------
000140r 3               
000140r 3               dbox9:
000140r 3  A0 00        	ldy #0
000142r 3  B1 rr        	lda (z80_hl),y		; get character.
000144r 3  E6 rr        	inc z80_l		; next one.
000146r 3  D0 02        	bne :+
000148r 3  E6 rr        	inc z80_h
00014Ar 3               :
00014Ar 3  C9 2C        	cmp #','		; another line?
00014Cr 3  F0 24        	beq dbox10		; yes, do next line.
00014Er 3  C9 0D        	cmp #ASCII_NEWLINE	; another line?
000150r 3  F0 20        	beq dbox10		; yes, do next line.
000152r 3  C9 80        	cmp #128		; end of message?
000154r 3  B0 03        	bcs :+
000156r 3  4C rr rr     	jmp dbox11		; yes, finish message.
000159r 3               :
000159r 3  4C rr rr     	jmp dbox9
00015Cr 3               
00015Cr 3               ;---------------------------------------------------
00015Cr 3               ; Fill box to end of line.
00015Cr 3               ;---------------------------------------------------
00015Cr 3               
00015Cr 3               dboxf:
00015Cr 3  A9 20        	lda #32			; space character.
00015Er 3  20 rr rr     	jsr pchr		; display character.
000161r 3  C6 rr        	dec z80_b
000163r 3  F0 03        	beq :+
000165r 3  4C rr rr     	jmp dboxf		; repeat for remaining chars on line.
000168r 3               :
000168r 3  60           	rts
000169r 3               dbox1:
000169r 3  E6 rr        	inc z80_l		; skip character.
00016Br 3  D0 02        	bne :+
00016Dr 3  E6 rr        	inc z80_h
00016Fr 3               :
00016Fr 3  20 rr rr     	jsr dboxf		; fill box out to right side.
000172r 3               dbox10:
000172r 3  E6 rr        	inc dispy		; y coordinate down a line next position.
000174r 3  4C rr rr     	jmp dbox2		; next line.
000177r 3               dbox7:
000177r 3  A5 rr        	lda z80_b		; chars remaining.
000179r 3  D0 03        	bne :+			; are any left?
00017Br 3  4C rr rr     	jmp dbox11		; no, nothing to draw.
00017Er 3               :
00017Er 3  20 rr rr     	jsr dboxf		; fill message to line.
000181r 3               
000181r 3               ;------------------------------------------------------
000181r 3               ; Drawn the box menu, now select option.
000181r 3               ;------------------------------------------------------
000181r 3               
000181r 3               dbox11:
000181r 3  A5 rr        	lda btop		; box top.
000183r 3  85 rr        	sta dispy		; set bar position.
000185r 3               dbox14:
000185r 3  20 rr rr     	jsr joykey		; get controls.
000188r 3  C9 7F        	cmp #$7f		; anything pressed?
00018Ar 3  D0 F9        	bne dbox14		; yes, debounce it.
00018Cr 3  20 rr rr     	jsr dbar		; draw bar.
00018Fr 3               dbox12:
00018Fr 3  20 rr rr     	jsr joykey		; get controls.
000192r 3  C9 7F        	cmp #$7f		; anything pressed?
000194r 3  F0 F9        	beq dbox12		; no, nothing.
000196r 3  29 10        	and #16			; fire button pressed?
000198r 3  D0 03        	bne :+
00019Ar 3               mod1:
00019Ar 3  4C rr rr     	jmp fstd		; yes, job done.
00019Dr 3               :
00019Dr 3  20 rr rr     	jsr dbar		; delete bar.
0001A0r 3               
0001A0r 3  A5 rr        	lda joyval		; joystick reading.
0001A2r 3  29 08        	and #8			; going up?
0001A4r 3  F0 13        	beq dboxu		; yes, go up.
0001A6r 3               
0001A6r 3  A6 rr        	ldx dispy		; vertical position of bar.
0001A8r 3  E8           	inx			; look down.
0001A9r 3  8A           	txa
0001AAr 3  38           	sec
0001ABr 3  E5 rr        	sbc btop		; find distance from top.
0001ADr 3  C5 rr        	cmp blen		; top of box.
0001AFr 3  D0 03        	bne :+
0001B1r 3  4C rr rr     	jmp dbox14		; yes, go no further.
0001B4r 3               :
0001B4r 3  E6 rr        	inc dispy		; move bar.
0001B6r 3  4C rr rr     	jmp dbox14		; continue.
0001B9r 3               dboxu:
0001B9r 3  A5 rr        	lda dispy		; vertical position of bar.
0001BBr 3  C5 rr        	cmp btop		; are we at the top?
0001BDr 3  D0 03        	bne :+
0001BFr 3  4C rr rr     	jmp dbox14		; yes, go no further.
0001C2r 3               :
0001C2r 3  C6 rr        	dec dispy		; move bar.
0001C4r 3  4C rr rr     	jmp dbox14		; continue.
0001C7r 3               fstd:
0001C7r 3  A5 rr        	lda dispy		; bar position.
0001C9r 3  38           	sec
0001CAr 3  E5 rr        	sbc btop		; find selected option.
0001CCr 3  85 rr        	sta varopt		; store the option.
0001CEr 3  4C rr rr     	jmp redraw		; redraw the screen.
0001D1r 3               
0001D1r 3               ;------------------------------------------------------
0001D1r 3               ; Option not available.  Skip this line.
0001D1r 3               ;------------------------------------------------------
0001D1r 3               
0001D1r 3               dbox13:
0001D1r 3  A0 00        	ldy #0
0001D3r 3  B1 rr        	lda (z80_hl),y		; get character.
0001D5r 3  E6 rr        	inc z80_l		; next one.
0001D7r 3               
0001D7r 3  D0 02        	bne :+
0001D9r 3  E6 rr        	inc z80_h
0001DBr 3               :
0001DBr 3  C9 2C        	cmp #','		; another line?
0001DDr 3  D0 03        	bne :+
0001DFr 3  4C rr rr     	jmp dbox2		; yes, do next line.
0001E2r 3               :
0001E2r 3  C9 0D        	cmp #ASCII_NEWLINE			; another line?
0001E4r 3  D0 03        	bne :+
0001E6r 3  4C rr rr     	jmp dbox2		; yes, do next line.
0001E9r 3               :
0001E9r 3               
0001E9r 3  10 03        	bpl :+			; end of message?
0001EBr 3  4C rr rr     	jmp dbox11		; yes, finish message.
0001EEr 3               :
0001EEr 3  4C rr rr     	jmp dbox13
0001F1r 3               dbox15:
0001F1r 3               .if xflag
0001F1r 3               	lda #WINDOWWID
0001F1r 3               	sta winwid
0001F1r 3               	lda #WINDOWHGT
0001F1r 3               	sta winhgt
0001F1r 3               .endif
0001F1r 3  A5 rr        	lda TmpAddr		; pop message pointer from the stack.
0001F3r 3  85 rr        	sta z80_h
0001F5r 3  A5 rr        	lda TmpAddr+1
0001F7r 3  85 rr        	sta z80_l
0001F9r 3  60           	rts
0001FAr 3               
0001FAr 3               ;------------------------------------------------------
0001FAr 3               ; Invert bar
0001FAr 3               ;------------------------------------------------------
0001FAr 3               
0001FAr 3               dbar:
0001FAr 3  A5 rr        	lda blft		; box left.
0001FCr 3  85 rr        	sta dispx		; set display coordinate.
0001FEr 3  20 rr rr     	jsr gprad		; get printing address.
000201r 3               
000201r 3  A5 rr        	lda bwid		; box width.
000203r 3  85 rr        	sta z80_c		; loop counter in c.
000205r 3  A5 rr        	lda z80_h
000207r 3  85 rr        	sta z80_d		; store screen address high byte.
000209r 3               dbar1:
000209r 3  A2 07        	ldx #7			; pixel height in b.
00020Br 3               dbar0:
00020Br 3  BC rr rr     	ldy scrtab,x
00020Er 3  B1 rr        	lda (scraddr),y		; get screen byte.
000210r 3  49 FF        	eor #255		; reverse all bits.
000212r 3  91 rr        	sta (scraddr),y		; write back to screen.
000214r 3  CA           	dex			; next line down.
000215r 3  10 F4        	bpl dbar0		; draw rest of character.
000217r 3               
000217r 3  A5 rr        	lda scraddr
000219r 3  69 10        	adc #16
00021Br 3  85 rr        	sta scraddr
00021Dr 3  90 02        	bcc :+
00021Fr 3  E6 rr        	inc scraddr+1
000221r 3               :
000221r 3  C6 rr        	dec z80_c		; decrement character counter.
000223r 3  D0 E4        	bne dbar1		; repeat for whole line.
000225r 3  60           	rts
000226r 3               
000226r 3               ;------------------------------------------------------
000226r 3               ; Point to object
000226r 3               ;
000226r 3               ; Input:
000226r 3               ;  -
000226r 3               ;
000226r 3               ; Output:
000226r 3               ;  A = object number, A=255 if already in possession
000226r 3               ;------------------------------------------------------
000226r 3               
000226r 3               invdis:
000226r 3  A5 rr        	lda z80_l		; store message text pointer.
000228r 3  48           	pha
000229r 3  A5 rr        	lda z80_h
00022Br 3  48           	pha
00022Cr 3  A5 rr        	lda combyt		; object number.
00022Er 3  E6 rr        	inc combyt		; ready for next one.
000230r 3  20 rr rr     	jsr gotob		; check if we have object.
000233r 3  A8           	tay
000234r 3  68           	pla
000235r 3  85 rr        	sta z80_h
000237r 3  68           	pla
000238r 3  85 rr        	sta z80_l
00023Ar 3  98           	tya
00023Br 3  60           	rts
00023Cr 3               
00023Cr 3               ;------------------------------------------------------
00023Cr 3               ; Find option selected.
00023Cr 3               ;
00023Cr 3               ; Input:
00023Cr 3               ;  -
00023Cr 3               ;
00023Cr 3               ; Output:
00023Cr 3               ;  OPT = selected object
00023Cr 3               ;------------------------------------------------------
00023Cr 3               
00023Cr 3               fopt:
00023Cr 3  A5 rr        	lda dispy
00023Er 3  38           	sec
00023Fr 3  E5 rr        	sbc btop		; find selected option.
000241r 3  85 rr        	sta tmp+2		; option selected in b register.
000243r 3  E6 rr        	inc tmp+2
000245r 3               
000245r 3  A9 00        	lda #0			; set to first item.
000247r 3  85 rr        	sta combyt		; object number.
000249r 3               fopt0:
000249r 3  20 rr rr     	jsr fobj		; find next object in inventory.
00024Cr 3  C6 rr        	dec tmp+2
00024Er 3  D0 F9        	bne fopt0		; repeat for relevant steps down the list.
000250r 3               
000250r 3  A5 rr        	lda combyt		; get option.
000252r 3  85 rr        	sta varopt		; store the option.
000254r 3  C6 rr        	dec varopt		; one less, due to where we increment combyt.
000256r 3  4C rr rr     	jmp redraw		; redraw the screen.
000259r 3               fobj:
000259r 3  A4 rr        	ldy combyt		; object number.
00025Br 3  E6 rr        	inc combyt		; ready for next item.
00025Dr 3  98           	tya
00025Er 3  20 rr rr     	jsr gotob		; do we have this item?
000261r 3  C9 FF        	cmp #255
000263r 3  D0 01        	bne :+
000265r 3  60           	rts
000266r 3               :
000266r 3  4C rr rr     	jmp fobj		; yes, it's on the list.
000269r 3               .endif
000269r 3               
000269r 3               ;----------------------------------------------------
000269r 3               ; Clear sprite table.
000269r 3               ;
000269r 3               ; sprtab[0] - sprtab[SPRBUF-1] = 255
000269r 3               ;----------------------------------------------------
000269r 3               
000269r 3               xspr:
000269r 3  A9 FF        	lda #255		; clear byte.
00026Br 3  A2 00        	ldx #0			; length of table.
00026Dr 3               xspr0:
00026Dr 3  9D rr rr     	sta sprtab,x		; sprite table.
000270r 3  E8           	inx			; move to next byte.
000271r 3  E0 CC        	cpx #SPRBUF
000273r 3  D0 F8        	bne xspr0		; repeat for rest of table.
000275r 3  60           	rts
000276r 3               
000276r 3               ;-------------------------------------------------------------
000276r 3               ; Initialise all objects.
000276r 3               ;
000276r 3               ; Reset current room,y,x to start room,y,x for all objects
000276r 3               ;-------------------------------------------------------------
000276r 3               
000276r 3               .if oflag
000276r 3               iniob:
000276r 3  A9 rr        	lda #<objdta		; objects table.
000278r 3  85 rr        	sta z80_x
00027Ar 3  A9 rr        	lda #>objdta
00027Cr 3  85 rr        	sta z80_i
00027Er 3               
00027Er 3  AE rr rr     	ldx numob 		; number of objects in the game.
000281r 3               iniob0:
000281r 3  A0 24        	ldy #36
000283r 3  B1 rr        	lda (z80_ix),y 		; start screen.
000285r 3  A0 21        	ldy #33
000287r 3  91 rr        	sta (z80_ix),y 		; set start screen.
000289r 3               
000289r 3  A0 25        	ldy #37
00028Br 3  B1 rr        	lda (z80_ix),y 		; find start y.
00028Dr 3  A0 22        	ldy #34
00028Fr 3  91 rr        	sta (z80_ix),y 		; set start y.
000291r 3               
000291r 3  A0 26        	ldy #38
000293r 3  B1 rr        	lda (z80_ix),y 		; get initial x.
000295r 3  A0 23        	ldy #35
000297r 3  91 rr        	sta (z80_ix),y 		; set x coord.
000299r 3               
000299r 3  18           	clc 			; point to next object.
00029Ar 3  A5 rr        	lda z80_x
00029Cr 3  69 27        	adc #39			; distance between objects.
00029Er 3  85 rr        	sta z80_x
0002A0r 3  90 02        	bcc :+
0002A2r 3  E6 rr        	inc z80_i
0002A4r 3               :
0002A4r 3  CA           	dex 			; repeat.
0002A5r 3  D0 DA        	bne iniob0
0002A7r 3               
0002A7r 3  60           	rts
0002A8r 3               .endif
0002A8r 3               
0002A8r 3               ;-----------------------------------------------
0002A8r 3               ; Redraw the screen.
0002A8r 3               ;
0002A8r 3               ; Remove old copy of all sprites for redraw.
0002A8r 3               ;-----------------------------------------------
0002A8r 3               
0002A8r 3               redraw:
0002A8r 3               .if xflag
0002A8r 3               	lda #WINDOWWID
0002A8r 3               	sta winwid
0002A8r 3               	lda #WINDOWHGT
0002A8r 3               	sta winhgt
0002A8r 3               .endif
0002A8r 3  A5 rr        	lda z80_i 		; place sprite pointer on stack.
0002AAr 3  48           	pha
0002ABr 3  A5 rr        	lda z80_x
0002ADr 3  48           	pha
0002AEr 3               
0002AEr 3  20 rr rr     	jsr droom		; show screen layout.
0002B1r 3               .if oflag
0002B1r 3  20 rr rr     	jsr shwob		; draw objects.
0002B4r 3               .endif
0002B4r 3               numsp0:
0002B4r 3  A9 0C        	lda #NUMSPR		; sprites to draw.
0002B6r 3  85 rr        	sta tmp
0002B8r 3               
0002B8r 3  A9 rr        	lda #<sprtab		; sprite table.
0002BAr 3  85 rr        	sta z80_x
0002BCr 3  A9 rr        	lda #>sprtab
0002BEr 3  85 rr        	sta z80_i
0002C0r 3               redrw0:
0002C0r 3  A0 00        	ldy #0
0002C2r 3  B1 rr        	lda (z80_ix),y		; old sprite type.
0002C4r 3  C9 FF        	cmp #255		; is it enabled?
0002C6r 3  F0 0B        	beq redrw1 		; no, find next one.
0002C8r 3               
0002C8r 3  A0 03        	ldy #var_Y
0002CAr 3  B1 rr        	lda (z80_ix),y 		; sprite y.
0002CCr 3  C9 A1        	cmp #SpriteMaxY		; beyond maximum?
0002CEr 3  B0 03        	bcs redrw1		; yes, nothing to draw.
0002D0r 3               
0002D0r 3  20 rr rr     	jsr sspria		; show single sprite.
0002D3r 3               
0002D3r 3               redrw1:
0002D3r 3  18           	clc			; next sprite.
0002D4r 3  A5 rr        	lda z80_x
0002D6r 3  69 11        	adc #TABSIZ		; distance to next odd/even entry.
0002D8r 3  85 rr        	sta z80_x
0002DAr 3  90 02        	bcc :+
0002DCr 3  E6 rr        	inc z80_i
0002DEr 3               :
0002DEr 3  C6 rr        	dec tmp			; repeat for remaining sprites.
0002E0r 3  D0 DE        	bne redrw0
0002E2r 3               
0002E2r 3               rpblc1:
0002E2r 3               ;	jsr dshrp		; redraw shrapnel.
0002E2r 3               
0002E2r 3               .if aflag
0002E2r 3               	jsr rbloc		; draw blocks for this screen
0002E2r 3               .endif
0002E2r 3  68           	pla			; retrieve sprite pointer.
0002E3r 3  85 rr        	sta z80_x
0002E5r 3  68           	pla
0002E6r 3  85 rr        	sta z80_i
0002E8r 3               
0002E8r 3  60           	rts
0002E9r 3               
0002E9r 3               ;----------------------------------------------------------------------
0002E9r 3               ; Clear screen routine.
0002E9r 3               ;
0002E9r 3               ; Fill screenmem $8000-$97ff with ScrFillByte
0002E9r 3               ;----------------------------------------------------------------------
0002E9r 3               
0002E9r 3               cls:
0002E9r 3  A9 10        	lda #>CharAddress	; Character RAM address.
0002EBr 3  8D rr rr     	sta clsloop+2
0002EEr 3               
0002EEr 3  A9 00        	lda #ScrFillByte	; Clear screen
0002F0r 3  A0 00        	ldy #0
0002F2r 3  A2 10        	ldx #16
0002F4r 3               clsloop:
0002F4r 3  99 00 10     	sta CharAddress,y
0002F7r 3  C8           	iny
0002F8r 3  D0 FA        	bne clsloop
0002FAr 3  EE rr rr     	inc clsloop+2
0002FDr 3  CA           	dex
0002FEr 3  D0 F4        	bne clsloop
000300r 3  60           	rts
000301r 3               
000301r 3               ;----------------------------------------------------------------------
000301r 3               ; Clear colour attributes
000301r 3               ;
000301r 3               ; Reset colour attributes to fontcol
000301r 3               ;----------------------------------------------------------------------
000301r 3               
000301r 3               clrcol:
000301r 3  AD rr rr     	lda fontcol		; Clear colour attributes
000304r 3  A2 00        	ldx #0
000306r 3               clscol:
000306r 3  9D 00 96     	sta ColorAttr,x
000309r 3  E8           	inx
00030Ar 3  E0 F2        	cpx #242
00030Cr 3  D0 F8        	bne clscol
00030Er 3               
00030Er 3  60           	rts
00030Fr 3               
00030Fr 3               ;----------------------------------------------------------------------
00030Fr 3               ; FODDER check
00030Fr 3               ;----------------------------------------------------------------------
00030Fr 3               
00030Fr 3               .if pflag .or dflag
00030Fr 3               fdchk:
00030Fr 3               	cmp #FODDER 		; is it fodder?
00030Fr 3               	beq :+
00030Fr 3               	rts 			; no.
00030Fr 3               :
00030Fr 3               	lda #0			; wipe fodder in MAP
00030Fr 3               	ldy #0
00030Fr 3               	sta (bufaddr),y 	; rewrite block type.
00030Fr 3               
00030Fr 3               	lda dispx		; x=x/8
00030Fr 3               	pha
00030Fr 3               	lsr a
00030Fr 3               	lsr a
00030Fr 3               	lsr a
00030Fr 3               	sta dispx
00030Fr 3               
00030Fr 3               	lda dispy		; y=y/8
00030Fr 3               	pha
00030Fr 3               	lsr a
00030Fr 3               	lsr a
00030Fr 3               	lsr a
00030Fr 3               	sta dispy
00030Fr 3               
00030Fr 3               	lda #0 			; block to write.
00030Fr 3               	jsr pattr 		; write block.
00030Fr 3               
00030Fr 3               	pla
00030Fr 3               	sta dispy
00030Fr 3               	pla
00030Fr 3               	sta dispx
00030Fr 3               	rts
00030Fr 3               .endif
00030Fr 3               
00030Fr 3               ;----------------------------------------------------
00030Fr 3               ; Scrolly text and puzzle variables.
00030Fr 3               ;----------------------------------------------------
00030Fr 3               
00030Fr 3               .if sflag
00030Fr 3               txtbit:	.byte 128		; bit to write.
00030Fr 3               txtwid:	.byte 16		; width of ticker message.
00030Fr 3               txtpos:	.word msgdat
00030Fr 3               txtini:	.word msgdat
00030Fr 3               txtscr:	.word ScreenAddr
00030Fr 3               .endif
00030Fr 3               
00030Fr 3               ;----------------------------------------------------
00030Fr 3               ; Specialist routines.
00030Fr 3               ; Process shrapnel.
00030Fr 3               ;----------------------------------------------------
00030Fr 3               proshr:
00030Fr 3               .if pflag
00030Fr 3               	lda #<SHRAPN		; table.
00030Fr 3               	sta z80_x
00030Fr 3               	lda #>SHRAPN
00030Fr 3               	sta z80_i
00030Fr 3               
00030Fr 3               	lda #NUMSHR		; shrapnel pieces to process.
00030Fr 3               	sta shrctr
00030Fr 3               prosh0:
00030Fr 3               	ldy #0
00030Fr 3               	lda (z80_ix),y		; on/off marker.
00030Fr 3               	asl a
00030Fr 3               proshx:
00030Fr 3               	bcs :+
00030Fr 3               	jsr prosh1 		; on, so process it.
00030Fr 3               :
00030Fr 3               	clc
00030Fr 3               	lda z80_x
00030Fr 3               	adc #SHRSIZ
00030Fr 3               	sta z80_x
00030Fr 3               	bcc :+
00030Fr 3               	inc z80_i
00030Fr 3               :
00030Fr 3               	dec shrctr		; round again.
00030Fr 3               	bne prosh0
00030Fr 3               .endif
00030Fr 3               .if sflag
00030Fr 3               	jsr scrly
00030Fr 3               .endif
00030Fr 3  60           	rts
000310r 3               
000310r 3               .if pflag
000310r 3               ;----------------------------------------------------
000310r 3               ; Proces shrapnel piece
000310r 3               ;----------------------------------------------------
000310r 3               
000310r 3               prosh1:
000310r 3               	jsr plot 		; delete the pixel.
000310r 3               
000310r 3               	lda #<shrptr		; shrapnel routine pointers.
000310r 3               	sta z80_l
000310r 3               	lda #>shrptr
000310r 3               	sta z80_h
000310r 3               
000310r 3               	ldy #0
000310r 3               	lda (z80_ix),y		; restore shrapnel type.
000310r 3               	jsr prosh2 		; run the routine.
000310r 3               	jsr chkxy		; check x and y are good before we redisplay.
000310r 3               
000310r 3               	lda #<SHRSIZ 		; distance to next.
000310r 3               	sta z80_e
000310r 3               	lda #>SHRSIZ
000310r 3               	sta z80_d
000310r 3               	rts
000310r 3               
000310r 3               ;----------------------------------------------------
000310r 3               ; Run the routine
000310r 3               ;----------------------------------------------------
000310r 3               
000310r 3               prosh2:
000310r 3               	asl a 			; 2 bytes per address.
000310r 3               	tay
000310r 3               	lda shrptr,y
000310r 3               	sta z80_l
000310r 3               	lda shrptr+1,y 		; fetch high byte from table.
000310r 3               	sta z80_h
000310r 3               	jmp (z80_hl) 		; jump to routine.
000310r 3               
000310r 3               ;----------------------------------------------------
000310r 3               ; Paricle routine table
000310r 3               ;----------------------------------------------------
000310r 3               
000310r 3               shrptr:	.word laser		; laser.
000310r 3               	.word trail		; vapour trail.
000310r 3               	.word shrap		; shrapnel from explosion.
000310r 3               	.word dotl		; horizontal starfield left.
000310r 3               	.word dotr		; horizontal starfield right.
000310r 3               	.word dotu		; vertical starfield up.
000310r 3               	.word dotd		; vertical starfield down.
000310r 3               	.word ptcusr		; user particle.
000310r 3               
000310r 3               ;----------------------------------------------------
000310r 3               ; Explosion shrapnel.
000310r 3               ;----------------------------------------------------
000310r 3               
000310r 3               shrap:
000310r 3               	ldy #1
000310r 3               	lda (z80_ix),y 		; get the angle.
000310r 3               	clc
000310r 3               	adc #<shrsin		; shrapnel sine table.
000310r 3               	sta z80_l
000310r 3               	lda #>shrsin
000310r 3               	adc #0
000310r 3               	sta z80_h
000310r 3               
000310r 3               	ldy #0
000310r 3               	lda (z80_hl),y 		; fetch value from table.
000310r 3               	sta z80_e
000310r 3               	inc z80_l 		; next byte of table.
000310r 3               	bne :+
000310r 3               	inc z80_h
000310r 3               :
000310r 3               	ldy #0
000310r 3               	lda (z80_hl),y		; fetch value from table.
000310r 3               	sta z80_d
000310r 3               	inc z80_l		; next byte of table.
000310r 3               	bne :+
000310r 3               	inc z80_h
000310r 3               :
000310r 3               	ldy #0
000310r 3               	lda (z80_hl),y 		; fetch value from table.
000310r 3               	sta z80_c
000310r 3               	inc z80_l 		; next byte of table.
000310r 3               	bne :+
000310r 3               	inc z80_h
000310r 3               :
000310r 3               	ldy #0
000310r 3               	lda (z80_hl),y 		; fetch value from table.
000310r 3               	sta z80_b
000310r 3               
000310r 3               	ldy #2
000310r 3               	lda (z80_ix),y 		; x coordinate in hl.
000310r 3               	clc
000310r 3               	adc z80_e		; add sine lb
000310r 3               	sta (z80_ix),y		; store new coordinate lb.
000310r 3               	ldy #3
000310r 3               	lda (z80_ix),y
000310r 3               	adc z80_d		; add sine hb
000310r 3               	sta (z80_ix),y		; store new coordinate hb.
000310r 3               
000310r 3               	ldy #4
000310r 3               	lda (z80_ix),y	 	; y coordinate in hl.
000310r 3               	clc
000310r 3               	adc z80_c		; add cosine lb
000310r 3               	sta (z80_ix),y		; store new coordinate lb.
000310r 3               	ldy #5
000310r 3               	lda (z80_ix),y
000310r 3               	adc z80_b		; add cosine lb
000310r 3               	sta (z80_ix),y		; store new coordinate hb.
000310r 3               
000310r 3               	rts
000310r 3               
000310r 3               ;----------------------------------------------------
000310r 3               ; Move dots
000310r 3               ;----------------------------------------------------
000310r 3               
000310r 3               dotl:
000310r 3               	ldy #5
000310r 3               	lda (z80_ix),y
000310r 3               	sec
000310r 3               	sbc #1		 	; move left.
000310r 3               	sta (z80_ix),y
000310r 3               	rts
000310r 3               dotr:
000310r 3               	ldy #5
000310r 3               	lda (z80_ix),y
000310r 3               	clc
000310r 3               	adc #1		 	; move left.
000310r 3               	sta (z80_ix),y
000310r 3               	rts
000310r 3               dotu:
000310r 3               	ldy #3
000310r 3               	lda (z80_ix),y
000310r 3               	sec
000310r 3               	sbc #1		 	; move up.
000310r 3               	sta (z80_ix),y
000310r 3               	rts
000310r 3               dotd:
000310r 3               	ldy #3
000310r 3               	lda (z80_ix),y
000310r 3               	clc
000310r 3               	adc #1			; move down.
000310r 3               	sta (z80_ix),y
000310r 3               	rts
000310r 3               
000310r 3               ;----------------------------------------------------
000310r 3               ; Check if coordinates are ok before redrawing at new position.
000310r 3               ;
000310r 3               ; left:   X>L		X=L	Ok
000310r 3               ; right:  R+15>X	X=R	Ok
000310r 3               ; top:    Y>T		Y=T	Ok
000310r 3               ; bottom: B+15>Y	Y=B	Ok
000310r 3               ;----------------------------------------------------
000310r 3               
000310r 3               chkxy:
000310r 3               
000310r 3               ; top:    Y>T		Y=T	Ok
000310r 3               
000310r 3               	ldy #3
000310r 3               	lda (z80_ix),y	 	; fetch shrapnel coordinate.
000310r 3               	cmp wntopx		; window top.
000310r 3               	bcs :+			; compare with top window limit.
000310r 3               	jmp kilshr		; out of window, kill shrapnel.
000310r 3               :
000310r 3               ; left:   X>L		X=L	Ok
000310r 3               
000310r 3               	ldy #5
000310r 3               	lda (z80_ix),y	 	; fetch shrapnel coordinate.
000310r 3               	cmp wnlftx		; left edge.
000310r 3               	bcs :+			; compare with left window limit.
000310r 3               	jmp kilshr		; out of window, kill shrapnel.
000310r 3               :
000310r 3               ; bottom: B+15>Y	Y=B	Ok
000310r 3               
000310r 3               	lda wnbotx		; point to bottom.
000310r 3               	clc
000310r 3               	adc #15
000310r 3               	ldy #3
000310r 3               	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
000310r 3               	bcs :+			; compare with shrapnel x coordinate.
000310r 3               	jmp kilshr		; off screen, kill shrapnel..
000310r 3               :
000310r 3               ; right:  R+15>X	X=R	Ok
000310r 3               
000310r 3               	lda wnrgtx		; point to right edge.
000310r 3               	clc
000310r 3               	adc #15
000310r 3               	ldy #5
000310r 3               	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
000310r 3               	bcs :+			; compare with window limit.
000310r 3               	jmp kilshr		; off screen, kill shrapnel.
000310r 3               :
000310r 3               
000310r 3               ;----------------------------------------------------
000310r 3               ; Drop through.
000310r 3               ; Display shrapnel.
000310r 3               ;----------------------------------------------------
000310r 3               
000310r 3               plot:
000310r 3               	ldy #3
000310r 3               	lda (z80_ix),y		; y integer.
000310r 3               	sta dispy	 	; workspace coordinates.
000310r 3               	ldy #5
000310r 3               	lda (z80_ix),y	 	; x integer.
000310r 3               	sta dispx 		; workspace coordinates.
000310r 3               
000310r 3               	ldy #0
000310r 3               	lda (z80_ix),y 		; type.
000310r 3               	bne :+			; is it a laser?
000310r 3               	jmp plot1 		; yes, draw laser instead.
000310r 3               :
000310r 3               plot0:
000310r 3               	lda dispx		; which pixel within byte do we
000310r 3               	and #7			; want to set first?
000310r 3               	tay
000310r 3               	lda dots,y 		; table of small pixel positions.
000310r 3               	sta z80_e 		; get value.
000310r 3               
000310r 3               	jsr scadd 		; screen address.
000310r 3               	ldy #0
000310r 3               	lda (scraddr),y		; see what's already there.
000310r 3               	eor z80_e
000310r 3               	sta (scraddr),y 	; put back on screen.
000310r 3               	rts
000310r 3               
000310r 3               plot1:
000310r 3               	jsr scadd 		; screen address.
000310r 3               	ldy #0
000310r 3               	lda (scraddr),y 	; fetch byte there.
000310r 3               	eor #255 		; toggle all bits.
000310r 3               	sta (scraddr),y 	; new byte.
000310r 3               	rts
000310r 3               
000310r 3               ;----------------------------------------------------
000310r 3               ; Switch off shrapnel
000310r 3               ;----------------------------------------------------
000310r 3               
000310r 3               kilshr:
000310r 3               	lda #128
000310r 3               	ldy #0
000310r 3               	sta (z80_ix),y	; switch off shrapnel.
000310r 3               	rts
000310r 3               
000310r 3               ;----------------------------------------------------
000310r 3               ; Sine/cosine table
000310r 3               ;----------------------------------------------------
000310r 3               
000310r 3               shrsin:	.word 0,1024,391,946,724,724,946,391
000310r 3               	.word 1024,0,946,65144,724,64811,391,64589
000310r 3               	.word 0,64512,65144,64589,64811,64811,64589,65144
000310r 3               	.word 64512,0,64589,391,64811,724,65144,946
000310r 3               
000310r 3               ;----------------------------------------------------
000310r 3               ; Create trail
000310r 3               ;----------------------------------------------------
000310r 3               
000310r 3               trail:
000310r 3               	ldy #1
000310r 3               	lda (z80_ix),y 	; time remaining.
000310r 3               	sec
000310r 3               	sbc #1
000310r 3               	sta (z80_ix),y
000310r 3               	bne :+
000310r 3               	jmp trailk		; time to switch it off.
000310r 3               :
000310r 3               	jsr qrand		; get a random number.
000310r 3               	lsr a 			; x or y axis?
000310r 3               	bcc :+
000310r 3               	jmp trailv		; use y.
000310r 3               :
000310r 3               ; Trail horizontal
000310r 3               
000310r 3               	lsr a 			; which direction?
000310r 3               	bcc :+
000310r 3               	jmp traill		; go left.
000310r 3               :
000310r 3               ; Trail right
000310r 3               
000310r 3               	ldy #5
000310r 3               	lda (z80_ix),y
000310r 3               	clc
000310r 3               	adc #1	 		; go right.
000310r 3               	sta (z80_ix),y
000310r 3               	rts
000310r 3               
000310r 3               ; Trail left
000310r 3               
000310r 3               traill:
000310r 3               	ldy #5
000310r 3               	lda (z80_ix),y
000310r 3               	sec
000310r 3               	sbc #1 			; go left.
000310r 3               	sta (z80_ix),y
000310r 3               	rts
000310r 3               
000310r 3               ; Trail vertical
000310r 3               
000310r 3               trailv:
000310r 3               	lsr a		 	; which direction?
000310r 3               	bcc :+
000310r 3               	jmp trailu		; go up.
000310r 3               :
000310r 3               ; Trail down
000310r 3               
000310r 3               	ldy #3
000310r 3               	lda (z80_ix),y
000310r 3               	clc
000310r 3               	adc #1 			; go down.
000310r 3               	sta (z80_ix),y
000310r 3               	rts
000310r 3               
000310r 3               ; Trail up
000310r 3               
000310r 3               trailu:
000310r 3               	ldy #3
000310r 3               	lda (z80_ix),y
000310r 3               	sec
000310r 3               	sbc #1 			; go up.
000310r 3               	sta (z80_ix),y
000310r 3               	rts
000310r 3               
000310r 3               ; Kill trail
000310r 3               
000310r 3               trailk:
000310r 3               	lda #200		; set off-screen to kill vapour trail.
000310r 3               	ldy #3
000310r 3               	sta (z80_ix),y
000310r 3               	rts
000310r 3               
000310r 3               ;----------------------------------------------------
000310r 3               ; Create laser beam
000310r 3               ;----------------------------------------------------
000310r 3               
000310r 3               laser:
000310r 3               	ldy #1
000310r 3               	lda (z80_ix),y 		; direction.
000310r 3               	ror a 			; left or right?
000310r 3               	bcs :+
000310r 3               	jmp laserl		; move left.
000310r 3               :
000310r 3               ; Laser right
000310r 3               
000310r 3               	lda #8			; distance to travel.
000310r 3               	sta z80_b
000310r 3               	jmp laserm		; move laser.
000310r 3               
000310r 3               ; Laser left
000310r 3               
000310r 3               laserl:
000310r 3               	lda #248		; distance to travel.
000310r 3               	sta z80_b
000310r 3               laserm:
000310r 3               	ldy #5
000310r 3               	lda (z80_ix),y		; x position.
000310r 3               	clc
000310r 3               	adc z80_b		; add distance.
000310r 3               	sta (z80_ix),y		; set new x coordinate.
000310r 3               
000310r 3               ; Test new block.
000310r 3               
000310r 3               	sta dispx 		; set x for block collision detection purposes.
000310r 3               	ldy #3
000310r 3               	lda (z80_ix),y 		; get y.
000310r 3               	sta dispy		; set coordinate for collision test.
000310r 3               	jsr tstbl 		; get block type there.
000310r 3               	cmp #WALL		; is it solid?
000310r 3               	bne :+
000310r 3               	jmp trailk		; yes, it cannot pass.
000310r 3               :
000310r 3               .if pflag .or dflag
000310r 3                       cmp #FODDER             ; is it fodder?
000310r 3                       bne :+
000310r 3                       jsr fdchk               ; remove fodder block.
000310r 3                       jmp trailk              ; destroy laser.
000310r 3               :
000310r 3               .endif
000310r 3               	rts
000310r 3               
000310r 3               ;----------------------------------------------------
000310r 3               ; Dots mask
000310r 3               ;----------------------------------------------------
000310r 3               
000310r 3               dots:	.byte 128,64,32,16,8,4,2,1
000310r 3               
000310r 3               
000310r 3               ;----------------------------------------------------
000310r 3               ; Plot, preserving de.
000310r 3               ;----------------------------------------------------
000310r 3               
000310r 3               plotde:
000310r 3               	lda z80_d 		; put de on stack.
000310r 3               	pha
000310r 3               	lda z80_e
000310r 3               	pha
000310r 3               
000310r 3               	jsr plot 		; plot pixel.
000310r 3               
000310r 3               	pla			; restore de from stack.
000310r 3               	sta z80_e
000310r 3               	pla
000310r 3               	sta z80_d
000310r 3               
000310r 3               	rts
000310r 3               
000310r 3               ;----------------------------------------------------
000310r 3               ; Shoot a laser.
000310r 3               ;----------------------------------------------------
000310r 3               
000310r 3               shoot:
000310r 3               	sta z80_c		; store direction in c register.
000310r 3               	ldy #8
000310r 3               	lda (z80_ix),y 		; y coordinate.
000310r 3               	clc
000310r 3               shoot1:
000310r 3               	adc #(SPR_HGT/2-1)	; down 7 pixels.
000310r 3               	sta z80_l 		; puty y coordinate in l.
000310r 3               
000310r 3               	ldy #9
000310r 3               	lda (z80_ix),y 		; x coordinate in h.
000310r 3               	sta z80_h
000310r 3               
000310r 3               	lda z80_i		; store pointer to sprite.
000310r 3               	pha
000310r 3               	lda z80_x
000310r 3               	pha
000310r 3               
000310r 3               	jsr fpslot 		; find particle slot.
000310r 3               	bcs :+
000310r 3               	jmp vapou2		; failed, restore ix.
000310r 3               :
000310r 3               	lda #0
000310r 3               	ldy #0
000310r 3               	sta (z80_ix),y 		; set up a laser.
000310r 3               
000310r 3               	lda z80_c
000310r 3               	ldy #1
000310r 3               	sta (z80_ix),y 		; set the direction.
000310r 3               
000310r 3               	lda z80_l
000310r 3               	ldy #3
000310r 3               	sta (z80_ix),y		; set y coordinate.
000310r 3               
000310r 3               	ror z80_c		; check direction we want.
000310r 3               	bcc :+
000310r 3               	jmp shootr		; shoot right.
000310r 3               :
000310r 3               	lda z80_h		; X position.
000310r 3               shoot0:
000310r 3               	and #248		; align on character boundary.
000310r 3               	ldy #5
000310r 3               	sta (z80_ix),y		; set x coordinate.
000310r 3               	jmp vapou0 		; draw first image.
000310r 3               shootr:
000310r 3               	lda z80_h		; x position.
000310r 3               	clc
000310r 3               	adc #15			; look right.
000310r 3               	jmp shoot0		; align and continue.
000310r 3               
000310r 3               ;----------------------------------------------------
000310r 3               ; Create a bit of vapour trail.
000310r 3               ;----------------------------------------------------
000310r 3               
000310r 3               vapour:
000310r 3               	lda z80_i		; store pointer to sprite.
000310r 3               	pha
000310r 3               	lda z80_x
000310r 3               	pha
000310r 3               
000310r 3               	ldy #8
000310r 3               	lda (z80_ix),y 		; y coordinate.
000310r 3               	clc
000310r 3               vapou3:
000310r 3               	adc #(SPR_HGT/2-1)	; mid-point of sprite.
000310r 3               	sta z80_l
000310r 3               
000310r 3               	ldy #9
000310r 3               	lda (z80_ix),y 		; x coordinate.
000310r 3               	adc #7
000310r 3               	sta z80_h
000310r 3               
000310r 3               	jsr fpslot 		; find particle slot.
000310r 3               	bcc :+
000310r 3               	jmp vapou1		; no, we can use it.
000310r 3               :
000310r 3               vapou2:
000310r 3               	pla
000310r 3               	sta z80_x
000310r 3               	pla
000310r 3               	sta z80_i
000310r 3               	rts
000310r 3               vapou1:
000310r 3               	lda z80_l
000310r 3               	ldy #3
000310r 3               	sta (z80_ix),y		; set up y.
000310r 3               
000310r 3               	lda z80_h
000310r 3               	ldy #5
000310r 3               	sta (z80_ix),y 		; set up x coordinate.
000310r 3               
000310r 3               	jsr qrand		; get quick random number.
000310r 3               	and #15			; random time.
000310r 3               	clc
000310r 3               	adc #15			; minimum time on screen.
000310r 3               	ldy #1
000310r 3               	sta (z80_ix),y		; set time on screen.
000310r 3               
000310r 3               	lda #1
000310r 3               	ldy #0
000310r 3               	sta (z80_ix),y		; define particle as vapour trail.
000310r 3               vapou0:
000310r 3               	jsr chkxy		; plot first position.
000310r 3               	jmp vapou2
000310r 3               
000310r 3               ;----------------------------------------------------
000310r 3               ; Create a user particle.
000310r 3               ;----------------------------------------------------
000310r 3               
000310r 3               ptusr:
000310r 3               	sta z80_f		; store timer.
000310r 3               
000310r 3               	ldy #8
000310r 3               	lda (z80_ix),y 		; y coordinate.
000310r 3               	clc
000310r 3               	adc #7			; mid-point of sprite.
000310r 3               	sta z80_l
000310r 3               
000310r 3               	ldy #9
000310r 3               	lda (z80_ix),y 		; x coordinate.
000310r 3               	clc
000310r 3               	adc #7			; mid-point of sprite.
000310r 3               	sta z80_h
000310r 3               
000310r 3               	jsr fpslot 		; find particle slot.
000310r 3               	bcs ptusr1
000310r 3               	rts 			; out of slots, can't generate anything.
000310r 3               ptusr1:
000310r 3               	lda z80_l
000310r 3               	ldy #3
000310r 3               	sta (z80_ix),y 		; set up y.
000310r 3               
000310r 3               	lda z80_h
000310r 3               	ldy #5
000310r 3               	sta (z80_ix),y		; set up x coordinate.
000310r 3               
000310r 3               	lda z80_f 		; restore timer.
000310r 3               	ldy #1
000310r 3               	sta (z80_ix),y		; set time on screen.
000310r 3               
000310r 3               	lda #7
000310r 3               	ldy #0
000310r 3               	sta (z80_ix),y		; define particle as user particle.
000310r 3               
000310r 3               	jmp chkxy		; plot first position.
000310r 3               
000310r 3               ;----------------------------------------------------
000310r 3               ; Create a vertical or horizontal star.
000310r 3               ;----------------------------------------------------
000310r 3               
000310r 3               star:
000310r 3               	lda z80_i		; store pointer to sprite.
000310r 3               	pha
000310r 3               	lda z80_x
000310r 3               	pha
000310r 3               
000310r 3               	jsr fpslot 		; find particle slot.
000310r 3               	bcs star7		; found one we can use.
000310r 3               star0:
000310r 3               	pla 			; restore sprite pointer.
000310r 3               	sta z80_x
000310r 3               	pla
000310r 3               	sta z80_i
000310r 3               	rts 			; out of slots, can't generate anything.
000310r 3               star7:
000310r 3               	lda z80_c		; direction.
000310r 3               	and #3 			; is it left?
000310r 3               	bne :+
000310r 3               	jmp star1 		; yes, it's left.
000310r 3               :
000310r 3               	cmp #1 			; is it right?
000310r 3               	bne :+
000310r 3               	jmp star2 		; yes, it's right.
000310r 3               :
000310r 3               	cmp #2 			; is it up?
000310r 3               	bne :+
000310r 3               	jmp star3 		; yes, it's up.
000310r 3               :
000310r 3               	ldy wntopx 		; get edge of screen.
000310r 3               	iny			; down one pixel.
000310r 3               	tya
000310r 3               star8:
000310r 3               	ldy #3
000310r 3               	sta (z80_ix),y 		; set y coord.
000310r 3               	jsr qrand 		; get quick random number.
000310r 3               star9:
000310r 3               	ldy #5
000310r 3               	sta (z80_ix),y		; set x position.
000310r 3               
000310r 3               	lda z80_c		; direction.
000310r 3               	and #3			; zero to three.
000310r 3               	clc
000310r 3               	adc #3			; 3 to 6 for starfield.
000310r 3               	ldy #0
000310r 3               	sta (z80_ix),y		; define particle as star.
000310r 3               	jsr chkxy		; plot first position.
000310r 3               	jmp star0
000310r 3               star1:
000310r 3               	jsr qrand		; get quick random number.
000310r 3               	ldy #3
000310r 3               	sta (z80_ix),y 		; set y coord.
000310r 3               
000310r 3               	lda wnrgtx 		; get edge of screen.
000310r 3               	clc
000310r 3               	adc #15			; add width of sprite minus 1.
000310r 3               	jmp star9
000310r 3               star2:
000310r 3               	jsr qrand 		; get quick random number.
000310r 3               	ldy #3
000310r 3               	sta (z80_ix),y		; set y coord.
000310r 3               
000310r 3               	lda wnlftx		; get edge of screen.
000310r 3               	jmp star9
000310r 3               star3:
000310r 3               	lda wnbotx 		; get edge of screen.
000310r 3               	clc
000310r 3               	adc #15 		; height of sprite minus one pixel.
000310r 3               	jmp star8
000310r 3               
000310r 3               ;----------------------------------------------------
000310r 3               ; Find particle slot for lasers or vapour trail.
000310r 3               ; can't use alternate accumulator.
000310r 3               ;----------------------------------------------------
000310r 3               
000310r 3               fpslot:
000310r 3               	lda #<SHRAPN 		; shrapnel table.
000310r 3               	sta z80_x
000310r 3               	lda #>SHRAPN
000310r 3               	sta z80_i
000310r 3               
000310r 3               	lda #NUMSHR		; number of pieces in table.
000310r 3               	sta z80_b
000310r 3               fpslt0:
000310r 3               	ldy #0
000310r 3               	lda (z80_ix),y		; get type.
000310r 3               	asl a  			; is this slot in use?
000310r 3               	bcc :+
000310r 3               	rts			; no, we can use it.
000310r 3               :
000310r 3               	clc			; point to more shrapnel.
000310r 3               	lda z80_x
000310r 3               	adc #SHRSIZ
000310r 3               	sta z80_x
000310r 3               	bcc :+
000310r 3               	inc z80_i
000310r 3               :
000310r 3               	dec z80_b		; repeat for all shrapnel.
000310r 3               	bne fpslt0
000310r 3               
000310r 3               	clc
000310r 3               	rts 			; out of slots, can't generate anything.
000310r 3               
000310r 3               ;----------------------------------------------------
000310r 3               ; Create an explosion at sprite position.
000310r 3               ;----------------------------------------------------
000310r 3               
000310r 3               explod:
000310r 3               	sta z80_c 		; particles to create.
000310r 3               
000310r 3               	lda z80_i 		; store pointer to sprite.
000310r 3               	pha
000310r 3               	lda z80_x
000310r 3               	pha
000310r 3               
000310r 3               	ldy #8
000310r 3               	lda (z80_ix),y 		; y coordinate.
000310r 3               	sta z80_l
000310r 3               	ldy #9
000310r 3               	lda (z80_ix),y		; x coordinate.
000310r 3               	sta z80_h
000310r 3               
000310r 3               	lda #<SHRAPN		; shrapnel table.
000310r 3               	sta z80_x
000310r 3               	lda #>SHRAPN
000310r 3               	sta z80_i
000310r 3               
000310r 3               	lda #NUMSHR		; number of pieces in table.
000310r 3               	sta explcnt
000310r 3               expld0:
000310r 3               	ldy #0
000310r 3               	lda (z80_ix),y		; get type.
000310r 3               	asl a 			; is this slot in use?
000310r 3               	bcs expld1		; no, we can use it.
000310r 3               expld2:
000310r 3               	clc
000310r 3               	lda z80_x
000310r 3               	adc #SHRSIZ
000310r 3               	sta z80_x
000310r 3               	bcc :+
000310r 3               	inc z80_i
000310r 3               :
000310r 3               	dec explcnt		; repeat for all shrapnel.
000310r 3               	bne expld0
000310r 3               expld3:
000310r 3               	pla			; restore sprite pointer.
000310r 3               	sta z80_x
000310r 3               	pla
000310r 3               	sta z80_i
000310r 3               	rts 			; out of slots, can't generate any more.
000310r 3               
000310r 3               expld1:
000310r 3               	lda z80_c		; shrapnel counter.
000310r 3               	and #15			; 0 to 15.
000310r 3               	clc			; add to x.
000310r 3               	adc z80_l
000310r 3               	ldy #3
000310r 3               	sta (z80_ix),y		; y coord.
000310r 3               
000310r 3               	lda seed3 		; crap random number.
000310r 3               	and #15			; 0 to 15.
000310r 3               	clc 			; add to y.
000310r 3               	adc z80_h
000310r 3               	ldy #5
000310r 3               	sta (z80_ix),y		; x coord.
000310r 3               
000310r 3               	lda #2
000310r 3               	ldy #0
000310r 3               	sta (z80_ix),y		; switch it on.
000310r 3               
000310r 3               	jsr chkxy		; plot first position.
000310r 3               	jsr qrand		; quick random angle.
000310r 3               	and #60 		; keep within range.
000310r 3               	ldy #1
000310r 3               	sta (z80_ix),y		; angle.
000310r 3               
000310r 3               	dec z80_c		; one less piece of shrapnel to generate.
000310r 3               	bne expld2 		; back to main explosion loop.
000310r 3               	jmp expld3 		; restore sprite pointer and exit.
000310r 3               
000310r 3               ;----------------------------------------------------
000310r 3               ; Quick random
000310r 3               ;----------------------------------------------------
000310r 3               
000310r 3               qrand:
000310r 3               	jsr random		; r register.
000310r 3               	eor seed3		; combine with seed.
000310r 3               	sta seed3 		; new seed.
000310r 3               	rts
000310r 3               
000310r 3               ;----------------------------------------------------
000310r 3               ; Display all shrapnel.
000310r 3               ;----------------------------------------------------
000310r 3               
000310r 3               dshrp:
000310r 3               	lda #<plotde		; display routine.
000310r 3               	sta proshx+1
000310r 3               	lda #>plotde
000310r 3               	sta proshx+2
000310r 3               	jsr proshr		; process shrapnel.
000310r 3               
000310r 3               	lda #<prosh1		; processing routine.
000310r 3               	sta proshx+1
000310r 3               	lda #>prosh1
000310r 3               	sta proshx+2
000310r 3               	rts
000310r 3               
000310r 3               ;------------------------------------------------------
000310r 3               ; Particle engine.
000310r 3               ;
000310r 3               ; Init particle data for 55 particles in SHRAPN table.
000310r 3               ; Every particle has 6 bytes.
000310r 3               ;
000310r 3               ; global:	-
000310r 3               ; local:	x,y,hl
000310r 3               ; calls:	-
000310r 3               ;------------------------------------------------------
000310r 3               
000310r 3               inishr:
000310r 3               	lda #<SHRAPN 		; table.
000310r 3               	sta z80_l
000310r 3               	lda #>SHRAPN
000310r 3               	sta z80_h
000310r 3               
000310r 3               	ldy #0
000310r 3               	ldx #NUMSHR		; shrapnel pieces to process.
000310r 3               inish0:
000310r 3               	lda #255 		; kill the shrapnel.
000310r 3               	sta (z80_hl),y
000310r 3               
000310r 3               	clc 			; point there.
000310r 3               	lda z80_l
000310r 3               	adc #SHRSIZ		; distance to next.
000310r 3               	sta z80_l
000310r 3               	bcc :+
000310r 3               	inc z80_h
000310r 3               :
000310r 3               	dex
000310r 3               	bne inish0 		; round again.
000310r 3               	rts
000310r 3               
000310r 3               ;------------------------------------------------------
000310r 3               ; Check for collision between laser and sprite.
000310r 3               ;------------------------------------------------------
000310r 3               
000310r 3               lcol:
000310r 3               	lda #<SHRAPN		; shrapnel table.
000310r 3               	sta z80_l
000310r 3               	lda #>SHRAPN
000310r 3               	sta z80_h
000310r 3               
000310r 3               	lda #NUMSHR		; number of pieces in table.
000310r 3               	sta z80_b
000310r 3               lcol0:
000310r 3               	ldy #0
000310r 3               	lda (z80_hl),y 		; get type.
000310r 3               	beq lcol1		; yes, check collision.
000310r 3               lcol3:
000310r 3               	clc			; point to more shrapnel.
000310r 3               	lda z80_l
000310r 3               	adc #SHRSIZ
000310r 3               	sta z80_l
000310r 3               	bcc :+
000310r 3               	inc z80_h
000310r 3               :
000310r 3               	dec z80_b		; repeat for all shrapnel.
000310r 3               	bne lcol0
000310r 3               	clc
000310r 3               	rts 			; no collision, carry not set.
000310r 3               lcol1:
000310r 3               	ldy #3
000310r 3               	lda (z80_hl),y		; get y.
000310r 3               	sec
000310r 3               	ldy #8
000310r 3               	sbc (z80_ix),y		; subtract sprite y.
000310r 3               lcolh:
000310r 3               	cmp #SPR_HGT 		; within range?
000310r 3               	bcc :+
000310r 3               	jmp lcol2		; no, missed.
000310r 3               :
000310r 3               	ldy #5
000310r 3               	lda (z80_hl),y 		; get x.
000310r 3               	sec
000310r 3               	ldy #9
000310r 3               	sbc (z80_ix),y 		; subtract sprite y.
000310r 3               	cmp #16			; within range?
000310r 3               	bcs :+
000310r 3               	jmp lcol4 		; yes, collision occurred.
000310r 3               :
000310r 3               lcol2:
000310r 3               	jmp lcol3
000310r 3               lcol4:
000310r 3               	sec
000310r 3               	rts 			; return with carry set for collision.
000310r 3               .endif
000310r 3               
000310r 3               ;------------------------------------------------------
000310r 3               ; Main game engine code starts here.
000310r 3               ; After initialisation, mloop is the main loop
000310r 3               ;------------------------------------------------------
000310r 3               
000310r 3               game:
000310r 3               
000310r 3               ; Set up screen address table.
000310r 3               
000310r 3               setsat:
000310r 3  A9 00        	lda #<CharAddress	; start of screen.
000312r 3  85 rr        	sta scraddr
000314r 3  A9 10        	lda #>CharAddress
000316r 3  85 rr        	sta scraddr+1
000318r 3               
000318r 3  A0 00        	ldy #0			; vertical lines on screen.
00031Ar 3               setsa0:
00031Ar 3  A5 rr        	lda scraddr
00031Cr 3  99 00 07     	sta SCADTB_lb,y		; write low byte.
00031Fr 3  A5 rr        	lda scraddr+1
000321r 3  99 00 08     	sta SCADTB_hb,y		; write high byte.
000324r 3  20 rr rr     	jsr nline		; next line down.
000327r 3  C8           	iny			; next position in table.
000328r 3  D0 F0        	bne setsa0
00032Ar 3               
00032Ar 3               ; Set up colour address table
00032Ar 3               
00032Ar 3               setsof:
00032Ar 3  A9 00        	lda #<ColorAttr		; start of colour attributes
00032Cr 3  85 rr        	sta bufaddr
00032Er 3  A9 96        	lda #>ColorAttr
000330r 3  85 rr        	sta bufaddr+1
000332r 3               
000332r 3  A0 00        	ldy #0			; vertical lines on screen.
000334r 3               setof0:
000334r 3  A5 rr        	lda bufaddr
000336r 3  99 4A 0A     	sta COLATTTB_lb,y	; write low byte.
000339r 3  A5 rr        	lda bufaddr+1
00033Br 3  99 55 0A     	sta COLATTTB_hb,y	; write high byte.
00033Er 3  18           	clc			; next line down.
00033Fr 3  A5 rr        	lda bufaddr
000341r 3  69 16        	adc #ScrWidth
000343r 3  85 rr        	sta bufaddr
000345r 3  90 02        	bcc :+
000347r 3  E6 rr        	inc bufaddr+1
000349r 3               :
000349r 3  C8           	iny			; next position in table.
00034Ar 3  C0 0B        	cpy #ScrHeight/2
00034Cr 3  D0 E6        	bne setof0
00034Er 3               
00034Er 3               ; Init graphics mode
00034Er 3               
00034Er 3  20 rr rr     	jsr init
000351r 3               
000351r 3               ; Init joysticks
000351r 3  20 rr rr     	jsr joyinit		; VIC20 joystick
000354r 3               
000354r 3               rpblc2:
000354r 3               .if pflag
000354r 3               	jsr inishr 		; initialise particle engine.
000354r 3               .endif
000354r 3               evintr:
000354r 3  20 rr rr     	jsr evnt12 		; call intro/menu event.
000357r 3               
000357r 3  A9 02        	lda #WALL 		; write default property.
000359r 3  A2 00        	ldx #0
00035Br 3               clrmap:
00035Br 3  9D 00 04     	sta MAP,x 		; block properties.
00035Er 3  9D 00 05     	sta MAP+256,x
000361r 3  E8           	inx
000362r 3  D0 F7        	bne clrmap
000364r 3               
000364r 3               .if oflag
000364r 3  20 rr rr     	jsr iniob 		; initialise objects.
000367r 3               .endif
000367r 3  A9 00        	lda #0			; put zero in accumulator.
000369r 3  85 rr        	sta gamwon		; reset game won flag.
00036Br 3               
00036Br 3  20 rr rr     	jsr inisc 		; init the score.
00036Er 3               mapst:
00036Er 3  AD rr rr     	lda stmap 		; start position on map.
000371r 3  8D rr rr     	sta roomtb		; set up position in table, if there is one.
000374r 3               
000374r 3               inipbl:
000374r 3               .if aflag
000374r 3               	lda #<eop		; reset blockpointer
000374r 3               	sta pbptr
000374r 3               	lda #>eop
000374r 3               	sta pbptr+1
000374r 3               .endif
000374r 3  20 rr rr     	jsr initsc 		; set up first screen.
000377r 3               
000377r 3  A9 rr        	lda #<ssprit 		; default to spare sprite in table.
000379r 3  85 rr        	sta z80_x
00037Br 3  A9 rr        	lda #>ssprit
00037Dr 3  85 rr        	sta z80_i
00037Fr 3               evini:
00037Fr 3  20 rr rr     	jsr evnt13 		; initialisation.
000382r 3               
000382r 3               ; Two restarts.
000382r 3               ; First restart - clear all sprites and initialise everything.
000382r 3               
000382r 3               rstrt:
000382r 3  20 rr rr     	jsr rsevt 		; restart events.
000385r 3  20 rr rr     	jsr xspr 		; clear sprite table.
000388r 3  20 rr rr     	jsr sprlst 		; fetch pointer to screen sprites.
00038Br 3  20 rr rr     	jsr ispr 		; initialise sprite table.
00038Er 3  4C rr rr     	jmp rstrt0
000391r 3               
000391r 3               ; Second restart - clear all but player, and don't initialise him.
000391r 3               
000391r 3               rstrtn:
000391r 3  20 rr rr     	jsr rsevt		; restart events.
000394r 3  20 rr rr     	jsr nspr 		; clear all non-player sprites.
000397r 3  20 rr rr     	jsr sprlst 		; fetch pointer to screen sprites.
00039Ar 3  20 rr rr     	jsr kspr 		; initialise sprite table, no more players.
00039Dr 3               
00039Dr 3               ; Set up the player and/or enemy sprites.
00039Dr 3               
00039Dr 3               rstrt0:
00039Dr 3  A9 00        	lda #0 			; zero in accumulator.
00039Fr 3  85 rr        	sta nexlev 		; reset next level flag.
0003A1r 3  85 rr        	sta restfl 		; reset restart flag.
0003A3r 3  85 rr        	sta deadf 		; reset dead flag.
0003A5r 3               
0003A5r 3  20 rr rr     	jsr droom 		; show screen layout.
0003A8r 3               rpblc0:
0003A8r 3               .if pflag
0003A8r 3               	jsr inishr 		; initialise particle engine.
0003A8r 3               .endif
0003A8r 3               .if aflag
0003A8r 3               	jsr rbloc		; draw blocks for this screen
0003A8r 3               .endif
0003A8r 3               .if oflag
0003A8r 3  20 rr rr     	jsr shwob		; draw objects.
0003ABr 3               .endif
0003ABr 3               
0003ABr 3  A9 rr        	lda #<sprtab 		; address of sprite table, even sprites.
0003ADr 3  85 rr        	sta z80_x
0003AFr 3  A9 rr        	lda #>sprtab
0003B1r 3  85 rr        	sta z80_i
0003B3r 3  20 rr rr     	jsr dspr 		; display sprites.
0003B6r 3  A9 rr        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
0003B8r 3  85 rr        	sta z80_x
0003BAr 3  A9 rr        	lda #>(sprtab+TABSIZ)
0003BCr 3  85 rr        	sta z80_i
0003BEr 3  20 rr rr     	jsr dspr 		; display sprites.
0003C1r 3               mloop:
0003C1r 3  20 rr rr     	jsr vsync 		; synchronise with display.
0003C4r 3               
0003C4r 3  A9 rr        	lda #<sprtab 		; address of sprite table, even sprites.
0003C6r 3  85 rr        	sta z80_x
0003C8r 3  A9 rr        	lda #>sprtab
0003CAr 3  85 rr        	sta z80_i
0003CCr 3  20 rr rr     	jsr dspr 		; display even sprites.
0003CFr 3               
0003CFr 3               ;	jsr plsnd 		; play sounds.
0003CFr 3  20 rr rr     	jsr vsync 		; synchronise with display.
0003D2r 3  20 rr rr     	jsr proshr
0003D5r 3               
0003D5r 3  A9 rr        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
0003D7r 3  85 rr        	sta z80_x
0003D9r 3  A9 rr        	lda #>(sprtab+TABSIZ)
0003DBr 3  85 rr        	sta z80_i
0003DDr 3  20 rr rr     	jsr dspr 		; display odd sprites.
0003E0r 3               
0003E0r 3  A9 rr        	lda #<(ssprit) 		; point to spare sprite for spawning purposes.
0003E2r 3  85 rr        	sta z80_x
0003E4r 3  A9 rr        	lda #>(ssprit)
0003E6r 3  85 rr        	sta z80_i
0003E8r 3               evlp1:
0003E8r 3  20 rr rr     	jsr evnt10 		; called once per main loop.
0003EBr 3  20 rr rr     	jsr pspr 		; process sprites.
0003EEr 3               
0003EEr 3               ; Main loop events.
0003EEr 3               
0003EEr 3  A9 rr        	lda #<ssprit 		; point to spare sprite for spawning purposes.
0003F0r 3  85 rr        	sta z80_x
0003F2r 3  A9 rr        	lda #>ssprit
0003F4r 3  85 rr        	sta z80_i
0003F6r 3               evlp2:
0003F6r 3  20 rr rr     	jsr evnt11 		; called once per main loop.
0003F9r 3               bsortx:
0003F9r 3  20 rr rr     	jsr bsort 		; sort sprites.
0003FCr 3               
0003FCr 3  A5 rr        	lda nexlev		; finished level flag.
0003FEr 3  D0 1F        	bne newlev		; is set, go to next level.
000400r 3  A5 rr        	lda gamwon		; finished game flag.
000402r 3  D0 2A        	bne evwon		; is set, finish the game.
000404r 3  A5 rr        	lda restfl 		; finished level flag.
000406r 3  C9 01        	cmp #1			; has it been set?
000408r 3  D0 03        	bne :+
00040Ar 3  4C rr rr     	jmp rstrt		; yes, go to next level.
00040Dr 3               :
00040Dr 3  C9 02        	cmp #2			; has it been set?
00040Fr 3  D0 03        	bne :+
000411r 3  4C rr rr     	jmp rstrtn		; yes, go to next level.
000414r 3               :
000414r 3  A5 rr        	lda deadf 		; dead flag.
000416r 3  D0 1C        	bne pdead		; yes, player dead.
000418r 3               
000418r 3               ; back to start of main loop.
000418r 3               
000418r 3  E6 rr        	inc frmno
00041Ar 3  E6 rr        	inc clock
00041Cr 3  4C rr rr     	jmp mloop		; switched to a jmp mloop during test mode.
00041Fr 3               
00041Fr 3               ;----------------------------------------------------------
00041Fr 3               ; Read blocks from list and update screen accordingly.
00041Fr 3               ;----------------------------------------------------------
00041Fr 3               
00041Fr 3               .if aflag
00041Fr 3               rbloc:
00041Fr 3               	lda #<eop		; reset blockpointer
00041Fr 3               	sta pbbuf
00041Fr 3               	lda #>eop
00041Fr 3               	sta pbbuf+1
00041Fr 3               
00041Fr 3               rbloc2:
00041Fr 3               	lda pbbuf			; check for last block
00041Fr 3               	cmp pbptr
00041Fr 3               	bne rbloc1
00041Fr 3               	lda pbbuf+1
00041Fr 3               	cmp pbptr+1
00041Fr 3               	bne rbloc1
00041Fr 3               	rts
00041Fr 3               rbloc1:
00041Fr 3               	ldy #0
00041Fr 3               	lda (pbbuf),y		; check if block for this scno
00041Fr 3               	cmp scno
00041Fr 3               	bne rbloc0		; if not, skip
00041Fr 3               	iny
00041Fr 3               	lda (pbbuf),y		; get y
00041Fr 3               	sta dispy
00041Fr 3               	iny
00041Fr 3               	lda (pbbuf),y		; get x
00041Fr 3               	sta dispx
00041Fr 3               	iny
00041Fr 3               	lda (pbbuf),y		; get blocknr
00041Fr 3               	jsr pattr2		; draw block
00041Fr 3               rbloc0:
00041Fr 3               	clc			; point to next block
00041Fr 3               	lda pbbuf
00041Fr 3               	adc #4
00041Fr 3               	sta pbbuf
00041Fr 3               	bcc rbloc2
00041Fr 3               	inc pbbuf+1
00041Fr 3               	jmp rbloc2
00041Fr 3               .endif
00041Fr 3               
00041Fr 3               ;----------------------------------------------------------
00041Fr 3               ; New level
00041Fr 3               ;----------------------------------------------------------
00041Fr 3               
00041Fr 3               newlev:
00041Fr 3  A5 rr        	lda scno 			; current screen.
000421r 3  18           	clc
000422r 3  69 01        	adc #1				; next screen.
000424r 3  CD rr rr     	cmp numsc 			; total number of screens.
000427r 3  B0 05        	bcs evwon			; yes, game finished.
000429r 3  85 rr        	sta scno			; set new level number.
00042Br 3  4C rr rr     	jmp rstrt			; restart, clearing all aliens.
00042Er 3               
00042Er 3               evwon:
00042Er 3  20 rr rr     	jsr evnt18		 	; game completed.
000431r 3  4C rr rr     	jmp tidyup			; tidy up and return to BASIC/calling routine.
000434r 3               
000434r 3               ;----------------------------------------------------------
000434r 3               ; Player dead.
000434r 3               ;----------------------------------------------------------
000434r 3               
000434r 3               pdead:
000434r 3  A9 00        	lda #0				; zeroise accumulator.
000436r 3  85 rr        	sta deadf			; reset dead flag.
000438r 3               evdie:
000438r 3  20 rr rr     	jsr evnt16 			; death subroutine.
00043Br 3  A5 rr        	lda numlif			; number of lives.
00043Dr 3  F0 03        	beq :+
00043Fr 3  4C rr rr     	jmp rstrt 			; restart game.
000442r 3               :
000442r 3               evfail:
000442r 3  20 rr rr     	jsr evnt17 			; failure event.
000445r 3  4C rr rr     	jmp game			; restart game
000448r 3               
000448r 3               ;----------------------------------------------------------
000448r 3               ; Tidy things up
000448r 3               ;----------------------------------------------------------
000448r 3               
000448r 3               tidyup:
000448r 3  A0 00        	ldy #0				; digits to check.
00044Ar 3               tidyu2:
00044Ar 3  B9 rr rr     	lda score,y 			; get score digit.
00044Dr 3  CD rr rr     	cmp hiscor 			; are we larger than high score digit?
000450r 3  90 07        	bcc tidyu0			; high score is bigger.
000452r 3  D0 0E        	bne tidyu1			; score is greater, record new high score.
000454r 3  C8           	iny				; next digit of high score.
000455r 3  C0 06        	cpy #6
000457r 3  D0 F1        	bne tidyu2			; repeat for all digits
000459r 3               tidyu0:
000459r 3  A9 rr        	lda #<score			; return pointing to score.
00045Br 3  85 rr        	sta z80_c
00045Dr 3  A9 rr        	lda #>score
00045Fr 3  85 rr        	sta z80_b
000461r 3  60           	rts
000462r 3               tidyu1:
000462r 3  A0 05        	ldy #5
000464r 3               tidyu3:
000464r 3  B9 rr rr     	lda score,y			; score.
000467r 3  99 rr rr     	sta hiscor,y			; high score.
00046Ar 3  88           	dey
00046Br 3  10 F7        	bpl tidyu3 			; copy score to high score.
00046Dr 3               evnewh:
00046Dr 3  20 rr rr     	jsr evnt19			; new high score event.
000470r 3  4C rr rr     	jmp tidyu0			; tidy up.
000473r 3               
000473r 3               ;--------------------------------------------------
000473r 3               ; Restart event.
000473r 3               ;--------------------------------------------------
000473r 3               
000473r 3               rsevt:
000473r 3  A9 rr        	lda #<ssprit 			; default to spare element in table.
000475r 3  85 rr        	sta z80_x
000477r 3  A9 rr        	lda #>ssprit
000479r 3  85 rr        	sta z80_i
00047Br 3               
00047Br 3               evrs:
00047Br 3  4C rr rr     	jmp evnt14	 		; call restart event.
00047Er 3               
00047Er 3               ;------------------------------------------------------------------
00047Er 3               ; Copy number passed in a to string position bc, right-justified.
00047Er 3               ;
00047Er 3               ; Input:
00047Er 3               ;  A  = number
00047Er 3               ;  BC = string address
00047Er 3               ;
00047Er 3               ; Output:
00047Er 3               ;  BC = string with number
00047Er 3               ;-----------------------------------------------------------------
00047Er 3               
00047Er 3               num2ch:
00047Er 3  85 rr        	sta z80_d		; Save number
000480r 3               
000480r 3  A9 00        	lda #0
000482r 3  85 rr        	sta flag
000484r 3               numdg3:
000484r 3  A2 64        	ldx #100		; hundreds column.
000486r 3  86 rr        	stx z80_e
000488r 3  20 rr rr     	jsr numdg		; show digit.
00048Br 3               numdg2:
00048Br 3  A2 0A        	ldx #10			; tens column.
00048Dr 3  86 rr        	stx z80_e
00048Fr 3  20 rr rr     	jsr numdg		; show digit.
000492r 3               
000492r 3  E6 rr        	inc flag
000494r 3  A2 01        	ldx #1			; units column.
000496r 3  86 rr        	stx z80_e
000498r 3               numdg:
000498r 3  A9 30        	lda #48			; clear digit.
00049Ar 3  85 rr        	sta z80_a
00049Cr 3               numdg1:
00049Cr 3  A5 rr        	lda z80_d
00049Er 3  C5 rr        	cmp z80_e
0004A0r 3  90 0E        	bcc numdg0		; nothing to show.
0004A2r 3  38           	sec
0004A3r 3  A5 rr        	lda z80_d
0004A5r 3  E5 rr        	sbc z80_e		; subtract from column.
0004A7r 3  85 rr        	sta z80_d
0004A9r 3  E6 rr        	inc z80_a		; increment digit.
0004ABr 3  E6 rr        	inc flag
0004ADr 3  4C rr rr     	jmp numdg1		; repeat until column is zero.
0004B0r 3               numdg0:
0004B0r 3  A0 00        	ldy #0
0004B2r 3  A5 rr        	lda z80_a
0004B4r 3  91 rr        	sta (z80_bc),y		; write digit to buffer.
0004B6r 3  A5 rr        	lda flag
0004B8r 3  F0 06        	beq :+
0004BAr 3  E6 rr        	inc z80_c		; next buffer position.
0004BCr 3  D0 02        	bne :+
0004BEr 3  E6 rr        	inc z80_b
0004C0r 3               :
0004C0r 3  60           	rts
0004C1r 3               num2dd:
0004C1r 3  85 rr        	sta z80_d		; Save number
0004C3r 3               
0004C3r 3  A9 01        	lda #1
0004C5r 3  85 rr        	sta flag
0004C7r 3               
0004C7r 3  4C rr rr     	jmp numdg2
0004CAr 3               num2td:
0004CAr 3  85 rr        	sta z80_d		; Save number
0004CCr 3               
0004CCr 3  A9 01        	lda #1
0004CEr 3  85 rr        	sta flag
0004D0r 3  4C rr rr     	jmp numdg3
0004D3r 3               
0004D3r 3               ;---------------------------------------------------------
0004D3r 3               ; Reset score to "000000"
0004D3r 3               ;---------------------------------------------------------
0004D3r 3               
0004D3r 3               inisc:
0004D3r 3  A9 30        	lda #'0'
0004D5r 3  A2 05        	ldx #5			; digits to initialise.
0004D7r 3               inisc0:
0004D7r 3  9D rr rr     	sta score,x 		; write zero digit.
0004DAr 3  CA           	dex			; next column.
0004DBr 3  10 FA        	bpl inisc0		; repeat for all digits.
0004DDr 3               
0004DDr 3  60           	rts
0004DEr 3               
0004DEr 3               ;-----------------------------------------------------
0004DEr 3               ; Multiply h by d and return in hl.
0004DEr 3               ;
0004DEr 3               ; Input:
0004DEr 3               ;  H = first number
0004DEr 3               ;  D = second number
0004DEr 3               ;
0004DEr 3               ; Output:
0004DEr 3               ;  HL = result H x D
0004DEr 3               ;-----------------------------------------------------
0004DEr 3               
0004DEr 3               imul:
0004DEr 3  A5 rr        	lda z80_d		; HL = H * D
0004E0r 3  85 rr        	sta z80_e
0004E2r 3  A5 rr        	lda z80_h
0004E4r 3  85 rr        	sta z80_c		; make c first multiplier.
0004E6r 3               imul0:
0004E6r 3  A9 00        	lda #0			; zeroise total.
0004E8r 3  85 rr        	sta z80_l
0004EAr 3  85 rr        	sta z80_h
0004ECr 3               
0004ECr 3  A5 rr        	lda z80_h
0004EEr 3  85 rr        	sta z80_d		; zeroise high byte.
0004F0r 3               
0004F0r 3  A9 08        	lda #8			; repeat 8 times.
0004F2r 3  85 rr        	sta z80_b
0004F4r 3               imul1:
0004F4r 3  46 rr        	lsr z80_c		; rotate rightmost bit into carry.
0004F6r 3  90 0E        	bcc imul2		; wasn't set.
0004F8r 3  18           	clc			; bit was set, so add de.
0004F9r 3  A5 rr        	lda z80_l
0004FBr 3  65 rr        	adc z80_e
0004FDr 3  85 rr        	sta z80_l
0004FFr 3  A5 rr        	lda z80_h
000501r 3  65 rr        	adc z80_d
000503r 3  85 rr        	sta z80_h
000505r 3  18           	clc 			; reset carry.
000506r 3               imul2:
000506r 3  06 rr        	asl z80_e 		; shift de 1 bit left.
000508r 3  26 rr        	rol z80_d
00050Ar 3  C6 rr        	dec z80_b
00050Cr 3  D0 E6        	bne imul1		; repeat 8 times.
00050Er 3               
00050Er 3  60           	rts
00050Fr 3               
00050Fr 3               ;-----------------------------------------------
00050Fr 3               ; Divide d by e and return in d, remainder in a.
00050Fr 3               ;
00050Fr 3               ; Input:
00050Fr 3               ;  D = first number
00050Fr 3               ;  E = second number
00050Fr 3               ;
00050Fr 3               ; Output:
00050Fr 3               ;  D = result D/E
00050Fr 3               ;  A = remainder
00050Fr 3               ;-----------------------------------------------
00050Fr 3               
00050Fr 3               idiv:
00050Fr 3  A9 00        	lda #0
000511r 3  A0 08        	ldy #8		 	; bits to shift.
000513r 3  06 rr        	asl z80_d
000515r 3               idiv0:
000515r 3  2A           	rol a 			; multiply d by 2.
000516r 3  C5 rr        	cmp z80_e 		; test if e is smaller.
000518r 3  90 02        	bcc idiv1		; e is greater, no division this time.
00051Ar 3  E5 rr        	sbc z80_e		; subtract it.
00051Cr 3               idiv1:
00051Cr 3  26 rr        	rol z80_d		; rotate into d.
00051Er 3  88           	dey
00051Fr 3  D0 F4        	bne idiv0		; repeat
000521r 3  60           	rts
000522r 3               
000522r 3               ;---------------------------------------------------
000522r 3               ; Play AY sound effect
000522r 3               ;---------------------------------------------------
000522r 3               
000522r 3               plsnd:
000522r 3  60           	rts
000523r 3               
000523r 3               ;---------------------------------------------------
000523r 3               ; Objects handling.
000523r 3               ; 32 bytes for image
000523r 3               ; 1 for colour
000523r 3               ; 3 for room, y and x
000523r 3               ; 3 for starting room, y and x.
000523r 3               ; 254 = disabled.
000523r 3               ; 255 = object in player"s pockets.
000523r 3               ;---------------------------------------------------
000523r 3               
000523r 3               ;---------------------------------------------------
000523r 3               ; Show items present.
000523r 3               ;---------------------------------------------------
000523r 3               
000523r 3               .if oflag
000523r 3               shwob:
000523r 3  A9 rr        	lda #<objdta			; objects table.
000525r 3  85 rr        	sta z80_l
000527r 3  A9 rr        	lda #>objdta
000529r 3  85 rr        	sta z80_h
00052Br 3  AD rr rr     	lda numob 			; number of objects in the game.
00052Er 3  85 rr        	sta sprcnt
000530r 3               shwob0:
000530r 3  A0 21        	ldy #33 			; distance to room number.
000532r 3  B1 rr        	lda (z80_hl),y 			; same as an item?
000534r 3  C5 rr        	cmp scno 			; current location.
000536r 3  D0 03        	bne :+
000538r 3  20 rr rr     	jsr dobj 			; yes, display object.
00053Br 3               :
00053Br 3  18           	clc
00053Cr 3  A5 rr        	lda z80_l
00053Er 3  69 27        	adc #39 			; distance to next item.
000540r 3  85 rr        	sta z80_l
000542r 3  A5 rr        	lda z80_h
000544r 3  69 00        	adc #0
000546r 3  85 rr        	sta z80_h	 		; point to it.
000548r 3  C6 rr        	dec sprcnt
00054Ar 3  D0 E4        	bne shwob0 			; repeat for others.
00054Cr 3  60           	rts
00054Dr 3               
00054Dr 3               ;---------------------------------------------------
00054Dr 3               ; Display object.
00054Dr 3               ; hl must point to object's start address.
00054Dr 3               ;
00054Dr 3               ; Input:
00054Dr 3               ;  HL = object address
00054Dr 3               ;---------------------------------------------------
00054Dr 3               
00054Dr 3               dobj:
00054Dr 3  A0 20        	ldy #32
00054Fr 3  B1 rr        	lda (z80_hl),y 			; point to y.
000551r 3  85 rr        	sta objcol
000553r 3  A0 22        	ldy #34
000555r 3  B1 rr        	lda (z80_hl),y 			; point to y.
000557r 3  85 rr        	sta dispy
000559r 3  C8           	iny
00055Ar 3  B1 rr        	lda (z80_hl),y 			; point to x.
00055Cr 3  85 rr        	sta dispx
00055Er 3               dobj1:
00055Er 3  4C rr rr     	jmp sprite 			; draw this sprite.
000561r 3               
000561r 3               ;--------------------------------------
000561r 3               ; Remove an object.
000561r 3               ;
000561r 3               ; Input:
000561r 3               ;  A = object number
000561r 3               ;--------------------------------------
000561r 3               
000561r 3               remob:
000561r 3  CD rr rr     	cmp numob			; number of objects in game.
000564r 3  90 01        	bcc :+				; are we checking past the end?
000566r 3  60           	rts				; yes, can't get non-existent item.
000567r 3               :
000567r 3  48           	pha				; remember object.
000568r 3  20 rr rr     	jsr getob			; pick it up if we haven't already got it.
00056Br 3  68           	pla				; retrieve object number.
00056Cr 3  20 rr rr     	jsr gotob			; get its address.
00056Fr 3  A9 FE        	lda #254
000571r 3  A0 21        	ldy #33
000573r 3  91 rr        	sta (z80_hl),y			; remove it.
000575r 3  60           	rts
000576r 3               
000576r 3               ;---------------------------------------------------
000576r 3               ; Pick up object number held in the accumulator.
000576r 3               ;
000576r 3               ; Input:
000576r 3               ;  A = object number
000576r 3               ;---------------------------------------------------
000576r 3               
000576r 3               getob:
000576r 3  CD rr rr     	cmp numob 		; number of objects in game.
000579r 3  90 01        	bcc :+			; are we checking past the end?
00057Br 3  60           	rts			; yes, can't get non-existent item.
00057Cr 3               :
00057Cr 3  20 rr rr     	jsr gotob 		; check if we already have it.
00057Fr 3  C9 FF        	cmp #255
000581r 3  D0 01        	bne :+
000583r 3  60           	rts			; we already do.
000584r 3               :
000584r 3  A0 21        	ldy #33
000586r 3  B1 rr        	lda (z80_hl),y		; is it on this screen?
000588r 3  C5 rr        	cmp scno 		; current screen.
00058Ar 3  D0 14        	bne getob0		; not on screen, so nothing to delete.
00058Cr 3               
00058Cr 3  A9 FF        	lda #255
00058Er 3  91 rr        	sta (z80_hl),y		; pick it up.
000590r 3  C8           	iny 			; point to y coord.
000591r 3               getob1:
000591r 3  A0 22        	ldy #34
000593r 3  B1 rr        	lda (z80_hl),y		; y coord.
000595r 3  85 rr        	sta dispy
000597r 3  A0 23        	ldy #35
000599r 3  B1 rr        	lda (z80_hl),y 		; x coord.
00059Br 3  85 rr        	sta dispx
00059Dr 3  4C rr rr     	jmp dobj1 		; delete object sprite.
0005A0r 3               getob0:
0005A0r 3  A9 FF        	lda #255
0005A2r 3  91 rr        	sta (z80_hl),y 		; pick it up.
0005A4r 3  60           	rts
0005A5r 3               .endif
0005A5r 3               
0005A5r 3               ;-----------------------------------------------------------------
0005A5r 3               ; Got object check.
0005A5r 3               ; Call with object in accumulator, returns zero set if in pockets.
0005A5r 3               ;
0005A5r 3               ; Input:
0005A5r 3               ;  A = object number
0005A5r 3               ;-----------------------------------------------------------------
0005A5r 3               .if oflag .or mflag
0005A5r 3               gotob:
0005A5r 3  CD rr rr     	cmp numob 		; number of objects in game.
0005A8r 3  90 03        	bcc :+ 			; are we checking past the end?
0005AAr 3  4C rr rr     	jmp gotob0 		; yes, we can't have a non-existent object.
0005ADr 3               :
0005ADr 3  20 rr rr     	jsr findob		; find the object.
0005B0r 3               gotob1:
0005B0r 3  60           	rts
0005B1r 3               
0005B1r 3               gotob0:
0005B1r 3  A9 FE        	lda #254 		; missing.
0005B3r 3  4C rr rr     	jmp gotob1
0005B6r 3               
0005B6r 3               findob:
0005B6r 3  48           	pha			; save object number
0005B7r 3  A9 rr        	lda #<objdta 		; objects.
0005B9r 3  85 rr        	sta z80_l
0005BBr 3  A9 rr        	lda #>objdta
0005BDr 3  85 rr        	sta z80_h
0005BFr 3  68           	pla			; retreive object number
0005C0r 3  F0 0F        	beq fndob1 		; is it zero? yes, skip loop.
0005C2r 3  AA           	tax 			; loop counter
0005C3r 3               fndob2:
0005C3r 3  18           	clc
0005C4r 3  A5 rr        	lda z80_l
0005C6r 3  69 27        	adc #39 		; size of each object.
0005C8r 3  85 rr        	sta z80_l
0005CAr 3  90 02        	bcc :+
0005CCr 3  E6 rr        	inc z80_h
0005CEr 3               :
0005CEr 3  CA           	dex 			; repeat until we find address.
0005CFr 3  D0 F2        	bne fndob2
0005D1r 3               fndob1:
0005D1r 3  A0 21        	ldy #33			; distance to room it's in.
0005D3r 3  B1 rr        	lda (z80_hl),y		; fetch status.
0005D5r 3  60           	rts
0005D6r 3               .endif
0005D6r 3               
0005D6r 3               ;---------------------------------------------
0005D6r 3               ; Drop object number at (dispx, dispy).
0005D6r 3               ;
0005D6r 3               ; Input:
0005D6r 3               ;  A = object number
0005D6r 3               ;---------------------------------------------
0005D6r 3               
0005D6r 3               .if oflag
0005D6r 3               drpob:
0005D6r 3  CD rr rr     	cmp numob 		; are we checking past the end?
0005D9r 3  90 01        	bcc :+
0005DBr 3  60           	rts			; yes, can't drop non-existent item.
0005DCr 3               :
0005DCr 3  20 rr rr     	jsr gotob		; make sure object is in inventory.
0005DFr 3  C5 rr        	cmp scno		; already on this screen?
0005E1r 3  D0 01        	bne :+
0005E3r 3  60           	rts			; yes, nothing to do.
0005E4r 3               :
0005E4r 3  A0 21        	ldy #33
0005E6r 3  A5 rr        	lda scno
0005E8r 3  91 rr        	sta (z80_hl),y		; bring onto screen.
0005EAr 3  A5 rr        	lda dispy		; sprite y coordinate.
0005ECr 3  C8           	iny
0005EDr 3  91 rr        	sta (z80_hl),y		; point to object y.
0005EFr 3  A5 rr        	lda dispx 		; sprite x coordinate.
0005F1r 3  C8           	iny
0005F2r 3  91 rr        	sta (z80_hl),y 		; point to object x
0005F4r 3  4C rr rr     	jmp dobj		; draw the object sprite.
0005F7r 3               
0005F7r 3               ;-----------------------------------------------
0005F7r 3               ; Seek objects at sprite position.
0005F7r 3               ;
0005F7r 3               ; Output:
0005F7r 3               ;  A = object number, if not found A=255
0005F7r 3               ;-----------------------------------------------
0005F7r 3               
0005F7r 3               skobj:
0005F7r 3  A9 rr        	lda #<objdta 		; pointer to objects.
0005F9r 3  85 rr        	sta z80_l
0005FBr 3  A9 rr        	lda #>objdta
0005FDr 3  85 rr        	sta z80_h
0005FFr 3               
0005FFr 3  AD rr rr     	lda numob 		; number of objects in game.
000602r 3  85 rr        	sta z80_b 		; set up the loop counter.
000604r 3               skobj0:
000604r 3  A5 rr        	lda scno		; current room number.
000606r 3  A0 21        	ldy #33
000608r 3  D1 rr        	cmp (z80_hl),y		; is object in here?
00060Ar 3  D0 03        	bne :+
00060Cr 3  20 rr rr     	jsr skobj1		; yes, check coordinates.
00060Fr 3               :
00060Fr 3  18           	clc			; point to next object in table.
000610r 3  A5 rr        	lda z80_l
000612r 3  69 27        	adc #39			; size of each object.
000614r 3  85 rr        	sta z80_l
000616r 3  90 02        	bcc :+
000618r 3  E6 rr        	inc z80_h
00061Ar 3               :
00061Ar 3  C6 rr        	dec z80_b
00061Cr 3  D0 E6        	bne skobj0		; repeat for all objects.
00061Er 3               
00061Er 3  A9 FF        	lda #255		; end of list and nothing found, return 255.
000620r 3  60           	rts
000621r 3               
000621r 3               skobj1:
000621r 3  A0 22        	ldy #34			; point to y coordinate.
000623r 3  B1 rr        	lda (z80_hl),y		; point to y coordinate.
000625r 3  38           	sec
000626r 3  A0 08        	ldy #var_newY
000628r 3  F1 rr        	sbc (z80_ix),y 		; subtract sprite y.
00062Ar 3  18           	clc
00062Br 3  69 0F        	adc #15			; add sprite height minus one.
00062Dr 3  C9 1F        	cmp #31			; within range?
00062Fr 3  B0 18        	bcs skobj2		; no, ignore object.
000631r 3               
000631r 3  A0 23        	ldy #35			; point to x coordinate now.
000633r 3  B1 rr        	lda (z80_hl),y 		; get coordinate.
000635r 3  38           	sec
000636r 3  A0 09        	ldy #var_newX
000638r 3  F1 rr        	sbc (z80_ix),y 		; subtract the sprite x.
00063Ar 3  18           	clc			; add sprite width minus one.
00063Br 3  69 0F        	adc #15
00063Dr 3  C9 1F        	cmp #31			; within range?
00063Fr 3  B0 08        	bcs skobj2		; no, ignore object.
000641r 3               
000641r 3  68           	pla			; remove return address from stack.
000642r 3  68           	pla
000643r 3               
000643r 3  AD rr rr     	lda numob 		; objects in game.
000646r 3  38           	sec
000647r 3  E5 rr        	sbc z80_b		; subtract loop counter.
000649r 3               skobj2:
000649r 3  60           	rts			; accumulator now points to object.
00064Ar 3               .endif
00064Ar 3               
00064Ar 3               ;---------------------------------------------------------------------
00064Ar 3               ; Spawn a new sprite.
00064Ar 3               ;---------------------------------------------------------------------
00064Ar 3               
00064Ar 3               spawn:
00064Ar 3  A9 rr        	lda #<sprtab		; sprite table.
00064Cr 3  85 rr        	sta z80_l
00064Er 3  A9 rr        	lda #>sprtab
000650r 3  85 rr        	sta z80_h
000652r 3               numsp1:
000652r 3  A9 0C        	lda #NUMSPR		; number of sprites.
000654r 3  85 rr        	sta spcnt
000656r 3               spaw0:
000656r 3  A0 00        	ldy #var_Type
000658r 3  B1 rr        	lda (z80_hl),y		; get sprite type.
00065Ar 3  C9 FF        	cmp #255		; is it an unused slot?
00065Cr 3  F0 0F        	beq spaw1 		; yes, we can use this one.
00065Er 3               
00065Er 3  18           	clc 			; point to next sprite in table.
00065Fr 3  A5 rr        	lda z80_l
000661r 3  69 11        	adc #TABSIZ		; size of each entry.
000663r 3  85 rr        	sta z80_l
000665r 3  90 02        	bcc :+
000667r 3  E6 rr        	inc z80_h
000669r 3               :
000669r 3  C6 rr        	dec spcnt		; one less iteration.
00066Br 3  D0 E9        	bne spaw0		; keep going until we find a slot.
00066Dr 3               
00066Dr 3               ; Didn't find one but drop through and set up a dummy sprite instead.
00066Dr 3               
00066Dr 3               spaw1:
00066Dr 3  A5 rr        	lda z80_i		; address of original sprite.
00066Fr 3  48           	pha
000670r 3  A5 rr        	lda z80_x
000672r 3  48           	pha
000673r 3               
000673r 3  A5 rr        	lda z80_l		; store spawned sprite address.
000675r 3  85 rr        	sta spptr
000677r 3  A5 rr        	lda z80_h
000679r 3  85 rr        	sta spptr+1
00067Br 3               
00067Br 3  A5 rr        	lda z80_c
00067Dr 3  A0 00        	ldy #var_Type
00067Fr 3  91 rr        	sta (z80_hl),y 		; set the type.
000681r 3  A0 05        	ldy #var_newType
000683r 3  91 rr        	sta (z80_hl),y		; copy
000685r 3               
000685r 3  A5 rr        	lda z80_b
000687r 3  A0 01        	ldy #var_Image
000689r 3  91 rr        	sta (z80_hl),y		; set the image.
00068Br 3  A0 06        	ldy #var_newImage
00068Dr 3  91 rr        	sta (z80_hl),y		; copy
00068Fr 3               
00068Fr 3  A9 00        	lda #0 				; frame zero.
000691r 3  A0 02        	ldy #var_Frame
000693r 3  91 rr        	sta (z80_hl),y		; set frame.
000695r 3  A0 07        	ldy #var_newFrame
000697r 3  91 rr        	sta (z80_hl),y		; copy
000699r 3               
000699r 3  A0 08        	ldy #8
00069Br 3  B1 rr        	lda (z80_ix),y 		; x coordinate.
00069Dr 3  A0 03        	ldy #3
00069Fr 3  91 rr        	sta (z80_hl),y		; set sprite coordinate.
0006A1r 3  A0 08        	ldy #8
0006A3r 3  91 rr        	sta (z80_hl),y		; copy
0006A5r 3               
0006A5r 3  A0 09        	ldy #9
0006A7r 3  B1 rr        	lda (z80_ix),y 		; y coordinate.
0006A9r 3  A0 04        	ldy #4
0006ABr 3  91 rr        	sta (z80_hl),y		; set sprite coordinate.
0006ADr 3  A0 09        	ldy #9
0006AFr 3  91 rr        	sta (z80_hl),y		; copy
0006B1r 3               
0006B1r 3  A0 0A        	ldy #10				; direction of original.
0006B3r 3  B1 rr        	lda (z80_ix),y
0006B5r 3  91 rr        	sta (z80_hl),y		; direction
0006B7r 3               
0006B7r 3  A9 00        	lda #0
0006B9r 3  A0 0D        	ldy #var_jumpLo
0006BBr 3  91 rr        	sta (z80_hl),y		; reset parameter.
0006BDr 3  C8           	iny
0006BEr 3  91 rr        	sta (z80_hl),y		; reset parameter.
0006C0r 3  C8           	iny
0006C1r 3  91 rr        	sta (z80_hl),y		; reset parameter.
0006C3r 3  C8           	iny
0006C4r 3  91 rr        	sta (z80_hl),y		; reset parameter.
0006C6r 3               rtssp:
0006C6r 3  A5 rr        	lda spptr			; address of new sprite.
0006C8r 3  85 rr        	sta z80_x
0006CAr 3  A5 rr        	lda spptr+1
0006CCr 3  85 rr        	sta z80_i
0006CEr 3               evis1:
0006CEr 3  20 rr rr     	jsr evnt09 			; call sprite initialisation event.
0006D1r 3               
0006D1r 3  A5 rr        	lda spptr 			; address of new sprite.
0006D3r 3  85 rr        	sta z80_x
0006D5r 3  A5 rr        	lda spptr+1
0006D7r 3  85 rr        	sta z80_i
0006D9r 3               
0006D9r 3               	; _BEEB clipping code copied from CPC Engine - MISSING?!
0006D9r 3  A0 03        	ldy #var_Y
0006DBr 3  B1 rr        	lda (z80_hl), y		; old x coord
0006DDr 3  C9 A1        	cmp #SpriteMaxY     ; beyond maximum?
0006DFr 3  B0 03        	bcs :+				; yes, don't draw it.
0006E1r 3               
0006E1r 3  20 rr rr     	jsr sspria 			; display the new sprite.
0006E4r 3               :
0006E4r 3  68           	pla					; address of original sprite.
0006E5r 3  85 rr        	sta z80_x
0006E7r 3  68           	pla
0006E8r 3  85 rr        	sta z80_i
0006EAr 3               
0006EAr 3  60           	rts
0006EBr 3               
0006EBr 3  30 30 30 30  score:	.byte "000000"		; player"s score.
0006EFr 3  30 30        
0006F1r 3  30 30 30 30  hiscor:	.byte "000000"		; high score.
0006F5r 3  30 30        
0006F7r 3  30 30 30 30  bonus:	.byte "000000"		; bonus.
0006FBr 3  30 30        
0006FDr 3  00 02        grbase:	.word ScreenAddr	; graphics base address.
0006FFr 3               
0006FFr 3               ;----------------------------------------------------
0006FFr 3               ; Check y-pos
0006FFr 3               ;----------------------------------------------------
0006FFr 3               
0006FFr 3               checkx:
0006FFr 3  A5 rr        	lda dispy		; y position.
000701r 3  C9 16        	cmp #22			; off screen?
000703r 3  B0 01        	bcs :+
000705r 3  60           	rts			; no, it's okay.
000706r 3               :
000706r 3  68           	pla			; remove return address from stack.
000707r 3  85 rr        	sta z80_l
000709r 3  68           	pla
00070Ar 3  85 rr        	sta z80_h
00070Cr 3  60           	rts
00070Dr 3               
00070Dr 3               ;-----------------------------------------------
00070Dr 3               ; Displays the current high score.
00070Dr 3               ;-----------------------------------------------
00070Dr 3               
00070Dr 3               dhisc:
00070Dr 3  A9 rr        	lda #<hiscor 		; high score text.
00070Fr 3  8D rr rr     	sta dscor3+1
000712r 3  8D rr rr     	sta bscor3+1
000715r 3  A9 rr        	lda #>hiscor
000717r 3  8D rr rr     	sta dscor3+2
00071Ar 3  8D rr rr     	sta bscor3+2
00071Dr 3  4C rr rr     	jmp dscor1		; check in printable range then show 6 digits.
000720r 3               
000720r 3               ;------------------------------------------------------
000720r 3               ; Displays the current score.
000720r 3               ;------------------------------------------------------
000720r 3               
000720r 3               dscor:
000720r 3  A9 rr        	lda #<score		; score text.
000722r 3  8D rr rr     	sta dscor3+1
000725r 3  8D rr rr     	sta bscor3+1
000728r 3  A9 rr        	lda #>score
00072Ar 3  8D rr rr     	sta dscor3+2
00072Dr 3  8D rr rr     	sta bscor3+2
000730r 3               dscor1:
000730r 3  8C rr rr     	sty tmpscr
000733r 3  20 rr rr     	jsr preprt		; set up font and print position.
000736r 3  20 rr rr     	jsr checkx		; make sure we're in a printable range.
000739r 3               
000739r 3               ;	lda #6			; digits to display.
000739r 3               ;	sta z80_b
000739r 3  A5 rr        	lda prtmod		; get print mode.
00073Br 3  F0 03        	beq :+			; standard size text?
00073Dr 3  4C rr rr     	jmp bscor0		; no, show double-height.
000740r 3               :
000740r 3               dscor0:
000740r 3               ;	ldy #0
000740r 3               ;	lda (z80_hl),y 		; fetch character.
000740r 3  AC rr rr     	ldy tmpscr
000743r 3               dscor3:
000743r 3  B9 rr rr     	lda score,y
000746r 3  20 rr rr     	jsr pchar 		; display character.
000749r 3  E6 rr        	inc dispx		; move along x coordinate
00074Br 3               
00074Br 3               ;	inc z80_l		; next score column.
00074Br 3               ;	bne :+
00074Br 3               ;	inc z80_h
00074Br 3               ;:
00074Br 3  EE rr rr     	inc tmpscr
00074Er 3  C6 rr        	dec z80_b
000750r 3  D0 EE        	bne dscor0 		; repeat for all digits.
000752r 3               dscor2:
000752r 3  A5 rr        	lda dispx 		; set up display coordinates.
000754r 3  85 rr        	sta charx
000756r 3  A5 rr        	lda dispy
000758r 3  85 rr        	sta chary
00075Ar 3  60           	rts
00075Br 3               
00075Br 3  00           tmpscr:	.byte 0
00075Cr 3               ;------------------------------------------------------
00075Cr 3               ; Displays the current score in double-height characters.
00075Cr 3               ;
00075Cr 3               ; Input:
00075Cr 3               ;  B  = digit number
00075Cr 3               ;  HL = score string
00075Cr 3               ;------------------------------------------------------
00075Cr 3               
00075Cr 3               bscor0:
00075Cr 3               ;	ldy #0
00075Cr 3               
00075Cr 3               ;	lda (z80_hl),y 		; fetch character.
00075Cr 3  A4 rr        	ldy tmp
00075Er 3               bscor3:
00075Er 3  B9 rr rr     	lda score,y
000761r 3  20 rr rr     	jsr bchar 		; display big char.
000764r 3               
000764r 3               ;	inc z80_l 		; next score column.
000764r 3               ;	bne :+
000764r 3               ;	inc z80_h
000764r 3               ;:
000764r 3  E6 rr        	inc tmp
000766r 3  C6 rr        	dec z80_b
000768r 3  F0 03        	beq :+
00076Ar 3  4C rr rr     	jmp bscor0 		; repeat for all digits.
00076Dr 3               :
00076Dr 3  4C rr rr     	jmp dscor2 		; tidy up line and column variables.
000770r 3               
000770r 3               ;-----------------------------------------------------
000770r 3               ; Adds number in the hl pair to the score.
000770r 3               ;-----------------------------------------------------
000770r 3               
000770r 3               addsc:
000770r 3  A9 rr        	lda #<(score+1) 	; ten thousands column.
000772r 3  85 rr        	sta z80_e
000774r 3  A9 rr        	lda #>(score+1)
000776r 3  85 rr        	sta z80_d
000778r 3  A9 10        	lda #<10000		; amount to add each time.
00077Ar 3  85 rr        	sta z80_c
00077Cr 3  A9 27        	lda #>10000
00077Er 3  85 rr        	sta z80_b
000780r 3  20 rr rr     	jsr incsc		; add to score.
000783r 3               
000783r 3  E6 rr        	inc z80_e		; thousands column.
000785r 3  D0 02        	bne :+
000787r 3  E6 rr        	inc z80_d
000789r 3               :
000789r 3  A9 E8        	lda #<1000		; amount to add each time.
00078Br 3  85 rr        	sta z80_c
00078Dr 3  A9 03        	lda #>1000
00078Fr 3  85 rr        	sta z80_b
000791r 3  20 rr rr     	jsr incsc 		; add to score.
000794r 3               
000794r 3  E6 rr        	inc z80_e		; hundreds column.
000796r 3  D0 02        	bne :+
000798r 3  E6 rr        	inc z80_d
00079Ar 3               :
00079Ar 3  A9 64        	lda #<100		; amount to add each time.
00079Cr 3  85 rr        	sta z80_c
00079Er 3  A9 00        	lda #>100
0007A0r 3  85 rr        	sta z80_b
0007A2r 3  20 rr rr     	jsr incsc		; add to score.
0007A5r 3               
0007A5r 3  E6 rr        	inc z80_e 		; tens column.
0007A7r 3  D0 02        	bne :+
0007A9r 3  E6 rr        	inc z80_d
0007ABr 3               :
0007ABr 3  A9 0A        	lda #<10		; amount to add each time.
0007ADr 3  85 rr        	sta z80_c
0007AFr 3  A9 00        	lda #>10
0007B1r 3  85 rr        	sta z80_b
0007B3r 3  20 rr rr     	jsr incsc 		; add to score.
0007B6r 3               
0007B6r 3  E6 rr        	inc z80_e		; units column.
0007B8r 3  D0 02        	bne :+
0007BAr 3  E6 rr        	inc z80_d
0007BCr 3               :
0007BCr 3  A9 01        	lda #<1			; units.
0007BEr 3  85 rr        	sta z80_c
0007C0r 3  A9 00        	lda #>1
0007C2r 3  85 rr        	sta z80_b
0007C4r 3               incsc:
0007C4r 3  A5 rr        	lda z80_h		; store amount to add.
0007C6r 3  48           	pha
0007C7r 3  A5 rr        	lda z80_l
0007C9r 3  48           	pha
0007CAr 3               
0007CAr 3  38           	sec			; subtract from amount to add.
0007CBr 3  A5 rr        	lda z80_l
0007CDr 3  E5 rr        	sbc z80_c
0007CFr 3  85 rr        	sta z80_l
0007D1r 3  A5 rr        	lda z80_h
0007D3r 3  E5 rr        	sbc z80_b
0007D5r 3  85 rr        	sta z80_h
0007D7r 3  90 14        	bcc incsc0		; too much, restore value.
0007D9r 3               
0007D9r 3  68           	pla			; delete the previous amount from the stack.
0007DAr 3  68           	pla
0007DBr 3               
0007DBr 3  A5 rr        	lda z80_d 		; store column position.
0007DDr 3  48           	pha
0007DEr 3  A5 rr        	lda z80_e
0007E0r 3  48           	pha
0007E1r 3  20 rr rr     	jsr incsc2		; do the increment.
0007E4r 3               
0007E4r 3  68           	pla			; restore column.
0007E5r 3  85 rr        	sta z80_e
0007E7r 3  68           	pla
0007E8r 3  85 rr        	sta z80_d
0007EAr 3  4C rr rr     	jmp incsc		; repeat until all added.
0007EDr 3               
0007EDr 3               incsc0:
0007EDr 3  68           	pla			; restore previous value.
0007EEr 3  85 rr        	sta z80_l
0007F0r 3  68           	pla
0007F1r 3  85 rr        	sta z80_h
0007F3r 3  60           	rts
0007F4r 3               incsc2:
0007F4r 3  A0 00        	ldy #0
0007F6r 3  B1 rr        	lda (z80_de),y 		; get amount.
0007F8r 3  18           	clc
0007F9r 3  69 01        	adc #1			; add one to column.
0007FBr 3  91 rr        	sta (z80_de),y		; write new column total.
0007FDr 3  C9 3A        	cmp #'9'+1		; gone beyond range of digits?
0007FFr 3  B0 01        	bcs :+
000801r 3  60           	rts			; no, carry on.
000802r 3               :
000802r 3  A9 30        	lda #'0'		; make it zero.
000804r 3  91 rr        	sta (z80_de),y		; write new column total.
000806r 3  C6 rr        	dec z80_e		; back one column.
000808r 3  D0 02        	bne :+
00080Ar 3  C6 rr        	dec z80_d
00080Cr 3               :
00080Cr 3  4C rr rr     	jmp incsc2
00080Fr 3               
00080Fr 3               ;------------------------------------
00080Fr 3               ; Add bonus to score and reset bonus
00080Fr 3               ;------------------------------------
00080Fr 3               
00080Fr 3               addbo:
00080Fr 3  A2 05        	ldx #5			; last digit.
000811r 3  18           	clc
000812r 3               addbo0:
000812r 3  BD rr rr     	lda score,x		; get score.
000815r 3  7D rr rr     	adc bonus,x		; add bonus.
000818r 3  38           	sec			; 0 to 18.
000819r 3  E9 30        	sbc #48
00081Br 3  48           	pha
00081Cr 3  A9 30        	lda #'0'
00081Er 3  9D rr rr     	sta bonus,x
000821r 3  68           	pla
000822r 3  C9 3A        	cmp #58
000824r 3  90 03        	bcc addbo1
000826r 3  38           	sec
000827r 3  E9 0A        	sbc #10
000829r 3               addbo1:
000829r 3  9D rr rr     	sta score,x		; zeroise bonus.
00082Cr 3  CA           	dex			; next digit.
00082Dr 3  10 E3        	bpl addbo0		; repeat for all 6 digits.
00082Fr 3  60           	rts
000830r 3               
000830r 3               ;------------------------------------
000830r 3               ; Swap score and bonus.
000830r 3               ;------------------------------------
000830r 3               
000830r 3               swpsb:
000830r 3  A2 05        	ldx #5			; digits to add.
000832r 3               swpsb0:
000832r 3  BD rr rr     	lda score,x 		; get score digits.
000835r 3  48           	pha			; save digit
000836r 3  BD rr rr     	lda bonus,x 		; get bonus digits.
000839r 3  9D rr rr     	sta score,x		; switch score-bonus
00083Cr 3  68           	pla
00083Dr 3  9D rr rr     	sta bonus,x
000840r 3  CA           	dex 			; repeat for all 6 digits.
000841r 3  10 EF        	bpl swpsb0
000843r 3  60           	rts
000844r 3               
000844r 3               ;----------------------------------------------------
000844r 3               ; Get print address.
000844r 3               ;----------------------------------------------------
000844r 3               
000844r 3               gprad:
000844r 3  98           	tya
000845r 3  48           	pha
000846r 3               
000846r 3  A5 rr        	lda dispx 		; x coordinate.
000848r 3  85 rr        	sta scraddr
00084Ar 3  A9 00        	lda #0
00084Cr 3  85 rr        	sta scraddr+1
00084Er 3  06 rr        	asl scraddr  		; multiply char by 16
000850r 3  26 rr        	rol scraddr+1
000852r 3  06 rr        	asl scraddr
000854r 3  26 rr        	rol scraddr+1
000856r 3  06 rr        	asl scraddr
000858r 3  26 rr        	rol scraddr+1
00085Ar 3  06 rr        	asl scraddr
00085Cr 3  26 rr        	rol scraddr+1
00085Er 3               
00085Er 3  A5 rr        	lda dispy		; y coordinate.
000860r 3  0A           	asl a
000861r 3  0A           	asl a
000862r 3  0A           	asl a			; multiply char by 8
000863r 3  A8           	tay
000864r 3               
000864r 3  18           	clc
000865r 3  A5 rr        	lda scraddr
000867r 3  79 00 07     	adc SCADTB_lb,y
00086Ar 3  85 rr        	sta scraddr
00086Cr 3  A5 rr        	lda scraddr+1
00086Er 3  79 00 08     	adc SCADTB_hb,y
000871r 3  85 rr        	sta scraddr+1
000873r 3               
000873r 3               
000873r 3               
000873r 3  A5 rr        	lda prtmod		; Double line if bigtxt
000875r 3  F0 08        	beq noskip
000877r 3  A5 rr        	lda dispx
000879r 3  29 E0        	and #$e0
00087Br 3  F0 02        	beq noskip
00087Dr 3  E6 rr        	inc scraddr+1
00087Fr 3               noskip:
00087Fr 3               
00087Fr 3  68           	pla
000880r 3  A8           	tay
000881r 3  60           	rts
000882r 3               ;--------------------------------------------------------------
000882r 3               ; Get property buffer address of char at (dispx, dispy) in hl.
000882r 3               ;
000882r 3               ; Output:
000882r 3               ;  buffaddr = bufaddr = MAP + dispy*22 + dispx
000882r 3               ;--------------------------------------------------------------
000882r 3               
000882r 3               pradd:
000882r 3  A5 rr        	lda dispy 		; y coordinate.
000884r 3  85 rr        	sta bufaddr
000886r 3  A9 00        	lda #0
000888r 3  85 rr        	sta bufaddr+1
00088Ar 3  06 rr        	asl bufaddr  		; multiply char by 32
00088Cr 3  26 rr        	rol bufaddr+1
00088Er 3  06 rr        	asl bufaddr
000890r 3  26 rr        	rol bufaddr+1
000892r 3  06 rr        	asl bufaddr
000894r 3  26 rr        	rol bufaddr+1
000896r 3  06 rr        	asl bufaddr
000898r 3  26 rr        	rol bufaddr+1
00089Ar 3  06 rr        	asl bufaddr
00089Cr 3  26 rr        	rol bufaddr+1
00089Er 3  18           	clc			; add address of MAP graphics.
00089Fr 3  A5 rr        	lda bufaddr
0008A1r 3  65 rr        	adc dispx
0008A3r 3  69 00        	adc #<MAP
0008A5r 3  85 rr        	sta bufaddr
0008A7r 3  A5 rr        	lda bufaddr+1
0008A9r 3  69 04        	adc #>MAP
0008ABr 3  85 rr        	sta bufaddr+1
0008ADr 3  60           	rts
0008AEr 3               
0008AEr 3               ;--------------------------------------------------------------
0008AEr 3               ; Get attribute address at (dispx, dispy).
0008AEr 3               ;
0008AEr 3               ; Output:
0008AEr 3               ;  bufaddr = COLOR + dispy*22 + dispx
0008AEr 3               ;--------------------------------------------------------------
0008AEr 3               
0008AEr 3               gaadd:
0008AEr 3  A5 rr        	lda dispy
0008B0r 3  4A           	lsr a
0008B1r 3  A8           	tay
0008B2r 3  B9 55 0A     	lda COLATTTB_hb,y
0008B5r 3  85 rr        	sta bufaddr+1
0008B7r 3  B9 4A 0A     	lda COLATTTB_lb,y
0008BAr 3  18           	clc
0008BBr 3  65 rr        	adc dispx
0008BDr 3  85 rr        	sta bufaddr
0008BFr 3  60           	rts
0008C0r 3               
0008C0r 3               ;----------------------------------------------
0008C0r 3               ; Print attributes, properties and pixels.
0008C0r 3               ;
0008C0r 3               ; Input:
0008C0r 3               ;  A	= tile number
0008C0r 3               ;----------------------------------------------
0008C0r 3               
0008C0r 3               pbpattr:			; entry PUTBLOCK command
0008C0r 3  A4 rr        	ldy charx
0008C2r 3  84 rr        	sty dispx
0008C4r 3  A4 rr        	ldy chary
0008C6r 3  84 rr        	sty dispy
0008C8r 3               pattr:
0008C8r 3               .if aflag
0008C8r 3               	pha
0008C8r 3               	jsr wbloc		; save blockinfo
0008C8r 3               	pla
0008C8r 3               .endif
0008C8r 3               
0008C8r 3               pattr2:
0008C8r 3  85 rr        	sta z80_b		; store cell in b register for now.
0008CAr 3  AA           	tax
0008CBr 3  BD rr rr     	lda bprop,x 		; block properties.
0008CEr 3  85 rr        	sta z80_c
0008D0r 3  C9 08        	cmp #COLECT
0008D2r 3  D0 04        	bne :+
0008D4r 3  A5 rr        	lda z80_b
0008D6r 3  85 rr        	sta colpatt
0008D8r 3               :
0008D8r 3  20 rr rr     	jsr pradd 		; get property buffer address.
0008DBr 3  A5 rr        	lda z80_c
0008DDr 3  A0 00        	ldy #0
0008DFr 3  91 rr        	sta (bufaddr),y 	; write property.
0008E1r 3  A5 rr        	lda z80_b 		; restore cell.
0008E3r 3  4C rr rr     	jmp panp
0008E6r 3               ; Print attributes, no properties.
0008E6r 3               
0008E6r 3               ;colpatt:	.byte 0
0008E6r 3               
0008E6r 3               panp:
0008E6r 3  85 rr        	sta z80_e		; displacement in e.
0008E8r 3  A9 00        	lda #0
0008EAr 3  85 rr        	sta z80_d		; no high byte.
0008ECr 3  06 rr        	asl z80_e  		; multiply char by 8.
0008EEr 3  26 rr        	rol z80_d
0008F0r 3  06 rr        	asl z80_e
0008F2r 3  26 rr        	rol z80_d
0008F4r 3  06 rr        	asl z80_e
0008F6r 3  26 rr        	rol z80_d
0008F8r 3  18           	clc
0008F9r 3  A5 rr        	lda z80_e
0008FBr 3  69 rr        	adc #<chgfx 		; address of graphics.
0008FDr 3  85 rr        	sta tileaddr
0008FFr 3  A5 rr        	lda z80_d
000901r 3  69 rr        	adc #>chgfx
000903r 3  85 rr        	sta tileaddr+1
000905r 3               
000905r 3  A6 rr        	ldx z80_b		; set colour attribute
000907r 3  BD rr rr     	lda bCol,x
00090Ar 3  48           	pha
00090Br 3  20 rr rr     	jsr gaadd
00090Er 3  A0 00        	ldy #0
000910r 3  68           	pla
000911r 3  91 rr        	sta (bufaddr),y
000913r 3               
000913r 3  20 rr rr     	jsr gprad 		; get screen address.
000916r 3  A2 07        	ldx #7			; number of pixel rows to write.
000918r 3               panp0:
000918r 3  A0 00        	ldy #0
00091Ar 3  B1 rr        	lda (tileaddr),y 	; get image byte.
00091Cr 3               .if iflag
00091Cr 3               	eor #$ff		; Invert
00091Cr 3               .endif
00091Cr 3  BC rr rr     	ldy scrtab,x
00091Fr 3  91 rr        	sta (scraddr),y 	; copy to screen.
000921r 3  E6 rr        	inc tileaddr 		; next image byte.
000923r 3  D0 02        	bne :+
000925r 3  E6 rr        	inc tileaddr+1
000927r 3               :
000927r 3  CA           	dex	 		; repeat for 8 pixel rows.
000928r 3  10 EE        	bpl panp0
00092Ar 3  E6 rr        	inc dispx 		; move along one.
00092Cr 3  E6 rr        	inc charx
00092Er 3  60           	rts
00092Fr 3               
00092Fr 3               ;----------------------------------------------
00092Fr 3               ; Write block
00092Fr 3               ;----------------------------------------------
00092Fr 3               
00092Fr 3               .if aflag
00092Fr 3               wbloc:
00092Fr 3               	ldy #3
00092Fr 3               	sta (pbptr),y		; store block number
00092Fr 3               	dey
00092Fr 3               	lda dispx
00092Fr 3               	sta (pbptr),y		; write x position of block.
00092Fr 3               	dey
00092Fr 3               	lda dispy
00092Fr 3               	sta (pbptr),y		; write y position of block.
00092Fr 3               	dey
00092Fr 3               	lda scno
00092Fr 3               	sta (pbptr),y		; write screen.
00092Fr 3               	clc			; point to next free location
00092Fr 3               	lda pbptr
00092Fr 3               	adc #4
00092Fr 3               	sta pbptr
00092Fr 3               	bcc :+
00092Fr 3               	inc pbptr+1
00092Fr 3               :
00092Fr 3               	rts
00092Fr 3               .endif
00092Fr 3               
00092Fr 3               ;.if kflag
00092Fr 3               ;panp:
00092Fr 3               ;.endif
00092Fr 3               
00092Fr 3               ;----------------------------------------------
00092Fr 3               ; Print character pixels, no more.
00092Fr 3               ;
00092Fr 3               ; Input:
00092Fr 3               ;  A	= character to print
00092Fr 3               ;----------------------------------------------
00092Fr 3               
00092Fr 3               pchr:
00092Fr 3  20 rr rr     	jsr pchar 		; show character in accumulator.
000932r 3  E6 rr        	inc dispx		; move along one.
000934r 3  60           	rts
000935r 3               
000935r 3               ;----------------------------------------------------
000935r 3               ; Shifter sprite routine for objects.
000935r 3               ;----------------------------------------------------
000935r 3               
000935r 3               .if oflag
000935r 3               sprit7:
000935r 3  A5 rr        	lda z80_b
000937r 3  F0 0C        	beq sprit0
000939r 3  85 rr        	sta z80_a
00093Br 3               sprit3:
00093Br 3  46 rr        	lsr spr			; shift into position.
00093Dr 3  66 rr        	ror spr+1
00093Fr 3  66 rr        	ror spr+2
000941r 3  C6 rr        	dec z80_a		; one less iteration.
000943r 3  D0 F6        	bne sprit3
000945r 3               sprit0:
000945r 3  60           	rts 			; now apply to screen.
000946r 3               .endif
000946r 3               
000946r 3               ;-----------------------------------------------------------
000946r 3               ; Get room address.
000946r 3               ;-----------------------------------------------------------
000946r 3               
000946r 3               groom:
000946r 3  A6 rr        	ldx scno 		; screen number.
000948r 3  A0 00        	ldy #0
00094Ar 3               groomx:
00094Ar 3  A9 rr        	lda #<scdat 		; pointer to screens.
00094Cr 3  85 rr        	sta z80_l
00094Er 3  A9 rr        	lda #>scdat
000950r 3  85 rr        	sta z80_h
000952r 3               groom1:
000952r 3  E0 00        	cpx #0			; is it the first one?
000954r 3  F0 15        	beq groom0 		; no more screens to skip.
000956r 3               
000956r 3  18           	clc
000957r 3  A5 rr        	lda z80_l
000959r 3  79 rr rr     	adc scdat,y 		; low byte of screen size.
00095Cr 3  85 rr        	sta z80_l
00095Er 3  C8           	iny			; point to high byte.
00095Fr 3  A5 rr        	lda z80_h
000961r 3  79 rr rr     	adc scdat,y 		; high byte of screen size.
000964r 3  85 rr        	sta z80_h
000966r 3  C8           	iny			; next address.
000967r 3               
000967r 3  CA           	dex 			; one less iteration.
000968r 3  4C rr rr     	jmp groom1 		; loop until we reach the end.
00096Br 3               groom0:
00096Br 3  AD rr rr     	lda numsc		; add displacement.
00096Er 3  0A           	asl a
00096Fr 3  18           	clc			; add double displacement to address.
000970r 3  65 rr        	adc z80_l
000972r 3  85 rr        	sta z80_l
000974r 3  A5 rr        	lda z80_h
000976r 3  69 00        	adc #0
000978r 3  85 rr        	sta z80_h
00097Ar 3  60           	rts
00097Br 3               
00097Br 3               ;-----------------------------------------------------------
00097Br 3               ; Draw present room.
00097Br 3               ;-----------------------------------------------------------
00097Br 3               
00097Br 3               droom:
00097Br 3  AD rr rr     	lda wintop 		; window top.
00097Er 3  85 rr        	sta dispy		; set cursor y position.
000980r 3               droom2:
000980r 3  20 rr rr     	jsr groom 		; get address of current room.
000983r 3  A9 00        	lda #0	 		; zero in accumulator.
000985r 3  85 rr        	sta comcnt 		; reset compression counter.
000987r 3  AD rr rr     	lda winhgt 		; height of window.
00098Ar 3  85 rr        	sta rrow		; set row counter
00098Cr 3               droom0:
00098Cr 3  AD rr rr     	lda winlft 		; window left edge.
00098Fr 3  85 rr        	sta dispx 		; set cursor x position.
000991r 3  AD rr rr     	lda winwid 		; width of window.
000994r 3  85 rr        	sta rcol		; set column counter
000996r 3               droom1:
000996r 3  20 rr rr     	jsr flbyt 		; decompress next byte on the fly.
000999r 3               .if xflag
000999r 3               	jsr drwmeta
000999r 3               .else
000999r 3  20 rr rr     	jsr pattr2 		; show attributes and block.
00099Cr 3               .endif
00099Cr 3  C6 rr        	dec rcol		; one less column.
00099Er 3  D0 F6        	bne droom1 		; repeat for entire line.
0009A0r 3  E6 rr        	inc dispy		; move down one line.
0009A2r 3               .if xflag
0009A2r 3               	inc dispy		; move down one line.
0009A2r 3               .endif
0009A2r 3  C6 rr        	dec rrow 		; one less row.
0009A4r 3  D0 E6        	bne droom0 		; repeat for all rows.
0009A6r 3  60           	rts
0009A7r 3               
0009A7r 3               ;----------------------------------------------
0009A7r 3               ; Decompress bytes on-the-fly.
0009A7r 3               ;----------------------------------------------
0009A7r 3               
0009A7r 3               flbyt:
0009A7r 3  A5 rr        	lda comcnt 		; compression counter.
0009A9r 3  D0 21        	bne flbyt1		; any more to decompress?  yes.
0009ABr 3               
0009ABr 3  A0 00        	ldy #0
0009ADr 3  B1 rr        	lda (z80_hl),y 		; fetch next byte.
0009AFr 3  E6 rr        	inc z80_l 		; point to next cell.
0009B1r 3  D0 02        	bne :+
0009B3r 3  E6 rr        	inc z80_h
0009B5r 3               :
0009B5r 3  C9 FF        	cmp #255 		; is this byte a control code?
0009B7r 3  F0 01        	beq :+
0009B9r 3  60           	rts 			; no, this byte is uncompressed.
0009BAr 3               :
0009BAr 3  B1 rr        	lda (z80_hl),y 		; fetch byte type.
0009BCr 3  85 rr        	sta combyt 		; set up the type.
0009BEr 3  E6 rr        	inc z80_l 		; point to quantity.
0009C0r 3  D0 02        	bne :+
0009C2r 3  E6 rr        	inc z80_h
0009C4r 3               :
0009C4r 3  B1 rr        	lda (z80_hl),y 		; get quantity.
0009C6r 3  E6 rr        	inc z80_l 		; point to next byte.
0009C8r 3  D0 02        	bne :+
0009CAr 3  E6 rr        	inc z80_h
0009CCr 3               :
0009CCr 3               flbyt1:
0009CCr 3  85 rr        	sta comcnt 		; store new quantity.
0009CEr 3  C6 rr        	dec comcnt		; one less.
0009D0r 3  A5 rr        	lda combyt 		; byte to expand.
0009D2r 3  60           	rts
0009D3r 3               
0009D3r 3               ; ------------------------------------------------------------------------------------------------------------------------------------------
0009D3r 3               ; Drawing a MetaBlock (4 tiles 8x8 => 16x16)
0009D3r 3               ; param in regA tells the block number to use, if 0 use 0,0,0,0  else use N,N+2 || N+1,N+3
0009D3r 3               ; ------------------------------------------------------------------------------------------------------------------------------------------
0009D3r 3               .if xflag
0009D3r 3               drwmeta:
0009D3r 3               	sta tmpblk
0009D3r 3               	jsr pattr2
0009D3r 3               
0009D3r 3               	inc dispy
0009D3r 3               	dec dispx
0009D3r 3               	ldx tmpblk
0009D3r 3               	beq :+
0009D3r 3               	inx
0009D3r 3               :
0009D3r 3               	txa
0009D3r 3               	jsr pattr2
0009D3r 3               
0009D3r 3               	ldx tmpblk
0009D3r 3               	beq :+
0009D3r 3               	inx
0009D3r 3               	inx
0009D3r 3               	inx
0009D3r 3               :
0009D3r 3               	txa
0009D3r 3               	jsr pattr2
0009D3r 3               
0009D3r 3               	dec dispy
0009D3r 3               	dec dispx
0009D3r 3               	ldx tmpblk
0009D3r 3               	beq :+
0009D3r 3               	inx
0009D3r 3               	inx
0009D3r 3               :
0009D3r 3               	txa
0009D3r 3               	jsr pattr2
0009D3r 3               	rts
0009D3r 3               
0009D3r 3               tmpblk:	.byte 0
0009D3r 3               
0009D3r 3               .endif
0009D3r 3               
0009D3r 3               ;------------------------------------------
0009D3r 3               ; Ladder down check.
0009D3r 3               ;
0009D3r 3               ; Input:
0009D3r 3               ;  IX = sprite pointer
0009D3r 3               ;------------------------------------------
0009D3r 3               
0009D3r 3               .if lflag
0009D3r 3               laddd:
0009D3r 3               	ldy #9
0009D3r 3               	lda (z80_ix),y		; x coordinate.
0009D3r 3               	sta dispx
0009D3r 3               
0009D3r 3               	ldy #8
0009D3r 3               	lda (z80_ix),y		; y coordinate.
0009D3r 3               	and #254		; make it even.
0009D3r 3               	sta (z80_ix),y 		; reset it.
0009D3r 3               	clc 			; look down 16 pixels.
0009D3r 3               numsp5:
0009D3r 3               	adc #SPR_HGT
0009D3r 3               	sta dispy		; coords in dispx,dispy.
0009D3r 3               	jmp laddv
0009D3r 3               
0009D3r 3               ;------------------------------------------
0009D3r 3               ; Ladder up check.
0009D3r 3               ;
0009D3r 3               ; Input:
0009D3r 3               ;  IX = sprite pointer
0009D3r 3               ;
0009D3r 3               ; Output:
0009D3r 3               ;  A  = 0 is ok, A <>0 is not ok
0009D3r 3               ;------------------------------------------
0009D3r 3               
0009D3r 3               laddu:
0009D3r 3               	ldy #9
0009D3r 3               	lda (z80_ix),y		; x coordinate.
0009D3r 3               	sta dispx
0009D3r 3               
0009D3r 3               	ldy #8
0009D3r 3               	lda (z80_ix),y		; y coordinate.
0009D3r 3               	and #254 		; make it even.
0009D3r 3               	sta (z80_ix),y		; reset it.
0009D3r 3               	clc 			; look 2 pixels above feet.
0009D3r 3               numsp6:
0009D3r 3               	adc #SPR_HGT-2
0009D3r 3               	sta dispy		; coords in dispx,dispy.
0009D3r 3               laddv:
0009D3r 3               	jsr tstbl 		; get map address.
0009D3r 3               	jsr ldchk 		; standard ladder check.
0009D3r 3               	beq :+
0009D3r 3               	rts 			; no way through.
0009D3r 3               :
0009D3r 3               	inc bufaddr 		; look right one cell.
0009D3r 3               	bne :+
0009D3r 3               	inc bufaddr+1
0009D3r 3               :
0009D3r 3               	jsr ldchk 		; do the check.
0009D3r 3               	beq :+
0009D3r 3               	rts 			; impassable.
0009D3r 3               :
0009D3r 3               	lda dispx 		; y coordinate.
0009D3r 3               	and #7 			; position straddling block cells.
0009D3r 3               	bne :+
0009D3r 3               	rts 			; no more checks needed.
0009D3r 3               :
0009D3r 3               	inc bufaddr 		; look to third cell.
0009D3r 3               	bne :+
0009D3r 3               	inc bufaddr+1
0009D3r 3               :
0009D3r 3               	jsr ldchk 		; do the check.
0009D3r 3               	rts  			; return with zero flag set accordingly.
0009D3r 3               .endif
0009D3r 3               
0009D3r 3               ;---------------------------------------------------------
0009D3r 3               ; Can go up check.
0009D3r 3               ;
0009D3r 3               ; Input:
0009D3r 3               ;  IX = sprite pointer
0009D3r 3               ;
0009D3r 3               ; Output:
0009D3r 3               ;  A  = 0 is ok, A <>0 is not ok
0009D3r 3               ;---------------------------------------------------------
0009D3r 3               
0009D3r 3               cangu:
0009D3r 3  A0 09        	ldy #9
0009D5r 3  B1 rr        	lda (z80_ix),y		; x coordinate.
0009D7r 3  85 rr        	sta dispx
0009D9r 3  A0 08        	ldy #8
0009DBr 3  B1 rr        	lda (z80_ix),y 		; y coordinate.
0009DDr 3  38           	sec
0009DEr 3  E9 02        	sbc #2
0009E0r 3  85 rr        	sta dispy		; coords in dispx,dispy.
0009E2r 3  20 rr rr     	jsr tstbl 		; get map address.
0009E5r 3  20 rr rr     	jsr lrchk 		; standard left/right check.
0009E8r 3  F0 01        	beq :+
0009EAr 3  60           	rts			; no way through.
0009EBr 3               :
0009EBr 3  E6 rr        	inc bufaddr		; look right one cell.
0009EDr 3  D0 02        	bne :+
0009EFr 3  E6 rr        	inc bufaddr+1
0009F1r 3               :
0009F1r 3  20 rr rr     	jsr lrchk 		; do the check.
0009F4r 3  F0 01        	beq :+
0009F6r 3  60           	rts			; impassable.
0009F7r 3               :
0009F7r 3  A5 rr        	lda dispx		; x coordinate.
0009F9r 3  29 07        	and #7			; position straddling block cells.
0009FBr 3  D0 01        	bne :+
0009FDr 3  60           	rts			; no more checks needed.
0009FEr 3               :
0009FEr 3  E6 rr        	inc bufaddr		; look to third cell.
000A00r 3  D0 02        	bne :+
000A02r 3  E6 rr        	inc bufaddr+1
000A04r 3               :
000A04r 3  20 rr rr     	jsr lrchk		; do the check.
000A07r 3  60           	rts 			; return with zero flag set accordingly.
000A08r 3               
000A08r 3               ;---------------------------------------------------------
000A08r 3               ; Can go down check.
000A08r 3               ;
000A08r 3               ; Input:
000A08r 3               ;  IX = sprite pointer
000A08r 3               ;
000A08r 3               ; Output:
000A08r 3               ;  A  = 0 is ok, A <>0 is not ok
000A08r 3               ;---------------------------------------------------------
000A08r 3               
000A08r 3               cangd:
000A08r 3  A0 09        	ldy #9
000A0Ar 3  B1 rr        	lda (z80_ix),y 		; x coordinate.
000A0Cr 3  85 rr        	sta dispx
000A0Er 3  A0 08        	ldy #8
000A10r 3  B1 rr        	lda (z80_ix),y		; y coordinate.
000A12r 3  18           	clc
000A13r 3               numsp3:
000A13r 3  69 10        	adc #SPR_HGT 		; look down 16 pixels.
000A15r 3  85 rr        	sta dispy		; coords in dispx,dispy.
000A17r 3  20 rr rr     	jsr tstbl 		; get map address.
000A1Ar 3  20 rr rr     	jsr plchk 		; block, platform check.
000A1Dr 3  F0 01        	beq :+
000A1Fr 3  60           	rts			; no way through.
000A20r 3               :
000A20r 3  E6 rr        	inc bufaddr		; look right one cell.
000A22r 3  D0 02        	bne :+
000A24r 3  E6 rr        	inc bufaddr+1
000A26r 3               :
000A26r 3  20 rr rr     	jsr plchk		; block, platform check.
000A29r 3  F0 01        	beq :+
000A2Br 3  60           	rts			; impassable.
000A2Cr 3               :
000A2Cr 3  A5 rr        	lda dispx		; x coordinate.
000A2Er 3  29 07        	and #7			; position straddling block cells.
000A30r 3  D0 01        	bne :+
000A32r 3  60           	rts			; no more checks needed.
000A33r 3               :
000A33r 3  E6 rr        	inc bufaddr		; look to third cell.
000A35r 3  D0 02        	bne :+
000A37r 3  E6 rr        	inc bufaddr+1
000A39r 3               :
000A39r 3  20 rr rr     	jsr plchk		; block, platform check.
000A3Cr 3  60           	rts			; return with zero flag set accordingly.
000A3Dr 3               
000A3Dr 3               ;---------------------------------------------------------
000A3Dr 3               ; Can go left check.
000A3Dr 3               ;
000A3Dr 3               ; Input:
000A3Dr 3               ;  IX = sprite pointer
000A3Dr 3               ;
000A3Dr 3               ; Output:
000A3Dr 3               ;  A  = 0 is ok, A <>0 is not ok
000A3Dr 3               ;---------------------------------------------------------
000A3Dr 3               
000A3Dr 3               cangl:
000A3Dr 3  A0 08        	ldy #8
000A3Fr 3  B1 rr        	lda (z80_ix),y 		; y coordinate.
000A41r 3  85 rr        	sta dispy
000A43r 3  A0 09        	ldy #9
000A45r 3  B1 rr        	lda (z80_ix),y 		; x coordinate.
000A47r 3  38           	sec
000A48r 3  E9 02        	sbc #2			; look left 2 pixels.
000A4Ar 3  85 rr        	sta dispx		; coords in dispx,dispy.
000A4Cr 3  4C rr rr     	jmp cangh		; test if we can go there.
000A4Fr 3               
000A4Fr 3               ;---------------------------------------------------------
000A4Fr 3               ; Can go right check.
000A4Fr 3               ;
000A4Fr 3               ; Input:
000A4Fr 3               ;  IX = sprite pointer
000A4Fr 3               ;
000A4Fr 3               ; Output:
000A4Fr 3               ;  A  = 0 is ok, A <>0 is not ok
000A4Fr 3               ;---------------------------------------------------------
000A4Fr 3               
000A4Fr 3               cangr:
000A4Fr 3  A0 08        	ldy #8
000A51r 3  B1 rr        	lda (z80_ix),y		; y coordinate.
000A53r 3  85 rr        	sta dispy
000A55r 3  A0 09        	ldy #9
000A57r 3  B1 rr        	lda (z80_ix),y		; x coordinate.
000A59r 3  18           	clc
000A5Ar 3  69 10        	adc #16			; look right 16 pixels.
000A5Cr 3  85 rr        	sta dispx		; coords in dispx,dispy.
000A5Er 3               cangh:
000A5Er 3               cangh2:
000A5Er 3  A9 03        	lda #(SPR_HGT/8+1)	; default rows to write.
000A60r 3  85 rr        	sta z80_b
000A62r 3  A5 rr        	lda dispy		; y position.
000A64r 3  29 07        	and #7			; does x straddle cells?
000A66r 3  D0 02        	bne cangh0		; yes, loop counter is good.
000A68r 3  C6 rr        	dec z80_b		; one less row to write.
000A6Ar 3               cangh0:
000A6Ar 3  20 rr rr     	jsr tstbl		; get map address.
000A6Dr 3               cangh1:
000A6Dr 3  20 rr rr     	jsr lrchk		; standard left/right check.
000A70r 3  F0 01        	beq :+
000A72r 3  60           	rts			; no way through.
000A73r 3               :
000A73r 3  48           	pha
000A74r 3  18           	clc
000A75r 3  A5 rr        	lda bufaddr
000A77r 3  69 20        	adc #32			; look down.
000A79r 3  85 rr        	sta bufaddr
000A7Br 3  90 02        	bcc :+
000A7Dr 3  E6 rr        	inc bufaddr+1
000A7Fr 3               :
000A7Fr 3  68           	pla
000A80r 3               
000A80r 3  C6 rr        	dec z80_b
000A82r 3  D0 E9        	bne cangh1
000A84r 3  60           	rts
000A85r 3               
000A85r 3               ;-------------------------------------
000A85r 3               ; Check left/right movement is okay.
000A85r 3               ;
000A85r 3               ; Input:
000A85r 3               ;  bufaddr = MAP + x/8 + y/8*32
000A85r 3               ;
000A85r 3               ; Output:
000A85r 3               ;  A  = 0 is ok, A <>0 is not ok
000A85r 3               ;-------------------------------------
000A85r 3               
000A85r 3               lrchk:
000A85r 3  A0 00        	ldy #0
000A87r 3  B1 rr        	lda (bufaddr),y		; fetch map cell.
000A89r 3  C9 02        	cmp #WALL 		; is it passable?
000A8Br 3  F0 0A        	beq lrchkx		; no.
000A8Dr 3               
000A8Dr 3  C9 04        	cmp #FODDER		; fodder has to be dug.
000A8Fr 3  F0 06        	beq lrchkx		; not passable.
000A91r 3  A9 00        	lda #0
000A93r 3  60           	rts
000A94r 3               
000A94r 3               ;--------------------------------------------------------------
000A94r 3               ; Called by mmenu
000A94r 3               ;--------------------------------------------------------------
000A94r 3               
000A94r 3               always:
000A94r 3  A9 FF        	lda #255		; report it as okay.
000A96r 3  60           	rts
000A97r 3               
000A97r 3               lrchkx:
000A97r 3  A9 01        	lda #1 			; reset all bits.
000A99r 3  60           	rts
000A9Ar 3               
000A9Ar 3               
000A9Ar 3               ;--------------------------------------------------------------
000A9Ar 3               ; Check platform or solid item is not in way.
000A9Ar 3               ;
000A9Ar 3               ; Input:
000A9Ar 3               ;  bufaddr = MAP + x/8 + y/8*32
000A9Ar 3               ;
000A9Ar 3               ; Output:
000A9Ar 3               ;  A  = 0 is ok, A <>0 is not ok
000A9Ar 3               ;--------------------------------------------------------------
000A9Ar 3               
000A9Ar 3               plchk:
000A9Ar 3  A0 00        	ldy #0
000A9Cr 3  B1 rr        	lda (bufaddr),y 	; fetch map cell.
000A9Er 3  C9 02        	cmp #WALL 		; is it passable?
000AA0r 3  F0 F5        	beq lrchkx		; no.
000AA2r 3               .if pflag .or dflag
000AA2r 3               	cmp #FODDER		; fodder has to be dug.
000AA2r 3               	beq lrchkx		; not passable.
000AA2r 3               .endif
000AA2r 3  C9 01        	cmp #PLATFM		; platform is solid.
000AA4r 3  F0 03        	beq plchkx		; not passable.
000AA6r 3               .if lflag
000AA6r 3               	cmp #LADDER		; is it a ladder?
000AA6r 3               	beq lrchkx		; on ladder, deny movement.
000AA6r 3               .endif
000AA6r 3               plchk0:
000AA6r 3  A9 00        	lda #0			; report as ok
000AA8r 3  60           	rts
000AA9r 3               plchkx:
000AA9r 3  A5 rr        	lda dispy		; x coordinate.
000AABr 3  29 07        	and #7			; position straddling blocks.
000AADr 3  F0 E8        	beq lrchkx		; on platform, deny movement.
000AAFr 3  4C rr rr     	jmp plchk0
000AB2r 3               
000AB2r 3               ;--------------------------------------------------------------
000AB2r 3               ; Check ladder is available.
000AB2r 3               ;
000AB2r 3               ; Input:
000AB2r 3               ;  bufaddr = MAP + x/8 + y/8*32
000AB2r 3               ;
000AB2r 3               ; Output:
000AB2r 3               ;  A  = 0 is ok, A <>0 is not ok
000AB2r 3               ;--------------------------------------------------------------
000AB2r 3               
000AB2r 3               .if lflag
000AB2r 3               ldchk:
000AB2r 3               	ldy #0
000AB2r 3               	lda (bufaddr),y 	; fetch cell.
000AB2r 3               	cmp #LADDER 		; is it a ladder?
000AB2r 3               	beq ldchk1
000AB2r 3               	lda #1
000AB2r 3               	rts  			; return with zero flag set accordingly.
000AB2r 3               ldchk1:
000AB2r 3               	lda #0
000AB2r 3               	rts
000AB2r 3               .endif
000AB2r 3               
000AB2r 3               ;--------------------------------------------------------------
000AB2r 3               ; Get collectables.
000AB2r 3               ;--------------------------------------------------------------
000AB2r 3               
000AB2r 3               .if cflag
000AB2r 3               getcol:
000AB2r 3                       lda #COLECT             ; collectable blocks.
000AB2r 3                       sta z80_b
000AB2r 3                       jsr tded                ; test for collectable blocks.
000AB2r 3                       cmp z80_b               ; did we find one?
000AB2r 3                       beq :+
000AB2r 3                       rts                     ; none were found, job done.
000AB2r 3               :
000AB2r 3                       jsr gtblk               ; get block.
000AB2r 3                       jsr evnt20              ; collected block event.
000AB2r 3                       jmp getcol              ; repeat until none left.
000AB2r 3               
000AB2r 3               ; Get collectable block.
000AB2r 3               
000AB2r 3               gtblk:
000AB2r 3               	ldy #0
000AB2r 3               	lda (bufaddr),y
000AB2r 3               	sta z80_a
000AB2r 3                       lda #0
000AB2r 3                       sta (bufaddr),y		; make it empty now.
000AB2r 3               
000AB2r 3               	lda bufaddr		; set dispx
000AB2r 3               	and #31
000AB2r 3               	sta dispx
000AB2r 3               
000AB2r 3               	lda bufaddr+1		; Set dispy
000AB2r 3               	sec
000AB2r 3               	sbc #>MAP
000AB2r 3               	sta bufaddr+1
000AB2r 3               	asl bufaddr
000AB2r 3               	rol bufaddr+1
000AB2r 3               	asl bufaddr
000AB2r 3               	rol bufaddr+1
000AB2r 3               	asl bufaddr
000AB2r 3               	rol bufaddr+1
000AB2r 3               	lda bufaddr+1
000AB2r 3               	sta dispy
000AB2r 3               
000AB2r 3               	lda colpatt		; get blocknr
000AB2r 3               	sta z80_e		; displacement in e.
000AB2r 3               	lda #0
000AB2r 3               	sta z80_d		; no high byte.
000AB2r 3               	asl z80_e  		; multiply char by 8.
000AB2r 3               	rol z80_d
000AB2r 3               	asl z80_e
000AB2r 3               	rol z80_d
000AB2r 3               	asl z80_e
000AB2r 3               	rol z80_d
000AB2r 3               	clc
000AB2r 3               	lda z80_e
000AB2r 3               	adc #<chgfx 		; address of graphics.
000AB2r 3               	sta tileaddr
000AB2r 3               	lda z80_d
000AB2r 3               	adc #>chgfx
000AB2r 3               	sta tileaddr+1
000AB2r 3               	jsr gprad 		; get screen address.
000AB2r 3               	ldx #7			; number of pixel rows to write.
000AB2r 3               gtblk0:
000AB2r 3               	ldy #0
000AB2r 3               	lda (tileaddr),y 	; get image byte.
000AB2r 3               	ldy scrtab,x
000AB2r 3               	eor (scraddr),y 	; XOR tile on screen
000AB2r 3               	sta (scraddr),y 	; copy to screen.
000AB2r 3               	inc tileaddr 		; next image byte.
000AB2r 3               	bne :+
000AB2r 3               	inc tileaddr+1
000AB2r 3               :
000AB2r 3               	dex	 		; repeat for 8 pixel rows.
000AB2r 3               	bpl gtblk0
000AB2r 3               	rts
000AB2r 3               .endif
000AB2r 3               
000AB2r 3               ;--------------------------------------------------------------
000AB2r 3               ; Touched deadly block check.
000AB2r 3               ; returns with DEADLY (must be non-zero) in accumulator if true.
000AB2r 3               ;
000AB2r 3               ; Input:
000AB2r 3               ;  IX = sprite address
000AB2r 3               ;
000AB2r 3               ; Output:
000AB2r 3               ;  A  = 0 is ok, A=5 is not ok
000AB2r 3               ;--------------------------------------------------------------
000AB2r 3               
000AB2r 3               tded:
000AB2r 3  A0 08        	ldy #8
000AB4r 3  B1 rr        	lda (z80_ix),y 		; y coordinate.
000AB6r 3  85 rr        	sta dispy
000AB8r 3  C8           	iny
000AB9r 3  B1 rr        	lda (z80_ix),y 		; x coordinate.
000ABBr 3  85 rr        	sta dispx		; coords in dispx,dispy.
000ABDr 3  20 rr rr     	jsr tstbl		; get map address.
000AC0r 3  48           	pha
000AC1r 3  A9 1F        	lda #31			; default distance to next line down.
000AC3r 3  85 rr        	sta z80_e
000AC5r 3  68           	pla
000AC6r 3  C5 rr        	cmp z80_b		; is this the required block?
000AC8r 3  D0 01        	bne :+
000ACAr 3  60           	rts			; yes.
000ACBr 3               :
000ACBr 3  E6 rr        	inc bufaddr 		; next cell.
000ACDr 3  D0 02        	bne :+
000ACFr 3  E6 rr        	inc bufaddr+1
000AD1r 3               :
000AD1r 3  A0 00        	ldy #0
000AD3r 3  B1 rr        	lda (bufaddr),y		; fetch type.
000AD5r 3  C5 rr        	cmp z80_b 		; is this deadly/custom?
000AD7r 3  D0 01        	bne :+
000AD9r 3  60           	rts			; yes.
000ADAr 3               :
000ADAr 3  A5 rr        	lda dispx		; horizontal position.
000ADCr 3  85 rr        	sta z80_c 		; store column in c register.
000ADEr 3  29 07        	and #7			; is it straddling cells?
000AE0r 3  D0 03        	bne :+
000AE2r 3  4C rr rr     	jmp tded0		; no.
000AE5r 3               :
000AE5r 3  E6 rr        	inc bufaddr 		; last cell.
000AE7r 3  D0 02        	bne :+
000AE9r 3  E6 rr        	inc bufaddr+1
000AEBr 3               :
000AEBr 3  A0 00        	ldy #0
000AEDr 3  B1 rr        	lda (bufaddr),y 	; fetch type.
000AEFr 3  C5 rr        	cmp z80_b		; is this the block?
000AF1r 3  D0 01        	bne :+
000AF3r 3  60           	rts			; yes.
000AF4r 3               :
000AF4r 3  C6 rr        	dec z80_e		; one less cell to next row down.
000AF6r 3               tded0:
000AF6r 3  18           	clc 			; point to next row.
000AF7r 3  A5 rr        	lda bufaddr
000AF9r 3  65 rr        	adc z80_e
000AFBr 3  85 rr        	sta bufaddr
000AFDr 3  90 02        	bcc :+
000AFFr 3  E6 rr        	inc bufaddr+1
000B01r 3               :
000B01r 3  A0 00        	ldy #0
000B03r 3  B1 rr        	lda (bufaddr),y		; fetch left cell block.
000B05r 3  C5 rr        	cmp z80_b		; is this fatal?
000B07r 3  D0 01        	bne :+
000B09r 3  60           	rts			; yes.
000B0Ar 3               :
000B0Ar 3  E6 rr        	inc bufaddr 		; next cell.
000B0Cr 3  D0 02        	bne :+
000B0Er 3  E6 rr        	inc bufaddr+1
000B10r 3               :
000B10r 3  A0 00        	ldy #0
000B12r 3  B1 rr        	lda (bufaddr),y 	; fetch type.
000B14r 3  C5 rr        	cmp z80_b		; is this fatal?
000B16r 3  D0 01        	bne :+
000B18r 3  60           	rts			; yes.
000B19r 3               :
000B19r 3  A5 rr        	lda z80_c		; horizontal position.
000B1Br 3  29 07        	and #7			; is it straddling cells?
000B1Dr 3  D0 03        	bne :+
000B1Fr 3  4C rr rr     	jmp tded1 		; no.
000B22r 3               :
000B22r 3  E6 rr        	inc bufaddr		; last cell.
000B24r 3  D0 02        	bne :+
000B26r 3  E6 rr        	inc bufaddr+1
000B28r 3               :
000B28r 3  A0 00        	ldy #0
000B2Ar 3  B1 rr        	lda (bufaddr),y		; fetch type.
000B2Cr 3  C5 rr        	cmp z80_b		; is this fatal?
000B2Er 3  D0 01        	bne :+
000B30r 3  60           	rts			; yes.
000B31r 3               :
000B31r 3               tded1:
000B31r 3  A5 rr        	lda dispy		; vertical position.
000B33r 3  29 07        	and #7 			; is it straddling cells?
000B35r 3  D0 01        	bne :+
000B37r 3  60           	rts			; no, job done.
000B38r 3               :
000B38r 3  18           	clc			; point to next row.
000B39r 3  A5 rr        	lda bufaddr
000B3Br 3  65 rr        	adc z80_e
000B3Dr 3  85 rr        	sta bufaddr
000B3Fr 3  90 02        	bcc :+
000B41r 3  E6 rr        	inc bufaddr+1
000B43r 3               :
000B43r 3  A0 00        	ldy #0
000B45r 3  B1 rr        	lda (bufaddr),y 	; fetch left cell block.
000B47r 3  C5 rr        	cmp z80_b		; is this fatal?
000B49r 3  D0 01        	bne :+
000B4Br 3  60           	rts			; yes.
000B4Cr 3               :
000B4Cr 3  E6 rr        	inc bufaddr		; next cell.
000B4Er 3  D0 02        	bne :+
000B50r 3  E6 rr        	inc bufaddr+1
000B52r 3               :
000B52r 3  A0 00        	ldy #0
000B54r 3  B1 rr        	lda (bufaddr),y 	; fetch type.
000B56r 3  C5 rr        	cmp z80_b		; is this fatal?
000B58r 3  D0 01        	bne :+
000B5Ar 3  60           	rts			; yes.
000B5Br 3               :
000B5Br 3  A5 rr        	lda z80_c		; horizontal position.
000B5Dr 3  29 07        	and #7			; is it straddling cells?
000B5Fr 3  D0 01        	bne :+
000B61r 3  60           	rts			; no.
000B62r 3               :
000B62r 3  E6 rr        	inc bufaddr		; last cell.
000B64r 3  D0 02        	bne :+
000B66r 3  E6 rr        	inc bufaddr+1
000B68r 3               :
000B68r 3  A0 00        	ldy #0
000B6Ar 3  B1 rr        	lda (bufaddr),y		; fetch final type.
000B6Cr 3  60           	rts 			; return with final type in accumulator.
000B6Dr 3               
000B6Dr 3               ;---------------------------------------------------
000B6Dr 3               ; Fetch block type at (dispx, dispy).
000B6Dr 3               ;
000B6Dr 3               ; Output:
000B6Dr 3               ;  A = block type
000B6Dr 3               ;---------------------------------------------------
000B6Dr 3               
000B6Dr 3               tstbl:
000B6Dr 3  A5 rr        	lda dispy 		; fetch y coord.
000B6Fr 3  4A           	lsr a			; bufaddr = y/8
000B70r 3  4A           	lsr a
000B71r 3  4A           	lsr a
000B72r 3               ;	sta chary
000B72r 3               
000B72r 3  85 rr        	sta bufaddr
000B74r 3  A9 00        	lda #0
000B76r 3  85 rr        	sta bufaddr+1
000B78r 3               
000B78r 3  06 rr        	asl bufaddr  		; bufaddr = y/8 * 32
000B7Ar 3  26 rr        	rol bufaddr+1
000B7Cr 3  06 rr        	asl bufaddr
000B7Er 3  26 rr        	rol bufaddr+1
000B80r 3  06 rr        	asl bufaddr
000B82r 3  26 rr        	rol bufaddr+1
000B84r 3  06 rr        	asl bufaddr
000B86r 3  26 rr        	rol bufaddr+1
000B88r 3  06 rr        	asl bufaddr
000B8Ar 3  26 rr        	rol bufaddr+1
000B8Cr 3               
000B8Cr 3  A5 rr        	lda dispx		; x/8
000B8Er 3  4A           	lsr a
000B8Fr 3  4A           	lsr a
000B90r 3  4A           	lsr a
000B91r 3               ;	sta charx
000B91r 3               
000B91r 3  18           	clc			; bufaddr = MAP + x/8 + y/8*32
000B92r 3  65 rr        	adc bufaddr
000B94r 3  69 00        	adc #<MAP
000B96r 3  85 rr        	sta bufaddr
000B98r 3  A5 rr        	lda bufaddr+1
000B9Ar 3  69 04        	adc #>MAP
000B9Cr 3  85 rr        	sta bufaddr+1
000B9Er 3               
000B9Er 3  A0 00        	ldy #0
000BA0r 3  B1 rr        	lda (bufaddr),y 	; fetch byte there.
000BA2r 3  60           	rts
000BA3r 3               
000BA3r 3               ;-------------------------------------------------------------------
000BA3r 3               ; Jump - if we can.
000BA3r 3               ; Requires initial speed to be set up in accumulator prior to call.
000BA3r 3               ;
000BA3r 3               ; Input:
000BA3r 3               ;  IX = sprite address
000BA3r 3               ;-------------------------------------------------------------------
000BA3r 3               
000BA3r 3               jump:
000BA3r 3  A0 0D        	ldy #var_jumpLo
000BA5r 3  B1 rr        	lda (z80_ix),y		; jump table low.
000BA7r 3  A0 0E        	ldy #var_jumpHi
000BA9r 3  11 rr        	ora (z80_ix),y		; jump table high.
000BABr 3  F0 01        	beq :+
000BADr 3  60           	rts			; already in the air.
000BAEr 3               :
000BAEr 3  A9 rr        	lda #>jtab
000BB0r 3  A0 0E        	ldy #var_jumpHi
000BB2r 3  91 rr        	sta (z80_ix),y		; set jump high.
000BB4r 3  A9 rr        	lda #<jtab		; jump table start.
000BB6r 3  A0 0D        	ldy #var_jumpLo
000BB8r 3  91 rr        	sta (z80_ix),y		; set jump low.
000BBAr 3  60           	rts
000BBBr 3               
000BBBr 3               ; Jump table.
000BBBr 3               ; _BEEB - jump table must reside entirely in a page otherwise grav fn breaks
000BBBr 3               ;.align 32
000BBBr 3               ;jtab:
000BBBr 3               ;	.byte 248,250,252
000BBBr 3               ;	.byte 254,254,255
000BBBr 3               ;	.byte 255,255,0,0
000BBBr 3               ;	.byte 0,1,1,1,2,2
000BBBr 3               ;	.byte 4,6,8,8,8,99
000BBBr 3               
000BBBr 3               ;------------------------------------------------
000BBBr 3               ; Random numbers code.
000BBBr 3               ; Pseudo-random number generator, 8-bit.
000BBBr 3               ;
000BBBr 3               ; Output:
000BBBr 3               ;  RND = random number
000BBBr 3               ;------------------------------------------------
000BBBr 3               
000BBBr 3               random:
000BBBr 3  A5 rr        	lda seed
000BBDr 3  F0 05        	beq doEor
000BBFr 3  0A           	asl a
000BC0r 3  F0 04        	beq noEor
000BC2r 3  90 02        	bcc noEor
000BC4r 3  49 1D        doEor:	eor #$1d
000BC6r 3  85 rr        noEor:	sta seed
000BC8r 3  60           	rts
000BC9r 3               
000BC9r 3  A5 rr        	lda seed		; get last random number.
000BCBr 3  0A           	asl a
000BCCr 3  0A           	asl a
000BCDr 3  18           	clc
000BCEr 3  65 rr        	adc seed
000BD0r 3  18           	clc
000BD1r 3  69 45        	adc #$45
000BD3r 3  85 rr        	sta seed		; store new seed.
000BD5r 3  85 rr        	sta varrnd		; return number in variable.
000BD7r 3  60           	rts
000BD8r 3               
000BD8r 3               ;-------------------------------------------------------
000BD8r 3               ; Joystick and keyboard reading routines.
000BD8r 3               ;
000BD8r 3               ; contrl = 0, Keyboard
000BD8r 3               ;          1, JoyKeyb
000BD8r 3               ;          2, JoyMMC
000BD8r 3               ;
000BD8r 3               ;      joyval=x65FUDLR (bit cleared if key pressed)
000BD8r 3               ;             ||||||||
000BD8r 3               ;             |||||||+> Right    KEY 0  - X
000BD8r 3               ;             ||||||+-> Left     KEY 1  - Z
000BD8r 3               ;             |||||+--> Down     KEY 2  - .
000BD8r 3               ;             ||||+---> Up       KEY 3  - ;
000BD8r 3               ;             |||+----> Fire1    KEY 4  - SPC
000BD8r 3               ;             ||+-----> Fire2    KEY 5  - Q
000BD8r 3               ;             |+------> Fire3    KEY 6  - P
000BD8r 3               ;             +-------> Not used
000BD8r 3               ;
000BD8r 3               ;                       Option1  KEY 7  - 1
000BD8r 3               ;                       Option2  KEY 8  - 2
000BD8r 3               ;                       Option3  KEY 9  - 3
000BD8r 3               ;                       Option4  KEY 10 - 4
000BD8r 3               ;-------------------------------------------------------
000BD8r 3               
000BD8r 3               joykey:
000BD8r 3  A5 rr        	lda contrl 		; control flag.
000BDAr 3  C9 01        	cmp #1
000BDCr 3  F0 1A        	beq joy1 		; scan joystick1
000BDEr 3  C9 02        	cmp #2
000BE0r 3  F0 1C        	beq joy2 		; scan joystick2
000BE2r 3               
000BE2r 3               ; Scan keyboard
000BE2r 3               
000BE2r 3  A9 00        	lda #0		 	; zero reading.
000BE4r 3  85 rr        	sta z80_e
000BE6r 3               
000BE6r 3  A0 06        	ldy #6	 		; address of last key.
000BE8r 3               joyke0:
000BE8r 3  B9 rr rr     	lda keys,y 		; get key from table.
000BEBr 3  20 rr rr     	jsr ktest		; being pressed?
000BEEr 3  26 rr        	rol z80_e 		; rotate into reading.
000BF0r 3               
000BF0r 3  88           	dey		 	; next key.
000BF1r 3  10 F5        	bpl joyke0 		; repeat for all keys.
000BF3r 3               joyret:
000BF3r 3  A5 rr        	lda z80_e
000BF5r 3  85 rr        	sta joyval
000BF7r 3  60           	rts
000BF8r 3               
000BF8r 3               ; Scan joystick 1
000BF8r 3               
000BF8r 3               joy1:
000BF8r 3  20 rr rr     	jsr joy1scan
000BFBr 3  4C rr rr     	jmp joyret 		; store the value.
000BFEr 3               
000BFEr 3               ; Scan joystick 2
000BFEr 3               
000BFEr 3               joy2:
000BFEr 3  20 rr rr     	jsr joy2scan
000C01r 3  4C rr rr     	jmp joyret 		; store the value.
000C04r 3               
000C04r 3               ;---------------------------------------------------------------
000C04r 3               ; Display message.
000C04r 3               ;
000C04r 3               ; Input:
000C04r 3               ;  A = message number
000C04r 3               ;---------------------------------------------------------------
000C04r 3               
000C04r 3               dmsg:
000C04r 3  AA           	tax
000C05r 3  A9 rr        	lda #<msgdat		; pointer to messages.
000C07r 3  85 rr        	sta z80_l
000C09r 3  A9 rr        	lda #>msgdat
000C0Br 3  85 rr        	sta z80_h
000C0Dr 3  20 rr rr     	jsr getwrd		; get message number.
000C10r 3               dmsg3:
000C10r 3  20 rr rr     	jsr preprt		; pre-printing stuff.
000C13r 3  20 rr rr     	jsr checkx		; make sure we"re in a printable range.
000C16r 3  A5 rr        	lda prtmod		; print mode.
000C18r 3  D0 47        	bne bmsg1		; no, double-height text.
000C1Ar 3               dmsg0:
000C1Ar 3  A5 rr        	lda z80_h		; store string pointer.
000C1Cr 3  48           	pha
000C1Dr 3  A5 rr        	lda z80_l
000C1Fr 3  48           	pha
000C20r 3               
000C20r 3  A0 00        	ldy #0
000C22r 3  B1 rr        	lda (z80_hl),y		; fetch byte to display.
000C24r 3  29 7F        	and #127		; remove any end marker.
000C26r 3  C9 0D        	cmp #ASCII_NEWLINE
000C28r 3  F0 24        	beq dmsg1
000C2Ar 3  20 rr rr     	jsr pchar		; display character.
000C2Dr 3  20 rr rr     	jsr nexpos 		; display position.
000C30r 3  D0 03        	bne dmsg2		; not on a new line.
000C32r 3  20 rr rr     	jsr nexlin		; next line down.
000C35r 3               dmsg2:
000C35r 3  68           	pla			; retrieve string pointer
000C36r 3  85 rr        	sta z80_l
000C38r 3  68           	pla
000C39r 3  85 rr        	sta z80_h
000C3Br 3               
000C3Br 3  A0 00        	ldy #0
000C3Dr 3  B1 rr        	lda (z80_hl),y		; fetch last character.
000C3Fr 3  0A           	asl a  			; was it the end?
000C40r 3  90 03        	bcc :+
000C42r 3  4C rr rr     	jmp dscor2		; yes, job done.
000C45r 3               :
000C45r 3  E6 rr        	inc z80_l		; next character to display.
000C47r 3  D0 02        	bne :+
000C49r 3  E6 rr        	inc z80_h
000C4Br 3               :
000C4Br 3  4C rr rr     	jmp dmsg0
000C4Er 3               dmsg1:
000C4Er 3  E6 rr        	inc dispy
000C50r 3  A5 rr        	lda dispy
000C52r 3  C9 18        	cmp #24
000C54r 3  90 04        	bcc dmsg4
000C56r 3  A9 00        	lda #0
000C58r 3  85 rr        	sta dispy
000C5Ar 3               dmsg4:
000C5Ar 3  A9 00        	lda #0
000C5Cr 3  85 rr        	sta dispx
000C5Er 3  4C rr rr     	jmp dmsg2
000C61r 3               
000C61r 3               
000C61r 3               ;----------------------------------------------------------
000C61r 3               ; Display message in big text.
000C61r 3               ;
000C61r 3               ; Input:
000C61r 3               ;  HL = string pointer
000C61r 3               ;----------------------------------------------------------
000C61r 3               
000C61r 3               bmsg1:
000C61r 3  A0 00        	ldy #0
000C63r 3  B1 rr        	lda (z80_hl),y 		; get character to display.
000C65r 3  29 7F        	and #127		; only want 7 bits.
000C67r 3  C9 0D        	cmp #ASCII_NEWLINE
000C69r 3  F0 13        	beq bmsg2
000C6Br 3  20 rr rr     	jsr bchar 		; display big char.
000C6Er 3               bmsg3:
000C6Er 3  A0 00        	ldy #0
000C70r 3  B1 rr        	lda (z80_hl),y 		; look at last character.
000C72r 3  48           	pha
000C73r 3  E6 rr        	inc z80_l 		; next character in list.
000C75r 3  D0 02        	bne :+
000C77r 3  E6 rr        	inc z80_h
000C79r 3               :
000C79r 3  68           	pla
000C7Ar 3  0A           	asl a  			; was terminator flag set?
000C7Br 3  90 E4        	bcc bmsg1		; no, keep going.
000C7Dr 3               
000C7Dr 3  60           	rts
000C7Er 3               bmsg2:
000C7Er 3  A9 00        	lda #0
000C80r 3  85 rr        	sta dispx
000C82r 3  E6 rr        	inc dispy
000C84r 3  E6 rr        	inc dispy
000C86r 3  A5 rr        	lda dispy
000C88r 3  C9 17        	cmp #23
000C8Ar 3  90 E2        	bcc bmsg3
000C8Cr 3  A9 00        	lda #0
000C8Er 3  85 rr        	sta dispy
000C90r 3  4C rr rr     	jmp bmsg3
000C93r 3               
000C93r 3               ;----------------------------------------------------------
000C93r 3               ; Big character display.
000C93r 3               ;
000C93r 3               ; Input:
000C93r 3               ;  A = character
000C93r 3               ;----------------------------------------------------------
000C93r 3               
000C93r 3               bchar:
000C93r 3  85 rr        	sta z80_e		; save char in lb
000C95r 3  A9 00        	lda #0
000C97r 3  85 rr        	sta z80_d		; reset hb
000C99r 3               
000C99r 3  06 rr        	asl z80_e 		; multiply char by 8.
000C9Br 3  26 rr        	rol z80_d
000C9Dr 3  06 rr        	asl z80_e
000C9Fr 3  26 rr        	rol z80_d
000CA1r 3  06 rr        	asl z80_e
000CA3r 3  26 rr        	rol z80_d		; de = a*8
000CA5r 3               
000CA5r 3  18           	clc			; de = #<(FONT-256) + a*8
000CA6r 3  A5 rr        	lda z80_e
000CA8r 3  69 rr        	adc #<(FONT-256) 		; address of font.
000CAAr 3  85 rr        	sta z80_e
000CACr 3  A5 rr        	lda z80_d
000CAEr 3  69 rr        	adc #>(FONT-256)
000CB0r 3  85 rr        	sta z80_d
000CB2r 3               
000CB2r 3  20 rr rr     	jsr gaadd		; set colour attribute
000CB5r 3  AD rr rr     	lda fontcol
000CB8r 3  A0 00        	ldy #0
000CBAr 3  91 rr        	sta (bufaddr),y
000CBCr 3               
000CBCr 3  20 rr rr     	jsr gprad 		; get screen address.
000CBFr 3               
000CBFr 3  A2 00        	ldx #0			; height of character in font.
000CC1r 3               bchar0:
000CC1r 3  A0 00        	ldy #0
000CC3r 3  B1 rr        	lda (z80_de),y 		; get a bit of the font.
000CC5r 3               
000CC5r 3               .if iflag
000CC5r 3               	eor #$ff
000CC5r 3               .endif
000CC5r 3               
000CC5r 3  91 rr        	sta (scraddr),y
000CC7r 3  48           	pha
000CC8r 3  20 rr rr     	jsr nline 		; next line down.
000CCBr 3  68           	pla
000CCCr 3  91 rr        	sta (scraddr),y
000CCEr 3  20 rr rr     	jsr nline 		; next line down.
000CD1r 3               
000CD1r 3  18           	clc
000CD2r 3  E6 rr        	inc z80_e 		; next line of font.
000CD4r 3  D0 02        	bne :+
000CD6r 3  E6 rr        	inc z80_d
000CD8r 3               :
000CD8r 3  E8           	inx
000CD9r 3  E0 08        	cpx #8
000CDBr 3  D0 E4        	bne bchar0
000CDDr 3               
000CDDr 3  20 rr rr     	jsr nexpos		; display position.
000CE0r 3  D0 05        	bne bchar2 		; not on a new line.
000CE2r 3               bchar3:
000CE2r 3  E6 rr        	inc dispy
000CE4r 3  20 rr rr     	jsr nexlin 		; next line check.
000CE7r 3               bchar2:
000CE7r 3  4C rr rr     	jmp dscor2		; tidy up line and column variables.
000CEAr 3               
000CEAr 3               
000CEAr 3               ;-------------------------------------------------
000CEAr 3               ; Display a character.
000CEAr 3               ;
000CEAr 3               ; Input:
000CEAr 3               ;  A = character
000CEAr 3               ;-------------------------------------------------
000CEAr 3               
000CEAr 3               achar:
000CEAr 3  85 rr        	sta z80_b 		; copy to b.
000CECr 3  20 rr rr     	jsr preprt 		; get ready to print.
000CEFr 3  A5 rr        	lda z80_b		; character in accumulator.
000CF1r 3  A6 rr        	ldx prtmod 		; print mode.
000CF3r 3  F0 03        	beq :+
000CF5r 3  4C rr rr     	jmp bchar 		; no, double-height text.
000CF8r 3               :
000CF8r 3  20 rr rr     	jsr pchar 		; display character.
000CFBr 3  20 rr rr     	jsr nexpos 		; display position.
000CFEr 3  F0 E2        	beq bchar3		; next line down.
000D00r 3  4C rr rr     	jmp bchar2 		; tidy up.
000D03r 3               
000D03r 3               
000D03r 3               ;-------------------------------------------------
000D03r 3               ; Get next print column position.
000D03r 3               ;-------------------------------------------------
000D03r 3               
000D03r 3               nexpos:
000D03r 3  E6 rr        	inc dispx		; move along one position.
000D05r 3  A5 rr        	lda dispx 		; get coordinate.
000D07r 3  C9 16        	cmp #22
000D09r 3  D0 0E        	bne :+
000D0Br 3  A9 00        	lda #0
000D0Dr 3  85 rr        	sta dispx
000D0Fr 3  A5 rr        	lda prtmod
000D11r 3  F0 06        	beq :+
000D13r 3  20 rr rr     	jsr nexlin
000D16r 3  4C rr rr     	jmp nexlin
000D19r 3               :
000D19r 3  60           	rts
000D1Ar 3               
000D1Ar 3               ;-------------------------------------------------
000D1Ar 3               ; Get next print line position.
000D1Ar 3               ;-------------------------------------------------
000D1Ar 3               
000D1Ar 3               nexlin:
000D1Ar 3  E6 rr        	inc dispy 		; newline.
000D1Cr 3  A5 rr        	lda dispy		; vertical position.
000D1Er 3  C9 16        	cmp #22			; past screen edge?
000D20r 3  B0 01        	bcs :+
000D22r 3  60           	rts			; no, still okay.
000D23r 3               :
000D23r 3  A9 00        	lda #0			; restart at top.
000D25r 3  85 rr        	sta dispy
000D27r 3  60           	rts
000D28r 3               
000D28r 3               ;--------------------------------------------------------
000D28r 3               ; Pre-print preliminaries.
000D28r 3               ;--------------------------------------------------------
000D28r 3               
000D28r 3               preprt:
000D28r 3  A9 rr        	lda #<(FONT-256)		; font pointer.
000D2Ar 3  8D rr rr     	sta grbase		; set up graphics base.
000D2Dr 3  A9 rr        	lda #>(FONT-256)
000D2Fr 3  8D rr rr     	sta grbase+1
000D32r 3               prescr:
000D32r 3  A5 rr        	lda charx 		; display coordinates.
000D34r 3  85 rr        	sta dispx		; set up general coordinates.
000D36r 3  A5 rr        	lda chary
000D38r 3  85 rr        	sta dispy
000D3Ar 3  60           	rts
000D3Br 3               
000D3Br 3               ;--------------------------------------------------------------
000D3Br 3               ; Get messagenr x in hl
000D3Br 3               ;
000D3Br 3               ; Input:
000D3Br 3               ;  HL = pointer to message list
000D3Br 3               ;  X  = message number.
000D3Br 3               ;--------------------------------------------------------------
000D3Br 3               
000D3Br 3               getwrd:
000D3Br 3  E0 00        	cpx #0
000D3Dr 3  D0 01        	bne:+ 			; first word in list?
000D3Fr 3  60           	rts 			; yep, don't search.
000D40r 3               :
000D40r 3  A0 00        	ldy #0
000D42r 3               getwd0:
000D42r 3  B1 rr        	lda (z80_hl),y
000D44r 3  48           	pha
000D45r 3  E6 rr        	inc z80_l
000D47r 3  D0 02        	bne :+
000D49r 3  E6 rr        	inc z80_h
000D4Br 3               :
000D4Br 3  68           	pla
000D4Cr 3  C9 80        	cmp #128		; found end?
000D4Er 3  30 F2        	bmi getwd0		; no, carry on.
000D50r 3  CA           	dex			; until we have right number.
000D51r 3  D0 EF        	bne getwd0
000D53r 3  60           	rts
000D54r 3               
000D54r 3               ;-----------------------------------------------------------
000D54r 3               ; Bubble sort.
000D54r 3               ;-----------------------------------------------------------
000D54r 3               
000D54r 3               bsort:
000D54r 3  A9 0B        	lda #NUMSPR - 1		; sprites to swap.
000D56r 3  85 rr        	sta qscnt
000D58r 3               
000D58r 3  A9 rr        	lda #<sprtab 		; sprite table.
000D5Ar 3  85 rr        	sta z80_x
000D5Cr 3  A9 rr        	lda #>sprtab
000D5Er 3  85 rr        	sta z80_i
000D60r 3               bsort0:
000D60r 3  A0 00        	ldy #0
000D62r 3  B1 rr        	lda (z80_ix),y 		; first sprite type.
000D64r 3  C9 FF        	cmp #255 		; is it switched off?
000D66r 3  F0 30        	beq swemp		; yes, may need to switch another in here.
000D68r 3               
000D68r 3  A0 11        	ldy #TABSIZ
000D6Ar 3  B1 rr        	lda (z80_ix),y 		; check next slot exists.
000D6Cr 3  C9 FF        	cmp #255 		; is it enabled?
000D6Er 3  F0 0A        	beq bsort2 		; no, nothing to swap.
000D70r 3               
000D70r 3  A0 14        	ldy #TABSIZ+3
000D72r 3  B1 rr        	lda (z80_ix),y 		; fetch next sprite's coordinate.
000D74r 3  A0 03        	ldy #3
000D76r 3  D1 rr        	cmp (z80_ix),y 		; compare with this x coordinate.
000D78r 3  90 10        	bcc bsort1		; next sprite is higher - may need to switch.
000D7Ar 3               bsort2:
000D7Ar 3  18           	clc
000D7Br 3  A5 rr        	lda z80_x
000D7Dr 3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
000D7Fr 3  85 rr        	sta z80_x
000D81r 3  90 02        	bcc :+
000D83r 3  E6 rr        	inc z80_i
000D85r 3               :
000D85r 3  C6 rr        	dec qscnt
000D87r 3  D0 D7        	bne bsort0		; repeat for remaining sprites.
000D89r 3  60           	rts
000D8Ar 3               
000D8Ar 3               bsort1:
000D8Ar 3  A0 11        	ldy #TABSIZ
000D8Cr 3  B1 rr        	lda (z80_ix),y		; sprite on/off flag.
000D8Er 3  C9 FF        	cmp #255		; is it enabled?
000D90r 3  F0 E8        	beq bsort2		; no, nothing to swap.
000D92r 3  20 rr rr     	jsr swspr		; swap positions.
000D95r 3  4C rr rr     	jmp bsort2
000D98r 3               swemp:
000D98r 3  A0 11        	ldy #TABSIZ
000D9Ar 3  B1 rr        	lda (z80_ix),y		; next table entry.
000D9Cr 3  C9 FF        	cmp #255		; is that one on?
000D9Er 3  F0 DA        	beq bsort2		; no, nothing to swap.
000DA0r 3  20 rr rr     	jsr swspr		; swap positions.
000DA3r 3  4C rr rr     	jmp bsort2
000DA6r 3               
000DA6r 3               ; Swap sprites.
000DA6r 3               
000DA6r 3               swspr:
000DA6r 3  A5 rr        	lda z80_x		; table address
000DA8r 3  85 rr        	sta z80_e		; copy to de pair.
000DAAr 3  85 rr        	sta z80_l		; copy to hl pair.
000DACr 3  A5 rr        	lda z80_i
000DAEr 3  85 rr        	sta z80_h
000DB0r 3  85 rr        	sta z80_d
000DB2r 3               
000DB2r 3  18           	clc
000DB3r 3  A5 rr        	lda z80_l
000DB5r 3  69 11        	adc #TABSIZ		; distance to second entry.
000DB7r 3  85 rr        	sta z80_l
000DB9r 3  90 02        	bcc :+
000DBBr 3  E6 rr        	inc z80_h
000DBDr 3               :
000DBDr 3  A9 11        	lda #TABSIZ		; bytes to swap.
000DBFr 3  85 rr        	sta z80_b
000DC1r 3  A0 00        	ldy #0
000DC3r 3               swspr0:
000DC3r 3  B1 rr        	lda (z80_hl),y		; fetch second byte.
000DC5r 3  48           	pha
000DC6r 3  B1 rr        	lda (z80_de),y 		; fetch first byte.
000DC8r 3  91 rr        	sta (z80_hl),y 		; copy to second.
000DCAr 3  68           	pla
000DCBr 3  91 rr        	sta (z80_de),y 		; copy to first sprite entry.
000DCDr 3               
000DCDr 3  E6 rr        	inc z80_e 		; next byte.
000DCFr 3  D0 02        	bne :+
000DD1r 3  E6 rr        	inc z80_d
000DD3r 3               :
000DD3r 3  E6 rr        	inc z80_l 		; next byte.
000DD5r 3  D0 02        	bne :+
000DD7r 3  E6 rr        	inc z80_h
000DD9r 3               :
000DD9r 3  C6 rr        	dec z80_b
000DDBr 3  D0 E6        	bne swspr0 		; swap all bytes in table entry.
000DDDr 3  60           	rts
000DDEr 3               
000DDEr 3               ;----------------------------------------------------
000DDEr 3               ; Process sprites.
000DDEr 3               ;----------------------------------------------------
000DDEr 3               
000DDEr 3               pspr:
000DDEr 3  A9 0C        	lda #NUMSPR		; sprites to process.
000DE0r 3  85 rr        	sta sprptr
000DE2r 3               
000DE2r 3  A9 rr        	lda #<sprtab 		; sprite table.
000DE4r 3  85 rr        	sta z80_x
000DE6r 3  A9 rr        	lda #>sprtab
000DE8r 3  85 rr        	sta z80_i
000DEAr 3               pspr1:
000DEAr 3  A0 00        	ldy #0
000DECr 3  B1 rr        	lda (z80_ix),y		; fetch sprite type.
000DEEr 3  C9 09        	cmp #9 			; within range of sprite types?
000DF0r 3  B0 03        	bcs :+
000DF2r 3  20 rr rr     	jsr pspr2 		; yes, process this one.
000DF5r 3               :
000DF5r 3  18           	clc
000DF6r 3  A5 rr        	lda z80_x
000DF8r 3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
000DFAr 3  85 rr        	sta z80_x
000DFCr 3  90 02        	bcc :+
000DFEr 3  E6 rr        	inc z80_i		; next sprite.
000E00r 3               :
000E00r 3  C6 rr        	dec sprptr 		; repeat for remaining sprites.
000E02r 3  D0 E6        	bne pspr1
000E04r 3  60           	rts
000E05r 3               
000E05r 3               pspr2:
000E05r 3  A5 rr        	lda z80_x 		; store original sprite pointer.
000E07r 3  85 rr        	sta ogptr
000E09r 3  A5 rr        	lda z80_i
000E0Br 3  85 rr        	sta ogptr+1
000E0Dr 3  20 rr rr     	jsr pspr3		; do the routine.
000E10r 3               rtorg:
000E10r 3  A5 rr        	lda ogptr 		; restore original pointer to sprite.
000E12r 3  85 rr        	sta z80_x
000E14r 3  A5 rr        	lda ogptr+1
000E16r 3  85 rr        	sta z80_i
000E18r 3               rtorg0:
000E18r 3  60           	rts
000E19r 3               
000E19r 3               pspr3:
000E19r 3  A9 rr        	lda #<evtyp0		; sprite type events list.
000E1Br 3  85 rr        	sta z80_l
000E1Dr 3  A9 rr        	lda #>evtyp0
000E1Fr 3  85 rr        	sta z80_h
000E21r 3               pspr4:
000E21r 3  B1 rr        	lda (z80_ix),y
000E23r 3  0A           	asl a			; double accumulator.
000E24r 3  18           	clc
000E25r 3  65 rr        	adc z80_l
000E27r 3  85 rr        	sta z80_l
000E29r 3  90 02        	bcc :+
000E2Br 3  E6 rr        	inc z80_h
000E2Dr 3               :
000E2Dr 3  B1 rr        	lda (z80_hl),y
000E2Fr 3  85 rr        	sta z80_e 		; copy to de.
000E31r 3  48           	pha
000E32r 3               
000E32r 3  E6 rr        	inc z80_l 		; next byte of address.
000E34r 3  D0 02        	bne :+
000E36r 3  E6 rr        	inc z80_h
000E38r 3               :
000E38r 3  B1 rr        	lda (z80_hl),y 		; address high.
000E3Ar 3  85 rr        	sta z80_d
000E3Cr 3               
000E3Cr 3  48           	pha	 		; swap address into hl.
000E3Dr 3  A5 rr        	lda z80_h
000E3Fr 3  85 rr        	sta z80_d
000E41r 3  68           	pla
000E42r 3  85 rr        	sta z80_h
000E44r 3  68           	pla
000E45r 3  85 rr        	sta z80_l
000E47r 3  A5 rr        	lda z80_l
000E49r 3  85 rr        	sta z80_e
000E4Br 3               
000E4Br 3  6C rr rr     	jmp (z80_hl) 		; go there.
000E4Er 3               
000E4Er 3               ; Address of each sprite type's routine.
000E4Er 3               
000E4Er 3  rr rr        evtyp0:	.word evnt00
000E50r 3  rr rr        evtyp1:	.word evnt01
000E52r 3  rr rr        evtyp2:	.word evnt02
000E54r 3  rr rr        evtyp3:	.word evnt03
000E56r 3  rr rr        evtyp4:	.word evnt04
000E58r 3  rr rr        evtyp5:	.word evnt05
000E5Ar 3  rr rr        evtyp6:	.word evnt06
000E5Cr 3  rr rr        evtyp7:	.word evnt07
000E5Er 3  rr rr        evtyp8:	.word evnt08
000E60r 3               
000E60r 3               ;--------------------------------------------------------------
000E60r 3               ; Display sprites.
000E60r 3               ;
000E60r 3               ; Input:
000E60r 3               ;  IX = sprite table
000E60r 3               ;--------------------------------------------------------------
000E60r 3               
000E60r 3               dspr:
000E60r 3  A9 06        	lda #(NUMSPR/2)		; number of sprites to display.
000E62r 3  85 rr        	sta sprcnt
000E64r 3               
000E64r 3               dspr0:
000E64r 3  A0 00        	ldy #var_Type
000E66r 3  B1 rr        	lda (z80_ix),y 		; get sprite type.
000E68r 3  C9 FF        	cmp #255 		; is it enabled?
000E6Ar 3  D0 45        	bne dspr1 		; yes, it needs deleting.
000E6Cr 3               dspr5:
000E6Cr 3  A0 05        	ldy #var_newType
000E6Er 3  B1 rr        	lda (z80_ix),y 		; new type.
000E70r 3  C9 FF        	cmp #255		; is it enabled?
000E72r 3  F0 03        	beq dspr2
000E74r 3  4C rr rr     	jmp dspr3 		; yes, it needs drawing.
000E77r 3               dspr2:
000E77r 3  A0 05        	ldy #var_newType
000E79r 3  B1 rr        	lda (z80_ix),y 		; copy new type.
000E7Br 3  A0 00        	ldy #var_Type
000E7Dr 3  91 rr        	sta (z80_ix),y
000E7Fr 3  A0 06        	ldy #var_newImage
000E81r 3  B1 rr        	lda (z80_ix),y 		; copy new image number.
000E83r 3  A0 01        	ldy #var_Image
000E85r 3  91 rr        	sta (z80_ix),y
000E87r 3  A0 07        	ldy #var_newFrame
000E89r 3  B1 rr        	lda (z80_ix),y 		; copy new frame.
000E8Br 3  A0 02        	ldy #var_Frame
000E8Dr 3  91 rr        	sta (z80_ix),y
000E8Fr 3  A0 08        	ldy #var_newY
000E91r 3  B1 rr        	lda (z80_ix),y 		; copy new y.
000E93r 3  A0 03        	ldy #var_Y
000E95r 3  91 rr        	sta (z80_ix),y
000E97r 3  A0 09        	ldy #var_newX
000E99r 3  B1 rr        	lda (z80_ix),y 		; copy new x.
000E9Br 3  A0 04        	ldy #var_X
000E9Dr 3  91 rr        	sta (z80_ix),y
000E9Fr 3               
000E9Fr 3  18           	clc
000EA0r 3  A5 rr        	lda z80_x
000EA2r 3  69 22        	adc #(TABSIZ*2)		; distance to next odd/even entry.
000EA4r 3  85 rr        	sta z80_x
000EA6r 3  A5 rr        	lda z80_i
000EA8r 3  69 00        	adc #0
000EAAr 3  85 rr        	sta z80_i 		; next sprite.
000EACr 3  C6 rr        	dec sprcnt
000EAEr 3  D0 B4        	bne dspr0		; repeat for remaining sprites.
000EB0r 3  60           	rts
000EB1r 3               
000EB1r 3               dspr1:
000EB1r 3               	; _BEEB clipping code copied from CPC Engine
000EB1r 3  A0 03        	ldy #var_Y
000EB3r 3  B1 rr        	lda (z80_ix), y		; old x coord
000EB5r 3  C9 A1        	cmp #SpriteMaxY     	; beyond maximum?
000EB7r 3  B0 B3        	bcs dspr5		; yes, don't delete it.
000EB9r 3               
000EB9r 3  A0 05        	ldy #var_newType
000EBBr 3  B1 rr        	lda (z80_ix),y 		; type of new sprite.
000EBDr 3  C9 FF        	cmp #255		; is this enabled?
000EBFr 3  D0 06        	bne dspr4 		; yes, display both.
000EC1r 3               
000EC1r 3               dspr6:
000EC1r 3  20 rr rr     	jsr sspria 		; show single sprite.
000EC4r 3  4C rr rr     	jmp dspr2
000EC7r 3               
000EC7r 3               ; Displaying two sprites.  Don't bother redrawing if nothing has changed.
000EC7r 3               
000EC7r 3               dspr4:
000EC7r 3               	; _BEEB clipping code copied from CPC Engine
000EC7r 3  A0 08        	ldy #var_newY
000EC9r 3  B1 rr        	lda (z80_ix), y		; old x coord
000ECBr 3  C9 A1        	cmp #SpriteMaxY     	; beyond maximum?
000ECDr 3  B0 F2        	bcs dspr6		; yes, don't display it.
000ECFr 3               
000ECFr 3  A0 04        	ldy #var_X
000ED1r 3  B1 rr        	lda (z80_ix),y		; old x.
000ED3r 3  A0 09        	ldy #var_newX
000ED5r 3  D1 rr        	cmp (z80_ix),y 		; compare with new value.
000ED7r 3  D0 21        	bne dspr7 		; they differ, need to redraw.
000ED9r 3               
000ED9r 3  A0 03        	ldy #var_Y
000EDBr 3  B1 rr        	lda (z80_ix),y		; old y.
000EDDr 3  A0 08        	ldy #var_newY
000EDFr 3  D1 rr        	cmp (z80_ix),y 		; compare against new value.
000EE1r 3  D0 17        	bne dspr7		; they differ, need to redraw.
000EE3r 3               
000EE3r 3  A0 02        	ldy #var_Frame
000EE5r 3  B1 rr        	lda (z80_ix),y 		; old frame.
000EE7r 3  A0 07        	ldy #var_newFrame
000EE9r 3  D1 rr        	cmp (z80_ix),y 		; compare against new value.
000EEBr 3  D0 0D        	bne dspr7 		; they differ, need to redraw.
000EEDr 3               
000EEDr 3  A0 01        	ldy #var_Image
000EEFr 3  B1 rr        	lda (z80_ix),y 		; old image.
000EF1r 3  A0 06        	ldy #var_newImage
000EF3r 3  D1 rr        	cmp (z80_ix),y 		; compare against new value.
000EF5r 3  D0 03        	bne dspr7 		; they differ, need to redraw.
000EF7r 3  4C rr rr     	jmp dspr2		; everything is the same, don't redraw.
000EFAr 3               dspr7:
000EFAr 3  20 rr rr     	jsr sspric 		; delete old sprite, draw new one simultaneously.
000EFDr 3  4C rr rr     	jmp dspr2
000F00r 3               dspr3:
000F00r 3               	; _BEEB clipping code copied from CPC Engine
000F00r 3  A0 08        	ldy #var_newY
000F02r 3  B1 rr        	lda (z80_ix), y		; old x coord
000F04r 3  C9 A1        	cmp #SpriteMaxY     	; beyond maximum?
000F06r 3  90 03        	bcc :+			; no, continue
000F08r 3  4C rr rr     	jmp dspr2		; yes, don't display it.
000F0Br 3               :
000F0Br 3  20 rr rr     	jsr ssprib 		; show single sprite.
000F0Er 3  4C rr rr     	jmp dspr2
000F11r 3               
000F11r 3               ;-----------------------------------------
000F11r 3               ; Get sprite address calculations.
000F11r 3               ; gspran = new sprite, gsprad = old sprite.
000F11r 3               ;
000F11r 3               ; Input:
000F11r 3               ;  IX = sprite address
000F11r 3               ;-----------------------------------------
000F11r 3               
000F11r 3               gspran:
000F11r 3  A0 08        	ldy #var_newY
000F13r 3  B1 rr        	lda (z80_ix),y 		; new y coordinate.
000F15r 3  85 rr        	sta dispy
000F17r 3  A0 09        	ldy #var_newX
000F19r 3  B1 rr        	lda (z80_ix),y 		; new x coordinate.
000F1Br 3  85 rr        	sta dispx
000F1Dr 3  A0 06        	ldy #var_newImage
000F1Fr 3  B1 rr        	lda (z80_ix),y 		; new sprite image.
000F21r 3  20 rr rr     	jsr gfrm		; fetch start frame for this sprite.
000F24r 3               
000F24r 3  A0 00        	ldy #0
000F26r 3  B1 rr        	lda (z80_hl),y 		; frame in accumulator.
000F28r 3  A0 07        	ldy #var_newFrame
000F2Ar 3  18           	clc
000F2Br 3  71 rr        	adc (z80_ix),y 		; new add frame number.
000F2Dr 3  4C rr rr     	jmp gspra0
000F30r 3               
000F30r 3               ;-----------------------------------------
000F30r 3               ; Calculate old sprite address
000F30r 3               ;
000F30r 3               ; Input:
000F30r 3               ;  IX = sprite address
000F30r 3               ;
000F30r 3               ; Output:
000F30r 3               ;  B  = right byte mask
000F30r 3               ;  C  = left byte mask
000F30r 3               ;  DE = spriteframe address
000F30r 3               ;  scraddr = screenaddress(dispx,dispy)
000F30r 3               ;-----------------------------------------
000F30r 3               
000F30r 3               gsprad:
000F30r 3  A0 03        	ldy #var_Y
000F32r 3  B1 rr        	lda (z80_ix),y		; y coordinate.
000F34r 3  85 rr        	sta dispy
000F36r 3  A0 04        	ldy #var_X
000F38r 3  B1 rr        	lda (z80_ix),y		; x coordinate.
000F3Ar 3  85 rr        	sta dispx
000F3Cr 3  A0 01        	ldy #var_Image
000F3Er 3  B1 rr        	lda (z80_ix),y 		; sprite image.
000F40r 3  20 rr rr     	jsr gfrm 		; fetch start frame for this sprite.
000F43r 3               
000F43r 3  A0 00        	ldy #0
000F45r 3  B1 rr        	lda (z80_hl),y 		; frame in accumulator.
000F47r 3  A0 02        	ldy #var_Frame
000F49r 3  18           	clc
000F4Ar 3  71 rr        	adc (z80_ix),y 		; add frame number.
000F4Cr 3               
000F4Cr 3               gspra0:
000F4Cr 3               .if rflag
000F4Cr 3               	sta z80_e		; multiply by 32.
000F4Cr 3               	lda #0
000F4Cr 3               	sta z80_d
000F4Cr 3               
000F4Cr 3               	asl z80_e
000F4Cr 3               	rol z80_d
000F4Cr 3               	asl z80_e
000F4Cr 3               	rol z80_d
000F4Cr 3               	asl z80_e
000F4Cr 3               	rol z80_d
000F4Cr 3               	asl z80_e
000F4Cr 3               	rol z80_d
000F4Cr 3               .if bflag
000F4Cr 3               	lda z80_e		; multiply by 48
000F4Cr 3               	sta tmp1
000F4Cr 3               	lda z80_d
000F4Cr 3               	sta tmp2
000F4Cr 3               .endif
000F4Cr 3               	asl z80_e
000F4Cr 3               	rol z80_d
000F4Cr 3               .if bflag
000F4Cr 3               	clc
000F4Cr 3               	lda z80_e
000F4Cr 3               	adc tmp1
000F4Cr 3               	sta z80_e
000F4Cr 3               	lda z80_d
000F4Cr 3               	adc tmp2
000F4Cr 3               	sta z80_d
000F4Cr 3               .endif
000F4Cr 3               .else
000F4Cr 3  4A           	lsr a	  		; multiply by 128.
000F4Dr 3  85 rr        	sta z80_d 		; store in d.
000F4Fr 3  85 rr        	sta tmp1
000F51r 3  A9 00        	lda #0
000F53r 3  6A           	ror a
000F54r 3  85 rr        	sta z80_e 		; got low byte.
000F56r 3  85 rr        	sta tmp2
000F58r 3               .if bflag
000F58r 3               	lsr tmp1		; multiply by 192
000F58r 3               	ror tmp2
000F58r 3               	clc
000F58r 3               	lda tmp2
000F58r 3               	adc z80_e
000F58r 3               	sta z80_e
000F58r 3               	lda tmp1
000F58r 3               	adc z80_d
000F58r 3               	sta z80_d
000F58r 3               .endif
000F58r 3               .endif
000F58r 3  18           	clc 			; address of play sprites.
000F59r 3  A5 rr        	lda z80_e
000F5Br 3  69 rr        	adc #<sprgfx
000F5Dr 3  85 rr        	sta z80_e
000F5Fr 3  A5 rr        	lda z80_d
000F61r 3  69 rr        	adc #>sprgfx
000F63r 3  85 rr        	sta z80_d
000F65r 3               
000F65r 3  A5 rr        	lda dispx 		; y coordinate.
000F67r 3  29 06        	and #6 			; position within byte boundary.
000F69r 3  AA           	tax	 		; low byte of table displacement.
000F6Ar 3               .if rflag
000F6Ar 3               	stx sprshft
000F6Ar 3               .else
000F6Ar 3  0A           	asl a	  		; multiply by 32.
000F6Br 3  0A           	asl a  			; already a multiple
000F6Cr 3  0A           	asl a  			; of 2, so just 4
000F6Dr 3               .if bflag
000F6Dr 3               	sta tmp1
000F6Dr 3               	asl a  			; shifts needed.
000F6Dr 3               	clc
000F6Dr 3               	adc tmp1
000F6Dr 3               .else
000F6Dr 3  0A           	asl a  			; shifts needed.
000F6Er 3               .endif
000F6Er 3  18           	clc 			; add to sprite address.
000F6Fr 3  65 rr        	adc z80_e
000F71r 3  85 rr        	sta z80_e
000F73r 3  90 02        	bcc :+
000F75r 3  E6 rr        	inc z80_d
000F77r 3               :
000F77r 3               .endif
000F77r 3  BD rr rr     	lda spmask,x		 ; pointer to mask table.
000F7Ar 3  85 rr        	sta z80_c 		; left mask.
000F7Cr 3  BD rr rr     	lda spmask+1,x
000F7Fr 3  85 rr        	sta z80_b 		; right mask.
000F81r 3               ; Drop into screen address routine.
000F81r 3  4C rr rr     	jmp scadd
000F84r 3               
000F84r 3  FF 00 3F C0  spmask:	.byte 255,0,63,192,15,240,3,252
000F88r 3  0F F0 03 FC  
000F8Cr 3               
000F8Cr 3               
000F8Cr 3               ;-----------------------------------------------------------
000F8Cr 3               ; Animates a sprite.
000F8Cr 3               ;
000F8Cr 3               ; Input:
000F8Cr 3               ;  IX = sprite address
000F8Cr 3               ;  HL = last sprite address
000F8Cr 3               ;-----------------------------------------------------------
000F8Cr 3               
000F8Cr 3               animsp:
000F8Cr 3  25 rr        	and frmno
000F8Er 3  F0 01        	beq :+
000F90r 3  60           	rts
000F91r 3               :
000F91r 3  A0 06        	ldy #var_newImage
000F93r 3  B1 rr        	lda (z80_ix),y		; sprite image
000F95r 3  20 rr rr     	jsr gfrm		; get frame data.
000F98r 3               
000F98r 3  E6 rr        	inc z80_l		; point to frames.
000F9Ar 3  D0 02        	bne :+
000F9Cr 3  E6 rr        	inc z80_h
000F9Er 3               :
000F9Er 3  A0 07        	ldy #var_newFrame
000FA0r 3  B1 rr        	lda (z80_ix),y		; sprite frame.
000FA2r 3  18           	clc
000FA3r 3  69 01        	adc #1			; next one along.
000FA5r 3  A0 00        	ldy #0
000FA7r 3  D1 rr        	cmp (z80_hl),y		; reached the last frame?
000FA9r 3  90 02        	bcc anims0		; no, not yet.
000FABr 3  A9 00        	lda #0			; start at first frame.
000FADr 3               anims0:
000FADr 3  A0 07        	ldy #var_newFrame
000FAFr 3  91 rr        	sta (z80_ix),y		; new frame.
000FB1r 3  60           	rts
000FB2r 3               
000FB2r 3               ;--------------------------------------------------------------
000FB2r 3               ; Animate back
000FB2r 3               ;
000FB2r 3               ; Input:
000FB2r 3               ;  IX = sprite address
000FB2r 3               ;  HL = last sprite address
000FB2r 3               ;--------------------------------------------------------------
000FB2r 3               
000FB2r 3               animbk:
000FB2r 3  25 rr        	and frmno
000FB4r 3  F0 01        	beq :+
000FB6r 3  60           	rts
000FB7r 3               :
000FB7r 3  A0 06        	ldy #var_newImage
000FB9r 3  B1 rr        	lda (z80_ix),y		; sprite image.
000FBBr 3  20 rr rr     	jsr gfrm		; get frame data.
000FBEr 3               
000FBEr 3  E6 rr        	inc z80_l 		; point to frames.
000FC0r 3  D0 02        	bne :+
000FC2r 3  E6 rr        	inc z80_h
000FC4r 3               :
000FC4r 3  A0 07        	ldy #var_newFrame
000FC6r 3  B1 rr        	lda (z80_ix),y 		; sprite frame.
000FC8r 3  F0 03        	beq :+
000FCAr 3  4C rr rr     	jmp rtanb0 		; yes, start at end.
000FCDr 3               :
000FCDr 3  A0 00        	ldy #0
000FCFr 3  B1 rr        	lda (z80_hl),y 		; last sprite.
000FD1r 3               rtanb0:
000FD1r 3  38           	sec
000FD2r 3  E9 01        	sbc #1			; next one along.
000FD4r 3  4C rr rr     	jmp anims0		; set new frame.
000FD7r 3               
000FD7r 3               ;--------------------------------------------------------------
000FD7r 3               ; Check for collision with other sprite, strict enforcement.
000FD7r 3               ;
000FD7r 3               ; Input:
000FD7r 3               ;  b		= sprite to test for
000FD7r 3               ;  ix		= current sprite pointer
000FD7r 3               ;
000FD7r 3               ; global:	b
000FD7r 3               ; local:	x,y,hl,de,skptr
000FD7r 3               ; calls:	-
000FD7r 3               ;--------------------------------------------------------------
000FD7r 3               
000FD7r 3               sktyp:
000FD7r 3  A9 rr        	lda #<sprtab				; sprite table.
000FD9r 3  85 rr        	sta z80_l
000FDBr 3  A9 rr        	lda #>sprtab
000FDDr 3  85 rr        	sta z80_h
000FDFr 3               numsp2:
000FDFr 3  A9 0C        	lda #NUMSPR				; number of sprites.
000FE1r 3  85 rr        	sta sktptr
000FE3r 3               sktyp0:
000FE3r 3  A5 rr        	lda z80_l 				; store pointer to sprite.
000FE5r 3  85 rr        	sta skptr
000FE7r 3  A5 rr        	lda z80_h
000FE9r 3  85 rr        	sta skptr+1
000FEBr 3               
000FEBr 3  A0 00        	ldy #0
000FEDr 3  B1 rr        	lda (z80_hl),y 				; get sprite type.
000FEFr 3  C5 rr        	cmp z80_b				; is it the type we seek?
000FF1r 3  F0 1D        	beq coltyp				; yes, we can use this one.
000FF3r 3               sktyp1:
000FF3r 3  18           	clc
000FF4r 3  A5 rr        	lda skptr				; retrieve sprite pointer.
000FF6r 3  69 11        	adc #TABSIZ				; size of each entry.
000FF8r 3  85 rr        	sta z80_l
000FFAr 3  A5 rr        	lda skptr+1
000FFCr 3  69 00        	adc #0
000FFEr 3  85 rr        	sta z80_h
001000r 3  C6 rr        	dec sktptr					; one less iteration.
001002r 3  D0 DF        	bne sktyp0				; keep going until we find a slot.
001004r 3  A9 00        	lda #0					; default to ROM address - no sprite.
001006r 3  85 rr        	sta z80_l
001008r 3  85 rr        	sta z80_h
00100Ar 3  85 rr        	sta skptr				; store pointer to sprite.
00100Cr 3  85 rr        	sta skptr+1
00100Er 3               
00100Er 3  18           	clc					; don't return with zero flag set.
00100Fr 3  60           	rts 					; didn't find one.
001010r 3               
001010r 3               coltyp:
001010r 3  A0 00        	ldy #0
001012r 3  B1 rr        	lda (z80_ix),y				; current sprite type.
001014r 3  C5 rr        	cmp z80_b				; seeking sprite of same type?
001016r 3  F0 3D        	beq colty1				; yes, need to check we're not detecting ourselves.
001018r 3               colty0:
001018r 3  A0 09        	ldy #9					; distance to x position in table.
00101Ar 3  B1 rr        	lda (z80_hl),y				; fetch x coordinate.
00101Cr 3  85 rr        	sta z80_e
00101Er 3  88           	dey
00101Fr 3  B1 rr        	lda (z80_hl),y				; fetch y coordinate.
001021r 3  85 rr        	sta z80_d
001023r 3               
001023r 3               ; Drop into collision detection.
001023r 3               
001023r 3               colc16:
001023r 3  A0 09        	ldy #9
001025r 3  B1 rr        	lda (z80_ix),y			 	; x coord.
001027r 3  38           	sec					; subtract x.
001028r 3  E5 rr        	sbc z80_e
00102Ar 3  B0 05        	bcs  colc1a 				; result is positive.
00102Cr 3  49 FF        	eor #$ff				; make negative positive.
00102Er 3  18           	clc
00102Fr 3  69 01        	adc #1
001031r 3               colc1a:
001031r 3  C9 10        	cmp #16 				; within x range?
001033r 3  B0 BE        	bcs sktyp1				; no - they"ve missed.
001035r 3  85 rr        	sta z80_c				; store difference.
001037r 3               
001037r 3  A0 08        	ldy #8
001039r 3  B1 rr        	lda (z80_ix),y				; y coord.
00103Br 3  38           	sec
00103Cr 3  E5 rr        	sbc z80_d				; subtract y.
00103Er 3  B0 05        	bcs colc1b				; result is positive.
001040r 3  49 FF        	eor #$ff				; make negative positive.
001042r 3  18           	clc
001043r 3  69 01        	adc #1
001045r 3               colc1b:
001045r 3  C9 10        	cmp #16					; within y range?
001047r 3  B0 AA        	bcs sktyp1 				; no - they've missed.
001049r 3  18           	clc					; add x difference.
00104Ar 3  65 rr        	adc z80_c
00104Cr 3  C9 1A        	cmp #26					; only 5 corner pixels touching?
00104Er 3  B0 02        	bcs :+
001050r 3  38           	sec
001051r 3  60           	rts 					; carry set if there's a collision.
001052r 3               :
001052r 3  4C rr rr     	jmp sktyp1				; try next sprite in table.
001055r 3               colty1:
001055r 3  A5 rr        	lda z80_x  				; compare the two.
001057r 3  C5 rr        	cmp z80_l
001059r 3  D0 09        	bne end_col
00105Br 3  A5 rr        	lda z80_i
00105Dr 3  C5 rr        	cmp z80_h
00105Fr 3  D0 03        	bne end_col
001061r 3  4C rr rr     	jmp sktyp1 				; addresses are identical.
001064r 3               end_col:
001064r 3  4C rr rr     	jmp colty0
001067r 3               
001067r 3               ;-----------------------------------------------------------
001067r 3               ; Display number, left aligned
001067r 3               ;
001067r 3               ; Input:
001067r 3               ;  a		= number
001067r 3               ;
001067r 3               ; global:	-
001067r 3               ; local:	a,y,bc,hl,displ0
001067r 3               ; calls:	num2ch,dmsg3
001067r 3               ;-----------------------------------------------------------
001067r 3               
001067r 3               disply:
001067r 3  85 rr        	sta z80_a
001069r 3  A9 rr        	lda #<displ0				; display workspace.
00106Br 3  85 rr        	sta z80_c
00106Dr 3  A9 rr        	lda #>displ0
00106Fr 3  85 rr        	sta z80_b
001071r 3  A5 rr        	lda z80_a
001073r 3  20 rr rr     	jsr num2ch				; convert accumulator to string.
001076r 3               displ1:
001076r 3  C6 rr        	dec z80_c				; back one character.
001078r 3  D0 02        	bne :+
00107Ar 3  C6 rr        	dec z80_b
00107Cr 3               :
00107Cr 3  A0 00        	ldy #0
00107Er 3  B1 rr        	lda (z80_bc),y				; fetch digit.
001080r 3  09 80        	ora #128				; insert end marker.
001082r 3  91 rr        	sta (z80_bc),y				; new value.
001084r 3               
001084r 3  A9 rr        	lda #<displ0				; display space.
001086r 3  85 rr        	sta z80_l
001088r 3  A9 rr        	lda #>displ0
00108Ar 3  85 rr        	sta z80_h
00108Cr 3  4C rr rr     	jmp dmsg3				; display the string.
00108Fr 3               
00108Fr 3  00 00 00 8D  displ0:	.byte 0,0,0,13+128
001093r 3               
001093r 3               ;----------------------------------------------------------------
001093r 3               ; Initialise screen.
001093r 3               ;
001093r 3               ; global:	roomtb,scno
001093r 3               ; local:	-
001093r 3               ; calls:	tstcs
001093r 3               ;----------------------------------------------------------------
001093r 3               
001093r 3               initsc:
001093r 3  AD rr rr     	lda roomtb 			; whereabouts in the map are we?
001096r 3  20 rr rr     	jsr tstsc 			; find displacement.
001099r 3  C9 FF        	cmp #255 			; is it valid?
00109Br 3  F0 02        	beq init_end 			; no, it's rubbish.
00109Dr 3  85 rr        	sta scno			; store new room number.
00109Fr 3               init_end:
00109Fr 3  60           	rts
0010A0r 3               
0010A0r 3               ;----------------------------------------------------------------
0010A0r 3               ; Test screen.
0010A0r 3               ;
0010A0r 3               ; global:	-
0010A0r 3               ; local:	x
0010A0r 3               ; calls:	-
0010A0r 3               ;----------------------------------------------------------------
0010A0r 3               
0010A0r 3               tstsc:
0010A0r 3  85 rr        	sta tmproom
0010A2r 3  18           	clc
0010A3r 3  69 03        	adc #MAPWID 			; add width in case we"re negative.
0010A5r 3  AA           	tax 				; add displacement to map data.
0010A6r 3  BD rr rr     	lda mapdat-MAPWID,x 		; find room number there.
0010A9r 3  60           	rts
0010AAr 3               
0010AAr 3               ;--------------------------
0010AAr 3               ; Screen left.
0010AAr 3               ;--------------------------
0010AAr 3               
0010AAr 3               scrl:
0010AAr 3  AD rr rr     	lda roomtb 			; present room table pointer.
0010ADr 3  38           	sec
0010AEr 3  E9 01        	sbc #1				; room left.
0010B0r 3               scrl0:
0010B0r 3  20 rr rr     	jsr tstsc			; test screen.
0010B3r 3  C9 FF        	cmp #255			; is there a screen this way?
0010B5r 3  D0 01        	bne :+
0010B7r 3  60           	rts				; no, return to loop.
0010B8r 3               :
0010B8r 3  A5 rr        	lda tmproom			; restore room displacement.
0010BAr 3  8D rr rr     	sta roomtb			; new room table position.
0010BDr 3               scrl1:
0010BDr 3  20 rr rr     	jsr initsc 			; set new screen.
0010C0r 3  A9 02        	lda #2
0010C2r 3  85 rr        	sta restfl 			; set it.
0010C4r 3  60           	rts
0010C5r 3               scrr:
0010C5r 3  AD rr rr     	lda roomtb 			; room table pointer.
0010C8r 3  18           	clc
0010C9r 3  69 01        	adc #1				; room right.
0010CBr 3  4C rr rr     	jmp scrl0
0010CEr 3               scru:
0010CEr 3  AD rr rr     	lda roomtb 			; room table pointer.
0010D1r 3  38           	sec
0010D2r 3  E9 03        	sbc #MAPWID 			; room up.
0010D4r 3  4C rr rr     	jmp scrl0
0010D7r 3               scrd:
0010D7r 3  AD rr rr     	lda roomtb 			; room table pointer.
0010DAr 3  18           	clc
0010DBr 3  69 03        	adc #MAPWID 			; room down.
0010DDr 3  4C rr rr     	jmp scrl0
0010E0r 3               
0010E0r 3               ;-----------------------------------------
0010E0r 3               ; Jump to new screen.
0010E0r 3               ;-----------------------------------------
0010E0r 3               
0010E0r 3               nwscr:
0010E0r 3  A2 00        	ldx #0				; start of map data.
0010E2r 3               nwscr0:
0010E2r 3  DD rr rr     	cmp mapdat,x
0010E5r 3  F0 06        	beq nwscr1			; have we found a match for screen?
0010E7r 3  E8           	inx 				; next room.
0010E8r 3  E0 50        	cpx #80				; zero room count, 80 to search.
0010EAr 3  D0 F6        	bne nwscr0			; keep looking.
0010ECr 3  60           	rts
0010EDr 3               nwscr1:
0010EDr 3  8E rr rr     	stx roomtb			; set the map position.
0010F0r 3  4C rr rr     	jmp scrl1			; draw new room.
0010F3r 3               
0010F3r 3               
0010F3r 3               ;----------------------------------------------------------
0010F3r 3               ; Gravity processing.
0010F3r 3               ;----------------------------------------------------------
0010F3r 3               
0010F3r 3               grav:
0010F3r 3  A0 0D        	ldy #13
0010F5r 3  B1 rr        	lda (z80_ix),y			; jump pointer low.
0010F7r 3  85 rr        	sta z80_l
0010F9r 3  A0 0E        	ldy #14
0010FBr 3  B1 rr        	lda (z80_ix),y			; jump pointer high.
0010FDr 3  85 rr        	sta z80_h
0010FFr 3  05 rr        	ora z80_l			; merge in low byte.
001101r 3  D0 01        	bne :+
001103r 3  60           	rts				; if neither is set, we're not in the air.
001104r 3               :
001104r 3  A0 00        	ldy #0
001106r 3  B1 rr        	lda (z80_hl),y			; pixels to move.
001108r 3  85 rr        	sta z80_a
00110Ar 3  C9 63        	cmp #99				; reached the end?
00110Cr 3  D0 0C        	bne grav0			; no, continue.
00110Er 3               grav2:
00110Er 3  C6 rr        	dec z80_l			; go back to previous value.
001110r 3  C9 FF        	cmp #$ff
001112r 3  D0 02        	bne :+
001114r 3  C6 rr        	dec z80_h
001116r 3               :
001116r 3  B1 rr        	lda (z80_hl),y			; fetch that from table.
001118r 3  85 rr        	sta z80_a
00111Ar 3               grav0:
00111Ar 3  E6 rr        	inc z80_l			; point to next table entry.
00111Cr 3  D0 02        	bne :+
00111Er 3  E6 rr        	inc z80_h
001120r 3               :
001120r 3  A5 rr        	lda z80_l
001122r 3  A0 0D        	ldy #13
001124r 3  91 rr        	sta (z80_ix),y			; store new pointer low.
001126r 3  A5 rr        	lda z80_h
001128r 3  A0 0E        	ldy #14
00112Ar 3  91 rr        	sta (z80_ix),y			; store new pointer high.
00112Cr 3               grav1:
00112Cr 3  A5 rr        	lda z80_a
00112Er 3  D0 01        	bne :+				; any movement required?
001130r 3  60           	rts				; no, not this time.
001131r 3               :
001131r 3  A5 rr        	lda z80_a
001133r 3  C9 80        	cmp #128			; is it up or down?
001135r 3  B0 15        	bcs gravu			; it's up.
001137r 3               gravd:
001137r 3  85 rr        	sta z80_b			; set pixels to move.
001139r 3               gravd0:
001139r 3  20 rr rr     	jsr cangd			; can we go down?
00113Cr 3  D0 28        	bne gravst			; can't move down, so stop.
00113Er 3  A0 08        	ldy #8
001140r 3  B1 rr        	lda (z80_ix),y			; adjust new x coord.
001142r 3  18           	clc
001143r 3  69 01        	adc #1
001145r 3  91 rr        	sta (z80_ix),y
001147r 3  C6 rr        	dec z80_b
001149r 3  D0 EE        	bne gravd0
00114Br 3  60           	rts
00114Cr 3               gravu:
00114Cr 3  49 FF        	eor #$ff			; flip the sign so it's positive.
00114Er 3  18           	clc
00114Fr 3  69 01        	adc #1
001151r 3  85 rr        	sta z80_b			; set pixels to move.
001153r 3               gravu0:
001153r 3  20 rr rr     	jsr cangu			; can we go up?
001156r 3  D0 6E        	bne ifalls			; can't move up, go down next.
001158r 3  A0 08        	ldy #8
00115Ar 3  B1 rr        	lda (z80_ix),y
00115Cr 3  38           	sec
00115Dr 3  E9 01        	sbc #1
00115Fr 3  91 rr        	sta (z80_ix),y			; adjust new x coord.
001161r 3  C6 rr        	dec z80_b
001163r 3  D0 EE        	bne gravu0
001165r 3  60           	rts
001166r 3               gravst:
001166r 3  A0 0D        	ldy #var_jumpLo
001168r 3  B1 rr        	lda (z80_ix),y			; jump pointer low.
00116Ar 3  85 rr        	sta z80_l
00116Cr 3  A0 0E        	ldy #var_jumpHi
00116Er 3  B1 rr        	lda (z80_ix),y			; jump pointer high.
001170r 3  85 rr        	sta z80_h
001172r 3               
001172r 3  A9 00        	lda #0				; null value in pointer.
001174r 3  A0 0D        	ldy #var_jumpLo
001176r 3  91 rr        	sta (z80_ix),y			; store new pointer low.
001178r 3  C8           	iny
001179r 3  91 rr        	sta (z80_ix),y			; store new pointer high.
00117Br 3               
00117Br 3  A0 00        	ldy #0
00117Dr 3  B1 rr        	lda (z80_hl),y			; fetch byte from table.
00117Fr 3  C9 63        	cmp #99				; is it the end marker?
001181r 3               evftf:
001181r 3  F0 01        	beq :+				; yes, fallen too far.
001183r 3  60           	rts
001184r 3               :
001184r 3  4C rr rr     	jmp evnt15			; EVENT FELLTOOFAR
001187r 3               
001187r 3               ;------------------------------------------------
001187r 3               ; Initiate fall check.
001187r 3               ;------------------------------------------------
001187r 3               
001187r 3               ifall:
001187r 3  A0 0D        	ldy #var_jumpLo
001189r 3  B1 rr        	lda (z80_ix),y 			; jump pointer low.
00118Br 3  85 rr        	sta z80_l
00118Dr 3  A0 0E        	ldy #var_jumpHi
00118Fr 3  B1 rr        	lda (z80_ix),y 			; jump pointer high.
001191r 3  85 rr        	sta z80_h			; high byte in accumulator.
001193r 3  05 rr        	ora z80_l			; merge in low byte.
001195r 3  F0 01        	beq :+
001197r 3  60           	rts				; if either is set, we're already in the air.
001198r 3               :
001198r 3  A0 09        	ldy #9
00119Ar 3  B1 rr        	lda (z80_ix),y			; y coordinate.
00119Cr 3  85 rr        	sta dispx
00119Er 3  A0 08        	ldy #8
0011A0r 3  B1 rr        	lda (z80_ix),y			; look x coordinate.
0011A2r 3  18           	clc
0011A3r 3               numsp7:
0011A3r 3  69 10        	adc #SPR_HGT			; add 16 pixels.
0011A5r 3  85 rr        	sta dispy			; set up test coordinates.
0011A7r 3  20 rr rr     	jsr tstbl			; get map address.
0011AAr 3  20 rr rr     	jsr plchk			; block, platform check.
0011ADr 3  F0 01        	beq :+
0011AFr 3  60           	rts				; it's solid, don't fall.
0011B0r 3               :
0011B0r 3  E6 rr        	inc bufaddr			; look right one cell.
0011B2r 3  20 rr rr     	jsr plchk			; block, platform check.
0011B5r 3  F0 01        	beq :+
0011B7r 3  60           	rts				; it's solid, don't fall.
0011B8r 3               :
0011B8r 3  A5 rr        	lda dispx			; y coordinate.
0011BAr 3  29 07        	and #7				; position straddling block cells.
0011BCr 3  F0 08        	beq ifalls			; no more checks needed.
0011BEr 3  E6 rr        	inc bufaddr			; look to third cell.
0011C0r 3  20 rr rr     	jsr plchk			; block, platform check.
0011C3r 3  F0 01        	beq :+
0011C5r 3  60           	rts				; it's solid, don't fall.
0011C6r 3               :
0011C6r 3               ifalls:
0011C6r 3  A9 rr        	lda #<jtab			; jump table start.
0011C8r 3  85 rr        	sta z80_l
0011CAr 3  A9 rr        	lda #>jtab
0011CCr 3  85 rr        	sta z80_h
0011CEr 3               ifal0:
0011CEr 3  E6 rr        	inc z80_l			; point to next value.
0011D0r 3  D0 02        	bne :+
0011D2r 3  E6 rr        	inc z80_h
0011D4r 3               :
0011D4r 3  A0 00        	ldy #0
0011D6r 3  B1 rr        	lda (z80_hl),y			; fetch value.
0011D8r 3  F0 F4        	beq ifal0			; no, get next value.
0011DAr 3  C9 63        	cmp #99				; reached end of table?
0011DCr 3  D0 01        	bne :+
0011DEr 3  60           	rts				; yes, don't fall.
0011DFr 3               :
0011DFr 3  C9 80        	cmp #128			; is it going up?
0011E1r 3  B0 EB        	bcs ifal0			; yes, looking for first movement down.
0011E3r 3               
0011E3r 3  A0 0D        	ldy #13
0011E5r 3  A5 rr        	lda z80_l
0011E7r 3  91 rr        	sta (z80_ix),y 			; set jump low.
0011E9r 3  A0 0E        	ldy #14
0011EBr 3  A5 rr        	lda z80_h
0011EDr 3  91 rr        	sta (z80_ix),y 			; set jump high.
0011EFr 3  60           	rts
0011F0r 3               
0011F0r 3               
0011F0r 3               ;----------------------------------------------------
0011F0r 3               ; Get frame data for a particular sprite.
0011F0r 3               ; Input:
0011F0r 3               ;  a		= framenumer
0011F0r 3               ; Output:
0011F0r 3               ;  hl		= frame address
0011F0r 3               ;
0011F0r 3               ; global:	hl,frmptr
0011F0r 3               ; local:	-
0011F0r 3               ; calls:	-
0011F0r 3               ;----------------------------------------------------
0011F0r 3               
0011F0r 3               gfrm:
0011F0r 3  0A           	asl a	 		 	; multiple of 2.
0011F1r 3  18           	clc
0011F2r 3  6D rr rr     	adc frmptr 			; frames used by game.
0011F5r 3  85 rr        	sta z80_l
0011F7r 3  AD rr rr     	lda frmptr+1
0011FAr 3  69 00        	adc #0
0011FCr 3  85 rr        	sta z80_h 			; point to frame start.
0011FEr 3  60           	rts
0011FFr 3               
0011FFr 3               ;----------------------------------------------------
0011FFr 3               ; Find sprite list for current room.
0011FFr 3               ;
0011FFr 3               ; global:	hl
0011FFr 3               ; local:	x,y
0011FFr 3               ; calls:	-
0011FFr 3               ;----------------------------------------------------
0011FFr 3               
0011FFr 3               sprlst:
0011FFr 3  A9 rr        	lda #<nmedat 			; list of enemy sprites.
001201r 3  85 rr        	sta z80_l
001203r 3  A9 rr        	lda #>nmedat
001205r 3  85 rr        	sta z80_h
001207r 3  A6 rr        	ldx scno 			; screen number.
001209r 3  D0 01        	bne sprls2 			; is it the first screen?
00120Br 3  60           	rts 				; yes, don't need to search data.
00120Cr 3               sprls2:
00120Cr 3  A0 00        	ldy #0
00120Er 3               sprls1:
00120Er 3  B1 rr        	lda (z80_hl),y 			; fetch type of sprite.
001210r 3  C9 FF        	cmp #255			; is it an end marker?
001212r 3  F0 0E        	beq sprls0 			; yes, end of this room.
001214r 3               
001214r 3  18           	clc 				; point to next sprite in list.
001215r 3  A5 rr        	lda z80_l
001217r 3  69 04        	adc #NMESIZ
001219r 3  85 rr        	sta z80_l
00121Br 3  90 02        	bcc :+
00121Dr 3  E6 rr        	inc z80_h
00121Fr 3               :
00121Fr 3  4C rr rr     	jmp sprls1 			; continue until end of room.
001222r 3               sprls0:
001222r 3  E6 rr        	inc z80_l 			; point to start of next screen.s
001224r 3  D0 02        	bne :+
001226r 3  E6 rr        	inc z80_h
001228r 3               :
001228r 3  CA           	dex
001229r 3  D0 E3        	bne sprls1 			; continue until room found.
00122Br 3  60           	rts
00122Cr 3               
00122Cr 3               
00122Cr 3               ;----------------------------------------------------
00122Cr 3               ; Clear all but a single player sprite.
00122Cr 3               ;
00122Cr 3               ; global:	-
00122Cr 3               ; local:	x,y,ix
00122Cr 3               ; calls:	-
00122Cr 3               ;----------------------------------------------------
00122Cr 3               
00122Cr 3               nspr:
00122Cr 3  A9 0C        	lda #NUMSPR			; sprite slots in table.
00122Er 3  85 rr        	sta sprcnt
001230r 3  A9 rr        	lda #<sprtab 			; sprite table.
001232r 3  85 rr        	sta z80_x
001234r 3  A9 rr        	lda #>sprtab
001236r 3  85 rr        	sta z80_i
001238r 3               nspr0:
001238r 3  A0 00        	ldy #0 				; fetch sprite type.
00123Ar 3  B1 rr        	lda (z80_ix),y 			; is it a player?
00123Cr 3  F0 1A        	beq nspr1 			; yes, keep this one.
00123Er 3               
00123Er 3  A9 FF        	lda #255
001240r 3  A0 00        	ldy #0 				; fetch sprite type.
001242r 3  91 rr        	sta (z80_ix),y 			; delete sprite.
001244r 3  A0 05        	ldy #5
001246r 3  91 rr        	sta (z80_ix),y 			; remove next type.
001248r 3               
001248r 3  18           	clc	 			; next sprite.
001249r 3  A5 rr        	lda z80_x
00124Br 3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
00124Dr 3  85 rr        	sta z80_x
00124Fr 3  90 02        	bcc :+
001251r 3  E6 rr        	inc z80_i
001253r 3               :
001253r 3  C6 rr        	dec sprcnt	 			; one less space in the table.
001255r 3  D0 E1        	bne nspr0
001257r 3  60           	rts
001258r 3               nspr1:
001258r 3  A9 FF        	lda #255
00125Ar 3  A0 00        	ldy #0
00125Cr 3  91 rr        	sta (z80_ix),y 			; delete sprite.
00125Er 3               
00125Er 3  18           	clc	 			; point to next sprite.
00125Fr 3  A5 rr        	lda z80_x
001261r 3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
001263r 3  85 rr        	sta z80_x
001265r 3  90 02        	bcc :+
001267r 3  E6 rr        	inc z80_i
001269r 3               :
001269r 3  C6 rr        	dec sprcnt	 			; one less to do.
00126Br 3  D0 01        	bne nspr2
00126Dr 3  60           	rts
00126Er 3               nspr2:
00126Er 3  A9 FF        	lda #255
001270r 3  A0 00        	ldy #0
001272r 3  91 rr        	sta (z80_ix),y 			; delete sprite.
001274r 3  A0 05        	ldy #5
001276r 3  91 rr        	sta (z80_ix),y 			; remove next type.
001278r 3               
001278r 3  18           	clc	 			; next sprite.
001279r 3  A5 rr        	lda z80_x
00127Br 3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
00127Dr 3  85 rr        	sta z80_x
00127Fr 3  90 02        	bcc :+
001281r 3  E6 rr        	inc z80_i
001283r 3               :
001283r 3  C6 rr        	dec sprcnt	 			; one less space in table.
001285r 3  D0 E7        	bne nspr2
001287r 3  60           	rts
001288r 3               
001288r 3               ;----------------------------------------------------------
001288r 3               ; Two initialisation routines.
001288r 3               ; Initialise sprites - copy everything from list to table.
001288r 3               ;
001288r 3               ; global:	-
001288r 3               ; local:	x,y,ix
001288r 3               ; calls:	cpsp
001288r 3               ;----------------------------------------------------------
001288r 3               
001288r 3               ispr:
001288r 3  A9 0C        	lda #NUMSPR			; sprite slots in table.
00128Ar 3  85 rr        	sta sprcnt
00128Cr 3  A9 rr        	lda #<sprtab			; sprite table.
00128Er 3  85 rr        	sta z80_x
001290r 3  A9 rr        	lda #>sprtab
001292r 3  85 rr        	sta z80_i
001294r 3               ispr2:
001294r 3  A0 00        	ldy #0
001296r 3  B1 rr        	lda (z80_hl),y 			; fetch byte.
001298r 3  C9 FF        	cmp #255 			; is it an end marker?
00129Ar 3  D0 01        	bne :+
00129Cr 3  60           	rts 				; yes, no more to do.
00129Dr 3               :
00129Dr 3               ispr1:
00129Dr 3  A0 00        	ldy #0
00129Fr 3  B1 rr        	lda (z80_ix),y 			; fetch sprite type.
0012A1r 3  C9 FF        	cmp #255 			; is it enabled yet?
0012A3r 3  D0 08        	bne ispr4			; yes, try another slot.
0012A5r 3               
0012A5r 3  A0 05        	ldy #5
0012A7r 3  B1 rr        	lda (z80_ix),y		 	; next type.
0012A9r 3  C9 FF        	cmp #255 			; is it enabled yet?
0012ABr 3  F0 10        	beq ispr3 			; no, process this one.
0012ADr 3               ispr4:
0012ADr 3  18           	clc 				; next sprite.
0012AEr 3  A5 rr        	lda z80_x
0012B0r 3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
0012B2r 3  85 rr        	sta z80_x
0012B4r 3  90 02        	bcc :+
0012B6r 3  E6 rr        	inc z80_i
0012B8r 3               :
0012B8r 3  C6 rr        	dec sprcnt
0012BAr 3  D0 E1        	bne ispr1 			; repeat for remaining sprites.
0012BCr 3  60           	rts  				; no more room in table.
0012BDr 3               ispr3:
0012BDr 3  20 rr rr     	jsr cpsp			; initialise a sprite.
0012C0r 3  C6 rr        	dec sprcnt			; one less space in the table.
0012C2r 3  D0 D0        	bne ispr2
0012C4r 3  60           	rts
0012C5r 3               
0012C5r 3               
0012C5r 3               ;-----------------------------------------------------------------------
0012C5r 3               ; Initialise sprites - but not player, we're keeping the old one.
0012C5r 3               ;
0012C5r 3               ; global:	-
0012C5r 3               ; local:	x,y,ix
0012C5r 3               ; calls:	cpsp
0012C5r 3               ;-----------------------------------------------------------------------
0012C5r 3               
0012C5r 3               kspr:
0012C5r 3  A2 0C        	ldx #NUMSPR			; sprite slots in table.
0012C7r 3  A9 rr        	lda #<sprtab 			; sprite table.
0012C9r 3  85 rr        	sta z80_x
0012CBr 3  A9 rr        	lda #>sprtab
0012CDr 3  85 rr        	sta z80_i
0012CFr 3               kspr2:
0012CFr 3  A0 00        	ldy #0
0012D1r 3  B1 rr        	lda (z80_hl),y 			; fetch byte.
0012D3r 3  C9 FF        	cmp #255 			; is it an end marker?
0012D5r 3  D0 01        	bne :+
0012D7r 3  60           	rts 				; yes, no more to do.
0012D8r 3               :
0012D8r 3  C9 00        	cmp #0
0012DAr 3  D0 0E        	bne kspr1 			; no, add to table as normal.
0012DCr 3               
0012DCr 3  18           	clc 				; next sprite.
0012DDr 3  A5 rr        	lda z80_l
0012DFr 3  69 04        	adc #NMESIZ		 	; distance to next odd/even entry.
0012E1r 3  85 rr        	sta z80_l
0012E3r 3  90 02        	bcc :+
0012E5r 3  E6 rr        	inc z80_h
0012E7r 3               :
0012E7r 3  4C rr rr     	jmp kspr2
0012EAr 3               kspr1:
0012EAr 3  A0 00        	ldy #0 				; fetch sprite type.
0012ECr 3  B1 rr        	lda (z80_ix),y
0012EEr 3  C9 FF        	cmp #255 			; is it enabled yet?
0012F0r 3  D0 08        	bne kspr4 			; yes, try another slot.
0012F2r 3               
0012F2r 3  A0 05        	ldy #5 				; next type.
0012F4r 3  B1 rr        	lda (z80_ix),y
0012F6r 3  C9 FF        	cmp #255 			; is it enabled yet?
0012F8r 3  F0 0F        	beq kspr3 			; no, process this one.
0012FAr 3               kspr4:
0012FAr 3  18           	clc 				; next sprite.
0012FBr 3  A5 rr        	lda z80_x
0012FDr 3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
0012FFr 3  85 rr        	sta z80_x
001301r 3  90 02        	bcc :+
001303r 3  E6 rr        	inc z80_i
001305r 3               :
001305r 3  CA           	dex	 			; repeat for remaining sprites.
001306r 3  D0 E2        	bne kspr1
001308r 3  60           	rts  				; no more room in table.
001309r 3               kspr3:
001309r 3  20 rr rr     	jsr cpsp 			; copy sprite to table.
00130Cr 3  CA           	dex	 			; one less space in the table.
00130Dr 3  D0 C0        	bne kspr2
00130Fr 3  60           	rts
001310r 3               
001310r 3               ;----------------------------------------------
001310r 3               ; Copy sprite from list to table.
001310r 3               ;
001310r 3               ; global:	hl,ix
001310r 3               ; local:	y
001310r 3               ; calls:	evnt09
001310r 3               ;----------------------------------------------
001310r 3               
001310r 3               cpsp:
001310r 3  A0 00        	ldy #0					; fetch byte from table.
001312r 3  B1 rr        	lda (z80_hl),y
001314r 3               	; y=var_Type
001314r 3  91 rr        	sta (z80_ix),y			; set up type.
001316r 3  A0 05        	ldy #var_newType
001318r 3  91 rr        	sta (z80_ix),y 			; set up type.
00131Ar 3               
00131Ar 3  E6 rr        	inc z80_l 				; move to next byte.
00131Cr 3  D0 02        	bne :+
00131Er 3  E6 rr        	inc z80_h
001320r 3               :
001320r 3  A0 00        	ldy #0 					; fetch byte from table.
001322r 3  B1 rr        	lda (z80_hl),y
001324r 3  A0 06        	ldy #var_newImage
001326r 3  91 rr        	sta (z80_ix),y			; set up image.
001328r 3               
001328r 3  E6 rr        	inc z80_l 				; move to next byte.
00132Ar 3  D0 02        	bne :+
00132Cr 3  E6 rr        	inc z80_h
00132Er 3               :
00132Er 3  A0 00        	ldy #0
001330r 3  B1 rr        	lda (z80_hl),y 			; fetch byte from table.
001332r 3  A0 08        	ldy #var_newY
001334r 3  91 rr        	sta (z80_ix),y 			; set up coordinate.
001336r 3               
001336r 3  A9 C8        	lda #200 				; set initial coordinate off screen.
001338r 3  A0 03        	ldy #var_Y
00133Ar 3  91 rr        	sta (z80_ix),y
00133Cr 3               
00133Cr 3  E6 rr        	inc z80_l 				; move to next byte.
00133Er 3  D0 02        	bne :+
001340r 3  E6 rr        	inc z80_h
001342r 3               :
001342r 3  A0 00        	ldy #0 					; fetch byte from table.
001344r 3  B1 rr        	lda (z80_hl),y
001346r 3  A0 09        	ldy #var_newX
001348r 3  91 rr        	sta (z80_ix),y 			; set up coordinate.
00134Ar 3               
00134Ar 3  E6 rr        	inc z80_l 				; move to next byte.
00134Cr 3  D0 02        	bne :+
00134Er 3  E6 rr        	inc z80_h
001350r 3               :
001350r 3  A9 00        	lda #0					; zeroes in accumulator.
001352r 3  A0 07        	ldy #var_newFrame 		; reset frame number.
001354r 3  91 rr        	sta (z80_ix),y
001356r 3  A0 0A        	ldy #var_Direction 		; reset direction.
001358r 3  91 rr        	sta (z80_ix),y
00135Ar 3  A0 0D        	ldy #var_jumpLo			; reset jump pointer low.
00135Cr 3  91 rr        	sta (z80_ix),y
00135Er 3  A0 0E        	ldy #var_jumpHi	 		; reset jump pointer high.
001360r 3  91 rr        	sta (z80_ix),y
001362r 3               
001362r 3  A9 FF        	lda #255 				; reset data pointer to auto-restore.
001364r 3  A0 10        	ldy #var_dataHi
001366r 3  91 rr        	sta (z80_ix),y
001368r 3               evis0:
001368r 3  A5 rr        	lda z80_i
00136Ar 3  48           	pha
00136Br 3  A5 rr        	lda z80_x
00136Dr 3  48           	pha
00136Er 3  A5 rr        	lda z80_h
001370r 3  48           	pha
001371r 3  A5 rr        	lda z80_l
001373r 3  48           	pha
001374r 3               
001374r 3  20 rr rr     	jsr evnt09 				; perform event.
001377r 3               
001377r 3  68           	pla
001378r 3  85 rr        	sta z80_l
00137Ar 3  68           	pla
00137Br 3  85 rr        	sta z80_h
00137Dr 3  68           	pla
00137Er 3  85 rr        	sta z80_x
001380r 3  68           	pla
001381r 3  85 rr        	sta z80_i
001383r 3               
001383r 3  18           	clc
001384r 3  A5 rr        	lda z80_x 			; distance to next odd/even entry.
001386r 3  69 11        	adc #TABSIZ		 	; next sprite.
001388r 3  85 rr        	sta z80_x
00138Ar 3  90 02        	bcc :+
00138Cr 3  E6 rr        	inc z80_i
00138Er 3               :
00138Er 3  60           	rts
00138Fr 3               
00138Fr 3               
00138Fr 3               ;-------------------------------------
00138Fr 3               ; Clear the play area window.
00138Fr 3               ;-------------------------------------
00138Fr 3               
00138Fr 3               clw:
00138Fr 3  AD rr rr     	lda wintop			; get coordinates of window.
001392r 3  85 rr        	sta dispy			; put into dispx for calculation.
001394r 3  AD rr rr     	lda winlft
001397r 3  85 rr        	sta dispx
001399r 3               
001399r 3  AD rr rr     	lda winhgt			; height of window.
00139Cr 3  85 rr        	sta rrow			; copy to b register.
00139Er 3               clw3:
00139Er 3  AD rr rr     	lda winwid 			; width of window.
0013A1r 3  85 rr        	sta rcol
0013A3r 3               clw2:
0013A3r 3  20 rr rr     	jsr gprad 			; get print address.
0013A6r 3  A9 00        	lda #0				; zero byte to write.
0013A8r 3  A2 07        	ldx #7				; pixel height of each cell.
0013AAr 3               clw1:
0013AAr 3  BC rr rr     	ldy scrtab,x
0013ADr 3  91 rr        	sta (scraddr),y 			; copy to screen.
0013AFr 3  CA           	dex				; next screen row down.
0013B0r 3  10 F8        	bpl clw1
0013B2r 3               
0013B2r 3  E6 rr        	inc dispx			; next column.
0013B4r 3  C6 rr        	dec rcol			; one less to do.
0013B6r 3  D0 EB        	bne clw2			; repeat for remaining columns.
0013B8r 3               
0013B8r 3  AD rr rr     	lda winlft			; get left edge.
0013BBr 3  85 rr        	sta dispx 			; reset x.
0013BDr 3  E6 rr        	inc dispy 			; next line down.
0013BFr 3               
0013BFr 3  C6 rr        	dec rrow
0013C1r 3  D0 DB        	bne clw3			; repeat down the screen.
0013C3r 3               
0013C3r 3  AD rr rr     	lda wintop			; get coordinates of window.
0013C6r 3  85 rr        	sta chary			; put into display position.
0013C8r 3  AD rr rr     	lda winlft
0013CBr 3  85 rr        	sta charx
0013CDr 3  60           	rts
0013CEr 3               
0013CEr 3               
0013CEr 3               ;----------------------------------------------------------
0013CEr 3               ; Effects code.
0013CEr 3               ; Ticker routine is called 25 times per second.
0013CEr 3               ;
0013CEr 3               ; txtini = text scroller address
0013CEr 3               ; txtscr = left text screen address
0013CEr 3               ; txtwid = scroller width
0013CEr 3               ; txtbit = 128
0013CEr 3               ; X      = message nr
0013CEr 3               ;----------------------------------------------------------
0013CEr 3               
0013CEr 3  00 08 10 18  scrollpos:	.byte   0,  8, 16, 24, 32, 40, 48, 56
0013D2r 3  20 28 30 38  
0013D6r 3  40 48 50 58  		.byte  64, 72, 80, 88, 96,104,112,120
0013DAr 3  60 68 70 78  
0013DEr 3  80 88 90 98  		.byte 128,136,144,152,160,168,176,184
0013E2r 3  A0 A8 B0 B8  
0013E6r 3  C0 C8 D0 D8  		.byte 192,200,208,216,224,232,240,248
0013EAr 3  E0 E8 F0 F8  
0013EEr 3               .if sflag
0013EEr 3               scrly:
0013EEr 3               	rts
0013EEr 3               	.word txtscr         	; set scr_l = left screen address.
0013EEr 3               	sta scr_l
0013EEr 3               	sta tmp_byte		; tmp_byte = lb left screen address
0013EEr 3               	lda txtscr+1
0013EEr 3               	sta scr_l+1
0013EEr 3               	sta scr_r+1		; set hb scr_r = hb left screen address
0013EEr 3               
0013EEr 3               	stx xtmp		; save x
0013EEr 3               
0013EEr 3               	ldx txtwid
0013EEr 3               	dex
0013EEr 3               	ldy scrollpos,x
0013EEr 3               	tya
0013EEr 3               	clc
0013EEr 3               	adc scr_l
0013EEr 3               	sta scr_r		; set lb scr_r = scr_l + (txtwid - 1) * 8
0013EEr 3               
0013EEr 3               	lda #8
0013EEr 3               	sta line_cnt
0013EEr 3               scrly1:
0013EEr 3               	ldx txtwid		; set txtwide
0013EEr 3               	dex
0013EEr 3               	clc
0013EEr 3               scrly0:
0013EEr 3               	ldy scrollpos,x
0013EEr 3               	lda (scr_l),y		; scroll 1 line
0013EEr 3               	rol a
0013EEr 3               	sta (scr_l),y
0013EEr 3               	dex
0013EEr 3               	bpl scrly0
0013EEr 3               
0013EEr 3               	inc scr_l
0013EEr 3               	dec line_cnt
0013EEr 3               	bne scrly1		; repeat 8 times
0013EEr 3               
0013EEr 3               	lda txtpos 		; get text pointer.
0013EEr 3               	sta scr_txt
0013EEr 3               	lda txtpos+1
0013EEr 3               	sta scr_txt+1
0013EEr 3               
0013EEr 3               	ldy #0
0013EEr 3               	lda (scr_txt),y 	; find character we're displaying.
0013EEr 3               	and #127 		; remove end marker bit if applicable.
0013EEr 3               	cmp #13			; is it newline?
0013EEr 3               	bne scrly5 		; no, it's okay.
0013EEr 3               	lda #32			; convert to a space instead.
0013EEr 3               scrly5:
0013EEr 3               	sta fntaddr		; calculate char address
0013EEr 3               	lda #0
0013EEr 3               	sta fntaddr+1
0013EEr 3               	asl fntaddr  		; multiply char by 8.
0013EEr 3               	rol fntaddr+1
0013EEr 3               	asl fntaddr
0013EEr 3               	rol fntaddr+1
0013EEr 3               	asl fntaddr
0013EEr 3               	rol fntaddr+1
0013EEr 3               	lda fntaddr
0013EEr 3               	clc
0013EEr 3               	adc #<(FONT-256)
0013EEr 3               	sta scrly3+1		; that's the low byte.
0013EEr 3               	lda fntaddr+1
0013EEr 3               	adc #>(FONT-256)
0013EEr 3               	sta scrly3+2		; add displacement.
0013EEr 3               
0013EEr 3               	ldy #0
0013EEr 3               scrly3:
0013EEr 3               	lda $3333,y		; get image of char line.
0013EEr 3               	and txtbit
0013EEr 3               	beq scrly2		; don't plot pixel
0013EEr 3               	lda (scr_r),y
0013EEr 3               	clc
0013EEr 3               	ora #1
0013EEr 3               	sta (scr_r),y		; plot pixel
0013EEr 3               scrly2:
0013EEr 3               	iny			; next line of char.
0013EEr 3               	cpy #8
0013EEr 3               	bne scrly3
0013EEr 3               
0013EEr 3               	lsr txtbit		; bit of text to display.
0013EEr 3               	bcs :+
0013EEr 3               	rts
0013EEr 3               :
0013EEr 3               	ldy #0
0013EEr 3               	lda (scr_txt),y 	; what was the character?
0013EEr 3               	asl a	  		; end of message?
0013EEr 3               	bcs scrly4
0013EEr 3               	inc txtpos
0013EEr 3               	bne :+
0013EEr 3               	inc txtpos+1
0013EEr 3               :
0013EEr 3               	jmp scrly6 		; not yet - continue.
0013EEr 3               scrly4:
0013EEr 3               	lda txtini 		; start of scrolling message.
0013EEr 3               	sta txtpos
0013EEr 3               	lda txtini+1
0013EEr 3               	sta txtpos+1
0013EEr 3               scrly6:
0013EEr 3               	lda #128
0013EEr 3               	sta txtbit
0013EEr 3               	ldx xtmp
0013EEr 3               	rts
0013EEr 3               
0013EEr 3               ;scrline:	.byte $00,$20,$40,$60,$80,$a0,$c0,$e0
0013EEr 3               tmp_byte:	.byte 0
0013EEr 3               line_cnt:	.byte 0
0013EEr 3               
0013EEr 3               ;-------------------------------------------------------
0013EEr 3               ; Entry TICKER command
0013EEr 3               ;
0013EEr 3               ; Entry:
0013EEr 3               ;  z80_b = message nr
0013EEr 3               ;  z80_c = width
0013EEr 3               ;-------------------------------------------------------
0013EEr 3               
0013EEr 3               iscrly:
0013EEr 3               	jsr prescr 		; set up display position.
0013EEr 3               	lda #<msgdat 		; text messages.
0013EEr 3               	sta z80_l
0013EEr 3               	lda #>msgdat
0013EEr 3               	sta z80_h
0013EEr 3               	lda z80_c 		; width.
0013EEr 3               	sec
0013EEr 3               	sbc #1			; subtract one.
0013EEr 3               	cmp #32 		; is it between 1 and 32?
0013EEr 3               	bcc :+
0013EEr 3               	lda #$60
0013EEr 3               	jmp iscrl0		; no, disable messages.
0013EEr 3               :
0013EEr 3               	ldx z80_b		; message number.
0013EEr 3               	jsr getwrd 		; find message start.
0013EEr 3               
0013EEr 3               	lda z80_l		; set initial text position.
0013EEr 3               	sta txtini
0013EEr 3               	lda z80_h
0013EEr 3               	sta txtini+1
0013EEr 3               
0013EEr 3               	lda #$ad		; code for lda adrr
0013EEr 3               iscrl0:
0013EEr 3               	sta scrly		; enable/disable scrolling routine.
0013EEr 3               
0013EEr 3               	jsr prescr 		; set up display position.
0013EEr 3               	jsr gprad 		; get print address.
0013EEr 3               
0013EEr 3               	lda scraddr 		; set text screen address.
0013EEr 3               	sta txtscr
0013EEr 3               	lda scraddr+1
0013EEr 3               	sta txtscr+1
0013EEr 3               
0013EEr 3               	lda z80_c		; width.
0013EEr 3               	sta txtwid		; set width in working storage.
0013EEr 3               
0013EEr 3               	lda #128 		; start with leftmost bit.
0013EEr 3               	sta txtbit
0013EEr 3               
0013EEr 3               	jmp scrly4
0013EEr 3               .endif
0013EEr 3               
0013EEr 3               ;------------------------------------------------------------------
0013EEr 3               ; Dig routine, conditional assembly depending on dflag
0013EEr 3               ;------------------------------------------------------------------
0013EEr 3               .if dflag
0013EEr 3               dig:
0013EEr 3               	and #3
0013EEr 3               	beq digr		; dig right
0013EEr 3               	cmp #1
0013EEr 3               	beq digl		; dig left
0013EEr 3               	cmp #2
0013EEr 3               	beq digd		; dig down
0013EEr 3               
0013EEr 3               ; Dig up.
0013EEr 3               
0013EEr 3               digu:				; dig up
0013EEr 3               	ldy #8
0013EEr 3               	lda (z80_ix),y
0013EEr 3               	sec
0013EEr 3               	sbc #2
0013EEr 3               	sta dispy		; set y
0013EEr 3               
0013EEr 3               	iny
0013EEr 3               	lda (z80_ix),y
0013EEr 3               	sta dispx		; set x
0013EEr 3               	jmp digv
0013EEr 3               
0013EEr 3               ; Dig down.
0013EEr 3               
0013EEr 3               digd:
0013EEr 3               	ldy #9
0013EEr 3               	lda (z80_ix),y
0013EEr 3               	sta dispx		; set y
0013EEr 3               
0013EEr 3               	dey
0013EEr 3               	clc
0013EEr 3               	lda (z80_ix),y
0013EEr 3               	adc #16
0013EEr 3               	sta dispy		; set y
0013EEr 3               	jmp digv
0013EEr 3               
0013EEr 3               ; Dig left.
0013EEr 3               
0013EEr 3               digl:
0013EEr 3               	ldy #8
0013EEr 3               	lda (z80_ix),y
0013EEr 3               	sta dispy		; set y
0013EEr 3               
0013EEr 3               	iny
0013EEr 3               	lda (z80_ix),y
0013EEr 3               	sec
0013EEr 3               	sbc #2			; x=x-2
0013EEr 3               	sta dispx		; set x
0013EEr 3               	jmp digh
0013EEr 3               
0013EEr 3               ; Dig right.
0013EEr 3               
0013EEr 3               digr:
0013EEr 3               	ldy #8
0013EEr 3               	lda (z80_ix),y
0013EEr 3               	sta dispy		; set y
0013EEr 3               
0013EEr 3               	iny
0013EEr 3               	lda (z80_ix),y
0013EEr 3               	clc
0013EEr 3               	adc #16
0013EEr 3               	sta dispx		; set x+16
0013EEr 3               	jmp digh
0013EEr 3               
0013EEr 3               ; Vertical digging
0013EEr 3               
0013EEr 3               digv:
0013EEr 3               	jsr tstbl		; check blocktype in MAP
0013EEr 3               	jsr fdchk		; test if FODDER
0013EEr 3               
0013EEr 3               	clc
0013EEr 3               	lda dispx		; look 1 cell down
0013EEr 3               	adc #8
0013EEr 3               	sta dispx
0013EEr 3               	jsr tstbl		; check blocktype in MAP
0013EEr 3               	jsr fdchk
0013EEr 3               	lda dispx
0013EEr 3               	and #7
0013EEr 3               	bne :+
0013EEr 3               	rts
0013EEr 3               :
0013EEr 3               	clc
0013EEr 3               	lda dispx		; look 1 cell down
0013EEr 3               	adc #8
0013EEr 3               	sta dispx
0013EEr 3               	jsr tstbl		; check blocktype in MAP
0013EEr 3               	jmp fdchk
0013EEr 3               
0013EEr 3               ; Horizontal digging
0013EEr 3               
0013EEr 3               digh:
0013EEr 3               	jsr tstbl		; check blocktype in MAP
0013EEr 3               	jsr fdchk		; test if FODDER
0013EEr 3               
0013EEr 3               	clc
0013EEr 3               	lda dispy		; look 1 cell down
0013EEr 3               	adc #8
0013EEr 3               	sta dispy
0013EEr 3               	jsr tstbl		; check blocktype in MAP
0013EEr 3               	jsr fdchk
0013EEr 3               	lda dispy
0013EEr 3               	and #7
0013EEr 3               	bne :+
0013EEr 3               	rts
0013EEr 3               :
0013EEr 3               	clc
0013EEr 3               	lda dispy		; look 1 cell down
0013EEr 3               	adc #8
0013EEr 3               	sta dispy
0013EEr 3               	jsr tstbl		; check blocktype in MAP
0013EEr 3               	jmp fdchk
0013EEr 3               
0013EEr 3               digcnt:	.byte 0
0013EEr 3               
0013EEr 3               .endif
0013EEr 3               
0013EEr 3               ;------------------------------------------------------------------
0013EEr 3               ; Sprite table
0013EEr 3               ;------------------------------------------------------------------
0013EEr 3               
0013EEr 3               
0013EEr 3               ; ix+0  = type.
0013EEr 3               ; ix+1  = sprite image number.
0013EEr 3               ; ix+2  = frame.
0013EEr 3               ; ix+3  = y coord.
0013EEr 3               ; ix+4  = x coord.
0013EEr 3               
0013EEr 3               ; ix+5  = new type.
0013EEr 3               ; ix+6  = new image number.
0013EEr 3               ; ix+7  = new frame.
0013EEr 3               ; ix+8  = new y coord.
0013EEr 3               ; ix+9  = new x coord.
0013EEr 3               
0013EEr 3               ; ix+10 = direction.
0013EEr 3               ; ix+11 = parameter 1.
0013EEr 3               ; ix+12 = parameter 2.
0013EEr 3               ; ix+13 = jump pointer low.
0013EEr 3               ; ix+14 = jump pointer high.
0013EEr 3               ; ix+15 = data pointer low.
0013EEr 3               ; ix+16 = data pointer high.
0013EEr 3               
0013EEr 3               ; block NUMSPR * TABSIZ,255
0013EEr 3               
0013EEr 3  FF FF FF FF  sprtab:	.res NUMSPR*TABSIZ,255
0013F2r 3  FF FF FF FF  
0013F6r 3  FF FF FF FF  
0014BAr 3  FF FF FF FF  ssprit:	.byte 255,255,255,255,255,255,255,0,192,120,0,0,0,255,255,255,255
0014BEr 3  FF FF FF 00  
0014C2r 3  C0 78 00 00  
0014CBr 3  07           roomtb:	.byte 7                      ; start room map offset.
0014CCr 3               
0014CCr 3               setfgcol:
0014CCr 3               setbgcol:
0014CCr 3  60           	rts
0014CDr 3               
0014CDr 3               ; User routine.  Put your own code in here to be called with USER instruction.
0014CDr 3               ; if USER has an argument it will be passed in the accumulator.
0014CDr 3               
0014CDr 3               user:
0014CDr 3               	.include "user.inc"
0014CDr 4  60           	rts
0014CEr 4               
0014CEr 3               
0014CEr 3               ; Everything below here will be generated by the editors.
0014CEr 3               
0014CEr 3               
0014CEr 3  60                   rts
0014CFr 3               WINDOWTOP = 0
0014CFr 3               WINDOWLFT = 0
0014CFr 3               WINDOWHGT = 22
0014CFr 3               WINDOWWID = 22 ;a
0014CFr 3               MAPWID = 3
0014CFr 3  FF FF FF             .byte 255,255,255
0014D2r 3               mapdat:
0014D2r 3  FF 00 FF             .byte 255,0,255
0014D5r 3  FF FF FF             .byte 255,255,255
0014D8r 3  01           stmap:  .byte 1
0014D9r 3               
0014D9r 3               evnt00:
0014D9r 3  60                   rts
0014DAr 3               evnt01:
0014DAr 3  60                   rts
0014DBr 3               evnt02:
0014DBr 3  60                   rts
0014DCr 3               evnt03:
0014DCr 3  60                   rts
0014DDr 3               evnt04:
0014DDr 3  60                   rts
0014DEr 3               evnt05:
0014DEr 3  60                   rts
0014DFr 3               evnt06:
0014DFr 3  60                   rts
0014E0r 3               evnt07:
0014E0r 3  60                   rts
0014E1r 3               evnt08:
0014E1r 3  60                   rts
0014E2r 3               evnt09:
0014E2r 3  60                   rts
0014E3r 3               evnt10:
0014E3r 3  A9 01                lda #1		; PRINTMODE
0014E5r 3  85 rr                sta prtmod
0014E7r 3  A9 00                lda #0		; AT
0014E9r 3  85 rr                sta chary
0014EBr 3  A9 01                lda #1
0014EDr 3  85 rr                sta charx
0014EFr 3  A9 00                lda #0		; PRINT
0014F1r 3  20 rr rr             jsr dmsg
0014F4r 3  A9 00                lda #0		; PRINTMODE
0014F6r 3  85 rr                sta prtmod
0014F8r 3  A9 04                lda #4		; AT
0014FAr 3  85 rr                sta chary
0014FCr 3  A9 01                lda #1
0014FEr 3  85 rr                sta charx
001500r 3  A9 01                lda #1		; PRINT
001502r 3  20 rr rr             jsr dmsg
001505r 3  A9 05                lda #5		; AT
001507r 3  85 rr                sta chary
001509r 3  A9 01                lda #1
00150Br 3  85 rr                sta charx
00150Dr 3  A9 02                lda #2		; PRINT
00150Fr 3  20 rr rr             jsr dmsg
001512r 3  A9 06                lda #6		; AT
001514r 3  85 rr                sta chary
001516r 3  A9 01                lda #1
001518r 3  85 rr                sta charx
00151Ar 3  A9 03                lda #3		; PRINT
00151Cr 3  20 rr rr             jsr dmsg
00151Fr 3  A0 07                ldy #7 	; KEY
001521r 3                       .if swrflag
001521r 3                       lda keys + data_address - data_start,y
001521r 3                       .else
001521r 3  B9 rr rr             lda keys,y
001524r 3                       .endif
001524r 3  20 rr rr             jsr ktest
001527r 3  90 03                bcc :+
001529r 3  4C rr rr             jmp k00271
00152Cr 3               :
00152Cr 3  A9 02                lda #2 	; INK
00152Er 3  8D rr rr             sta fontcol
001531r 3  A9 04                lda #4		; MENU
001533r 3  AA                   tax
001534r 3  20 rr rr             jsr mmenu
001537r 3  A9 00                lda #0 	; INK
001539r 3  8D rr rr             sta fontcol
00153Cr 3  A9 15                lda #21		; AT
00153Er 3  85 rr                sta chary
001540r 3  A9 02                lda #2
001542r 3  85 rr                sta charx
001544r 3  A9 05                lda #5		; PRINT
001546r 3  20 rr rr             jsr dmsg
001549r 3  A5 rr                lda varopt	; DISPLAY
00154Br 3  20 rr rr             jsr disply
00154Er 3  A9 06                lda #6		; PRINT
001550r 3  20 rr rr             jsr dmsg
001553r 3  A0 08        k00271: ldy #8 	; KEY
001555r 3                       .if swrflag
001555r 3                       lda keys + data_address - data_start,y
001555r 3                       .else
001555r 3  B9 rr rr             lda keys,y
001558r 3                       .endif
001558r 3  20 rr rr             jsr ktest
00155Br 3  90 03                bcc :+
00155Dr 3  4C rr rr             jmp k00526
001560r 3               :
001560r 3  A9 00                lda #0	; GET
001562r 3  20 rr rr             jsr getob
001565r 3  A9 03                lda #3	; GET
001567r 3  20 rr rr             jsr getob
00156Ar 3  A9 05                lda #5	; GET
00156Cr 3  20 rr rr             jsr getob
00156Fr 3  A9 04                lda #4 	; INK
001571r 3  8D rr rr             sta fontcol
001574r 3  A9 07                lda #7		; INVENTORY
001576r 3  AA                   tax
001577r 3  20 rr rr             jsr minve
00157Ar 3  A9 00                lda #0 	; INK
00157Cr 3  8D rr rr             sta fontcol
00157Fr 3  A9 15                lda #21		; AT
001581r 3  85 rr                sta chary
001583r 3  A9 02                lda #2
001585r 3  85 rr                sta charx
001587r 3  A9 08                lda #8		; PRINT
001589r 3  20 rr rr             jsr dmsg
00158Cr 3  A5 rr                lda varopt	; DISPLAY
00158Er 3  20 rr rr             jsr disply
001591r 3  A9 09                lda #9		; PRINT
001593r 3  20 rr rr             jsr dmsg
001596r 3  A9 14                lda #20
001598r 3  85 rr                sta vari
00159Ar 3  A5 rr                lda vari
00159Cr 3  85 rr                sta z80_d
00159Er 3  A5 rr                lda varopt
0015A0r 3  85 rr                sta z80_h
0015A2r 3  20 rr rr             jsr imul
0015A5r 3  A5 rr                lda z80_l
0015A7r 3  85 rr                sta vari
0015A9r 3  A9 12                lda #18
0015ABr 3  85 rr                sta z80_c
0015ADr 3  A5 rr                lda vari
0015AFr 3  18                   clc
0015B0r 3  65 rr                adc z80_c
0015B2r 3  85 rr                sta vari
0015B4r 3  A5 rr                lda vari	; PUT
0015B6r 3  85 rr                sta dispx
0015B8r 3  A9 90                lda #144
0015BAr 3  85 rr                sta dispy
0015BCr 3  A5 rr                lda varopt
0015BEr 3  20 rr rr             jsr drpob
0015C1r 3  A0 09        k00526: ldy #9 	; KEY
0015C3r 3                       .if swrflag
0015C3r 3                       lda keys + data_address - data_start,y
0015C3r 3                       .else
0015C3r 3  B9 rr rr             lda keys,y
0015C6r 3                       .endif
0015C6r 3  20 rr rr             jsr ktest
0015C9r 3  90 03                bcc :+
0015CBr 3  4C rr rr             jmp k00812
0015CEr 3               :
0015CEr 3  A9 00                lda #0		; GOT
0015D0r 3  20 rr rr             jsr gotob
0015D3r 3  C9 FF                cmp #255
0015D5r 3  F0 03                beq :+
0015D7r 3  4C rr rr             jmp k00624
0015DAr 3               :
0015DAr 3  A9 12                lda #18	; PUT
0015DCr 3  85 rr                sta dispx
0015DEr 3  A9 90                lda #144
0015E0r 3  85 rr                sta dispy
0015E2r 3  A9 00                lda #0
0015E4r 3  20 rr rr             jsr drpob
0015E7r 3  A9 03        k00624: lda #3		; GOT
0015E9r 3  20 rr rr             jsr gotob
0015ECr 3  C9 FF                cmp #255
0015EEr 3  F0 03                beq :+
0015F0r 3  4C rr rr             jmp k00674
0015F3r 3               :
0015F3r 3  A9 4E                lda #78	; PUT
0015F5r 3  85 rr                sta dispx
0015F7r 3  A9 90                lda #144
0015F9r 3  85 rr                sta dispy
0015FBr 3  A9 03                lda #3
0015FDr 3  20 rr rr             jsr drpob
001600r 3  A9 05        k00674: lda #5		; GOT
001602r 3  20 rr rr             jsr gotob
001605r 3  C9 FF                cmp #255
001607r 3  F0 03                beq :+
001609r 3  4C rr rr             jmp k00725
00160Cr 3               :
00160Cr 3  A9 76                lda #118	; PUT
00160Er 3  85 rr                sta dispx
001610r 3  A9 90                lda #144
001612r 3  85 rr                sta dispy
001614r 3  A9 05                lda #5
001616r 3  20 rr rr             jsr drpob
001619r 3  A9 06        k00725: lda #6 	; INK
00161Br 3  8D rr rr             sta fontcol
00161Er 3  A9 0A                lda #10		; INVENTORY
001620r 3  AA                   tax
001621r 3  20 rr rr             jsr minve
001624r 3  A9 00                lda #0 	; INK
001626r 3  8D rr rr             sta fontcol
001629r 3  A9 15                lda #21		; AT
00162Br 3  85 rr                sta chary
00162Dr 3  A9 02                lda #2
00162Fr 3  85 rr                sta charx
001631r 3  A9 0B                lda #11		; PRINT
001633r 3  20 rr rr             jsr dmsg
001636r 3  A5 rr                lda varopt	; DISPLAY
001638r 3  20 rr rr             jsr disply
00163Br 3  A9 0C                lda #12		; PRINT
00163Dr 3  20 rr rr             jsr dmsg
001640r 3  60           k00812: rts
001641r 3               evnt11:
001641r 3  60                   rts
001642r 3               evnt12:
001642r 3  20 rr rr             jsr cls		; CLS
001645r 3  60                   rts
001646r 3               evnt13:
001646r 3  60                   rts
001647r 3               evnt14:
001647r 3  60                   rts
001648r 3               evnt15:
001648r 3  60                   rts
001649r 3               evnt16:
001649r 3  60                   rts
00164Ar 3               evnt17:
00164Ar 3  60                   rts
00164Br 3               evnt18:
00164Br 3  60                   rts
00164Cr 3               evnt19:
00164Cr 3  60                   rts
00164Dr 3               evnt20:
00164Dr 3  60                   rts
00164Er 3  60           ptcusr: rts
00164Fr 3               data_start:
00164Fr 3               msgdat:
00164Fr 3  4D 45 4E 55          .byte "MENU/INVENTORY TEST",186
001653r 3  2F 49 4E 56  
001657r 3  45 4E 54 4F  
001663r 3  4D 45 4E 55          .byte "MENU      = PRESS ",177
001667r 3  20 20 20 20  
00166Br 3  20 20 3D 20  
001676r 3  49 4E 56 45          .byte "INVENTORY = PRESS ",178
00167Ar 3  4E 54 4F 52  
00167Er 3  59 20 3D 20  
001689r 3  45 4D 50 54          .byte "EMPTY INV = PRESS ",179
00168Dr 3  59 20 49 4E  
001691r 3  56 20 3D 20  
00169Cr 3  4F 4E 45 2C          .byte "ONE,TWO,THREE,FOUR,FIVE,SI",216
0016A0r 3  54 57 4F 2C  
0016A4r 3  54 48 52 45  
0016B7r 3  53 45 4C 45          .byte "SELECTION WAS:",160
0016BBr 3  43 54 49 4F  
0016BFr 3  4E 20 57 41  
0016C6r 3  20 A0                .byte " ",160
0016C8r 3  20 4F 42 4A          .byte " OBJ0 , OBJ1 , OBJ2 , OBJ3 , OBJ4 , OBJ",181
0016CCr 3  30 20 2C 20  
0016D0r 3  4F 42 4A 31  
0016F0r 3  53 45 4C 45          .byte "SELECTION WAS:",160
0016F4r 3  43 54 49 4F  
0016F8r 3  4E 20 57 41  
0016FFr 3  20 A0                .byte " ",160
001701r 3  20 4F 42 4A          .byte " OBJ0 , OBJ1 , OBJ2 , OBJ3 , OBJ4 , OBJ",181
001705r 3  30 20 2C 20  
001709r 3  4F 42 4A 31  
001729r 3  53 45 4C 45          .byte "SELECTION WAS:",160
00172Dr 3  43 54 49 4F  
001731r 3  4E 20 57 41  
001738r 3  20 A0                .byte " ",160
00173Ar 3               nummsg:
00173Ar 3  0D                   .byte 13
00173Br 3               chgfx:
00173Br 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
00173Fr 3  00 00 00 00  
001743r 3               bCol:
001743r 3  00                   .byte 0
001744r 3               bprop:
001744r 3  00                   .byte 0
001745r 3               sprgfx:
001745r 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
001749r 3  00 00 00 00  
00174Dr 3  00 00 00 00  
001765r 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
001769r 3  00 00 00 00  
00176Dr 3  00 00 00 00  
001785r 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
001789r 3  00 00 00 00  
00178Dr 3  00 00 00 00  
0017A5r 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0017A9r 3  00 00 00 00  
0017ADr 3  00 00 00 00  
0017C5r 3               frmlst:
0017C5r 3  00 01 01 00          .byte 0,1,1,0
0017C9r 3               scdat:
0017C9r 3  06 00                .word 6
0017CBr 3  FF 00 00 FF          .byte 255,0,0,255,0,228
0017CFr 3  00 E4        
0017D1r 3               numsc:
0017D1r 3  01                   .byte 1
0017D2r 3               nmedat:
0017D2r 3  42 00 58 50          .byte 66,0,88,80,255
0017D6r 3  FF           
0017D7r 3               NUMOBJ = 6
0017D7r 3               objdta:
0017D7r 3  FF FF FF FF          .byte 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,144,18,0,144,18
0017DBr 3  FF FF FF FF  
0017DFr 3  FF FF FF FF  
0017FEr 3  FF FF FF FF          .byte 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,2,0,144,38,0,144,38
001802r 3  FF FF FF FF  
001806r 3  FF FF FF FF  
001825r 3  FF FF FF FF          .byte 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,3,0,144,58,0,144,58
001829r 3  FF FF FF FF  
00182Dr 3  FF FF FF FF  
00184Cr 3  FF FF FF FF          .byte 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,4,0,144,78,0,144,78
001850r 3  FF FF FF FF  
001854r 3  FF FF FF FF  
001873r 3  FF FF FF FF          .byte 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,5,0,144,98,0,144,98
001877r 3  FF FF FF FF  
00187Br 3  FF FF FF FF  
00189Ar 3  FF FF FF FF          .byte 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,6,0,144,118,0,144,118
00189Er 3  FF FF FF FF  
0018A2r 3  FF FF FF FF  
0018C1r 3               font:
0018C1r 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
0018C5r 3  00 00 00 00  
0018C9r 3  00 30 30 30          .byte 0,48,48,48,48,0,48,0
0018CDr 3  30 00 30 00  
0018D1r 3  00 6C 6C 00          .byte 0,108,108,0,0,0,0,0
0018D5r 3  00 00 00 00  
0018D9r 3  00 6C FE 6C          .byte 0,108,254,108,108,254,108,0
0018DDr 3  6C FE 6C 00  
0018E1r 3  00 18 7E 78          .byte 0,24,126,120,126,30,126,24
0018E5r 3  7E 1E 7E 18  
0018E9r 3  00 E6 EC 18          .byte 0,230,236,24,48,110,206,0
0018EDr 3  30 6E CE 00  
0018F1r 3  00 30 78 30          .byte 0,48,120,48,126,204,126,0
0018F5r 3  7E CC 7E 00  
0018F9r 3  00 18 30 00          .byte 0,24,48,0,0,0,0,0
0018FDr 3  00 00 00 00  
001901r 3  00 0C 18 18          .byte 0,12,24,24,24,24,12,0
001905r 3  18 18 0C 00  
001909r 3  00 60 30 30          .byte 0,96,48,48,48,48,96,0
00190Dr 3  30 30 60 00  
001911r 3  00 00 3C 18          .byte 0,0,60,24,126,24,60,0
001915r 3  7E 18 3C 00  
001919r 3  00 00 18 18          .byte 0,0,24,24,126,24,24,0
00191Dr 3  7E 18 18 00  
001921r 3  00 00 00 00          .byte 0,0,0,0,0,24,24,48
001925r 3  00 18 18 30  
001929r 3  00 00 00 00          .byte 0,0,0,0,126,0,0,0
00192Dr 3  7E 00 00 00  
001931r 3  00 00 00 00          .byte 0,0,0,0,0,56,56,0
001935r 3  00 38 38 00  
001939r 3  00 00 06 0C          .byte 0,0,6,12,24,48,96,0
00193Dr 3  18 30 60 00  
001941r 3  00 7C CE DE          .byte 0,124,206,222,246,230,124,0
001945r 3  F6 E6 7C 00  
001949r 3  00 38 78 18          .byte 0,56,120,24,24,24,126,0
00194Dr 3  18 18 7E 00  
001951r 3  00 7C C6 06          .byte 0,124,198,6,124,192,254,0
001955r 3  7C C0 FE 00  
001959r 3  00 7C C6 1C          .byte 0,124,198,28,6,198,124,0
00195Dr 3  06 C6 7C 00  
001961r 3  00 18 38 78          .byte 0,24,56,120,216,254,24,0
001965r 3  D8 FE 18 00  
001969r 3  00 FE C0 FC          .byte 0,254,192,252,6,198,124,0
00196Dr 3  06 C6 7C 00  
001971r 3  00 7C C0 FC          .byte 0,124,192,252,198,198,124,0
001975r 3  C6 C6 7C 00  
001979r 3  00 FE 06 0C          .byte 0,254,6,12,24,48,48,0
00197Dr 3  18 30 30 00  
001981r 3  00 7C C6 7C          .byte 0,124,198,124,198,198,124,0
001985r 3  C6 C6 7C 00  
001989r 3  00 7C C6 C6          .byte 0,124,198,198,126,6,124,0
00198Dr 3  7E 06 7C 00  
001991r 3  00 00 00 30          .byte 0,0,0,48,0,0,48,0
001995r 3  00 00 30 00  
001999r 3  00 00 30 00          .byte 0,0,48,0,0,48,48,96
00199Dr 3  00 30 30 60  
0019A1r 3  00 00 0C 18          .byte 0,0,12,24,48,24,12,0
0019A5r 3  30 18 0C 00  
0019A9r 3  00 00 00 7E          .byte 0,0,0,126,0,126,0,0
0019ADr 3  00 7E 00 00  
0019B1r 3  00 00 30 18          .byte 0,0,48,24,12,24,48,0
0019B5r 3  0C 18 30 00  
0019B9r 3  00 7C C6 0C          .byte 0,124,198,12,24,0,24,0
0019BDr 3  18 00 18 00  
0019C1r 3  00 7C DE FE          .byte 0,124,222,254,254,192,124,0
0019C5r 3  FE C0 7C 00  
0019C9r 3  00 7C C6 C6          .byte 0,124,198,198,254,198,198,0
0019CDr 3  FE C6 C6 00  
0019D1r 3  00 FC C6 FC          .byte 0,252,198,252,198,198,252,0
0019D5r 3  C6 C6 FC 00  
0019D9r 3  00 7C C6 C0          .byte 0,124,198,192,192,198,124,0
0019DDr 3  C0 C6 7C 00  
0019E1r 3  00 F8 CC C6          .byte 0,248,204,198,198,204,248,0
0019E5r 3  C6 CC F8 00  
0019E9r 3  00 FE C0 FC          .byte 0,254,192,252,192,192,254,0
0019EDr 3  C0 C0 FE 00  
0019F1r 3  00 FE C0 FC          .byte 0,254,192,252,192,192,192,0
0019F5r 3  C0 C0 C0 00  
0019F9r 3  00 7C C6 C0          .byte 0,124,198,192,222,198,124,0
0019FDr 3  DE C6 7C 00  
001A01r 3  00 C6 C6 FE          .byte 0,198,198,254,198,198,198,0
001A05r 3  C6 C6 C6 00  
001A09r 3  00 7E 18 18          .byte 0,126,24,24,24,24,126,0
001A0Dr 3  18 18 7E 00  
001A11r 3  00 06 06 06          .byte 0,6,6,6,198,198,124,0
001A15r 3  C6 C6 7C 00  
001A19r 3  00 CC D8 F0          .byte 0,204,216,240,216,204,198,0
001A1Dr 3  D8 CC C6 00  
001A21r 3  00 C0 C0 C0          .byte 0,192,192,192,192,192,254,0
001A25r 3  C0 C0 FE 00  
001A29r 3  00 C6 EE FE          .byte 0,198,238,254,198,198,198,0
001A2Dr 3  C6 C6 C6 00  
001A31r 3  00 C6 E6 F6          .byte 0,198,230,246,222,206,198,0
001A35r 3  DE CE C6 00  
001A39r 3  00 7C C6 C6          .byte 0,124,198,198,198,198,124,0
001A3Dr 3  C6 C6 7C 00  
001A41r 3  00 FC C6 C6          .byte 0,252,198,198,252,192,192,0
001A45r 3  FC C0 C0 00  
001A49r 3  00 7C C6 C6          .byte 0,124,198,198,246,222,124,0
001A4Dr 3  F6 DE 7C 00  
001A51r 3  00 FC C6 C6          .byte 0,252,198,198,252,204,198,0
001A55r 3  FC CC C6 00  
001A59r 3  00 7C C0 7C          .byte 0,124,192,124,6,198,124,0
001A5Dr 3  06 C6 7C 00  
001A61r 3  00 FE 30 30          .byte 0,254,48,48,48,48,48,0
001A65r 3  30 30 30 00  
001A69r 3  00 C6 C6 C6          .byte 0,198,198,198,198,198,124,0
001A6Dr 3  C6 C6 7C 00  
001A71r 3  00 C6 C6 C6          .byte 0,198,198,198,198,108,56,0
001A75r 3  C6 6C 38 00  
001A79r 3  00 C6 C6 C6          .byte 0,198,198,198,198,254,108,0
001A7Dr 3  C6 FE 6C 00  
001A81r 3  00 C6 6C 38          .byte 0,198,108,56,56,108,198,0
001A85r 3  38 6C C6 00  
001A89r 3  00 86 CC 78          .byte 0,134,204,120,48,48,48,0
001A8Dr 3  30 30 30 00  
001A91r 3  00 FE 0C 18          .byte 0,254,12,24,48,96,254,0
001A95r 3  30 60 FE 00  
001A99r 3  00 1E 18 18          .byte 0,30,24,24,24,24,30,0
001A9Dr 3  18 18 1E 00  
001AA1r 3  00 00 C0 60          .byte 0,0,192,96,48,24,12,0
001AA5r 3  30 18 0C 00  
001AA9r 3  00 F0 30 30          .byte 0,240,48,48,48,48,240,0
001AADr 3  30 30 F0 00  
001AB1r 3  00 30 78 FC          .byte 0,48,120,252,48,48,48,0
001AB5r 3  30 30 30 00  
001AB9r 3  00 00 00 00          .byte 0,0,0,0,0,0,0,255
001ABDr 3  00 00 00 FF  
001AC1r 3  00 3C 66 F8          .byte 0,60,102,248,96,96,254,0
001AC5r 3  60 60 FE 00  
001AC9r 3  00 00 78 0C          .byte 0,0,120,12,124,204,124,0
001ACDr 3  7C CC 7C 00  
001AD1r 3  00 60 60 7C          .byte 0,96,96,124,102,102,124,0
001AD5r 3  66 66 7C 00  
001AD9r 3  00 00 3C 60          .byte 0,0,60,96,96,96,60,0
001ADDr 3  60 60 3C 00  
001AE1r 3  00 0C 0C 7C          .byte 0,12,12,124,204,204,124,0
001AE5r 3  CC CC 7C 00  
001AE9r 3  00 00 78 CC          .byte 0,0,120,204,248,192,124,0
001AEDr 3  F8 C0 7C 00  
001AF1r 3  00 1C 30 38          .byte 0,28,48,56,48,48,48,0
001AF5r 3  30 30 30 00  
001AF9r 3  00 00 7C CC          .byte 0,0,124,204,204,124,12,120
001AFDr 3  CC 7C 0C 78  
001B01r 3  00 C0 C0 F8          .byte 0,192,192,248,204,204,204,0
001B05r 3  CC CC CC 00  
001B09r 3  00 30 00 70          .byte 0,48,0,112,48,48,120,0
001B0Dr 3  30 30 78 00  
001B11r 3  00 0C 00 0C          .byte 0,12,0,12,12,12,108,56
001B15r 3  0C 0C 6C 38  
001B19r 3  00 60 78 70          .byte 0,96,120,112,112,120,108,0
001B1Dr 3  70 78 6C 00  
001B21r 3  00 30 30 30          .byte 0,48,48,48,48,48,28,0
001B25r 3  30 30 1C 00  
001B29r 3  00 00 F8 FC          .byte 0,0,248,252,252,252,252,0
001B2Dr 3  FC FC FC 00  
001B31r 3  00 00 F8 CC          .byte 0,0,248,204,204,204,204,0
001B35r 3  CC CC CC 00  
001B39r 3  00 00 78 CC          .byte 0,0,120,204,204,204,120,0
001B3Dr 3  CC CC 78 00  
001B41r 3  00 00 F8 CC          .byte 0,0,248,204,204,248,192,192
001B45r 3  CC F8 C0 C0  
001B49r 3  00 00 7C CC          .byte 0,0,124,204,204,124,12,14
001B4Dr 3  CC 7C 0C 0E  
001B51r 3  00 00 3C 60          .byte 0,0,60,96,96,96,96,0
001B55r 3  60 60 60 00  
001B59r 3  00 00 78 C0          .byte 0,0,120,192,120,12,248,0
001B5Dr 3  78 0C F8 00  
001B61r 3  00 30 78 30          .byte 0,48,120,48,48,48,28,0
001B65r 3  30 30 1C 00  
001B69r 3  00 00 CC CC          .byte 0,0,204,204,204,204,120,0
001B6Dr 3  CC CC 78 00  
001B71r 3  00 00 CC CC          .byte 0,0,204,204,120,120,48,0
001B75r 3  78 78 30 00  
001B79r 3  00 00 CC FC          .byte 0,0,204,252,252,252,120,0
001B7Dr 3  FC FC 78 00  
001B81r 3  00 00 CC 78          .byte 0,0,204,120,48,120,204,0
001B85r 3  30 78 CC 00  
001B89r 3  00 00 CC CC          .byte 0,0,204,204,204,124,12,120
001B8Dr 3  CC 7C 0C 78  
001B91r 3  00 00 FC 18          .byte 0,0,252,24,48,96,252,0
001B95r 3  30 60 FC 00  
001B99r 3  00 1E 18 70          .byte 0,30,24,112,24,24,30,0
001B9Dr 3  18 18 1E 00  
001BA1r 3  00 18 18 18          .byte 0,24,24,24,24,24,24,0
001BA5r 3  18 18 18 00  
001BA9r 3  00 F0 30 1C          .byte 0,240,48,28,48,48,240,0
001BADr 3  30 30 F0 00  
001BB1r 3  00 3C 78 00          .byte 0,60,120,0,0,0,0,0
001BB5r 3  00 00 00 00  
001BB9r 3  7C C6 BB E3          .byte 124,198,187,227,227,187,198,124
001BBDr 3  E3 BB C6 7C  
001BC1r 3               jtab:
001BC1r 3  63                   .byte 99
001BC2r 3  65 14 51 10  keys:   .byte 101,20,81,16,48,68,52,112,0,113,1
001BC6r 3  30 44 34 70  
001BCAr 3  00 71 01     
001BCDr 3               
001BCDr 2               
001BCDr 1               	.include "lib.inc"
001BCDr 2               ;----------------------------------------------------------------------
001BCDr 2               ; VIC20 Platform Specific functions
001BCDr 2               ;----------------------------------------------------------------------
001BCDr 2               
001BCDr 2               ;============================================================
001BCDr 2               ; PLATFORM VARIABLES
001BCDr 2               ;============================================================
001BCDr 2               ;
001BCDr 2               ; Memory map:
001BCDr 2               ;
001BCDr 2               ;	$0000-$01ff	 0.5kB	CPU WS
001BCDr 2               ;	$0200-$03ff	 0.5kB	VIDEO RAM
001BCDr 2               ;	$0400-$0fff	 3,0kB	RAM
001BCDr 2               ;	$1000-$1fff	 4,0kB	CHAR RAM
001BCDr 2               ;	$2000-$7fff	24,0kB	RAM
001BCDr 2               ;	$8000-$8fff	 4,0kB	CHAR ROM
001BCDr 2               ;	$9000-$93ff	 1,0kB	VIC VIA's
001BCDr 2               ;	$9600-$97ff	 1,0kB	COLOUR RAM
001BCDr 2               ;	$9800-$9fff	 2,0kB	I/O
001BCDr 2               ;	$a000-$bfff	 8,0kB	RAM
001BCDr 2               ;	$c000-$dfff	 8,0kB	BASIC ROM
001BCDr 2               ;	$e000-$ffff	 8,0kB	KERNAL ROM
001BCDr 2               ;
001BCDr 2               ; Keyboard matrix:
001BCDr 2               ;                          	  $9121
001BCDr 2               ;          $9120	b7  b6  b5  b4  b3  b2  b1  b0
001BCDr 2               ; 	127-0111 1111 	F7  Hom  -   0   8   6   4   2
001BCDr 2               ;               ASCII   ??  ??  45  48  56  54  52  50
001BCDr 2               ;                 VIC   07  06  05  04  03  02  01  00
001BCDr 2               ;
001BCDr 2               ; 	191-1011 1111 	F5       @   O   U   T   E   Q
001BCDr 2               ;               ASCII   ??  ??  64  79  85  84  69  81
001BCDr 2               ;                 VIC   17  16  15  14  13  12  11  10
001BCDr 2               ;
001BCDr 2               ; 	223-1101 1111 	F3   =   :   K   H   F   S  Com
001BCDr 2               ;               ASCII   ??  61  58  75  72  70  83  ??
001BCDr 2               ;                 VIC   27  26  25  24  23  22  21  20
001BCDr 2               ;
001BCDr 2               ; 	239-1110 1111 	F1  RSh  .   M   B   C   Z  Spc
001BCDr 2               ;               ASCII   ??  ??  46  77  66  67  90  32
001BCDr 2               ;                 VIC   37  36  35  34  33  32  31  30
001BCDr 2               ;
001BCDr 2               ; 	247-1111 0111	Cur  /   ,   N   V   X  LSh Run
001BCDr 2               ;               ASCII   ??  47  44  78  86  88  ??  ??
001BCDr 2               ;                 VIC   47  46  45  44  43  42  41  40
001BCDr 2               ;
001BCDr 2               ; 	251-1111 1011	Cur  ;   L   J   G   D   A  Ctr
001BCDr 2               ;               ASCII   ??  59  76  74  71  68  65  ??
001BCDr 2               ;                 VIC   57  56  55  54  53  52  51  50
001BCDr 2               ;
001BCDr 2               ; 	253-1111 1101	Ret  *   P   I   Y   R   W
001BCDr 2               ;               ASCII   13  42  80  73  89  82  87
001BCDr 2               ;                 VIC   67  66  65  64  63  62  61  60
001BCDr 2               ;
001BCDr 2               ; 	254-1111 1110	Del Pnd  +   9   7   5   3   1
001BCDr 2               ;               ASCII   08  ??  43  57  55  53  51  49
001BCDr 2               ;                 VIC   77  76  75  74  73  72  71  70
001BCDr 2               ;
001BCDr 2               ;	 P =$65,O=$14,A=$51,Q=$10
001BCDr 2               ;	SPC=$30,N=$44,M=$34
001BCDr 2               ;	 1 =$70,2=$00,3=$71,4=$01
001BCDr 2               ;
001BCDr 2               ; Joysticks:
001BCDr 2               ;
001BCDr 2               ;               b7    b6    b5    b4    b3    b2    b1    b0
001BCDr 2               ;	$9111	-     -     Fire  Left  Down  Up    -     -
001BCDr 2               ;	$9120	Right -     -     -     -     -     -     -
001BCDr 2               ;
001BCDr 2               ;	$9122	DDRB = Data Direction Register port $9120
001BCDr 2               ;               0 = input, 1 = output
001BCDr 2               ;		Bit7 should be 0 to read joystick $9120
001BCDr 2               ;
001BCDr 2               ; Video registers:
001BCDr 2               ;
001BCDr 2               ;	$9000	horizontal centering
001BCDr 2               ;		bits 0-6 horizontal centering
001BCDr 2               ;		bit  7 sets interlace scan
001BCDr 2               ;	$9001	vertical centering
001BCDr 2               ;	$9002	set # of columns
001BCDr 2               ;		bits 0-6 set # of columns
001BCDr 2               ;		bit 7 is part of video matrix address
001BCDr 2               ;	$9003	set # of rows
001BCDr 2               ;		bit 0 sets 8x8 or 16x8 chars
001BCDr 2               ;		bits 1-6 set # of rows
001BCDr 2               ;	$9005	start of character memory
001BCDr 2               ;		bits 0-3 start of character memory (default = 0)
001BCDr 2               ;		bits 4-7 is rest of video address (default= F)
001BCDr 2               ;		BITS 3,2,1,0 CM startinq address
001BCDr 2               ;			     HEX   DEC
001BCDr 2               ;		0000   ROM   8000  32768
001BCDr 2               ;		0001	     8400  33792
001BCDr 2               ;		0010	     8800  34816
001BCDr 2               ;		0011	     8C00  35840
001BCDr 2               ;		1000   RAM   0000  0000
001BCDr 2               ;		1001  xxxx
001BCDr 2               ;		1010  xxxx   unavail.
001BCDr 2               ;		1011  xxxx
001BCDr 2               ;		1100	     1000  4096
001BCDr 2               ;		1101	     1400  5120
001BCDr 2               ;		1110	     1800  6144
001BCDr 2               ;		1111	     1C00  7168
001BCDr 2               ;	$900f	Screen and border color register
001BCDr 2               ;		bits 4-7 select background color
001BCDr 2               ;		bits 0-2 select border color
001BCDr 2               ;		bit 3 selects inverted or normal mode
001BCDr 2               ;
001BCDr 2               
001BCDr 2               ; VIC constants
001BCDr 2               
001BCDr 2               ;	scrchar 	= 22				; char/line
001BCDr 2               ;	scrline		= 22				; lines/screen
001BCDr 2               	ScreenSize	= ScrWidth * ScrHeight * 8	; Screen size bytes
001BCDr 2               	ScreenRowBytes	= ScrWidth * 16			; bytes/line
001BCDr 2               	SpriteMaxY	= 161				; maxlines - 16 + 1
001BCDr 2               
001BCDr 2               ; VIC variables:
001BCDr 2               
001BCDr 2  00           	fontcol:	.byte 0		; Frontcolour text
001BCEr 2               
001BCEr 2               ; Addresses
001BCEr 2               
001BCEr 2               	MapAddr		= $400		; RAM
001BCEr 2               	ScreenAddr	= $0200		; VIDEO RAM
001BCEr 2               	CharAddress	= $1000		; CHAR RAM
001BCEr 2               	Reg0		= $9000		; Horizontal centering
001BCEr 2               	Reg1		= $9001		; Vertical centering
001BCEr 2               	Reg2		= $9002		; Set # of columns
001BCEr 2               	Reg3		= $9003		; Set # of rows
001BCEr 2               	Reg4		= $9004		; Vsync signal
001BCEr 2               	Reg5		= $9005		; Start of character memory
001BCEr 2               	RegE		= $900e		; Colour and auxcolour register
001BCEr 2               	RegF		= $900f		; Screen and border color register
001BCEr 2               	JoyAddr1	= $9111		; Joystick address 1
001BCEr 2               	KeyColAddr	= $9120		; Keyboard column (write)
001BCEr 2               	JoyAddr2	= $9120		; Joystick address 2
001BCEr 2               	KeyRowAddr	= $9121		; Keyboard row (read)
001BCEr 2               	DDRB		= $9122		; Bit7 must be 0 for joystick read
001BCEr 2               	Timer1_Low  	= $9114		; Timer 1 low byte
001BCEr 2               	Timer1_High 	= $9115		; Timer 1 high byte
001BCEr 2               	Timer2_Low  	= $9118		; Timer 2 low byte
001BCEr 2               	Timer2_High 	= $9119		; Timer 2 high byte
001BCEr 2               	AUX		= $911b		; Auxiliary control register
001BCEr 2               	IFR		= $911d		; Interrupt Flag Register
001BCEr 2               	IER		= $911e		; Interrupt Enable Register
001BCEr 2               	ColorAttr	= $9600		; Color attributes
001BCEr 2               
001BCEr 2               ;----------------------------------------------------------------------
001BCEr 2               ; VIC20 video hardware fns
001BCEr 2               ;----------------------------------------------------------------------
001BCEr 2               
001BCEr 2               init:
001BCEr 2               
001BCEr 2               ; Disable interrupts
001BCEr 2               
001BCEr 2  A9 7F        	lda #$7f
001BD0r 2  8D 1E 91     	sta $911e
001BD3r 2  8D 2D 91     	sta $912d
001BD6r 2  8D 2E 91     	sta $912e
001BD9r 2               
001BD9r 2               ; Set audio volume to max
001BD9r 2  A9 0F        	lda #$0f
001BDBr 2  8D 0E 90     	sta $900e
001BDEr 2               
001BDEr 2               ; Init screen for NTSC
001BDEr 2               ; this sets the background and border color of the screen
001BDEr 2               ; in this case border black and background black
001BDEr 2               
001BDEr 2  A9 18        	lda #%00011000
001BE0r 2  8D 0F 90     	sta RegF
001BE3r 2               
001BE3r 2               ; Reset fontcolor
001BE3r 2  A9 00        	lda #0		; Black
001BE5r 2  8D rr rr     	sta fontcol
001BE8r 2               
001BE8r 2               
001BE8r 2               ; max num of columns 24
001BE8r 2               
001BE8r 2  AD 02 90     	lda Reg2
001BEBr 2  29 80        	and #%10000000
001BEDr 2  09 16        	ora #ScrWidth
001BEFr 2  8D 02 90     	sta Reg2
001BF2r 2               
001BF2r 2               ; max num of lines (mult by 2 - 24) for 8x8 chars
001BF2r 2               ; no multiply for 8x16 chars
001BF2r 2               
001BF2r 2  AD 03 90     	lda Reg3
001BF5r 2  29 81        	and #%10000001
001BF7r 2  09 16        	ora #ScrWidth		; number of rows multipled by two
001BF9r 2  8D 03 90     	sta Reg3
001BFCr 2               
001BFCr 2               ; horizontal and vertical position must be set for
001BFCr 2               ; non standard screen resolution (standard 22x23)
001BFCr 2               ; same games even allow the user to change them
001BFCr 2               ; these values are for PAL for NTSC should be different
001BFCr 2               ; move horizontal position in the screen
001BFCr 2               
001BFCr 2  AD 00 90     	lda Reg0
001BFFr 2  29 80        	and #%10000000
001C01r 2  09 04        	ora #CentreX
001C03r 2  8D 00 90     	sta Reg0
001C06r 2               
001C06r 2               ; move vertical position in the screen
001C06r 2               
001C06r 2  A9 1B        	lda #CentreY
001C08r 2  8D 01 90     	sta Reg1
001C0Br 2               
001C0Br 2               ; Set screem memory to $200
001C0Br 2               ; bit 7 on $9002 has to be set
001C0Br 2               
001C0Br 2  AD 02 90     	lda Reg2
001C0Er 2  09 80        	ora #%10000000
001C10r 2  8D 02 90     	sta Reg2
001C13r 2               
001C13r 2               ; Set character data pointer to CHAR RAM at $1000
001C13r 2               ; bit 7 on $9005 has always to be set
001C13r 2               ; (based on compute - mapping the vic book)
001C13r 2               ; color ram goes to 9600
001C13r 2               
001C13r 2  AD 05 90     	lda Reg5
001C16r 2  29 0C        	and #%00001100
001C18r 2  09 8C        	ora #%10001100
001C1Ar 2  8D 05 90     	sta Reg5
001C1Dr 2               
001C1Dr 2               ; This set the char size to 8x16
001C1Dr 2               
001C1Dr 2  AD 03 90     	lda Reg3
001C20r 2  09 01        	ora #%00000001
001C22r 2  8D 03 90     	sta Reg3
001C25r 2               
001C25r 2               ; Init screencharacters
001C25r 2               ; Fill screen with characters from left to right, up to down
001C25r 2               
001C25r 2  A2 00        	ldx #0
001C27r 2  A0 00        	ldy #0
001C29r 2               scrinit:
001C29r 2  8A           	txa
001C2Ar 2  9D 00 02     	sta ScreenAddr,x
001C2Dr 2  98           	tya
001C2Er 2  9D 00 96     	sta ColorAttr,x
001C31r 2  E8           	inx
001C32r 2  E0 F2        	cpx#242
001C34r 2  D0 F3        	bne scrinit
001C36r 2               
001C36r 2               
001C36r 2               ; Reset fontcolor
001C36r 2               
001C36r 2  A9 00        	lda #0			; Black
001C38r 2  8D rr rr     	sta fontcol
001C3Br 2               
001C3Br 2               ; Init VIA timer for timeout 1/25 sec
001C3Br 2               
001C3Br 2  A9 E0        	lda #$e0		; T1 continuous
001C3Dr 2  8D 1B 91     	sta AUX
001C40r 2  A9 7F        	lda #$7f		; No int
001C42r 2  8D 1E 91     	sta IER
001C45r 2  A9 00        	lda #0
001C47r 2  8D 1D 91     	sta IFR			; Clear interrupt flags
001C4Ar 2  A9 A8        	lda #<timervalue	; Timer 1/25 sec
001C4Cr 2  8D 14 91     	sta Timer1_Low
001C4Fr 2  A9 61        	lda #>timervalue
001C51r 2  8D 15 91     	sta Timer1_High
001C54r 2               
001C54r 2  60           	rts
001C55r 2               
001C55r 2               ;========================================================
001C55r 2               ; KEY AND JOYSTICK ROUTINES
001C55r 2               ;--------------------------------------------------------
001C55r 2               ; Keys
001C55r 2               ;
001C55r 2               ; Out: joyval=x65FUDLR (bit cleared if key pressed)
001C55r 2               ;             ||||||||
001C55r 2               ;             |||||||+> Right    KEY 0  - X
001C55r 2               ;             ||||||+-> Left     KEY 1  - Z
001C55r 2               ;             |||||+--> Down     KEY 2  - .
001C55r 2               ;             ||||+---> Up       KEY 3  - ;
001C55r 2               ;             |||+----> Fire1    KEY 4  - SPC
001C55r 2               ;             ||+-----> Fire2    KEY 5  - Q
001C55r 2               ;             |+------> Fire3    KEY 6  - P
001C55r 2               ;             +-------> Not used
001C55r 2               ;
001C55r 2               ;                       Option1  KEY 7  - 1
001C55r 2               ;                       Option2  KEY 8  - 2
001C55r 2               ;                       Option3  KEY 9  - 3
001C55r 2               ;                       Option4  KEY 10 - 4
001C55r 2               ;--------------------------------------------------------
001C55r 2               
001C55r 2               ;--------------------------------------------------------
001C55r 2               ; PRSKEY
001C55r 2               ;
001C55r 2               ; Wait for keypress.
001C55r 2               ;--------------------------------------------------------
001C55r 2               
001C55r 2               prskey:
001C55r 2  98           	tya
001C56r 2  48           	pha
001C57r 2               prsloop:
001C57r 2  20 rr rr     	jsr vsync
001C5Ar 2  20 rr rr     	jsr readkey
001C5Dr 2  C0 FF        	cpy #255
001C5Fr 2  F0 F6        	beq prsloop		; wait until key pressed
001C61r 2               
001C61r 2               prsrelease:
001C61r 2  20 rr rr     	jsr vsync
001C64r 2  20 rr rr     	jsr readkey
001C67r 2  C0 FF        	cpy #255
001C69r 2  D0 F6        	bne prsrelease		; wait until key released
001C6Br 2               
001C6Br 2  20 rr rr     	jsr joykey
001C6Er 2               
001C6Er 2  68           	pla
001C6Fr 2  A8           	tay
001C70r 2  60           	rts
001C71r 2               
001C71r 2               ;--------------------------------------------------------
001C71r 2               ; KTEST
001C71r 2               ;
001C71r 2               ; Keyboard test routine with key in A.
001C71r 2               ; Scan key and clear carry if key pressed
001C71r 2               ;--------------------------------------------------------
001C71r 2               
001C71r 2               ktest:
001C71r 2  85 rr        	sta z80_a		; save key
001C73r 2               
001C73r 2  4A           	lsr a
001C74r 2  4A           	lsr a
001C75r 2  4A           	lsr a
001C76r 2  4A           	lsr a
001C77r 2  AA           	tax
001C78r 2  BD rr rr     	lda colmask,x
001C7Br 2  8D 20 91     	sta KeyColAddr		; set row
001C7Er 2               
001C7Er 2  A5 rr        	lda z80_a
001C80r 2  29 0F        	and #$0f
001C82r 2  AA           	tax			; get column
001C83r 2               
001C83r 2  AD 21 91     	lda KeyRowAddr		; read column
001C86r 2  3D rr rr     	and keymask,x		; check if key pressed
001C89r 2  F0 02        	beq pressed		; Skip if pressed
001C8Br 2  38           	sec			; key not pressed
001C8Cr 2  60           	rts
001C8Dr 2               pressed:
001C8Dr 2  18           	clc			; key pressed
001C8Er 2  60           	rts
001C8Fr 2               
001C8Fr 2  7F BF DF EF  colmask:	.byte 127,191,223,239,247,251,253,254
001C93r 2  F7 FB FD FE  
001C97r 2  01 02 04 08  keymask:	.byte $01,$02,$04,$08,$10,$20,$40,$80
001C9Br 2  10 20 40 80  
001C9Fr 2               
001C9Fr 2               ;---------------------------------------------------------------
001C9Fr 2               ; KGET
001C9Fr 2               ;
001C9Fr 2               ; Read keyboard matrix if a key is pressed.
001C9Fr 2               ; Return A = high nibble=row and low nibble=col
001C9Fr 2               ;---------------------------------------------------------------
001C9Fr 2               
001C9Fr 2               kget:
001C9Fr 2  86 rr        	stx xtmp		; Save x-reg
001CA1r 2               kget0:
001CA1r 2  A2 00        	ldx #0			; reset row
001CA3r 2               kget1:
001CA3r 2  BD rr rr     	lda colmask,x		; Get mask
001CA6r 2  8D 20 91     	sta KeyColAddr		; Set row
001CA9r 2  AD 21 91     	lda KeyRowAddr		; Read columns
001CACr 2  85 rr        	sta tmp			; Save colums
001CAEr 2  C9 FF        	cmp #$ff		; Key pressed?
001CB0r 2  D0 08        	bne kget2		; Yes, skip
001CB2r 2  E8           	inx			; Next row
001CB3r 2  E0 08        	cpx #8			; All rows scanned?
001CB5r 2  D0 EC        	bne kget1		; No, repeat
001CB7r 2  4C rr rr     	jmp kget0		; No key pressed, a=$ff
001CBAr 2               kget2:
001CBAr 2  A0 00        	ldy #0			; Reset column
001CBCr 2               kget3:
001CBCr 2  46 rr        	lsr tmp			; Test bit
001CBEr 2  90 04        	bcc kget4		; If clear, key pressed
001CC0r 2  C8           	iny			; Next column
001CC1r 2  4C rr rr     	jmp kget3		; Repeat
001CC4r 2               kget4:
001CC4r 2  86 rr        	stx tmp			; Get row
001CC6r 2  06 rr        	asl tmp			; Make high nibble
001CC8r 2  06 rr        	asl tmp
001CCAr 2  06 rr        	asl tmp
001CCCr 2  06 rr        	asl tmp
001CCEr 2  98           	tya			; Get column
001CCFr 2  18           	clc
001CD0r 2  65 rr        	adc tmp			; Add row as low nibble
001CD2r 2  85 rr        	sta tmp
001CD4r 2               kget5:
001CD4r 2  AD 21 91     	lda KeyRowAddr		; Read columns
001CD7r 2  C9 FF        	cmp #$ff
001CD9r 2  D0 F9        	bne kget5
001CDBr 2               
001CDBr 2  A5 rr        	lda tmp			; Return keycode
001CDDr 2  A6 rr        	ldx xtmp		; Restore X-reg
001CDFr 2  60           	rts			; Return
001CE0r 2               
001CE0r 2               ;-------------------------------------------------------------
001CE0r 2               ; READKEY
001CE0r 2               ;
001CE0r 2               ; Check keyboard matrix if a key is pressed
001CE0r 2               ; Return keymask in Y
001CE0r 2               ;-------------------------------------------------------------
001CE0r 2               
001CE0r 2               readkey:
001CE0r 2  A9 FF        	lda #$ff		; Keymask
001CE2r 2  85 rr        	sta tmp
001CE4r 2  A2 07        	ldx #7
001CE6r 2               scanrow:
001CE6r 2  BD rr rr     	lda colmask,x
001CE9r 2  8D 20 91     	sta KeyColAddr		; set row
001CECr 2  AD 21 91     	lda KeyRowAddr		; read column
001CEFr 2  25 rr        	and tmp			; Reset bit is key pressed
001CF1r 2  85 rr        	sta tmp
001CF3r 2  CA           	dex
001CF4r 2  10 F0        	bpl scanrow
001CF6r 2  A5 rr        	lda tmp
001CF8r 2  A8           	tay
001CF9r 2  60           	rts
001CFAr 2               
001CFAr 2               ;-------------------------------------------------------------
001CFAr 2               ; JOY1SCAN
001CFAr 2               ;
001CFAr 2               ; Initializes joystick
001CFAr 2               ;-------------------------------------------------------------
001CFAr 2               
001CFAr 2               joyinit:
001CFAr 2  60           	rts
001CFBr 2               
001CFBr 2               ;-------------------------------------------------------------
001CFBr 2               ; JOY1SCAN
001CFBr 2               ;
001CFBr 2               ; Scan joystick1 and return key in z80_e
001CFBr 2               ; Up, down, left, right and fire are read from the joystick
001CFBr 2               ; Fire2 and fire3 are read from the keyboard
001CFBr 2               ;-------------------------------------------------------------
001CFBr 2               
001CFBr 2               joy1scan:
001CFBr 2  A9 FF        	lda #$ff
001CFDr 2  85 rr        	sta z80_e
001CFFr 2               
001CFFr 2  AD 11 91     	lda JoyAddr1		; Read joystick input
001D02r 2  4A           	lsr a
001D03r 2  4A           	lsr a
001D04r 2               
001D04r 2  4A           	lsr a
001D05r 2  26 rr        	rol z80_e		; Up
001D07r 2  4A           	lsr a
001D08r 2  26 rr        	rol z80_e		; Down
001D0Ar 2  4A           	lsr a
001D0Br 2  26 rr        	rol z80_e		; Left
001D0Dr 2               
001D0Dr 2  A9 7F        	lda #%01111111
001D0Fr 2  8D 22 91     	sta DDRB		; Bit7 = input joystick b7
001D12r 2  AD 20 91     	lda JoyAddr2
001D15r 2  0A           	asl a
001D16r 2  26 rr        	rol z80_e		; Right
001D18r 2  A9 FF        	lda #%11111111
001D1Ar 2  8D 22 91     	sta DDRB		; Reset
001D1Dr 2               
001D1Dr 2  AD 11 91     	lda JoyAddr1
001D20r 2  29 20        	and #%00100000
001D22r 2  D0 06        	bne :+
001D24r 2  A5 rr        	lda z80_e
001D26r 2  29 EF        	and #%11101111		; Fire
001D28r 2  85 rr        	sta z80_e
001D2Ar 2               :
001D2Ar 2  AD rr rr     	lda keys+6		; Scan keys for Fire3
001D2Dr 2  20 rr rr     	jsr ktest
001D30r 2  B0 06        	bcs :+
001D32r 2  A5 rr        	lda z80_e
001D34r 2  29 BF        	and #%10111111
001D36r 2  85 rr        	sta z80_e
001D38r 2               :
001D38r 2  AD rr rr     	lda keys+5		; Scan keys for Fire2
001D3Br 2  20 rr rr     	jsr ktest
001D3Er 2  B0 06        	bcs :+
001D40r 2  A5 rr        	lda z80_e
001D42r 2  29 DF        	and #%11011111
001D44r 2  85 rr        	sta z80_e
001D46r 2               :
001D46r 2  60           	rts
001D47r 2               
001D47r 2               ;-------------------------------------------------------------
001D47r 2               ; JOY2SCAN
001D47r 2               ;
001D47r 2               ; TODO, Scan joystick2 and return key in z80_e
001D47r 2               ;-------------------------------------------------------------
001D47r 2               
001D47r 2               joy2scan:
001D47r 2  60           	rts
001D48r 2               
001D48r 2               
001D48r 2               
001D48r 2               ;========================================================
001D48r 2               ; HARDWARE DEPENDING ROUTINES
001D48r 2               ;========================================================
001D48r 2               
001D48r 2               ;----------------------------------------------------
001D48r 2               ; DELAY
001D48r 2               ;
001D48r 2               ; Delay routine A * 1/50 sec
001D48r 2               ;----------------------------------------------------
001D48r 2               
001D48r 2               delay:
001D48r 2  85 rr        	sta xtmp		; set delaycounter
001D4Ar 2               del_loop:
001D4Ar 2  AD 04 90     	lda Reg4
001D4Dr 2  D0 FB        	bne del_loop		; wait for flyback (1/60 sec)
001D4Fr 2               
001D4Fr 2  A0 D0        	ldy #208		; wait 208 x 16 = 3328 usec
001D51r 2               delay1:
001D51r 2  61 80        	adc ($80,x)		;	 6 usec
001D53r 2  61 80        	adc ($80,x)		;	 6 usec
001D55r 2  88           	dey			;	 2 usec
001D56r 2  D0 F9        	bne delay1		;	 2 usec
001D58r 2  EA           	nop			; 2 usec
001D59r 2  EA           	nop			; 2 usec
001D5Ar 2               				; tot: 20000 usec
001D5Ar 2  C6 rr        	dec xtmp		; Next 1/50 sec delay
001D5Cr 2  D0 EC        	bne del_loop
001D5Er 2  60           	rts
001D5Fr 2               
001D5Fr 2               ;-------------------------------------------------------------
001D5Fr 2               ; VSYNC
001D5Fr 2               ;
001D5Fr 2               ; - read joystick/keyboard
001D5Fr 2               ; - sync framerate with timer 25Hz
001D5Fr 2               ; - handle shrapnel every even frame
001D5Fr 2               ; - handle sound
001D5Fr 2               ;-------------------------------------------------------------
001D5Fr 2               
001D5Fr 2               vsync:
001D5Fr 2  48           	pha			; save registers
001D60r 2  98           	tya
001D61r 2  48           	pha
001D62r 2  8A           	txa
001D63r 2  48           	pha
001D64r 2               
001D64r 2               ; Read joystick/keyboard.
001D64r 2               
001D64r 2  20 rr rr     	jsr joykey
001D67r 2               
001D67r 2               ; Sync framerate with timer 25Hz
001D67r 2               
001D67r 2  A9 40        	lda #$40		; set Timer1 expired bit
001D69r 2               vsync1:
001D69r 2  2C 1D 91     	bit IFR			; check Interrupt Flag Register
001D6Cr 2  F0 FB        	beq vsync1		; wait if timer not expired
001D6Er 2  AD 14 91     	lda Timer1_Low		; clear Timer interrupt
001D71r 2               
001D71r 2               ; Handle shrapnel every even frame
001D71r 2               
001D71r 2  A5 rr        	lda clock		; get clock
001D73r 2  29 01        	and #1			; 2 frames expired
001D75r 2  D0 03        	bne:+
001D77r 2  20 rr rr     	jsr proshr		; process shrapnel
001D7Ar 2               :
001D7Ar 2               
001D7Ar 2               ; Handle sound
001D7Ar 2               
001D7Ar 2  AD rr rr         lda sndtyp
001D7Dr 2  F0 33            beq sndskip
001D7Fr 2               
001D7Fr 2               sndloop:
001D7Fr 2  AC rr rr         ldy sndtyp
001D82r 2               sndwait:
001D82r 2  88               dey
001D83r 2  D0 FD            bne sndwait
001D85r 2               
001D85r 2  AD rr rr         lda sndtyp
001D88r 2  30 11            bmi crashaudio
001D8Ar 2               
001D8Ar 2               
001D8Ar 2               beepaudio:
001D8Ar 2                   ; enable sound on channel 2
001D8Ar 2                   ; add 128 because sound is in range 128-255
001D8Ar 2  4A               lsr
001D8Br 2  A9 FF            lda #$ff
001D8Dr 2  38               sec
001D8Er 2  ED rr rr         sbc sndtyp
001D91r 2  4A               lsr
001D92r 2  4A               lsr
001D93r 2  09 C0            ora #%11000000
001D95r 2  8D 0C 90         sta $900c
001D98r 2               
001D98r 2  4C rr rr         jmp endaudiotype
001D9Br 2               crashaudio:
001D9Br 2  A9 FF            lda #$ff
001D9Dr 2  38               sec
001D9Er 2  ED rr rr         sbc sndtyp
001DA1r 2  09 80            ora #%10000000
001DA3r 2  8D 0D 90         sta $900d
001DA6r 2               
001DA6r 2               endaudiotype:
001DA6r 2               
001DA6r 2  CE rr rr         dec sndtyp
001DA9r 2  F0 07            beq sndskip
001DABr 2  C9 80            cmp #128
001DADr 2  F0 03            beq sndskip
001DAFr 2  4C rr rr         jmp sndloop
001DB2r 2               sndskip:
001DB2r 2                   ; disable sound
001DB2r 2  A9 00            lda #$00
001DB4r 2  8D 0C 90         sta $900c
001DB7r 2  8D 0D 90         sta $900d
001DBAr 2               
001DBAr 2  68               pla
001DBBr 2  AA               tax
001DBCr 2  68               pla
001DBDr 2  A8               tay
001DBEr 2  68               pla
001DBFr 2  60               rts
001DC0r 2  00           sndtyp:		.byte 0		; Beep sound parameter
001DC1r 2               
001DC1r 2               
001DC1r 2               
001DC1r 2               
001DC1r 2               
001DC1r 2               
001DC1r 2               ;========================================================
001DC1r 2               ; SPRITE HANDLING ROUTINES
001DC1r 2               ;========================================================
001DC1r 2               
001DC1r 2               ;----------------------------------------------------
001DC1r 2               ; SPRITE
001DC1r 2               ;
001DC1r 2               ; Draw object sprite
001DC1r 2               ;----------------------------------------------------
001DC1r 2               
001DC1r 2               .if oflag
001DC1r 2               sprite:
001DC1r 2  86 rr        	stx xtmp		; Save X-reg
001DC3r 2  20 rr rr     	jsr scadd 		; get screen address in scraddr.
001DC6r 2               
001DC6r 2  A5 rr        	lda dispx 		; x position.
001DC8r 2  29 07        	and #7 			; position straddling cells.
001DCAr 2  85 rr        	sta z80_b		; store in b register.
001DCCr 2               
001DCCr 2  A5 rr        	lda z80_l		; store sprite graphic address.
001DCEr 2  8D rr rr     	sta sprit1+1
001DD1r 2  8D rr rr     	sta sprit2+1
001DD4r 2  A5 rr        	lda z80_h
001DD6r 2  8D rr rr     	sta sprit1+2
001DD9r 2  8D rr rr     	sta sprit2+2
001DDCr 2               
001DDCr 2  A2 00        	ldx #0			; pixel height.
001DDEr 2  A0 00        	ldy #0
001DE0r 2               sprit1:
001DE0r 2  BD rr rr     	lda objdta,x		; fetch first byte.
001DE3r 2  85 rr        	sta spr
001DE5r 2  E8           	inx
001DE6r 2               sprit2:
001DE6r 2  BD rr rr     	lda objdta,x
001DE9r 2  85 rr        	sta spr+1
001DEBr 2               
001DEBr 2  A9 00        	lda #0
001DEDr 2  85 rr        	sta spr+2
001DEFr 2  20 rr rr     	jsr sprit7		; shift sprite
001DF2r 2               
001DF2r 2  A5 rr        	lda spr			; fetch graphic.
001DF4r 2  A0 00        	ldy #0			; _BEEB
001DF6r 2  51 rr        	eor (scraddr),y		; merge with screen image.
001DF8r 2  91 rr        	sta (scraddr),y		; write to screen.
001DFAr 2               
001DFAr 2  A5 rr        	lda spr+1		; fetch graphic.
001DFCr 2  A0 10        	ldy #16			; _BEEB
001DFEr 2  51 rr        	eor (scraddr),y		; merge with screen image.
001E00r 2  91 rr        	sta (scraddr),y		; write to screen.
001E02r 2               
001E02r 2  A5 rr        	lda spr+2		; fetch graphic.
001E04r 2  A0 20        	ldy #32			; _BEEB
001E06r 2  51 rr        	eor (scraddr),y		; merge with screen image.
001E08r 2  91 rr        	sta (scraddr),y		; write to screen.
001E0Ar 2               
001E0Ar 2  20 rr rr     	jsr nline
001E0Dr 2               
001E0Dr 2  E8           	inx			; next source byte.
001E0Er 2  E0 20        	cpx #32
001E10r 2  D0 CE        	bne sprit1		; repeat
001E12r 2               
001E12r 2  A6 rr        	ldx xtmp		; retreive X-reg
001E14r 2  60           	rts
001E15r 2               
001E15r 2               .endif
001E15r 2               
001E15r 2               ;------------------------------------------------------------------
001E15r 2               ; SCADD
001E15r 2               ;
001E15r 2               ; This routine returns a screen address for X,Y in scraddr.
001E15r 2               ;------------------------------------------------------------------
001E15r 2               
001E15r 2               scadd:
001E15r 2  A5 rr        	lda dispx		; get x
001E17r 2  29 F8        	and #$f8		; reset bit 0-2 for get block pos
001E19r 2  85 rr        	sta scraddr		; set lb scraddr
001E1Br 2  A9 00        	lda #0
001E1Dr 2  85 rr        	sta scraddr+1		; set hb scraddr
001E1Fr 2  06 rr        	asl scraddr		; multiply X by 2
001E21r 2  26 rr        	rol scraddr+1
001E23r 2               
001E23r 2               ; Add line address Y pos to X
001E23r 2               
001E23r 2  A6 rr        	ldx dispy		; get row address Y pos
001E25r 2  18           	clc
001E26r 2  A5 rr        	lda scraddr
001E28r 2  7D 00 07     	adc SCADTB_lb,x
001E2Br 2  85 rr        	sta scraddr
001E2Dr 2  A5 rr        	lda scraddr+1
001E2Fr 2  7D 00 08     	adc SCADTB_hb,x
001E32r 2  85 rr        	sta scraddr+1
001E34r 2               
001E34r 2  60           	rts
001E35r 2               
001E35r 2               ;------------------------------------------------------------------
001E35r 2               ; SSPRIA
001E35r 2               ;
001E35r 2               ; Erase single sprite, old (ix+0).
001E35r 2               ;------------------------------------------------------------------
001E35r 2               
001E35r 2               sspria:
001E35r 2  20 rr rr     	jsr gsprad		; get old sprite address.
001E38r 2               sspri2:
001E38r 2               .if rflag
001E38r 2               	lda z80_e		; 3c
001E38r 2               	sta dline_spraddr1+1	; 4c
001E38r 2               	sta dline_spraddr2+1	; 4c
001E38r 2               	lda z80_d		; 3c
001E38r 2               	sta dline_spraddr1+2	; 4c
001E38r 2               	sta dline_spraddr2+2	; 4c
001E38r 2               
001E38r 2               	ldx sprshft
001E38r 2               	lda shift_table,x
001E38r 2               	sta dline_shift1+1
001E38r 2               	sta dline_shift2+1
001E38r 2               	lda shift_table+1,x
001E38r 2               	sta dline_shift1+2
001E38r 2               	sta dline_shift2+2
001E38r 2               
001E38r 2               	ldx #0			; byte counter.
001E38r 2               sspri0:
001E38r 2               	jsr dline		; draw a line.
001E38r 2                 .if bflag
001E38r 2               	cpx #48			; big sprites have 24 bytes
001E38r 2                 .else
001E38r 2               	cpx #32			; normal sprites have 32 bytes
001E38r 2                 .endif
001E38r 2               	bne sspri0		; repeat 16 times x 2 bytes
001E38r 2               	rts
001E38r 2               .else
001E38r 2                 .if bflag
001E38r 2               	lda #24			; big sprites have 24 lines
001E38r 2                 .else
001E38r 2  A9 10        	lda #16			; normal sprites have 16 lines.
001E3Ar 2                 .endif
001E3Ar 2  8D rr rr     	sta acnt
001E3Dr 2               sspri0:
001E3Dr 2  20 rr rr     	jsr dline		; draw a line.
001E40r 2  CE rr rr     	dec acnt
001E43r 2  D0 F8        	bne sspri0		; repeat 16 times
001E45r 2  60           	rts
001E46r 2               
001E46r 2  00           acnt:	.byte 0			; line counter
001E47r 2               
001E47r 2               .endif
001E47r 2               
001E47r 2               ;------------------------------------------------------------------
001E47r 2               ; SSPRIB
001E47r 2               ;
001E47r 2               ; Display single sprite, new (ix+5).
001E47r 2               ;------------------------------------------------------------------
001E47r 2               
001E47r 2               ssprib:
001E47r 2  20 rr rr     	jsr gspran 		; get new sprite address.
001E4Ar 2  4C rr rr     	jmp sspri2		; Display sprite
001E4Dr 2               
001E4Dr 2               ;------------------------------------------------------------------
001E4Dr 2               ; SSPRIC
001E4Dr 2               ;
001E4Dr 2               ; Erase old (ix+0) and display new (ix+5) sprite line by line.
001E4Dr 2               ;------------------------------------------------------------------
001E4Dr 2               
001E4Dr 2               sspric:
001E4Dr 2               .if rflag
001E4Dr 2               	jsr gsprad 		; get old sprite address.
001E4Dr 2               
001E4Dr 2               	lda z80_e		; 3c
001E4Dr 2               	sta ddline_spraddr3+1	; 4c
001E4Dr 2               	sta ddline_spraddr4+1	; 4c
001E4Dr 2               
001E4Dr 2               	lda z80_d		; 3c
001E4Dr 2               	sta ddline_spraddr3+2	; 4c
001E4Dr 2               	sta ddline_spraddr4+2	; 4c
001E4Dr 2               
001E4Dr 2               	ldx sprshft		; set spriteshift table addresses
001E4Dr 2               	lda shift_table,x
001E4Dr 2               	sta ddline_shift3+1
001E4Dr 2               	sta ddline_shift4+1
001E4Dr 2               	lda shift_table+1,x
001E4Dr 2               	sta ddline_shift3+2
001E4Dr 2               	sta ddline_shift4+2
001E4Dr 2               
001E4Dr 2               	jsr exx  		; store addresses.
001E4Dr 2               	jsr gspran 		; get new sprite addresses.
001E4Dr 2               
001E4Dr 2               	lda z80_e		; 3c
001E4Dr 2               	sta ddline_spraddr1+1	; 4c
001E4Dr 2               	sta ddline_spraddr2+1	; 4c
001E4Dr 2               
001E4Dr 2               	lda z80_d		; 3c
001E4Dr 2               	sta ddline_spraddr1+2	; 4c
001E4Dr 2               	sta ddline_spraddr2+2	; 4c
001E4Dr 2               
001E4Dr 2               	ldx sprshft
001E4Dr 2               	lda shift_table,x
001E4Dr 2               	sta ddline_shift1+1
001E4Dr 2               	sta ddline_shift2+1
001E4Dr 2               	lda shift_table+1,x
001E4Dr 2               	sta ddline_shift1+2
001E4Dr 2               	sta ddline_shift2+2
001E4Dr 2               
001E4Dr 2               	ldx #0
001E4Dr 2               lloop:
001E4Dr 2               	jsr ddline 		; draw a line.
001E4Dr 2                 .if bflag
001E4Dr 2               	cpx #48
001E4Dr 2                 .else
001E4Dr 2               	cpx #32
001E4Dr 2                 .endif
001E4Dr 2               	bne lloop
001E4Dr 2               	rts
001E4Dr 2               
001E4Dr 2               shift_table:
001E4Dr 2               	.word shift0
001E4Dr 2               	.word shift2
001E4Dr 2               	.word shift4
001E4Dr 2               	.word shift6
001E4Dr 2               
001E4Dr 2               ;------------------------------------------------------------------
001E4Dr 2               ; DLINE
001E4Dr 2               ;
001E4Dr 2               ; Draw a sprite line, now work out next target address.
001E4Dr 2               ;
001E4Dr 2               ; Input:
001E4Dr 2               ;  B  = right mask
001E4Dr 2               ;  C  = left mask
001E4Dr 2               ;  DE = spriteaddress
001E4Dr 2               ;  scraddr = screen address
001E4Dr 2               ;------------------------------------------------------------------
001E4Dr 2               
001E4Dr 2               dline:
001E4Dr 2               
001E4Dr 2               dline_spraddr1:
001E4Dr 2               	ldy $ffff,x 		; get graphic data as pointer.
001E4Dr 2               dline_shift1:
001E4Dr 2               	lda $ffff,y		; get pre-shifted data
001E4Dr 2               	sta sprtmp		; save byte
001E4Dr 2               	and z80_c 		; mask right for left byte
001E4Dr 2               
001E4Dr 2               	ldy #0
001E4Dr 2               	eor (scraddr),y 	; XOR with what's there.
001E4Dr 2               	sta (scraddr),y 	; display left byte
001E4Dr 2               
001E4Dr 2               ; carry to next screen byte
001E4Dr 2               
001E4Dr 2               	lda sprtmp		; fetch data.
001E4Dr 2               	and z80_b 		; mask for left part
001E4Dr 2               	sta sprtmp
001E4Dr 2               
001E4Dr 2               ; middle screen byte
001E4Dr 2               
001E4Dr 2               	inx
001E4Dr 2               dline_spraddr2:
001E4Dr 2               	ldy $ffff,x 		; second bit of data.
001E4Dr 2               dline_shift2:
001E4Dr 2               	lda $ffff,y
001E4Dr 2               	sta sprtmp2
001E4Dr 2               	and z80_c 		; mask away what's not needed.
001E4Dr 2               	ora sprtmp
001E4Dr 2               	ldy #16
001E4Dr 2               	eor (scraddr),y 	; XOR with what's there.
001E4Dr 2               	sta (scraddr),y 	; display middle bye.
001E4Dr 2               
001E4Dr 2               ; carry to last screen byte
001E4Dr 2               
001E4Dr 2               	lda sprtmp2
001E4Dr 2               	and z80_b 		; mask away unwanted
001E4Dr 2               
001E4Dr 2               	ldy #32
001E4Dr 2               	eor (scraddr),y 	; XOR with what's there.
001E4Dr 2               	sta (scraddr),y 	; display right byte.
001E4Dr 2               
001E4Dr 2               	inx
001E4Dr 2               .else
001E4Dr 2               
001E4Dr 2  20 rr rr     	jsr gsprad 		; get old sprite address.
001E50r 2  20 rr rr     	jsr exx  		; store addresses.
001E53r 2  20 rr rr     	jsr gspran 		; get new sprite addresses.
001E56r 2               
001E56r 2               .if bflag
001E56r 2               	lda #23
001E56r 2               .else
001E56r 2  A9 0F        	lda #15
001E58r 2               .endif
001E58r 2  85 rr        	sta ccnt
001E5Ar 2               lloop:
001E5Ar 2  20 rr rr     	jsr dline 		; draw a line.
001E5Dr 2  20 rr rr     	jsr exx  		; restore old addresses.
001E60r 2  20 rr rr     	jsr dline 		; delete a line.
001E63r 2  20 rr rr     	jsr exx  		; flip to new sprite addresses.
001E66r 2  C6 rr        	dec ccnt
001E68r 2  D0 F0        	bne lloop
001E6Ar 2               
001E6Ar 2  20 rr rr     	jsr dline		; draw a line.
001E6Dr 2  20 rr rr     	jsr exx 		; restore old addresses.
001E70r 2               
001E70r 2               ;-------------------------------------------------------------
001E70r 2               ; Drop through.
001E70r 2               ; Line drawn, now work out next target address.
001E70r 2               ;
001E70r 2               ; Input:
001E70r 2               ;  B  = right mask
001E70r 2               ;  C  = left mask
001E70r 2               ;  DE = spriteaddress
001E70r 2               ;  scraddr = screen address
001E70r 2               ;-------------------------------------------------------------
001E70r 2               
001E70r 2               dline:
001E70r 2  A0 00        	ldy #0
001E72r 2  B1 rr        	lda (z80_de),y 		; graphic data.
001E74r 2  48           	pha
001E75r 2  25 rr        	and z80_c 		; mask away what's not needed.
001E77r 2  51 rr        	eor (scraddr),y 	; XOR with what's there.
001E79r 2  91 rr        	sta (scraddr),y 	; left byte on screen.
001E7Br 2               
001E7Br 2  68           	pla
001E7Cr 2  25 rr        	and z80_b 		; mask away unwanted bits.
001E7Er 2  A0 20        	ldy #32
001E80r 2  51 rr        	eor (scraddr),y 	; XOR with what's there.
001E82r 2  91 rr        	sta (scraddr),y 	; right byte on screen
001E84r 2               
001E84r 2  E6 rr        	inc z80_e 		; next graphic.
001E86r 2  D0 02        	bne :+
001E88r 2  E6 rr        	inc z80_d
001E8Ar 2               :
001E8Ar 2               ; _BEEB screen arrangement
001E8Ar 2               ;	sec
001E8Ar 2               ;	lda scraddr 		; one character cell to the left.
001E8Ar 2               ;	sbc #8
001E8Ar 2               ;	sta scraddr
001E8Ar 2               ;	lda scraddr+1
001E8Ar 2               ;	sbc #0
001E8Ar 2               ;	sta scraddr+1
001E8Ar 2               
001E8Ar 2  A0 00        	ldy #0
001E8Cr 2  B1 rr        	lda (z80_de),y 		; second bit of data.
001E8Er 2  A0 10        	ldy #16
001E90r 2  51 rr        	eor (scraddr),y 	; XOR with what's there.
001E92r 2  91 rr        	sta (scraddr),y 	; middle byte on screen.
001E94r 2               
001E94r 2  E6 rr        	inc z80_e 		; point to next line of data.
001E96r 2  D0 02        	bne :+
001E98r 2  E6 rr        	inc z80_d
001E9Ar 2               :
001E9Ar 2               ; _BEEB screen arrangement
001E9Ar 2               ;	sec
001E9Ar 2               ;	lda scraddr 		; another char left.
001E9Ar 2               ;	sbc #8
001E9Ar 2               ;	sta scraddr
001E9Ar 2               ;	lda scraddr+1
001E9Ar 2               ;	sbc #0
001E9Ar 2               ;	sta scraddr+1
001E9Ar 2               .endif
001E9Ar 2               
001E9Ar 2               ;----------------------------------------------------------------------
001E9Ar 2               ; Line drawn, now work out next target address.
001E9Ar 2               ;----------------------------------------------------------------------
001E9Ar 2               
001E9Ar 2               ; _BEEB screen arrangement
001E9Ar 2               
001E9Ar 2               nline:
001E9Ar 2  A5 rr        	lda scraddr 			; get low byte of address.
001E9Cr 2  29 0F        	and #15
001E9Er 2  C9 0F        	cmp #15				; is this last line of row?
001EA0r 2  F0 03        	beq beeb_next_row
001EA2r 2               
001EA2r 2               	; within same row
001EA2r 2  E6 rr        	inc scraddr			; new low byte of address.
001EA4r 2  60           	rts
001EA5r 2               
001EA5r 2               beeb_next_row:
001EA5r 2  18           	clc
001EA6r 2  A5 rr        	lda scraddr
001EA8r 2  69 51        	adc #<(ScreenRowBytes-15)
001EAAr 2  85 rr        	sta scraddr			; new low byte of address.
001EACr 2  A5 rr        	lda scraddr+1
001EAEr 2  69 01        	adc #>(ScreenRowBytes-15)
001EB0r 2  85 rr        	sta scraddr+1			; new high byte of address.
001EB2r 2  60           	rts
001EB3r 2               
001EB3r 2               .if rflag
001EB3r 2               ;-------------------------------------------------------------
001EB3r 2               ; Drop through.
001EB3r 2               ; Line drawn, now work out next target address.
001EB3r 2               ;
001EB3r 2               ; Input:
001EB3r 2               ;  B  = right mask
001EB3r 2               ;  C  = left mask
001EB3r 2               ;  DE = spriteaddress
001EB3r 2               ;  scraddr = screen address
001EB3r 2               ;-------------------------------------------------------------
001EB3r 2               
001EB3r 2               ddline:
001EB3r 2               
001EB3r 2               ; NEW SPRITE
001EB3r 2               
001EB3r 2               ; first screen byte
001EB3r 2               
001EB3r 2               ddline_spraddr1:
001EB3r 2               	ldy $ffff,x 		; graphic data.
001EB3r 2               ddline_shift1:
001EB3r 2               	lda $ffff,y
001EB3r 2               	sta sprtmp
001EB3r 2               	and z80_c 			; mask away what's not needed.
001EB3r 2               
001EB3r 2               	ldy #0
001EB3r 2               	eor (scraddr),y 	; XOR with what's there.
001EB3r 2               	sta (scraddr),y 	; bung it in.
001EB3r 2               
001EB3r 2               ; carry to next screen byte
001EB3r 2               
001EB3r 2               	lda sprtmp			; fetch data.
001EB3r 2               	and z80_b 			; mask away unwanted
001EB3r 2               	sta sprtmp
001EB3r 2               
001EB3r 2               ; middle screen byte
001EB3r 2               
001EB3r 2               	inx
001EB3r 2               ddline_spraddr2:
001EB3r 2               	ldy $ffff,x 		; second bit of data.
001EB3r 2               ddline_shift2:
001EB3r 2               	lda $ffff,y
001EB3r 2               	sta sprtmp2
001EB3r 2               	and z80_c 			; mask away what's not needed.
001EB3r 2               	ora sprtmp
001EB3r 2               
001EB3r 2               	ldy #16
001EB3r 2               	eor (scraddr),y 	; XOR with what's there.
001EB3r 2               	sta (scraddr),y 	; bung it in.
001EB3r 2               
001EB3r 2               ; carry to last screen byte
001EB3r 2               
001EB3r 2               	lda sprtmp2
001EB3r 2               	and z80_b 			; mask away unwanted
001EB3r 2               
001EB3r 2               	ldy #32
001EB3r 2               	eor (scraddr),y 	; XOR with what's there.
001EB3r 2               	sta (scraddr),y 	; bung it in.
001EB3r 2               
001EB3r 2               ; _BEEB next row
001EB3r 2               
001EB3r 2               	lda scraddr 		; get low byte of address.
001EB3r 2               	and #15
001EB3r 2               	cmp #15				; is this last line of row?
001EB3r 2               	beq :+
001EB3r 2               
001EB3r 2               	; within same row can't increment page
001EB3r 2               	inc scraddr			; new low byte of address.
001EB3r 2               	bne ddline2
001EB3r 2               
001EB3r 2               :
001EB3r 2               	clc
001EB3r 2               	lda scraddr
001EB3r 2               	adc #<(ScreenRowBytes-15)
001EB3r 2               	sta scraddr			; new low byte of address.
001EB3r 2               	lda scraddr+1
001EB3r 2               	adc #>(ScreenRowBytes-15)
001EB3r 2               	sta scraddr+1		; new high byte of address.
001EB3r 2               
001EB3r 2               ; OLD SPRITE
001EB3r 2               
001EB3r 2               ddline2:
001EB3r 2               
001EB3r 2               ; still first row but different data!
001EB3r 2               
001EB3r 2               	dex
001EB3r 2               
001EB3r 2               ; first screen byte
001EB3r 2               
001EB3r 2               ddline_spraddr3:
001EB3r 2               	ldy $ffff,x			; graphic data.
001EB3r 2               ddline_shift3:
001EB3r 2               	lda $ffff,y
001EB3r 2               	sta sprtmp
001EB3r 2               	and z80_cp 			; mask away what's not needed.
001EB3r 2               
001EB3r 2               	ldy #0
001EB3r 2               	eor (z80_hlp),y 	; XOR with what's there.
001EB3r 2               	sta (z80_hlp),y 	; bung it in.
001EB3r 2               
001EB3r 2               ; carry to next screen byte
001EB3r 2               
001EB3r 2               	lda sprtmp			; fetch data.
001EB3r 2               	and z80_bp 			; mask away unwanted
001EB3r 2               	sta sprtmp
001EB3r 2               
001EB3r 2               ; middle screen byte
001EB3r 2               
001EB3r 2               	inx
001EB3r 2               ddline_spraddr4:
001EB3r 2               	ldy $ffff,x 		; second bit of data.
001EB3r 2               ddline_shift4:
001EB3r 2               	lda $ffff,y
001EB3r 2               	sta sprtmp2
001EB3r 2               	and z80_cp 			; mask away what's not needed.
001EB3r 2               	ora sprtmp
001EB3r 2               
001EB3r 2               	ldy #16
001EB3r 2               	eor (z80_hlp),y 	; XOR with what's there.
001EB3r 2               	sta (z80_hlp),y 	; bung it in.
001EB3r 2               
001EB3r 2               ; last screen byte
001EB3r 2               
001EB3r 2               	lda sprtmp2			; fetch data.
001EB3r 2               	and z80_bp 			; mask away unwanted
001EB3r 2               
001EB3r 2               	ldy #32
001EB3r 2               	eor (z80_hlp),y 	; XOR with what's there.
001EB3r 2               	sta (z80_hlp),y 	; bung it in.
001EB3r 2               
001EB3r 2               ; next row of sprite data
001EB3r 2               
001EB3r 2               	inx
001EB3r 2               
001EB3r 2               ; _BEEB screen arrangement
001EB3r 2               
001EB3r 2               	lda z80_lp 			; get low byte of address.
001EB3r 2               	and #15
001EB3r 2               	cmp #15				; is this last line of row?
001EB3r 2               	beq :+
001EB3r 2               
001EB3r 2               	; within same row can't increment page
001EB3r 2               	inc z80_lp			; new low byte of address.
001EB3r 2               	rts
001EB3r 2               
001EB3r 2               :
001EB3r 2               	clc
001EB3r 2               	lda z80_lp
001EB3r 2               	adc #<(ScreenRowBytes-15)
001EB3r 2               	sta z80_lp			; new low byte of address.
001EB3r 2               	lda z80_lp+1
001EB3r 2               	adc #>(ScreenRowBytes-15)
001EB3r 2               	sta z80_lp+1		; new high byte of address.
001EB3r 2               	rts
001EB3r 2               .endif
001EB3r 2               
001EB3r 2               ;----------------------------------------------------
001EB3r 2               ; Display character in A at dispx,dispy.
001EB3r 2               ;
001EB3r 2               ; Input:
001EB3r 2               ;  A 	   = character to print
001EB3r 2               ;----------------------------------------------------
001EB3r 2               
001EB3r 2               pchar:
001EB3r 2  85 rr        	sta fntaddr
001EB5r 2  A9 00        	lda #0
001EB7r 2  85 rr        	sta fntaddr+1
001EB9r 2  06 rr        	asl fntaddr  		; multiply char by 8.
001EBBr 2  26 rr        	rol fntaddr+1
001EBDr 2  06 rr        	asl fntaddr
001EBFr 2  26 rr        	rol fntaddr+1
001EC1r 2  06 rr        	asl fntaddr
001EC3r 2  26 rr        	rol fntaddr+1
001EC5r 2               
001EC5r 2  A5 rr        	lda fntaddr
001EC7r 2  18           	clc
001EC8r 2  69 rr        	adc #<(FONT-256)
001ECAr 2  85 rr        	sta fntaddr		; that's the low byte.
001ECCr 2  A5 rr        	lda fntaddr+1
001ECEr 2  69 rr        	adc #>(FONT-256)
001ED0r 2  85 rr        	sta fntaddr+1		; add displacement.
001ED2r 2               
001ED2r 2               pchark:
001ED2r 2  20 rr rr     	jsr gaadd		; set colour attribute
001ED5r 2  AD rr rr     	lda fontcol
001ED8r 2  A0 00        	ldy #0
001EDAr 2  91 rr        	sta (bufaddr),y
001EDCr 2               
001EDCr 2  20 rr rr     	jsr gprad		; get screen address.
001EDFr 2  A2 07        	ldx #7			; lines to write.
001EE1r 2               pchar0:
001EE1r 2  A0 00        	ldy #0
001EE3r 2  B1 rr        	lda (fntaddr),y 	; get image byte.
001EE5r 2  BC rr rr     	ldy scrtab,x		; Get rowoffset
001EE8r 2               .if iflag
001EE8r 2               	eor #TxtInvert		; Invert
001EE8r 2               .endif
001EE8r 2  91 rr        	sta (scraddr),y 	; copy to screen.
001EEAr 2  E6 rr        	inc fntaddr		; next image byte.
001EECr 2  D0 02        	bne :+
001EEEr 2  E6 rr        	inc fntaddr+1
001EF0r 2               :
001EF0r 2  CA           	dex			; next screen row down.
001EF1r 2  10 EE        	bpl pchar0		; repeat.
001EF3r 2               
001EF3r 2  60           	rts
001EF4r 2               
001EF4r 2  07 06 05 04  scrtab:		.byte $07,$06,$05,$04,$03,$02,$01,$00
001EF8r 2  03 02 01 00  
001EFCr 2               
001EFCr 2               .if rflag
001EFCr 2               ;----------------------------------------------------
001EFCr 2               ; Shift tables
001EFCr 2               ;----------------------------------------------------
001EFCr 2               
001EFCr 2               .align 256
001EFCr 2               shift0:
001EFCr 2               .repeat 256, i
001EFCr 2               	.byte i
001EFCr 2               .endrep
001EFCr 2               
001EFCr 2               shift2:
001EFCr 2               .repeat 256, i
001EFCr 2               	.byte (i >> 2) | (i << 6) & $c0
001EFCr 2               .endrep
001EFCr 2               
001EFCr 2               shift4:
001EFCr 2               .repeat 256, i
001EFCr 2               	.byte (i >> 4) | ((i << 4) & $f0)
001EFCr 2               .endrep
001EFCr 2               
001EFCr 2               shift6:
001EFCr 2               .repeat 256, i
001EFCr 2               	.byte (i >> 6) | ((i << 2) & $fc)
001EFCr 2               .endrep
001EFCr 2               .endif
001EFCr 2               
001EFCr 1               	.include "z80.asm"
001EFCr 2               ;------------------------------------------------------
001EFCr 2               ; z80.asm
001EFCr 2               ; spectrum stuff
001EFCr 2               ; adresses
001EFCr 2               
001EFCr 2               ;ws	 = $60
001EFCr 2               
001EFCr 2               ;z80_f	 = ws+$00
001EFCr 2               ;z80_a	 = ws+$01
001EFCr 2               ;z80_af	 = z80_f
001EFCr 2               
001EFCr 2               ;z80_c	 = ws+$02
001EFCr 2               ;z80_b	 = ws+$03
001EFCr 2               ;z80_bc	 = z80_c
001EFCr 2               
001EFCr 2               ;z80_e	 = ws+$04
001EFCr 2               ;z80_d	 = ws+$05
001EFCr 2               ;z80_de	 = z80_e
001EFCr 2               
001EFCr 2               ;z80_l	 = ws+$06
001EFCr 2               ;z80_h	 = ws+$07
001EFCr 2               ;z80_hl	 = z80_l
001EFCr 2               
001EFCr 2               ;z80_x    = ws+$08
001EFCr 2               ;z80_i    = ws+$09
001EFCr 2               ;z80_ix	 = z80_x
001EFCr 2               
001EFCr 2               ;z80_iy	 = ws+$0a
001EFCr 2               
001EFCr 2               ;z80_fp	 = ws+$0c
001EFCr 2               ;z80_ap	 = ws+$0d
001EFCr 2               
001EFCr 2               ;z80_cp	 = ws+$0e
001EFCr 2               ;z80_bp	 = ws+$0f
001EFCr 2               ;z80_bcp = z80_cp
001EFCr 2               
001EFCr 2               ;z80_ep	 = ws+$10
001EFCr 2               ;z80_dp	 = ws+$11
001EFCr 2               ;z80_dep = z80_ep
001EFCr 2               
001EFCr 2               ;z80_lp	 = ws+$12
001EFCr 2               ;z80_hp	 = ws+$13
001EFCr 2               ;z80_hlp = z80_lp
001EFCr 2               
001EFCr 2               ;z80_sp   = ws+$14
001EFCr 2               
001EFCr 2               ;z80_reg0 = ws+$16
001EFCr 2               ;z80_reg1 = ws+$17
001EFCr 2               ;z80_reg2 = ws+$18
001EFCr 2               ;z80_reg3 = ws+$19
001EFCr 2               
001EFCr 2               ;z80_r	 = ws+$1a
001EFCr 2               
001EFCr 2               ; Contains seperatly 1 bit set
001EFCr 2               ; _BEEB this is not safe memory to use as required by MOS
001EFCr 2               
001EFCr 2               _bitmem0	= $f8
001EFCr 2               _bitmem1	= $f9
001EFCr 2               _bitmem2	= $fa
001EFCr 2               _bitmem3	= $fb
001EFCr 2               _bitmem4	= $fc
001EFCr 2               _bitmem5	= $fd
001EFCr 2               _bitmem6	= $fe
001EFCr 2               _bitmem7	= $ff
001EFCr 2               
001EFCr 2               ; constants
001EFCr 2               _bitvalue0	= $01
001EFCr 2               _bitvalue1	= $02
001EFCr 2               _bitvalue2	= $04
001EFCr 2               _bitvalue3	= $08
001EFCr 2               _bitvalue4	= $10
001EFCr 2               _bitvalue5	= $20
001EFCr 2               _bitvalue6	= $40
001EFCr 2               _bitvalue7	= $80
001EFCr 2               
001EFCr 2               _notbitvalue0	= $fe
001EFCr 2               _notbitvalue1	= $fd
001EFCr 2               _notbitvalue2	= $fb
001EFCr 2               _notbitvalue3	= $f7
001EFCr 2               _notbitvalue4	= $ef
001EFCr 2               _notbitvalue5	= $df
001EFCr 2               _notbitvalue6	= $bf
001EFCr 2               _notbitvalue7	= $7f
001EFCr 2               
001EFCr 2               
001EFCr 2               ;add_hl_bc:
001EFCr 2               ;		lda z80_l
001EFCr 2               ;		clc
001EFCr 2               ;		adc z80_c
001EFCr 2               ;		sta z80_l
001EFCr 2               ;		lda z80_h
001EFCr 2               ;		adc z80_b
001EFCr 2               ;		sta z80_h
001EFCr 2               ;		rts
001EFCr 2               ;
001EFCr 2               ;add_ix_de:
001EFCr 2               ;		lda z80_ix
001EFCr 2               ;		clc
001EFCr 2               ;		adc z80_e
001EFCr 2               ;		sta z80_ix
001EFCr 2               ;		lda z80_ix+1
001EFCr 2               ;		adc z80_d
001EFCr 2               ;		sta z80_ix+1
001EFCr 2               ;		rts
001EFCr 2               ;
001EFCr 2               ;add_iy_de:
001EFCr 2               ;		lda z80_iy
001EFCr 2               ;		clc
001EFCr 2               ;		adc z80_e
001EFCr 2               ;		sta z80_iy
001EFCr 2               ;		lda z80_iy+1
001EFCr 2               ;		adc z80_d
001EFCr 2               ;		sta z80_iy+1
001EFCr 2               ;		rts
001EFCr 2               ;
001EFCr 2               ;add_hl_de:
001EFCr 2               ;		lda z80_l
001EFCr 2               ;		clc
001EFCr 2               ;		adc z80_e
001EFCr 2               ;		sta z80_l
001EFCr 2               ;		lda z80_h
001EFCr 2               ;		adc z80_d
001EFCr 2               ;		sta z80_h
001EFCr 2               ;		rts
001EFCr 2               ;
001EFCr 2               ;add_ix_bc:
001EFCr 2               ;		lda z80_ix
001EFCr 2               ;		clc
001EFCr 2               ;		adc z80_c
001EFCr 2               ;		sta z80_ix
001EFCr 2               ;		lda z80_ix+1
001EFCr 2               ;		adc z80_b
001EFCr 2               ;		sta z80_ix+1
001EFCr 2               ;		rts
001EFCr 2               ;
001EFCr 2               ;add_iy_bc:
001EFCr 2               ;		lda z80_iy
001EFCr 2               ;		clc
001EFCr 2               ;		adc z80_c
001EFCr 2               ;		sta z80_iy
001EFCr 2               ;		lda z80_iy+1
001EFCr 2               ;		adc z80_b
001EFCr 2               ;		sta z80_iy+1
001EFCr 2               ;		rts
001EFCr 2               ;
001EFCr 2               ;sbc_hl_de:
001EFCr 2               ;		lda z80_l
001EFCr 2               ;		sbc z80_e
001EFCr 2               ;		sta z80_l
001EFCr 2               ;		lda z80_h
001EFCr 2               ;		sbc z80_d
001EFCr 2               ;		sta z80_h
001EFCr 2               ;		rts
001EFCr 2               ;
001EFCr 2               ;sbc_hl_bc:
001EFCr 2               ;		lda z80_l
001EFCr 2               ;		sbc z80_c
001EFCr 2               ;		sta z80_l
001EFCr 2               ;		lda z80_h
001EFCr 2               ;		sbc z80_b
001EFCr 2               ;		sta z80_h
001EFCr 2               ;		rts
001EFCr 2               ;
001EFCr 2               ;cmp_hl_bc:
001EFCr 2               ;		lda z80_l
001EFCr 2               ;		cmp z80_c
001EFCr 2               ;		bne cmp_hl_bc_end
001EFCr 2               ;		lda z80_h
001EFCr 2               ;		cmp z80_b
001EFCr 2               ;cmp_hl_bc_end:
001EFCr 2               ;		rts
001EFCr 2               ;
001EFCr 2               ;cmp_iy_ix:
001EFCr 2               ;		lda z80_iy
001EFCr 2               ;		cmp z80_ix
001EFCr 2               ;		bne cmp_iy_ix_end
001EFCr 2               ;		lda z80_iy+1
001EFCr 2               ;		cmp z80_ix+1
001EFCr 2               ;cmp_iy_ix_end:
001EFCr 2               ;		rts
001EFCr 2               ;
001EFCr 2               ;dec_hl:
001EFCr 2               ;		lda z80_l
001EFCr 2               ;		bne dec_hl_no_dec_h
001EFCr 2               ;		dec z80_h
001EFCr 2               ;dec_hl_no_dec_h:
001EFCr 2               ;		dec z80_l
001EFCr 2               ;		rts
001EFCr 2               ;
001EFCr 2               ;dec_ix:
001EFCr 2               ;		lda z80_ix
001EFCr 2               ;		bne dec_ix_no_dec_h
001EFCr 2               ;		dec z80_ix+1
001EFCr 2               ;dec_ix_no_dec_h:
001EFCr 2               ;		dec z80_ix
001EFCr 2               ;		rts
001EFCr 2               ;
001EFCr 2               ;dec_bc:
001EFCr 2               ;		lda z80_c
001EFCr 2               ;		bne dec_bc_no_dec_b
001EFCr 2               ;		dec z80_b
001EFCr 2               ;dec_bc_no_dec_b:
001EFCr 2               ;		dec z80_c
001EFCr 2               ;		rts
001EFCr 2               ;
001EFCr 2               ;dec_de:
001EFCr 2               ;		lda z80_e
001EFCr 2               ;		bne dec_de_no_dec_d
001EFCr 2               ;		dec z80_d
001EFCr 2               ;dec_de_no_dec_d:
001EFCr 2               ;		dec z80_e
001EFCr 2               ;		rts
001EFCr 2               ;
001EFCr 2               ;ex_af_afs:
001EFCr 2               ;	rts
001EFCr 2               ;ex_de_hl:
001EFCr 2               ;		lda z80_e
001EFCr 2               ;		ldx z80_l
001EFCr 2               ;		stx z80_e
001EFCr 2               ;		sta z80_l
001EFCr 2               ;		lda z80_d
001EFCr 2               ;		ldx z80_h
001EFCr 2               ;		stx z80_d
001EFCr 2               ;		sta z80_h
001EFCr 2               ;		rts
001EFCr 2               ;
001EFCr 2               exx:
001EFCr 2  A5 rr        		lda z80_c
001EFEr 2  A4 rr        		ldy z80_cp
001F00r 2  84 rr        		sty z80_c
001F02r 2  85 rr        		sta z80_cp
001F04r 2  A5 rr        		lda z80_b
001F06r 2  A4 rr        		ldy z80_bp
001F08r 2  84 rr        		sty z80_b
001F0Ar 2  85 rr        		sta z80_bp
001F0Cr 2  A5 rr        		lda z80_e
001F0Er 2  A4 rr        		ldy z80_ep
001F10r 2  84 rr        		sty z80_e
001F12r 2  85 rr        		sta z80_ep
001F14r 2  A5 rr        		lda z80_d
001F16r 2  A4 rr        		ldy z80_dp
001F18r 2  84 rr        		sty z80_d
001F1Ar 2  85 rr        		sta z80_dp
001F1Cr 2  A5 rr        		lda scraddr
001F1Er 2  A4 rr        		ldy z80_lp
001F20r 2  84 rr        		sty scraddr
001F22r 2  85 rr        		sta z80_lp
001F24r 2  A5 rr        		lda scraddr+1
001F26r 2  A4 rr        		ldy z80_hp
001F28r 2  84 rr        		sty scraddr+1
001F2Ar 2  85 rr        		sta z80_hp
001F2Cr 2  60           		rts
001F2Dr 2               
001F2Dr 2               ;ex_sp_hl:
001F2Dr 2               ;		tsx
001F2Dr 2               ;		lda $0103,x
001F2Dr 2               ;		ldy z80_h
001F2Dr 2               ;		sta z80_h
001F2Dr 2               ;		tya
001F2Dr 2               ;		sta $0103,x
001F2Dr 2               ;		lda $0104,x
001F2Dr 2               ;		ldy z80_l
001F2Dr 2               ;		sta z80_l
001F2Dr 2               ;		tya
001F2Dr 2               ;		sta $104,x
001F2Dr 2               ;		rts
001F2Dr 2               ;
001F2Dr 2               ;ldi:
001F2Dr 2               ;	rts
001F2Dr 2               ;ldir:
001F2Dr 2               ;		ldy #$00
001F2Dr 2               ;		ldx z80_b
001F2Dr 2               ;		beq ldir_last_page
001F2Dr 2               ;ldir_loop:
001F2Dr 2               ;		lda (z80_hl),y
001F2Dr 2               ;		sta (z80_de),y
001F2Dr 2               ;		iny
001F2Dr 2               ;		bne ldir_loop
001F2Dr 2               ;		inc z80_h
001F2Dr 2               ;		inc z80_d
001F2Dr 2               ;		dex
001F2Dr 2               ;		bne ldir_loop
001F2Dr 2               ;ldir_last_page:
001F2Dr 2               ;		lda z80_c
001F2Dr 2               ;		beq ldir_end
001F2Dr 2               ;ldir_last_page_loop:
001F2Dr 2               ;		lda (z80_hl),y
001F2Dr 2               ;		sta (z80_de),y
001F2Dr 2               ;		iny
001F2Dr 2               ;		cpy z80_c
001F2Dr 2               ;		bne ldir_last_page_loop
001F2Dr 2               ;ldir_end:
001F2Dr 2               ;		stx z80_c
001F2Dr 2               ;		stx z80_b
001F2Dr 2               ;		tya
001F2Dr 2               ;		clc
001F2Dr 2               ;		adc z80_l
001F2Dr 2               ;		sta z80_l
001F2Dr 2               ;		bcc *+4
001F2Dr 2               ;		inc z80_h
001F2Dr 2               ;		tya
001F2Dr 2               ;		clc
001F2Dr 2               ;		adc z80_e
001F2Dr 2               ;		sta z80_e
001F2Dr 2               ;		bcc *+4
001F2Dr 2               ;		inc z80_d
001F2Dr 2               ;		rts
001F2Dr 2               ;
001F2Dr 2               ;lddr:		ldy #$00
001F2Dr 2               ;lddr_loop:
001F2Dr 2               ;		lda (z80_hl),y
001F2Dr 2               ;		sta (z80_de),y
001F2Dr 2               ;		jsr dec_hl
001F2Dr 2               ;		jsr dec_de
001F2Dr 2               ;		jsr dec_bc
001F2Dr 2               ;		lda z80_b
001F2Dr 2               ;		ora z80_c
001F2Dr 2               ;		bne lddr_loop
001F2Dr 2               ;		rts
001F2Dr 2               ;ei:
001F2Dr 2               ;		rts
001F2Dr 2               ;di:
001F2Dr 2               ;		rts
001F2Dr 2               
001F2Dr 2               ;-------------------------------------------------------------
001F2Dr 2               ; Set bits in bitmem
001F2Dr 2               ;-------------------------------------------------------------
001F2Dr 2               
001F2Dr 2               .if 0
001F2Dr 2               z80_init:
001F2Dr 2               	ldx #$00
001F2Dr 2               	lda #$01
001F2Dr 2               z80_init_loop:
001F2Dr 2               	sta _bitmem0,x
001F2Dr 2               	inx
001F2Dr 2               	asl a
001F2Dr 2               	bne z80_init_loop
001F2Dr 2               	rts
001F2Dr 2               .endif
001F2Dr 2               
001F2Dr 2               push_af:
001F2Dr 2               push_bc:
001F2Dr 2               push_de:
001F2Dr 2               push_hl:
001F2Dr 2               
001F2Dr 2               pop_af:
001F2Dr 2               pop_bc:
001F2Dr 2               pop_de:
001F2Dr 2               pop_ix:
001F2Dr 2               pop_hl:
001F2Dr 2               
001F2Dr 2               add_hl_hl:
001F2Dr 2               
001F2Dr 2               inc_bc:
001F2Dr 2               inc_de:
001F2Dr 2               inc_hl:
001F2Dr 2               inc_ix:
001F2Dr 2               inc_sp:
001F2Dr 2               
001F2Dr 2               cpir:
001F2Dr 2               
001F2Dr 2               ex_af_af:
001F2Dr 2               ;	rts
001F2Dr 2               
001F2Dr 1               eind_asm:
001F2Dr 1               eop:					; End Of Program
001F2Dr 1               
001F2Dr 1               .out .sprintf("Gamecode size = %d bytes, free space = %d bytes", (eind_asm - main),(24576-eind_asm + main))
001F2Dr 1               
