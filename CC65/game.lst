ca65 V2.13.3 - (C) Copyright 1998-2012 Ullrich von Bassewitz
Main file   : game.asm
Current file: game.asm

000000r 1               ;----------------------------------------------
000000r 1               ; Common AGD engine
000000r 1               ; VIC20 conversion by Kees van Oss 2024
000000r 1               ;----------------------------------------------
000000r 1               
000000r 1               .segment "ZEROPAGE"
000000r 1               	.include "game.cfg"
000000r 2               ; Flags saved by AGD Compiler
000000r 2               
000000r 2               mflag = 0 ;
000000r 2               pflag = 1 ;
000000r 2               sflag = 0 ;
000000r 2               dflag = 0 ;
000000r 2               cflag = 0 ;
000000r 2               oflag = 0 ;
000000r 2               lflag = 1 ;
000000r 2               bflag = 0 ;
000000r 2               rflag = 0 ;
000000r 2               
000000r 1               	.include "engine-zp.inc"
000000r 2               ;----------------------------------------------------------------------
000000r 2               ; AGD 6502 Engine Zero Page Variables
000000r 2               ;----------------------------------------------------------------------
000000r 2               
000000r 2               ; Variables start here.
000000r 2               
000000r 2  xx           scno:	.res 1			; present screen number.
000001r 2  xx           numlif:	.res 1			; number of lives.
000002r 2               
000002r 2  xx           vara:	.res 1			; general-purpose variable.
000003r 2  xx           varb:	.res 1			; general-purpose variable.
000004r 2  xx           varc:	.res 1			; general-purpose variable.
000005r 2  xx           vard:	.res 1			; general-purpose variable.
000006r 2  xx           vare:	.res 1			; general-purpose variable.
000007r 2  xx           varf:	.res 1			; general-purpose variable.
000008r 2  xx           varg:	.res 1			; general-purpose variable.
000009r 2  xx           varh:	.res 1			; general-purpose variable.
00000Ar 2  xx           vari:	.res 1			; general-purpose variable.
00000Br 2  xx           varj:	.res 1			; general-purpose variable.
00000Cr 2  xx           vark:	.res 1			; general-purpose variable.
00000Dr 2  xx           varl:	.res 1			; general-purpose variable.
00000Er 2  xx           varm:	.res 1			; general-purpose variable.
00000Fr 2  xx           varn:	.res 1			; general-purpose variable.
000010r 2  xx           varo:	.res 1			; general-purpose variable.
000011r 2  xx           varp:	.res 1			; general-purpose variable.
000012r 2  xx           varq:	.res 1			; general-purpose variable.
000013r 2  xx           varr:	.res 1			; general-purpose variable.
000014r 2  xx           vars:	.res 1			; general-purpose variable.
000015r 2  xx           vart:	.res 1			; general-purpose variable.
000016r 2  xx           varu:	.res 1			; general-purpose variable.
000017r 2  xx           varv:	.res 1			; general-purpose variable.
000018r 2  xx           varw:	.res 1			; general-purpose variable.
000019r 2  xx           varz:	.res 1			; general-purpose variable.
00001Ar 2               
00001Ar 2  xx           charx:	.res 1			; cursor x position.
00001Br 2  xx           chary:	.res 1			; cursor y position.
00001Cr 2               
00001Cr 2  xx           clock:	.res 1			; last clock reading.
00001Dr 2  xx           varrnd:	.res 1	        ; last random number.
00001Er 2  xx           varobj:	.res 1  	    ; last object number.
00001Fr 2  xx           varopt:	.res 1     		; last option chosen from menu.
000020r 2  xx           varblk:	.res 1  		; block type.
000021r 2  xx           nexlev:	.res 1			; next level flag.
000022r 2  xx           restfl:	.res 1			; restart screen flag.
000023r 2  xx           deadf:	.res 1			; dead flag.
000024r 2  xx           gamwon:	.res 1			; game won flag.
000025r 2  xx           dispx:	.res 1			; cursor x position.
000026r 2  xx           dispy:	.res 1			; cursor y position.
000027r 2               
000027r 2  xx xx xx xx  dummy:  .res 5
00002Br 2  xx           
00002Cr 2               
00002Cr 2  xx           contrl:	.res 1			; control 0 = keyboard, 1 = Joystick.
00002Dr 2  xx           joyval:	.res 1			; joystick reading.
00002Er 2  xx           frmno:	.res 1			; selected frame.
00002Fr 2               
00002Fr 2               ;----------------------------------------------------
00002Fr 2               ; Missing vars
00002Fr 2               ;----------------------------------------------------
00002Fr 2               
00002Fr 2  xx           loopa:	    .res 1
000030r 2  xx           loopb:	    .res 1
000031r 2  xx           loopc:	    .res 1
000032r 2  xx xx        FontPtr:    .res 2
000034r 2               
000034r 2               ; Local vars
000034r 2               
000034r 2  xx xx        scraddr:    .res 2
000036r 2  xx xx        fntaddr:    .res 2
000038r 2  xx xx        tileaddr:   .res 2
00003Ar 2  xx xx        bufaddr:    .res 2
00003Cr 2               
00003Cr 2  xx xx        tmp:        .res 2
00003Er 2               .if sflag
00003Er 2               scr_l:      .res 2
00003Er 2               scr_r:      .res 2
00003Er 2               scr_txt:    .res 2
00003Er 2               scr_tmp:    .res 2
00003Er 2               .endif
00003Er 2               
00003Er 2  xx           xtmp:	    .res 1
00003Fr 2  xx           spcnt:	    .res 1
000040r 2  xx xx        spptr:	    .res 2		; spawned sprite pointer.
000042r 2  xx           seed:	    .res 1		; seed for random numbers.
000043r 2               
000043r 2  xx           ccnt:       .res 1
000044r 2  xx           flag:	    .res 1
000045r 2  xx           rcol:	    .res 1
000046r 2  xx           rrow:	    .res 1
000047r 2               
000047r 2  xx           combyt:	    .res 1		; byte type compressed.
000048r 2  xx           comcnt:	    .res 1		; compression counter.
000049r 2  xx           prtmod:	    .res 1      ; print mode, 0 = standard, 1 = double-height.
00004Ar 2  xx           qscnt:	    .res 1
00004Br 2               
00004Br 2  xx           sprptr:	    .res 1      ; not a ptr
00004Cr 2  xx           sprcnt:	    .res 1
00004Dr 2               
00004Dr 2  xx xx        skptr:	    .res 2		; search pointer.
00004Fr 2  xx           sktptr:	    .res 1      ; not a ptr
000050r 2  xx           tmproom:    .res 1
000051r 2  xx xx        ogptr:	    .res 2		; original sprite pointer.
000053r 2               
000053r 2  xx xx xx     spr:	    .res 3      ; static sprite data
000056r 2  xx           vsync_count:.res 1
000057r 2  xx           colpatt:    .res 1
000058r 2  xx           sprtmp:     .res 1
000059r 2  xx           sprtmp2:    .res 1
00005Ar 2  xx           sprshft:    .res 1
00005Br 2               
00005Br 2  xx           spriteink:  .res 1
00005Cr 2  xx           colour_byte:.res 1
00005Dr 2  xx           colour_xor: .res 1
00005Er 2  xx           objcol:	    .res 1
00005Fr 2               
00005Fr 2               .if mflag
00005Fr 2               TmpAddr:    .res 2
00005Fr 2               bwid:	    .res 1     ; box/menu width.
00005Fr 2               blen:	    .res 1     ; box/menu height.
00005Fr 2               btop:	    .res 1     ; box coordinates.
00005Fr 2               blft:	    .res 1
00005Fr 2               .endif
00005Fr 2               
00005Fr 2               .if pflag
00005Fr 2  xx           shrctr:	    .res 1
000060r 2  xx           explcnt:    .res 1
000061r 2  xx           seed3:	    .res 1
000062r 2               .endif
000062r 2               
000062r 2               .if aflag
000062r 2               pbbuf:      .res 2
000062r 2               pbptr:      .res 2
000062r 2               .endif
000062r 2               
000062r 2  xx           tmp1:       .res 1
000063r 2  xx           tmp2:       .res 1
000064r 2               
000064r 2  xx           SOUNDS_STATUS:      .res 1
000065r 2               
000065r 2               ;----------------------------------------------------
000065r 2               ; Music player variables
000065r 2               ;----------------------------------------------------
000065r 2               
000065r 2               ;SONG_POS:		.res 1	; = $90
000065r 2               ;PATTERN_POS:		.res 1	; = $91
000065r 2               ;FRAME_COUNT:		.res 1	; = $92
000065r 2               ;FRAME_LENGTH:		.res 1	; = $93
000065r 2               ;SONG_NEXT_TRUE:		.res 1	; = $94
000065r 2               ;SONG_END_TRUE:		.res 1	; = $95
000065r 2               
000065r 2               ; 2 byte address of pattern data
000065r 2               ;CH1_PATTERN_POS:	.res 2	; = $96
000065r 2               ;CH2_PATTERN_POS:	.res 2	; = $98
000065r 2               ;CH3_PATTERN_POS:	.res 2	; = $9a
000065r 2               ;CH4_PATTERN_POS:	.res 2	; = $9c
000065r 2               
000065r 2               ; #$00 == inactive mode
000065r 2               ;CH1_ACTIVE:		.res 1	; = $a0
000065r 2               ;CH2_ACTIVE:		.res 1	; = $a1
000065r 2               ;CH3_ACTIVE:		.res 1	; = $a2
000065r 2               ;CH4_ACTIVE:		.res 1	; = $a3
000065r 2               
000065r 2               ;TEMP_GUY:		.res 1	; = $a4
000065r 2               ;CHAN_NOTE_DATA:		.res 1	; = $a5
000065r 2               ;CHANS_INACTIVE:		.res 1	; = $a6
000065r 2               ;FAST_COUNTER:		.res 1	; = $a7
000065r 2               ;MEGA_COUNTER:		.res 1	; = $a8
000065r 2               
000065r 1               	.include "z80-zp.inc"
000065r 2               ;ws	 = $60
000065r 2               
000065r 2  xx           z80_f: .res 1;	 = ws+$00
000066r 2  xx           z80_a: .res 1;	 = ws+$01
000067r 2               z80_af	 = z80_f
000067r 2               
000067r 2  xx           z80_c: .res 1;	 = ws+$02
000068r 2  xx           z80_b: .res 1;	 = ws+$03
000069r 2               z80_bc	 = z80_c
000069r 2               
000069r 2  xx           z80_e: .res 1;	 = ws+$04
00006Ar 2  xx           z80_d: .res 1;	 = ws+$05
00006Br 2               z80_de	 = z80_e
00006Br 2               
00006Br 2  xx           z80_l: .res 1;	 = ws+$06
00006Cr 2  xx           z80_h: .res 1;	 = ws+$07
00006Dr 2               z80_hl	 = z80_l
00006Dr 2               
00006Dr 2  xx           z80_x: .res 1;    = ws+$08
00006Er 2  xx           z80_i: .res 1;    = ws+$09
00006Fr 2               z80_ix	 = z80_x
00006Fr 2               
00006Fr 2  xx xx        z80_iy: .res 2;	 = ws+$0a
000071r 2               
000071r 2  xx           z80_fp: .res 1;	 = ws+$0c
000072r 2  xx           z80_ap: .res 1;	 = ws+$0d
000073r 2               
000073r 2  xx           z80_cp: .res 1;	 = ws+$0e
000074r 2  xx           z80_bp: .res 1;	 = ws+$0f
000075r 2               z80_bcp	 = z80_cp
000075r 2               
000075r 2  xx           z80_ep: .res 1;	 = ws+$10
000076r 2  xx           z80_dp: .res 1;	 = ws+$11
000077r 2               z80_dep	 = z80_ep
000077r 2               
000077r 2  xx           z80_lp: .res 1;	 = ws+$12
000078r 2  xx           z80_hp: .res 1;	 = ws+$13
000079r 2               z80_hlp	 = z80_lp
000079r 2               
000079r 2  xx xx        z80_sp: .res 2;   = ws+$14
00007Br 2               
00007Br 2  xx           z80_reg0: .res 1; = ws+$16
00007Cr 2  xx           z80_reg1: .res 1; = ws+$17
00007Dr 2  xx           z80_reg2: .res 1; = ws+$18
00007Er 2  xx           z80_reg3: .res 1; = ws+$19
00007Fr 2               
00007Fr 2               ;z80_r: .res 1;	 = ws+$1a
00007Fr 2               
00007Fr 1               
00007Fr 1               ;----------------------------------------------
00007Fr 1               ; BASIC header
00007Fr 1               ;----------------------------------------------
00007Fr 1               
00007Fr 1               .segment "BASIC"
000000r 1               
000000r 1  rr rr        	.word load
000002r 1  rr rr        load:   .word @end
000004r 1  02 00        	.word 2
000006r 1  9E           	.byte $9e
000007r 1  rr           	.byte .lobyte(main/1000 .mod 10) + $30
000008r 1  rr           	.byte .lobyte(main/100 .mod 10) + $30
000009r 1  rr           	.byte .lobyte(main/10 .mod 10) + $30
00000Ar 1  rr           	.byte .lobyte(main/1 .mod 10) + $30
00000Br 1  00           	.byte 0
00000Cr 1  00 00        @end:   .word 0
00000Er 1               
00000Er 1               ;----------------------------------------------
00000Er 1               
00000Er 1               .segment "CODE"
000000r 1               main:
000000r 1               	.include "game.inc"
000000r 2               .include "ladder.inc"
000000r 3               ; Game engine code --------------------------------------------------------------
000000r 3               
000000r 3               ; Arcade Game Designer.
000000r 3               ; (C) 2008 Jonathan Cauldwell.
000000r 3               ; ZX Spectrum Next Engine v0.1.
000000r 3               
000000r 3               ; Conditional compilation flags
000000r 3               ; Code is installed if flag is set
000000r 3               ; Flags are set in commandline assembly or by the compiler
000000r 3               
000000r 3               ; Flags set by AGD compiler
000000r 3               ;	mflag  			; MENU + INV
000000r 3               ;	pflag 			; particle engine
000000r 3               ;	sflag 			; scrollytext
000000r 3               ;	dflag 			; digging mode
000000r 3               ;	cflag			; collectable blocks
000000r 3               ;	oflag			; objects
000000r 3               ;	lflag			; ladders
000000r 3               ;	bflag			; big sprites (16x24)
000000r 3               ;	rflag			; Pre-shifted byte tables
000000r 3               ;
000000r 3               ; Flags set manually
000000r 3               ;	aflag			; adventure mode
000000r 3               ;	iflag			; invert mode
000000r 3               
000000r 3               .if mflag
000000r 3               	.out "- MEN/INV enabled"
000000r 3               .endif
000000r 3               .if pflag
000000r 3               	.out "- Particles enabled"
000000r 3               .endif
000000r 3               .if sflag
000000r 3               	.out "- Scrolling enabled"
000000r 3               .endif
000000r 3               .if dflag
000000r 3               	.out "- Digging enabled"
000000r 3               .endif
000000r 3               .if cflag
000000r 3               	.out "- Collectable blocks enabled"
000000r 3               .endif
000000r 3               .if oflag
000000r 3               	.out "- Objects enabled"
000000r 3               .endif
000000r 3               .if lflag
000000r 3               	.out "- Ladders enabled"
000000r 3               .endif
000000r 3               .if aflag
000000r 3               	.out "- Adventure mode enabled"
000000r 3               .endif
000000r 3               .if bflag
000000r 3               	.out "- Big Sprites (16x24) enabled"
000000r 3               .endif
000000r 3               .if iflag
000000r 3               	.out "- Invert mode enabled"
000000r 3               .endif
000000r 3               .if rflag
000000r 3               	.out "- Pre-shifted byte tables enabled"
000000r 3               .endif
000000r 3               
000000r 3               ;------------------------------------------------------------
000000r 3               ; VIC20 check for PAL or NTSC
000000r 3               ;------------------------------------------------------------
000000r 3               
000000r 3               .if modelflag
000000r 3               	ScrWidth	= 22	; PAL settings
000000r 3               	ScrHeight	= 22
000000r 3               	CentreX		= 12
000000r 3               	CentreY		= 38
000000r 3               	CentreXMP   = 14
000000r 3               	CentreYMP   = 36
000000r 3               	timervalue	= 24000
000000r 3               	timerint	= 24000			; Interrupt timer 1/50 sec
000000r 3               	.out "- PAL"
000000r 3               .else
000000r 3               	ScrWidth	= 22	; NTSC settings
000000r 3               	ScrHeight	= 22
000000r 3               	CentreX		= 4
000000r 3               	CentreY		= 27
000000r 3               	CentreXMP   = 6
000000r 3               	CentreYMP   = 24
000000r 3               	timervalue	= 20000
000000r 3               	timerint	= 20000			; Interrupt timer 1/50 sec
000000r 3                	.out "- NTSC"
000000r 3               .endif
000000r 3               .out ""
000000r 3               
000000r 3               ;------------------------------------------------------------
000000r 3               ; Constants MPAGD
000000r 3               ;------------------------------------------------------------
000000r 3               
000000r 3               ; Global definitions
000000r 3               
000000r 3               	FONT 		= font
000000r 3               	MAP 		= MapAddr		; properties map buffer (3x256 bytes)
000000r 3               	SCADTB_lb	= MAP + $300		; Screen address table
000000r 3               	SCADTB_hb	= SCADTB_lb + $100
000000r 3               	SHRAPN 		= SCADTB_hb + $100	; shrapnel table (55x6 bytes)
000000r 3               	COLATTTB_lb	= SHRAPN + 55*6		; Colour attribute address table
000000r 3               	COLATTTB_hb	= COLATTTB_lb + 11
000000r 3               
000000r 3               ; Block characteristics.
000000r 3               
000000r 3               	PLATFM	= 1		; platform.
000000r 3               	WALL	= PLATFM + 1	; solid wall.
000000r 3               	LADDER	= WALL + 1	; ladder.
000000r 3               	FODDER	= LADDER + 1	; fodder block.
000000r 3               	DEADLY	= FODDER + 1	; deadly block.
000000r 3               	CUSTOM	= DEADLY + 1	; custom block.
000000r 3               	WATER	= CUSTOM + 1	; water block.
000000r 3                       COLECT	= WATER + 1	; collectable block.
000000r 3                       NUMTYP	= COLECT + 1	; number of types.
000000r 3               
000000r 3               ; Sprites.
000000r 3               
000000r 3               .if bflag
000000r 3               	SPR_HGT	= 24		; Sprite height
000000r 3               	SPR_WID = 16		; Sprite width
000000r 3               	NUMSPR	= 8		; number of sprites.
000000r 3               .else				; 16x16 sprites
000000r 3               	SPR_HGT = 16		; Sprite height
000000r 3               	SPR_WID = 16		; Sprite width
000000r 3               	NUMSPR	= 12		; number of sprites.
000000r 3               .endif
000000r 3               	TABSIZ = 18			; size of each entry.
000000r 3               	SPRBUF = NUMSPR * TABSIZ; size of entire table.
000000r 3               	NMESIZ = 4			; bytes stored in nmetab for each sprite.
000000r 3               
000000r 3               ; Sprite table variable offsets.
000000r 3               
000000r 3               	var_Type = 0		; sprite type
000000r 3               	var_Image = 1		; sprite time number
000000r 3               	var_Frame = 2		; sprite frame
000000r 3               	var_Y = 3			; sprite y coordinate
000000r 3               	var_X = 4			; sprite X coordinate
000000r 3               
000000r 3               	var_newType = 5		; sprite new type
000000r 3               	var_newImage = 6	; sprite new image number
000000r 3               	var_newFrame = 7	; sprite new frame
000000r 3               	var_newY = 8		; sprite new y coordinate
000000r 3               	var_newX = 9		; sprite new x coordinate
000000r 3               
000000r 3               	var_Direction = 10	; sprite direction
000000r 3               	var_Param1 = 11		; sprite parameter 1
000000r 3               	var_Param2 = 12		; sprite parameter 2
000000r 3               
000000r 3               	var_jumpLo = 13		; sprite jump ptr low
000000r 3               	var_jumpHi = 14		; sprite jump ptr high
000000r 3               	var_dataLo = 15		; sprite data ptr low
000000r 3               	var_dataHi = 16		; sprite data ptr high
000000r 3               	var_colour = 17		; sprite colour
000000r 3               
000000r 3               ; Particle engine.
000000r 3               
000000r 3               	NUMSHR = 55			; pieces of shrapnel.
000000r 3               	SHRSIZ = 6			; bytes per particle.
000000r 3               
000000r 3               .if iflag
000000r 3               	TxtInvert   = $ff	; Invert byte for character printing
000000r 3               	ScrFillByte = $ff	; Screen fill byte for CLS
000000r 3               .else
000000r 3               	TxtInvert   = $00	; Invert byte for character printing
000000r 3               	ScrFillByte = $00	; Screen fill byte for CLS
000000r 3               .endif
000000r 3               
000000r 3               	ASCII_NEWLINE = 13
000000r 3               
000000r 3               ;===============================================================
000000r 3               ; Game starts here
000000r 3               ;===============================================================
000000r 3               
000000r 3               ;--------------------------------------------------------------
000000r 3               ; If a font is required...
000000r 3               ;--------------------------------------------------------------
000000r 3               
000000r 3               start:
000000r 3               
000000r 3               ; Clear variables
000000r 3               
000000r 3  A9 00        	lda #0
000002r 3  AA           	tax
000003r 3               clrloop:
000003r 3  95 00        	sta 0,x
000005r 3  E8           	inx
000006r 3  D0 FB        	bne clrloop
000008r 3               
000008r 3  20 rr rr     	jsr game	 		; start the game.
00000Br 3  4C rr rr     	jmp start
00000Er 3               
00000Er 3               ; Don't change the order of these four.
00000Er 3               ; Menu routine relies on winlft following wintop.
00000Er 3               
00000Er 3  00           wintop:	.byte WINDOWTOP		; top of window.
00000Fr 3  00           winlft:	.byte WINDOWLFT		; left edge.
000010r 3  16           winhgt:	.byte WINDOWHGT		; window height.
000011r 3  16           winwid:	.byte WINDOWWID		; window width.
000012r 3  01           numob:	.byte NUMOBJ		; number of objects in game.
000013r 3               
000013r 3               ; Pixel versions of wintop, winlft, winhgt, winwid.
000013r 3               
000013r 3  00           wntopx:	.byte (8 * WINDOWTOP)
000014r 3  00           wnlftx:	.byte (8 * WINDOWLFT)
000015r 3  A0           wnbotx:	.byte ((WINDOWTOP * 8) + (WINDOWHGT * 8) - 16)
000016r 3  A0           wnrgtx:	.byte ((WINDOWLFT * 8) + (WINDOWWID * 8) - 16)
000017r 3               
000017r 3               ; Make sure pointers are arranged in the same order as the data itself.
000017r 3               
000017r 3  rr rr        frmptr:	.word frmlst        ; sprite frames.
000019r 3               
000019r 3               ; Assorted game routines which can go in contended memory.
000019r 3               
000019r 3               ;--------------------------------------------------------------
000019r 3               ; Modify for inventory.
000019r 3               ; called by the INV command
000019r 3               ;
000019r 3               ; Input:
000019r 3               ;  X   = message nr with objects seperated with ,
000019r 3               ;
000019r 3               ; Output:
000019r 3               ;  OPT = selected line nr of INV menu
000019r 3               ;--------------------------------------------------------------
000019r 3               
000019r 3               .if mflag
000019r 3               minve:
000019r 3               .if xflag
000019r 3               	lda #WINDOWHGT
000019r 3               	asl a
000019r 3               	sta winhgt
000019r 3               	lda #WINDOWWID
000019r 3               	asl a
000019r 3               	sta winwid
000019r 3               .endif
000019r 3               	lda #<(invdis)		; routine address.
000019r 3               	sta mod0+1		; set up menu routine.
000019r 3               	sta mod2+1		; set up count routine.
000019r 3               	lda #>(invdis)
000019r 3               	sta mod0+2
000019r 3               	sta mod2+2
000019r 3               	lda #<(fopt)		; find option from available objects.
000019r 3               	sta mod1+1		; set up routine.
000019r 3               	lda #>(fopt)
000019r 3               	sta mod1+1+1
000019r 3               	jmp dbox		; do menu routine.
000019r 3               
000019r 3               ;--------------------------------------------------------------
000019r 3               ; Modify for menu.
000019r 3               ; called by the MENU command
000019r 3               ;
000019r 3               ; Input:
000019r 3               ;  X   = message nr with menu items seperated with ,
000019r 3               ;
000019r 3               ; Output:
000019r 3               ;  OPT = selected line nr of MENU menu
000019r 3               ;--------------------------------------------------------------
000019r 3               
000019r 3               mmenu:
000019r 3               	lda #<(always)		; routine address.
000019r 3               	sta mod0+1		; set up routine.
000019r 3               	sta mod2+1		; set up count routine.
000019r 3               	lda #>(always)
000019r 3               	sta mod0+2
000019r 3               	sta mod2+2
000019r 3               
000019r 3               	lda #<(fstd)		; standard option selection.
000019r 3               	sta mod1+1		; set up routine.
000019r 3               	lda #>(fstd)
000019r 3               	sta mod1+2
000019r 3               
000019r 3               ; Drop through into box routine.
000019r 3               
000019r 3               ;--------------------------------------------------------------
000019r 3               ; Work out size of box for message or menu.
000019r 3               ;--------------------------------------------------------------
000019r 3               
000019r 3               dbox:
000019r 3               	lda #<msgdat		; pointer to messages.
000019r 3               	sta z80_l
000019r 3               	lda #>msgdat
000019r 3               	sta z80_h
000019r 3               
000019r 3               	jsr getwrd		; get message number.
000019r 3               
000019r 3               	lda z80_h		; store pointer to message.
000019r 3               	sta TmpAddr
000019r 3               	lda z80_l
000019r 3               	sta TmpAddr+1
000019r 3               
000019r 3               	lda #1			; height.
000019r 3               	sta z80_d
000019r 3               	lda #0			; start at object zero.
000019r 3               	sta combyt		; store number of object in combyt.
000019r 3               	sta z80_e		; maximum width.
000019r 3               dbox5:
000019r 3               	lda #0			; this line"s width.
000019r 3               	sta z80_b
000019r 3               mod2:
000019r 3               	jsr always		; item in player"s possession?
000019r 3               	cmp #255
000019r 3               	bne dbox6		; not in inventory, skip this line.
000019r 3               	inc z80_d		; add to tally.
000019r 3               dbox6:
000019r 3               	ldy #0			; get character.
000019r 3               	lda (z80_hl),y
000019r 3               	sta z80_a
000019r 3               	inc z80_l		; next character.
000019r 3               	bne :+
000019r 3               	inc z80_h
000019r 3               :
000019r 3               	lda z80_a		; reached end of line?
000019r 3               	cmp #','
000019r 3               	beq dbox3		; yes.
000019r 3               	cmp #ASCII_NEWLINE
000019r 3               	beq dbox3		; yes.
000019r 3               	inc z80_b		; add to this line"s width.
000019r 3               	lda z80_a
000019r 3               	bmi dbox4		; end of message? yes, end count.
000019r 3               	jmp dbox6		; repeat until we find the end.
000019r 3               dbox3:
000019r 3               	lda z80_e		; maximum line width.
000019r 3               	cmp z80_b		; have we exceeded longest so far?
000019r 3               	bpl dbox5		; no, carry on looking.
000019r 3               	lda z80_b		; make this the widest so far.
000019r 3               	sta z80_e
000019r 3               	jmp dbox5		; keep looking.
000019r 3               dbox4:
000019r 3               	lda z80_e		; maximum line width.
000019r 3               	cmp z80_b		; have we exceeded longest so far?
000019r 3               	bpl dbox8		; no, carry on looking.
000019r 3               	lda z80_b		; final line is the longest so far.
000019r 3               	sta z80_e
000019r 3               dbox8:
000019r 3               	dec z80_d		; decrement items found.
000019r 3               	bne :+			; total was zero.
000019r 3               	lda #255
000019r 3               	sta varopt
000019r 3               	jmp dbox15
000019r 3               :
000019r 3               	lda z80_e		; longest line.
000019r 3               	bne :+			; was it zero?
000019r 3               	jmp dbox15		; total was zero.
000019r 3               :
000019r 3               	sta bwid		; set up size.
000019r 3               	lda z80_d
000019r 3               	sta blen
000019r 3               
000019r 3               ;--------------------------------------------------------------
000019r 3               ; That's set up our box size.
000019r 3               ;--------------------------------------------------------------
000019r 3               
000019r 3               	lda winhgt		; window height in characters.
000019r 3               	sec
000019r 3               	sbc z80_d		; subtract height of box.
000019r 3               	lsr a			; divide by 2.
000019r 3               	clc
000019r 3               	adc wintop		; add top edge of window.
000019r 3               	sta btop		; set up box top.
000019r 3               
000019r 3               	lda winwid		; window width in characters.
000019r 3               	sec
000019r 3               	sbc z80_e		; subtract box width.
000019r 3               	lsr a			; divide by 2.
000019r 3               	clc
000019r 3               	adc winlft		; add left edge of window.
000019r 3               	sta blft		; box left.
000019r 3               
000019r 3               	lda #<(FONT-256)		; font.
000019r 3               	sta grbase		; set up for text display.
000019r 3               	lda #>(FONT-256)
000019r 3               	sta grbase+1
000019r 3               
000019r 3               	lda TmpAddr+1		; restore message pointer.
000019r 3               	sta z80_l
000019r 3               	lda TmpAddr
000019r 3               	sta z80_h
000019r 3               
000019r 3               	lda btop		; box top.
000019r 3               	sta dispy		; set display coordinate.
000019r 3               	lda #0			; start at object zero.
000019r 3               	sta combyt		; store number of object in combyt.
000019r 3               dbox2:
000019r 3               	lda combyt		; get object number.
000019r 3               	sta z80_a
000019r 3               mod0:
000019r 3               	jsr always		; check inventory for display.
000019r 3               	cmp #255
000019r 3               	beq :+
000019r 3               	jmp dbox13		; not in inventory, skip this line.
000019r 3               :
000019r 3               	lda blft		; box left.
000019r 3               	sta dispx		; set left display position.
000019r 3               	lda bwid		; box width.
000019r 3               	sta z80_b		; store width.
000019r 3               dbox0:
000019r 3               	ldy #0			; get character.
000019r 3               	lda (z80_hl),y
000019r 3               	cmp #','		; end of line?
000019r 3               	beq dbox1		; yes, next one.
000019r 3               	cmp #ASCII_NEWLINE			; end of line?
000019r 3               	beq dbox1		; yes, next one.
000019r 3               
000019r 3               	cmp #141			; end of line?
000019r 3               	bne :+
000019r 3               	dec bwid
000019r 3               	jmp dbox7		; yes, next one.
000019r 3               :
000019r 3               	dec z80_b		; one less to display.
000019r 3               	and #127		; remove terminator.
000019r 3               
000019r 3               	jsr pchr		; display on screen.
000019r 3               
000019r 3               	ldy #0
000019r 3               	lda (z80_hl),y		; get character.
000019r 3               	sta z80_a
000019r 3               	inc z80_l		; next character.
000019r 3               	bne :+
000019r 3               	inc z80_h
000019r 3               :
000019r 3               	lda z80_a
000019r 3               	cmp #128		; end of message?
000019r 3               	bmi :+
000019r 3               	jmp dbox7		; yes, job done.
000019r 3               :
000019r 3               	lda z80_b		; chars remaining.
000019r 3               	beq :+			; are any left?
000019r 3               	jmp dbox0		; yes, continue.
000019r 3               :
000019r 3               ;---------------------------------------------------
000019r 3               ; Reached limit of characters per line.
000019r 3               ;---------------------------------------------------
000019r 3               
000019r 3               dbox9:
000019r 3               	ldy #0
000019r 3               	lda (z80_hl),y		; get character.
000019r 3               	inc z80_l		; next one.
000019r 3               	bne :+
000019r 3               	inc z80_h
000019r 3               :
000019r 3               	cmp #','		; another line?
000019r 3               	beq dbox10		; yes, do next line.
000019r 3               	cmp #ASCII_NEWLINE	; another line?
000019r 3               	beq dbox10		; yes, do next line.
000019r 3               	cmp #128		; end of message?
000019r 3               	bcs :+
000019r 3               	jmp dbox11		; yes, finish message.
000019r 3               :
000019r 3               	jmp dbox9
000019r 3               
000019r 3               ;---------------------------------------------------
000019r 3               ; Fill box to end of line.
000019r 3               ;---------------------------------------------------
000019r 3               
000019r 3               dboxf:
000019r 3               	lda #32			; space character.
000019r 3               	jsr pchr		; display character.
000019r 3               	dec z80_b
000019r 3               	beq :+
000019r 3               	jmp dboxf		; repeat for remaining chars on line.
000019r 3               :
000019r 3               	rts
000019r 3               dbox1:
000019r 3               	inc z80_l		; skip character.
000019r 3               	bne :+
000019r 3               	inc z80_h
000019r 3               :
000019r 3               	jsr dboxf		; fill box out to right side.
000019r 3               dbox10:
000019r 3               	inc dispy		; y coordinate down a line next position.
000019r 3               	jmp dbox2		; next line.
000019r 3               dbox7:
000019r 3               	lda z80_b		; chars remaining.
000019r 3               	bne :+			; are any left?
000019r 3               	jmp dbox11		; no, nothing to draw.
000019r 3               :
000019r 3               	jsr dboxf		; fill message to line.
000019r 3               
000019r 3               ;------------------------------------------------------
000019r 3               ; Drawn the box menu, now select option.
000019r 3               ;------------------------------------------------------
000019r 3               
000019r 3               dbox11:
000019r 3               	lda btop		; box top.
000019r 3               	sta dispy		; set bar position.
000019r 3               dbox14:
000019r 3               	jsr joykey		; get controls.
000019r 3               	cmp #$7f		; anything pressed?
000019r 3               	bne dbox14		; yes, debounce it.
000019r 3               	jsr dbar		; draw bar.
000019r 3               dbox12:
000019r 3               	jsr joykey		; get controls.
000019r 3               	cmp #$7f		; anything pressed?
000019r 3               	beq dbox12		; no, nothing.
000019r 3               	and #16			; fire button pressed?
000019r 3               	bne :+
000019r 3               mod1:
000019r 3               	jmp fstd		; yes, job done.
000019r 3               :
000019r 3               	jsr dbar		; delete bar.
000019r 3               
000019r 3               	lda joyval		; joystick reading.
000019r 3               	and #8			; going up?
000019r 3               	beq dboxu		; yes, go up.
000019r 3               
000019r 3               	ldx dispy		; vertical position of bar.
000019r 3               	inx			; look down.
000019r 3               	txa
000019r 3               	sec
000019r 3               	sbc btop		; find distance from top.
000019r 3               	cmp blen		; top of box.
000019r 3               	bne :+
000019r 3               	jmp dbox14		; yes, go no further.
000019r 3               :
000019r 3               	inc dispy		; move bar.
000019r 3               	jmp dbox14		; continue.
000019r 3               dboxu:
000019r 3               	lda dispy		; vertical position of bar.
000019r 3               	cmp btop		; are we at the top?
000019r 3               	bne :+
000019r 3               	jmp dbox14		; yes, go no further.
000019r 3               :
000019r 3               	dec dispy		; move bar.
000019r 3               	jmp dbox14		; continue.
000019r 3               fstd:
000019r 3               	lda dispy		; bar position.
000019r 3               	sec
000019r 3               	sbc btop		; find selected option.
000019r 3               	sta varopt		; store the option.
000019r 3               	jmp redraw		; redraw the screen.
000019r 3               
000019r 3               ;------------------------------------------------------
000019r 3               ; Option not available.  Skip this line.
000019r 3               ;------------------------------------------------------
000019r 3               
000019r 3               dbox13:
000019r 3               	ldy #0
000019r 3               	lda (z80_hl),y		; get character.
000019r 3               	inc z80_l		; next one.
000019r 3               
000019r 3               	bne :+
000019r 3               	inc z80_h
000019r 3               :
000019r 3               	cmp #','		; another line?
000019r 3               	bne :+
000019r 3               	jmp dbox2		; yes, do next line.
000019r 3               :
000019r 3               	cmp #ASCII_NEWLINE			; another line?
000019r 3               	bne :+
000019r 3               	jmp dbox2		; yes, do next line.
000019r 3               :
000019r 3               
000019r 3               	bpl :+			; end of message?
000019r 3               	jmp dbox11		; yes, finish message.
000019r 3               :
000019r 3               	jmp dbox13
000019r 3               dbox15:
000019r 3               .if xflag
000019r 3               	lda #WINDOWWID
000019r 3               	sta winwid
000019r 3               	lda #WINDOWHGT
000019r 3               	sta winhgt
000019r 3               .endif
000019r 3               	lda TmpAddr		; pop message pointer from the stack.
000019r 3               	sta z80_h
000019r 3               	lda TmpAddr+1
000019r 3               	sta z80_l
000019r 3               	rts
000019r 3               
000019r 3               ;------------------------------------------------------
000019r 3               ; Invert bar
000019r 3               ;------------------------------------------------------
000019r 3               
000019r 3               dbar:
000019r 3               	lda blft		; box left.
000019r 3               	sta dispx		; set display coordinate.
000019r 3               	jsr gprad		; get printing address.
000019r 3               
000019r 3               	lda bwid		; box width.
000019r 3               	sta z80_c		; loop counter in c.
000019r 3               	lda z80_h
000019r 3               	sta z80_d		; store screen address high byte.
000019r 3               dbar1:
000019r 3               	ldx #7			; pixel height in b.
000019r 3               dbar0:
000019r 3               	ldy scrtab,x
000019r 3               	lda (scraddr),y		; get screen byte.
000019r 3               	eor #255		; reverse all bits.
000019r 3               	sta (scraddr),y		; write back to screen.
000019r 3               	dex			; next line down.
000019r 3               	bpl dbar0		; draw rest of character.
000019r 3               
000019r 3               	lda scraddr
000019r 3               	adc #16
000019r 3               	sta scraddr
000019r 3               	bcc :+
000019r 3               	inc scraddr+1
000019r 3               :
000019r 3               	dec z80_c		; decrement character counter.
000019r 3               	bne dbar1		; repeat for whole line.
000019r 3               	rts
000019r 3               
000019r 3               ;------------------------------------------------------
000019r 3               ; Point to object
000019r 3               ;
000019r 3               ; Input:
000019r 3               ;  -
000019r 3               ;
000019r 3               ; Output:
000019r 3               ;  A = object number, A=255 if already in possession
000019r 3               ;------------------------------------------------------
000019r 3               
000019r 3               invdis:
000019r 3               	lda z80_l		; store message text pointer.
000019r 3               	pha
000019r 3               	lda z80_h
000019r 3               	pha
000019r 3               	lda combyt		; object number.
000019r 3               	inc combyt		; ready for next one.
000019r 3               	jsr gotob		; check if we have object.
000019r 3               	tay
000019r 3               	pla
000019r 3               	sta z80_h
000019r 3               	pla
000019r 3               	sta z80_l
000019r 3               	tya
000019r 3               	rts
000019r 3               
000019r 3               ;------------------------------------------------------
000019r 3               ; Find option selected.
000019r 3               ;
000019r 3               ; Input:
000019r 3               ;  -
000019r 3               ;
000019r 3               ; Output:
000019r 3               ;  OPT = selected object
000019r 3               ;------------------------------------------------------
000019r 3               
000019r 3               fopt:
000019r 3               	lda dispy
000019r 3               	sec
000019r 3               	sbc btop		; find selected option.
000019r 3               	sta tmp+2		; option selected in b register.
000019r 3               	inc tmp+2
000019r 3               
000019r 3               	lda #0			; set to first item.
000019r 3               	sta combyt		; object number.
000019r 3               fopt0:
000019r 3               	jsr fobj		; find next object in inventory.
000019r 3               	dec tmp+2
000019r 3               	bne fopt0		; repeat for relevant steps down the list.
000019r 3               
000019r 3               	lda combyt		; get option.
000019r 3               	sta varopt		; store the option.
000019r 3               	dec varopt		; one less, due to where we increment combyt.
000019r 3               	jmp redraw		; redraw the screen.
000019r 3               fobj:
000019r 3               	ldy combyt		; object number.
000019r 3               	inc combyt		; ready for next item.
000019r 3               	tya
000019r 3               	jsr gotob		; do we have this item?
000019r 3               	cmp #255
000019r 3               	bne :+
000019r 3               	rts
000019r 3               :
000019r 3               	jmp fobj		; yes, it's on the list.
000019r 3               .endif
000019r 3               
000019r 3               ;----------------------------------------------------
000019r 3               ; Clear sprite table.
000019r 3               ;
000019r 3               ; sprtab[0] - sprtab[SPRBUF-1] = 255
000019r 3               ;----------------------------------------------------
000019r 3               
000019r 3               xspr:
000019r 3  A9 FF        	lda #255		; clear byte.
00001Br 3  A2 00        	ldx #0			; length of table.
00001Dr 3               xspr0:
00001Dr 3  9D rr rr     	sta sprtab,x		; sprite table.
000020r 3  E8           	inx			; move to next byte.
000021r 3  E0 D8        	cpx #SPRBUF
000023r 3  D0 F8        	bne xspr0		; repeat for rest of table.
000025r 3  60           	rts
000026r 3               
000026r 3               ;-------------------------------------------------------------
000026r 3               ; Initialise all objects.
000026r 3               ;
000026r 3               ; Reset current room,y,x to start room,y,x for all objects
000026r 3               ;-------------------------------------------------------------
000026r 3               
000026r 3               .if oflag
000026r 3               iniob:
000026r 3               	lda #<objdta		; objects table.
000026r 3               	sta z80_x
000026r 3               	lda #>objdta
000026r 3               	sta z80_i
000026r 3               
000026r 3               	ldx numob 		; number of objects in the game.
000026r 3               iniob0:
000026r 3               	ldy #36
000026r 3               	lda (z80_ix),y 		; start screen.
000026r 3               	ldy #33
000026r 3               	sta (z80_ix),y 		; set start screen.
000026r 3               
000026r 3               	ldy #37
000026r 3               	lda (z80_ix),y 		; find start y.
000026r 3               	ldy #34
000026r 3               	sta (z80_ix),y 		; set start y.
000026r 3               
000026r 3               	ldy #38
000026r 3               	lda (z80_ix),y 		; get initial x.
000026r 3               	ldy #35
000026r 3               	sta (z80_ix),y 		; set x coord.
000026r 3               
000026r 3               	clc 			; point to next object.
000026r 3               	lda z80_x
000026r 3               	adc #39			; distance between objects.
000026r 3               	sta z80_x
000026r 3               	bcc :+
000026r 3               	inc z80_i
000026r 3               :
000026r 3               	dex 			; repeat.
000026r 3               	bne iniob0
000026r 3               
000026r 3               	rts
000026r 3               .endif
000026r 3               
000026r 3               ;-----------------------------------------------
000026r 3               ; Redraw the screen.
000026r 3               ;
000026r 3               ; Remove old copy of all sprites for redraw.
000026r 3               ;-----------------------------------------------
000026r 3               
000026r 3               redraw:
000026r 3               .if xflag
000026r 3               	lda #WINDOWWID
000026r 3               	sta winwid
000026r 3               	lda #WINDOWHGT
000026r 3               	sta winhgt
000026r 3               .endif
000026r 3  A5 rr        	lda z80_i 		; place sprite pointer on stack.
000028r 3  48           	pha
000029r 3  A5 rr        	lda z80_x
00002Br 3  48           	pha
00002Cr 3               
00002Cr 3  20 rr rr     	jsr droom		; show screen layout.
00002Fr 3               .if oflag
00002Fr 3               	jsr shwob		; draw objects.
00002Fr 3               .endif
00002Fr 3               numsp0:
00002Fr 3  A9 0C        	lda #NUMSPR		; sprites to draw.
000031r 3  85 rr        	sta tmp
000033r 3               
000033r 3  A9 rr        	lda #<sprtab		; sprite table.
000035r 3  85 rr        	sta z80_x
000037r 3  A9 rr        	lda #>sprtab
000039r 3  85 rr        	sta z80_i
00003Br 3               redrw0:
00003Br 3  A0 00        	ldy #0
00003Dr 3  B1 rr        	lda (z80_ix),y		; old sprite type.
00003Fr 3  C9 FF        	cmp #255		; is it enabled?
000041r 3  F0 0B        	beq redrw1 		; no, find next one.
000043r 3               
000043r 3  A0 03        	ldy #var_Y
000045r 3  B1 rr        	lda (z80_ix),y 		; sprite y.
000047r 3  C9 A1        	cmp #SpriteMaxY		; beyond maximum?
000049r 3  B0 03        	bcs redrw1		; yes, nothing to draw.
00004Br 3               
00004Br 3  20 rr rr     	jsr sspria		; show single sprite.
00004Er 3               
00004Er 3               redrw1:
00004Er 3  18           	clc			; next sprite.
00004Fr 3  A5 rr        	lda z80_x
000051r 3  69 12        	adc #TABSIZ		; distance to next odd/even entry.
000053r 3  85 rr        	sta z80_x
000055r 3  90 02        	bcc :+
000057r 3  E6 rr        	inc z80_i
000059r 3               :
000059r 3  C6 rr        	dec tmp			; repeat for remaining sprites.
00005Br 3  D0 DE        	bne redrw0
00005Dr 3               
00005Dr 3               rpblc1:
00005Dr 3               ;	jsr dshrp		; redraw shrapnel.
00005Dr 3               
00005Dr 3               .if aflag
00005Dr 3               	jsr rbloc		; draw blocks for this screen
00005Dr 3               .endif
00005Dr 3  68           	pla			; retrieve sprite pointer.
00005Er 3  85 rr        	sta z80_x
000060r 3  68           	pla
000061r 3  85 rr        	sta z80_i
000063r 3               
000063r 3  60           	rts
000064r 3               
000064r 3               ;----------------------------------------------------------------------
000064r 3               ; Clear screen routine.
000064r 3               ;
000064r 3               ; Fill screenmem $9400-$97ff with ScrFillByte
000064r 3               ;----------------------------------------------------------------------
000064r 3               
000064r 3               cls:
000064r 3  A9 10        	lda #>CharAddress	; Character RAM address.
000066r 3  8D rr rr     	sta clrdata+2
000069r 3               
000069r 3               ; Clear bitmap data
000069r 3               
000069r 3  A9 00        	lda #ScrFillByte	; Clear screen
00006Br 3  A0 00        	ldy #0
00006Dr 3  A2 10        	ldx #16
00006Fr 3               clrdata:
00006Fr 3  99 00 10     	sta CharAddress,y
000072r 3  C8           	iny
000073r 3  D0 FA        	bne clrdata
000075r 3  EE rr rr     	inc clrdata+2
000078r 3  CA           	dex
000079r 3  D0 F4        	bne clrdata
00007Br 3               
00007Br 3               ; Clear colour attributes
00007Br 3               
00007Br 3  AD rr rr     	lda fontcol
00007Er 3  A2 00        	ldx #0
000080r 3               clrcolour:
000080r 3  9D 00 94     	sta ColorAttr-$200,x
000083r 3  9D 00 96     	sta ColorAttr,x
000086r 3  E8           	inx
000087r 3  D0 F7        	bne clrcolour
000089r 3  60           	rts
00008Ar 3               
00008Ar 3               ;----------------------------------------------------------------------
00008Ar 3               ; Clear colour attributes
00008Ar 3               ;
00008Ar 3               ; Reset colour attributes to fontcol
00008Ar 3               ;----------------------------------------------------------------------
00008Ar 3               
00008Ar 3               clrcol:
00008Ar 3  AD rr rr     	lda fontcol		; Clear colour attributes
00008Dr 3  A2 00        	ldx #0
00008Fr 3               clscol:
00008Fr 3  9D 00 96     	sta ColorAttr,x
000092r 3  E8           	inx
000093r 3  E0 F2        	cpx #242
000095r 3  D0 F8        	bne clscol
000097r 3               
000097r 3  60           	rts
000098r 3               
000098r 3               ;----------------------------------------------------------------------
000098r 3               ; FODDER check
000098r 3               ;----------------------------------------------------------------------
000098r 3               
000098r 3               .if pflag .or dflag
000098r 3               fdchk:
000098r 3  C9 04        	cmp #FODDER 		; is it fodder?
00009Ar 3  F0 01        	beq :+
00009Cr 3  60           	rts 			; no.
00009Dr 3               :
00009Dr 3  A9 00        	lda #0			; wipe fodder in MAP
00009Fr 3  A0 00        	ldy #0
0000A1r 3  91 rr        	sta (bufaddr),y 	; rewrite block type.
0000A3r 3               
0000A3r 3  A5 rr        	lda dispx		; x=x/8
0000A5r 3  48           	pha
0000A6r 3  4A           	lsr a
0000A7r 3  4A           	lsr a
0000A8r 3  4A           	lsr a
0000A9r 3  85 rr        	sta dispx
0000ABr 3               
0000ABr 3  A5 rr        	lda dispy		; y=y/8
0000ADr 3  48           	pha
0000AEr 3  4A           	lsr a
0000AFr 3  4A           	lsr a
0000B0r 3  4A           	lsr a
0000B1r 3  85 rr        	sta dispy
0000B3r 3               
0000B3r 3  A9 00        	lda #0 			; block to write.
0000B5r 3  20 rr rr     	jsr pattr 		; write block.
0000B8r 3               
0000B8r 3  68           	pla
0000B9r 3  85 rr        	sta dispy
0000BBr 3  68           	pla
0000BCr 3  85 rr        	sta dispx
0000BEr 3  60           	rts
0000BFr 3               .endif
0000BFr 3               
0000BFr 3               ;----------------------------------------------------
0000BFr 3               ; Scrolly text and puzzle variables.
0000BFr 3               ;----------------------------------------------------
0000BFr 3               
0000BFr 3               .if sflag
0000BFr 3               txtbit:	.byte 128		; bit to write.
0000BFr 3               txtwid:	.byte 16		; width of ticker message.
0000BFr 3               txtpos:	.word msgdat
0000BFr 3               txtini:	.word msgdat
0000BFr 3               txtscr:	.word ScreenAddr
0000BFr 3               .endif
0000BFr 3               
0000BFr 3               ;----------------------------------------------------
0000BFr 3               ; Specialist routines.
0000BFr 3               ; Process shrapnel.
0000BFr 3               ;----------------------------------------------------
0000BFr 3               proshr:
0000BFr 3               .if pflag
0000BFr 3  A9 00        	lda #<SHRAPN		; table.
0000C1r 3  85 rr        	sta z80_x
0000C3r 3  A9 09        	lda #>SHRAPN
0000C5r 3  85 rr        	sta z80_i
0000C7r 3               
0000C7r 3  A9 37        	lda #NUMSHR		; shrapnel pieces to process.
0000C9r 3  85 rr        	sta shrctr
0000CBr 3               prosh0:
0000CBr 3  A0 00        	ldy #0
0000CDr 3  B1 rr        	lda (z80_ix),y		; on/off marker.
0000CFr 3  0A           	asl a
0000D0r 3               proshx:
0000D0r 3  B0 03        	bcs :+
0000D2r 3  20 rr rr     	jsr prosh1 		; on, so process it.
0000D5r 3               :
0000D5r 3  18           	clc
0000D6r 3  A5 rr        	lda z80_x
0000D8r 3  69 06        	adc #SHRSIZ
0000DAr 3  85 rr        	sta z80_x
0000DCr 3  90 02        	bcc :+
0000DEr 3  E6 rr        	inc z80_i
0000E0r 3               :
0000E0r 3  C6 rr        	dec shrctr		; round again.
0000E2r 3  D0 E7        	bne prosh0
0000E4r 3               .endif
0000E4r 3               .if sflag
0000E4r 3               	jsr scrly
0000E4r 3               .endif
0000E4r 3  60           	rts
0000E5r 3               
0000E5r 3               .if pflag
0000E5r 3               ;----------------------------------------------------
0000E5r 3               ; Proces shrapnel piece
0000E5r 3               ;----------------------------------------------------
0000E5r 3               
0000E5r 3               prosh1:
0000E5r 3  20 rr rr     	jsr plot 		; delete the pixel.
0000E8r 3               
0000E8r 3  A9 rr        	lda #<shrptr		; shrapnel routine pointers.
0000EAr 3  85 rr        	sta z80_l
0000ECr 3  A9 rr        	lda #>shrptr
0000EEr 3  85 rr        	sta z80_h
0000F0r 3               
0000F0r 3  A0 00        	ldy #0
0000F2r 3  B1 rr        	lda (z80_ix),y		; restore shrapnel type.
0000F4r 3  20 rr rr     	jsr prosh2 		; run the routine.
0000F7r 3  20 rr rr     	jsr chkxy		; check x and y are good before we redisplay.
0000FAr 3               
0000FAr 3  A9 06        	lda #<SHRSIZ 		; distance to next.
0000FCr 3  85 rr        	sta z80_e
0000FEr 3  A9 00        	lda #>SHRSIZ
000100r 3  85 rr        	sta z80_d
000102r 3  60           	rts
000103r 3               
000103r 3               ;----------------------------------------------------
000103r 3               ; Run the routine
000103r 3               ;----------------------------------------------------
000103r 3               
000103r 3               prosh2:
000103r 3  0A           	asl a 			; 2 bytes per address.
000104r 3  A8           	tay
000105r 3  B9 rr rr     	lda shrptr,y
000108r 3  85 rr        	sta z80_l
00010Ar 3  B9 rr rr     	lda shrptr+1,y 		; fetch high byte from table.
00010Dr 3  85 rr        	sta z80_h
00010Fr 3  6C rr rr     	jmp (z80_hl) 		; jump to routine.
000112r 3               
000112r 3               ;----------------------------------------------------
000112r 3               ; Paricle routine table
000112r 3               ;----------------------------------------------------
000112r 3               
000112r 3  rr rr        shrptr:	.word laser		; laser.
000114r 3  rr rr        	.word trail		; vapour trail.
000116r 3  rr rr        	.word shrap		; shrapnel from explosion.
000118r 3  rr rr        	.word dotl		; horizontal starfield left.
00011Ar 3  rr rr        	.word dotr		; horizontal starfield right.
00011Cr 3  rr rr        	.word dotu		; vertical starfield up.
00011Er 3  rr rr        	.word dotd		; vertical starfield down.
000120r 3  rr rr        	.word ptcusr		; user particle.
000122r 3               
000122r 3               ;----------------------------------------------------
000122r 3               ; Explosion shrapnel.
000122r 3               ;----------------------------------------------------
000122r 3               
000122r 3               shrap:
000122r 3  A0 01        	ldy #1
000124r 3  B1 rr        	lda (z80_ix),y 		; get the angle.
000126r 3  18           	clc
000127r 3  69 rr        	adc #<shrsin		; shrapnel sine table.
000129r 3  85 rr        	sta z80_l
00012Br 3  A9 rr        	lda #>shrsin
00012Dr 3  69 00        	adc #0
00012Fr 3  85 rr        	sta z80_h
000131r 3               
000131r 3  A0 00        	ldy #0
000133r 3  B1 rr        	lda (z80_hl),y 		; fetch value from table.
000135r 3  85 rr        	sta z80_e
000137r 3  E6 rr        	inc z80_l 		; next byte of table.
000139r 3  D0 02        	bne :+
00013Br 3  E6 rr        	inc z80_h
00013Dr 3               :
00013Dr 3  A0 00        	ldy #0
00013Fr 3  B1 rr        	lda (z80_hl),y		; fetch value from table.
000141r 3  85 rr        	sta z80_d
000143r 3  E6 rr        	inc z80_l		; next byte of table.
000145r 3  D0 02        	bne :+
000147r 3  E6 rr        	inc z80_h
000149r 3               :
000149r 3  A0 00        	ldy #0
00014Br 3  B1 rr        	lda (z80_hl),y 		; fetch value from table.
00014Dr 3  85 rr        	sta z80_c
00014Fr 3  E6 rr        	inc z80_l 		; next byte of table.
000151r 3  D0 02        	bne :+
000153r 3  E6 rr        	inc z80_h
000155r 3               :
000155r 3  A0 00        	ldy #0
000157r 3  B1 rr        	lda (z80_hl),y 		; fetch value from table.
000159r 3  85 rr        	sta z80_b
00015Br 3               
00015Br 3  A0 02        	ldy #2
00015Dr 3  B1 rr        	lda (z80_ix),y 		; x coordinate in hl.
00015Fr 3  18           	clc
000160r 3  65 rr        	adc z80_e		; add sine lb
000162r 3  91 rr        	sta (z80_ix),y		; store new coordinate lb.
000164r 3  A0 03        	ldy #3
000166r 3  B1 rr        	lda (z80_ix),y
000168r 3  65 rr        	adc z80_d		; add sine hb
00016Ar 3  91 rr        	sta (z80_ix),y		; store new coordinate hb.
00016Cr 3               
00016Cr 3  A0 04        	ldy #4
00016Er 3  B1 rr        	lda (z80_ix),y	 	; y coordinate in hl.
000170r 3  18           	clc
000171r 3  65 rr        	adc z80_c		; add cosine lb
000173r 3  91 rr        	sta (z80_ix),y		; store new coordinate lb.
000175r 3  A0 05        	ldy #5
000177r 3  B1 rr        	lda (z80_ix),y
000179r 3  65 rr        	adc z80_b		; add cosine lb
00017Br 3  91 rr        	sta (z80_ix),y		; store new coordinate hb.
00017Dr 3               
00017Dr 3  60           	rts
00017Er 3               
00017Er 3               ;----------------------------------------------------
00017Er 3               ; Move dots
00017Er 3               ;----------------------------------------------------
00017Er 3               
00017Er 3               dotl:
00017Er 3  A0 05        	ldy #5
000180r 3  B1 rr        	lda (z80_ix),y
000182r 3  38           	sec
000183r 3  E9 01        	sbc #1		 	; move left.
000185r 3  91 rr        	sta (z80_ix),y
000187r 3  60           	rts
000188r 3               dotr:
000188r 3  A0 05        	ldy #5
00018Ar 3  B1 rr        	lda (z80_ix),y
00018Cr 3  18           	clc
00018Dr 3  69 01        	adc #1		 	; move left.
00018Fr 3  91 rr        	sta (z80_ix),y
000191r 3  60           	rts
000192r 3               dotu:
000192r 3  A0 03        	ldy #3
000194r 3  B1 rr        	lda (z80_ix),y
000196r 3  38           	sec
000197r 3  E9 01        	sbc #1		 	; move up.
000199r 3  91 rr        	sta (z80_ix),y
00019Br 3  60           	rts
00019Cr 3               dotd:
00019Cr 3  A0 03        	ldy #3
00019Er 3  B1 rr        	lda (z80_ix),y
0001A0r 3  18           	clc
0001A1r 3  69 01        	adc #1			; move down.
0001A3r 3  91 rr        	sta (z80_ix),y
0001A5r 3  60           	rts
0001A6r 3               
0001A6r 3               ;----------------------------------------------------
0001A6r 3               ; Check if coordinates are ok before redrawing at new position.
0001A6r 3               ;
0001A6r 3               ; left:   X>L		X=L	Ok
0001A6r 3               ; right:  R+15>X	X=R	Ok
0001A6r 3               ; top:    Y>T		Y=T	Ok
0001A6r 3               ; bottom: B+15>Y	Y=B	Ok
0001A6r 3               ;----------------------------------------------------
0001A6r 3               
0001A6r 3               chkxy:
0001A6r 3               
0001A6r 3               ; top:    Y>T		Y=T	Ok
0001A6r 3               
0001A6r 3  A0 03        	ldy #3
0001A8r 3  B1 rr        	lda (z80_ix),y	 	; fetch shrapnel coordinate.
0001AAr 3  CD rr rr     	cmp wntopx		; window top.
0001ADr 3  B0 03        	bcs :+			; compare with top window limit.
0001AFr 3  4C rr rr     	jmp kilshr		; out of window, kill shrapnel.
0001B2r 3               :
0001B2r 3               ; left:   X>L		X=L	Ok
0001B2r 3               
0001B2r 3  A0 05        	ldy #5
0001B4r 3  B1 rr        	lda (z80_ix),y	 	; fetch shrapnel coordinate.
0001B6r 3  CD rr rr     	cmp wnlftx		; left edge.
0001B9r 3  B0 03        	bcs :+			; compare with left window limit.
0001BBr 3  4C rr rr     	jmp kilshr		; out of window, kill shrapnel.
0001BEr 3               :
0001BEr 3               ; bottom: B+15>Y	Y=B	Ok
0001BEr 3               
0001BEr 3  AD rr rr     	lda wnbotx		; point to bottom.
0001C1r 3  18           	clc
0001C2r 3  69 0F        	adc #15
0001C4r 3  A0 03        	ldy #3
0001C6r 3  D1 rr        	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
0001C8r 3  B0 03        	bcs :+			; compare with shrapnel x coordinate.
0001CAr 3  4C rr rr     	jmp kilshr		; off screen, kill shrapnel..
0001CDr 3               :
0001CDr 3               ; right:  R+15>X	X=R	Ok
0001CDr 3               
0001CDr 3  AD rr rr     	lda wnrgtx		; point to right edge.
0001D0r 3  18           	clc
0001D1r 3  69 0F        	adc #15
0001D3r 3  A0 05        	ldy #5
0001D5r 3  D1 rr        	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
0001D7r 3  B0 03        	bcs :+			; compare with window limit.
0001D9r 3  4C rr rr     	jmp kilshr		; off screen, kill shrapnel.
0001DCr 3               :
0001DCr 3               
0001DCr 3               ;----------------------------------------------------
0001DCr 3               ; Drop through.
0001DCr 3               ; Display shrapnel.
0001DCr 3               ;----------------------------------------------------
0001DCr 3               
0001DCr 3               plot:
0001DCr 3  A0 03        	ldy #3
0001DEr 3  B1 rr        	lda (z80_ix),y		; y integer.
0001E0r 3  85 rr        	sta dispy	 	; workspace coordinates.
0001E2r 3  A0 05        	ldy #5
0001E4r 3  B1 rr        	lda (z80_ix),y	 	; x integer.
0001E6r 3  85 rr        	sta dispx 		; workspace coordinates.
0001E8r 3               
0001E8r 3  A0 00        	ldy #0
0001EAr 3  B1 rr        	lda (z80_ix),y 		; type.
0001ECr 3  D0 03        	bne :+			; is it a laser?
0001EEr 3  4C rr rr     	jmp plot1 		; yes, draw laser instead.
0001F1r 3               :
0001F1r 3               plot0:
0001F1r 3  A5 rr        	lda dispx		; which pixel within byte do we
0001F3r 3  29 07        	and #7			; want to set first?
0001F5r 3  A8           	tay
0001F6r 3  B9 rr rr     	lda dots,y 		; table of small pixel positions.
0001F9r 3  85 rr        	sta z80_e 		; get value.
0001FBr 3               
0001FBr 3  20 rr rr     	jsr scadd 		; screen address.
0001FEr 3  A0 00        	ldy #0
000200r 3  B1 rr        	lda (scraddr),y		; see what's already there.
000202r 3  45 rr        	eor z80_e
000204r 3  91 rr        	sta (scraddr),y 	; put back on screen.
000206r 3  60           	rts
000207r 3               
000207r 3               plot1:
000207r 3  20 rr rr     	jsr scadd 		; screen address.
00020Ar 3  A0 00        	ldy #0
00020Cr 3  B1 rr        	lda (scraddr),y 	; fetch byte there.
00020Er 3  49 FF        	eor #255 		; toggle all bits.
000210r 3  91 rr        	sta (scraddr),y 	; new byte.
000212r 3  60           	rts
000213r 3               
000213r 3               ;----------------------------------------------------
000213r 3               ; Switch off shrapnel
000213r 3               ;----------------------------------------------------
000213r 3               
000213r 3               kilshr:
000213r 3  A9 80        	lda #128
000215r 3  A0 00        	ldy #0
000217r 3  91 rr        	sta (z80_ix),y	; switch off shrapnel.
000219r 3  60           	rts
00021Ar 3               
00021Ar 3               ;----------------------------------------------------
00021Ar 3               ; Sine/cosine table
00021Ar 3               ;----------------------------------------------------
00021Ar 3               
00021Ar 3  00 00 00 04  shrsin:	.word 0,1024,391,946,724,724,946,391
00021Er 3  87 01 B2 03  
000222r 3  D4 02 D4 02  
00022Ar 3  00 04 00 00  	.word 1024,0,946,65144,724,64811,391,64589
00022Er 3  B2 03 78 FE  
000232r 3  D4 02 2B FD  
00023Ar 3  00 00 00 FC  	.word 0,64512,65144,64589,64811,64811,64589,65144
00023Er 3  78 FE 4D FC  
000242r 3  2B FD 2B FD  
00024Ar 3  00 FC 00 00  	.word 64512,0,64589,391,64811,724,65144,946
00024Er 3  4D FC 87 01  
000252r 3  2B FD D4 02  
00025Ar 3               
00025Ar 3               ;----------------------------------------------------
00025Ar 3               ; Create trail
00025Ar 3               ;----------------------------------------------------
00025Ar 3               
00025Ar 3               trail:
00025Ar 3  A0 01        	ldy #1
00025Cr 3  B1 rr        	lda (z80_ix),y 	; time remaining.
00025Er 3  38           	sec
00025Fr 3  E9 01        	sbc #1
000261r 3  91 rr        	sta (z80_ix),y
000263r 3  D0 03        	bne :+
000265r 3  4C rr rr     	jmp trailk		; time to switch it off.
000268r 3               :
000268r 3  20 rr rr     	jsr qrand		; get a random number.
00026Br 3  4A           	lsr a 			; x or y axis?
00026Cr 3  90 03        	bcc :+
00026Er 3  4C rr rr     	jmp trailv		; use y.
000271r 3               :
000271r 3               ; Trail horizontal
000271r 3               
000271r 3  4A           	lsr a 			; which direction?
000272r 3  90 03        	bcc :+
000274r 3  4C rr rr     	jmp traill		; go left.
000277r 3               :
000277r 3               ; Trail right
000277r 3               
000277r 3  A0 05        	ldy #5
000279r 3  B1 rr        	lda (z80_ix),y
00027Br 3  18           	clc
00027Cr 3  69 01        	adc #1	 		; go right.
00027Er 3  91 rr        	sta (z80_ix),y
000280r 3  60           	rts
000281r 3               
000281r 3               ; Trail left
000281r 3               
000281r 3               traill:
000281r 3  A0 05        	ldy #5
000283r 3  B1 rr        	lda (z80_ix),y
000285r 3  38           	sec
000286r 3  E9 01        	sbc #1 			; go left.
000288r 3  91 rr        	sta (z80_ix),y
00028Ar 3  60           	rts
00028Br 3               
00028Br 3               ; Trail vertical
00028Br 3               
00028Br 3               trailv:
00028Br 3  4A           	lsr a		 	; which direction?
00028Cr 3  90 03        	bcc :+
00028Er 3  4C rr rr     	jmp trailu		; go up.
000291r 3               :
000291r 3               ; Trail down
000291r 3               
000291r 3  A0 03        	ldy #3
000293r 3  B1 rr        	lda (z80_ix),y
000295r 3  18           	clc
000296r 3  69 01        	adc #1 			; go down.
000298r 3  91 rr        	sta (z80_ix),y
00029Ar 3  60           	rts
00029Br 3               
00029Br 3               ; Trail up
00029Br 3               
00029Br 3               trailu:
00029Br 3  A0 03        	ldy #3
00029Dr 3  B1 rr        	lda (z80_ix),y
00029Fr 3  38           	sec
0002A0r 3  E9 01        	sbc #1 			; go up.
0002A2r 3  91 rr        	sta (z80_ix),y
0002A4r 3  60           	rts
0002A5r 3               
0002A5r 3               ; Kill trail
0002A5r 3               
0002A5r 3               trailk:
0002A5r 3  A9 C8        	lda #200		; set off-screen to kill vapour trail.
0002A7r 3  A0 03        	ldy #3
0002A9r 3  91 rr        	sta (z80_ix),y
0002ABr 3  60           	rts
0002ACr 3               
0002ACr 3               ;----------------------------------------------------
0002ACr 3               ; Create laser beam
0002ACr 3               ;----------------------------------------------------
0002ACr 3               
0002ACr 3               laser:
0002ACr 3  A0 01        	ldy #1
0002AEr 3  B1 rr        	lda (z80_ix),y 		; direction.
0002B0r 3  6A           	ror a 			; left or right?
0002B1r 3  B0 03        	bcs :+
0002B3r 3  4C rr rr     	jmp laserl		; move left.
0002B6r 3               :
0002B6r 3               ; Laser right
0002B6r 3               
0002B6r 3  A9 08        	lda #8			; distance to travel.
0002B8r 3  85 rr        	sta z80_b
0002BAr 3  4C rr rr     	jmp laserm		; move laser.
0002BDr 3               
0002BDr 3               ; Laser left
0002BDr 3               
0002BDr 3               laserl:
0002BDr 3  A9 F8        	lda #248		; distance to travel.
0002BFr 3  85 rr        	sta z80_b
0002C1r 3               laserm:
0002C1r 3  A0 05        	ldy #5
0002C3r 3  B1 rr        	lda (z80_ix),y		; x position.
0002C5r 3  18           	clc
0002C6r 3  65 rr        	adc z80_b		; add distance.
0002C8r 3  91 rr        	sta (z80_ix),y		; set new x coordinate.
0002CAr 3               
0002CAr 3               ; Test new block.
0002CAr 3               
0002CAr 3  85 rr        	sta dispx 		; set x for block collision detection purposes.
0002CCr 3  A0 03        	ldy #3
0002CEr 3  B1 rr        	lda (z80_ix),y 		; get y.
0002D0r 3  85 rr        	sta dispy		; set coordinate for collision test.
0002D2r 3  20 rr rr     	jsr tstbl 		; get block type there.
0002D5r 3  C9 02        	cmp #WALL		; is it solid?
0002D7r 3  D0 03        	bne :+
0002D9r 3  4C rr rr     	jmp trailk		; yes, it cannot pass.
0002DCr 3               :
0002DCr 3               .if pflag .or dflag
0002DCr 3  C9 04                cmp #FODDER             ; is it fodder?
0002DEr 3  D0 06                bne :+
0002E0r 3  20 rr rr             jsr fdchk               ; remove fodder block.
0002E3r 3  4C rr rr             jmp trailk              ; destroy laser.
0002E6r 3               :
0002E6r 3               .endif
0002E6r 3  60           	rts
0002E7r 3               
0002E7r 3               ;----------------------------------------------------
0002E7r 3               ; Dots mask
0002E7r 3               ;----------------------------------------------------
0002E7r 3               
0002E7r 3  80 40 20 10  dots:	.byte 128,64,32,16,8,4,2,1
0002EBr 3  08 04 02 01  
0002EFr 3               
0002EFr 3               
0002EFr 3               ;----------------------------------------------------
0002EFr 3               ; Plot, preserving de.
0002EFr 3               ;----------------------------------------------------
0002EFr 3               
0002EFr 3               plotde:
0002EFr 3  A5 rr        	lda z80_d 		; put de on stack.
0002F1r 3  48           	pha
0002F2r 3  A5 rr        	lda z80_e
0002F4r 3  48           	pha
0002F5r 3               
0002F5r 3  20 rr rr     	jsr plot 		; plot pixel.
0002F8r 3               
0002F8r 3  68           	pla			; restore de from stack.
0002F9r 3  85 rr        	sta z80_e
0002FBr 3  68           	pla
0002FCr 3  85 rr        	sta z80_d
0002FEr 3               
0002FEr 3  60           	rts
0002FFr 3               
0002FFr 3               ;----------------------------------------------------
0002FFr 3               ; Shoot a laser.
0002FFr 3               ;----------------------------------------------------
0002FFr 3               
0002FFr 3               shoot:
0002FFr 3  85 rr        	sta z80_c		; store direction in c register.
000301r 3  A0 08        	ldy #8
000303r 3  B1 rr        	lda (z80_ix),y 		; y coordinate.
000305r 3  18           	clc
000306r 3               shoot1:
000306r 3  69 07        	adc #(SPR_HGT/2-1)	; down 7 pixels.
000308r 3  85 rr        	sta z80_l 		; puty y coordinate in l.
00030Ar 3               
00030Ar 3  A0 09        	ldy #9
00030Cr 3  B1 rr        	lda (z80_ix),y 		; x coordinate in h.
00030Er 3  85 rr        	sta z80_h
000310r 3               
000310r 3  A5 rr        	lda z80_i		; store pointer to sprite.
000312r 3  48           	pha
000313r 3  A5 rr        	lda z80_x
000315r 3  48           	pha
000316r 3               
000316r 3  20 rr rr     	jsr fpslot 		; find particle slot.
000319r 3  B0 03        	bcs :+
00031Br 3  4C rr rr     	jmp vapou2		; failed, restore ix.
00031Er 3               :
00031Er 3  A9 00        	lda #0
000320r 3  A0 00        	ldy #0
000322r 3  91 rr        	sta (z80_ix),y 		; set up a laser.
000324r 3               
000324r 3  A5 rr        	lda z80_c
000326r 3  A0 01        	ldy #1
000328r 3  91 rr        	sta (z80_ix),y 		; set the direction.
00032Ar 3               
00032Ar 3  A5 rr        	lda z80_l
00032Cr 3  A0 03        	ldy #3
00032Er 3  91 rr        	sta (z80_ix),y		; set y coordinate.
000330r 3               
000330r 3  66 rr        	ror z80_c		; check direction we want.
000332r 3  90 03        	bcc :+
000334r 3  4C rr rr     	jmp shootr		; shoot right.
000337r 3               :
000337r 3  A5 rr        	lda z80_h		; X position.
000339r 3               shoot0:
000339r 3  29 F8        	and #248		; align on character boundary.
00033Br 3  A0 05        	ldy #5
00033Dr 3  91 rr        	sta (z80_ix),y		; set x coordinate.
00033Fr 3  4C rr rr     	jmp vapou0 		; draw first image.
000342r 3               shootr:
000342r 3  A5 rr        	lda z80_h		; x position.
000344r 3  18           	clc
000345r 3  69 0F        	adc #15			; look right.
000347r 3  4C rr rr     	jmp shoot0		; align and continue.
00034Ar 3               
00034Ar 3               ;----------------------------------------------------
00034Ar 3               ; Create a bit of vapour trail.
00034Ar 3               ;----------------------------------------------------
00034Ar 3               
00034Ar 3               vapour:
00034Ar 3  A5 rr        	lda z80_i		; store pointer to sprite.
00034Cr 3  48           	pha
00034Dr 3  A5 rr        	lda z80_x
00034Fr 3  48           	pha
000350r 3               
000350r 3  A0 08        	ldy #8
000352r 3  B1 rr        	lda (z80_ix),y 		; y coordinate.
000354r 3  18           	clc
000355r 3               vapou3:
000355r 3  69 07        	adc #(SPR_HGT/2-1)	; mid-point of sprite.
000357r 3  85 rr        	sta z80_l
000359r 3               
000359r 3  A0 09        	ldy #9
00035Br 3  B1 rr        	lda (z80_ix),y 		; x coordinate.
00035Dr 3  69 07        	adc #7
00035Fr 3  85 rr        	sta z80_h
000361r 3               
000361r 3  20 rr rr     	jsr fpslot 		; find particle slot.
000364r 3  90 03        	bcc :+
000366r 3  4C rr rr     	jmp vapou1		; no, we can use it.
000369r 3               :
000369r 3               vapou2:
000369r 3  68           	pla
00036Ar 3  85 rr        	sta z80_x
00036Cr 3  68           	pla
00036Dr 3  85 rr        	sta z80_i
00036Fr 3  60           	rts
000370r 3               vapou1:
000370r 3  A5 rr        	lda z80_l
000372r 3  A0 03        	ldy #3
000374r 3  91 rr        	sta (z80_ix),y		; set up y.
000376r 3               
000376r 3  A5 rr        	lda z80_h
000378r 3  A0 05        	ldy #5
00037Ar 3  91 rr        	sta (z80_ix),y 		; set up x coordinate.
00037Cr 3               
00037Cr 3  20 rr rr     	jsr qrand		; get quick random number.
00037Fr 3  29 0F        	and #15			; random time.
000381r 3  18           	clc
000382r 3  69 0F        	adc #15			; minimum time on screen.
000384r 3  A0 01        	ldy #1
000386r 3  91 rr        	sta (z80_ix),y		; set time on screen.
000388r 3               
000388r 3  A9 01        	lda #1
00038Ar 3  A0 00        	ldy #0
00038Cr 3  91 rr        	sta (z80_ix),y		; define particle as vapour trail.
00038Er 3               vapou0:
00038Er 3  20 rr rr     	jsr chkxy		; plot first position.
000391r 3  4C rr rr     	jmp vapou2
000394r 3               
000394r 3               ;----------------------------------------------------
000394r 3               ; Create a user particle.
000394r 3               ;----------------------------------------------------
000394r 3               
000394r 3               ptusr:
000394r 3  85 rr        	sta z80_f		; store timer.
000396r 3               
000396r 3  A0 08        	ldy #8
000398r 3  B1 rr        	lda (z80_ix),y 		; y coordinate.
00039Ar 3  18           	clc
00039Br 3  69 07        	adc #7			; mid-point of sprite.
00039Dr 3  85 rr        	sta z80_l
00039Fr 3               
00039Fr 3  A0 09        	ldy #9
0003A1r 3  B1 rr        	lda (z80_ix),y 		; x coordinate.
0003A3r 3  18           	clc
0003A4r 3  69 07        	adc #7			; mid-point of sprite.
0003A6r 3  85 rr        	sta z80_h
0003A8r 3               
0003A8r 3  20 rr rr     	jsr fpslot 		; find particle slot.
0003ABr 3  B0 01        	bcs ptusr1
0003ADr 3  60           	rts 			; out of slots, can't generate anything.
0003AEr 3               ptusr1:
0003AEr 3  A5 rr        	lda z80_l
0003B0r 3  A0 03        	ldy #3
0003B2r 3  91 rr        	sta (z80_ix),y 		; set up y.
0003B4r 3               
0003B4r 3  A5 rr        	lda z80_h
0003B6r 3  A0 05        	ldy #5
0003B8r 3  91 rr        	sta (z80_ix),y		; set up x coordinate.
0003BAr 3               
0003BAr 3  A5 rr        	lda z80_f 		; restore timer.
0003BCr 3  A0 01        	ldy #1
0003BEr 3  91 rr        	sta (z80_ix),y		; set time on screen.
0003C0r 3               
0003C0r 3  A9 07        	lda #7
0003C2r 3  A0 00        	ldy #0
0003C4r 3  91 rr        	sta (z80_ix),y		; define particle as user particle.
0003C6r 3               
0003C6r 3  4C rr rr     	jmp chkxy		; plot first position.
0003C9r 3               
0003C9r 3               ;----------------------------------------------------
0003C9r 3               ; Create a vertical or horizontal star.
0003C9r 3               ;----------------------------------------------------
0003C9r 3               
0003C9r 3               star:
0003C9r 3  A5 rr        	lda z80_i		; store pointer to sprite.
0003CBr 3  48           	pha
0003CCr 3  A5 rr        	lda z80_x
0003CEr 3  48           	pha
0003CFr 3               
0003CFr 3  20 rr rr     	jsr fpslot 		; find particle slot.
0003D2r 3  B0 07        	bcs star7		; found one we can use.
0003D4r 3               star0:
0003D4r 3  68           	pla 			; restore sprite pointer.
0003D5r 3  85 rr        	sta z80_x
0003D7r 3  68           	pla
0003D8r 3  85 rr        	sta z80_i
0003DAr 3  60           	rts 			; out of slots, can't generate anything.
0003DBr 3               star7:
0003DBr 3  A5 rr        	lda z80_c		; direction.
0003DDr 3  29 03        	and #3 			; is it left?
0003DFr 3  D0 03        	bne :+
0003E1r 3  4C rr rr     	jmp star1 		; yes, it's left.
0003E4r 3               :
0003E4r 3  C9 01        	cmp #1 			; is it right?
0003E6r 3  D0 03        	bne :+
0003E8r 3  4C rr rr     	jmp star2 		; yes, it's right.
0003EBr 3               :
0003EBr 3  C9 02        	cmp #2 			; is it up?
0003EDr 3  D0 03        	bne :+
0003EFr 3  4C rr rr     	jmp star3 		; yes, it's up.
0003F2r 3               :
0003F2r 3  AC rr rr     	ldy wntopx 		; get edge of screen.
0003F5r 3  C8           	iny			; down one pixel.
0003F6r 3  98           	tya
0003F7r 3               star8:
0003F7r 3  A0 03        	ldy #3
0003F9r 3  91 rr        	sta (z80_ix),y 		; set y coord.
0003FBr 3  20 rr rr     	jsr qrand 		; get quick random number.
0003FEr 3               star9:
0003FEr 3  A0 05        	ldy #5
000400r 3  91 rr        	sta (z80_ix),y		; set x position.
000402r 3               
000402r 3  A5 rr        	lda z80_c		; direction.
000404r 3  29 03        	and #3			; zero to three.
000406r 3  18           	clc
000407r 3  69 03        	adc #3			; 3 to 6 for starfield.
000409r 3  A0 00        	ldy #0
00040Br 3  91 rr        	sta (z80_ix),y		; define particle as star.
00040Dr 3  20 rr rr     	jsr chkxy		; plot first position.
000410r 3  4C rr rr     	jmp star0
000413r 3               star1:
000413r 3  20 rr rr     	jsr qrand		; get quick random number.
000416r 3  A0 03        	ldy #3
000418r 3  91 rr        	sta (z80_ix),y 		; set y coord.
00041Ar 3               
00041Ar 3  AD rr rr     	lda wnrgtx 		; get edge of screen.
00041Dr 3  18           	clc
00041Er 3  69 0F        	adc #15			; add width of sprite minus 1.
000420r 3  4C rr rr     	jmp star9
000423r 3               star2:
000423r 3  20 rr rr     	jsr qrand 		; get quick random number.
000426r 3  A0 03        	ldy #3
000428r 3  91 rr        	sta (z80_ix),y		; set y coord.
00042Ar 3               
00042Ar 3  AD rr rr     	lda wnlftx		; get edge of screen.
00042Dr 3  4C rr rr     	jmp star9
000430r 3               star3:
000430r 3  AD rr rr     	lda wnbotx 		; get edge of screen.
000433r 3  18           	clc
000434r 3  69 0F        	adc #15 		; height of sprite minus one pixel.
000436r 3  4C rr rr     	jmp star8
000439r 3               
000439r 3               ;----------------------------------------------------
000439r 3               ; Find particle slot for lasers or vapour trail.
000439r 3               ; can't use alternate accumulator.
000439r 3               ;----------------------------------------------------
000439r 3               
000439r 3               fpslot:
000439r 3  A9 00        	lda #<SHRAPN 		; shrapnel table.
00043Br 3  85 rr        	sta z80_x
00043Dr 3  A9 09        	lda #>SHRAPN
00043Fr 3  85 rr        	sta z80_i
000441r 3               
000441r 3  A9 37        	lda #NUMSHR		; number of pieces in table.
000443r 3  85 rr        	sta z80_b
000445r 3               fpslt0:
000445r 3  A0 00        	ldy #0
000447r 3  B1 rr        	lda (z80_ix),y		; get type.
000449r 3  0A           	asl a  			; is this slot in use?
00044Ar 3  90 01        	bcc :+
00044Cr 3  60           	rts			; no, we can use it.
00044Dr 3               :
00044Dr 3  18           	clc			; point to more shrapnel.
00044Er 3  A5 rr        	lda z80_x
000450r 3  69 06        	adc #SHRSIZ
000452r 3  85 rr        	sta z80_x
000454r 3  90 02        	bcc :+
000456r 3  E6 rr        	inc z80_i
000458r 3               :
000458r 3  C6 rr        	dec z80_b		; repeat for all shrapnel.
00045Ar 3  D0 E9        	bne fpslt0
00045Cr 3               
00045Cr 3  18           	clc
00045Dr 3  60           	rts 			; out of slots, can't generate anything.
00045Er 3               
00045Er 3               ;----------------------------------------------------
00045Er 3               ; Create an explosion at sprite position.
00045Er 3               ;----------------------------------------------------
00045Er 3               
00045Er 3               explod:
00045Er 3  85 rr        	sta z80_c 		; particles to create.
000460r 3               
000460r 3  A5 rr        	lda z80_i 		; store pointer to sprite.
000462r 3  48           	pha
000463r 3  A5 rr        	lda z80_x
000465r 3  48           	pha
000466r 3               
000466r 3  A0 08        	ldy #8
000468r 3  B1 rr        	lda (z80_ix),y 		; y coordinate.
00046Ar 3  85 rr        	sta z80_l
00046Cr 3  A0 09        	ldy #9
00046Er 3  B1 rr        	lda (z80_ix),y		; x coordinate.
000470r 3  85 rr        	sta z80_h
000472r 3               
000472r 3  A9 00        	lda #<SHRAPN		; shrapnel table.
000474r 3  85 rr        	sta z80_x
000476r 3  A9 09        	lda #>SHRAPN
000478r 3  85 rr        	sta z80_i
00047Ar 3               
00047Ar 3  A9 37        	lda #NUMSHR		; number of pieces in table.
00047Cr 3  85 rr        	sta explcnt
00047Er 3               expld0:
00047Er 3  A0 00        	ldy #0
000480r 3  B1 rr        	lda (z80_ix),y		; get type.
000482r 3  0A           	asl a 			; is this slot in use?
000483r 3  B0 16        	bcs expld1		; no, we can use it.
000485r 3               expld2:
000485r 3  18           	clc
000486r 3  A5 rr        	lda z80_x
000488r 3  69 06        	adc #SHRSIZ
00048Ar 3  85 rr        	sta z80_x
00048Cr 3  90 02        	bcc :+
00048Er 3  E6 rr        	inc z80_i
000490r 3               :
000490r 3  C6 rr        	dec explcnt		; repeat for all shrapnel.
000492r 3  D0 EA        	bne expld0
000494r 3               expld3:
000494r 3  68           	pla			; restore sprite pointer.
000495r 3  85 rr        	sta z80_x
000497r 3  68           	pla
000498r 3  85 rr        	sta z80_i
00049Ar 3  60           	rts 			; out of slots, can't generate any more.
00049Br 3               
00049Br 3               expld1:
00049Br 3  A5 rr        	lda z80_c		; shrapnel counter.
00049Dr 3  29 0F        	and #15			; 0 to 15.
00049Fr 3  18           	clc			; add to x.
0004A0r 3  65 rr        	adc z80_l
0004A2r 3  A0 03        	ldy #3
0004A4r 3  91 rr        	sta (z80_ix),y		; y coord.
0004A6r 3               
0004A6r 3  A5 rr        	lda seed3 		; crap random number.
0004A8r 3  29 0F        	and #15			; 0 to 15.
0004AAr 3  18           	clc 			; add to y.
0004ABr 3  65 rr        	adc z80_h
0004ADr 3  A0 05        	ldy #5
0004AFr 3  91 rr        	sta (z80_ix),y		; x coord.
0004B1r 3               
0004B1r 3  A9 02        	lda #2
0004B3r 3  A0 00        	ldy #0
0004B5r 3  91 rr        	sta (z80_ix),y		; switch it on.
0004B7r 3               
0004B7r 3  20 rr rr     	jsr chkxy		; plot first position.
0004BAr 3  20 rr rr     	jsr qrand		; quick random angle.
0004BDr 3  29 3C        	and #60 		; keep within range.
0004BFr 3  A0 01        	ldy #1
0004C1r 3  91 rr        	sta (z80_ix),y		; angle.
0004C3r 3               
0004C3r 3  C6 rr        	dec z80_c		; one less piece of shrapnel to generate.
0004C5r 3  D0 BE        	bne expld2 		; back to main explosion loop.
0004C7r 3  4C rr rr     	jmp expld3 		; restore sprite pointer and exit.
0004CAr 3               
0004CAr 3               ;----------------------------------------------------
0004CAr 3               ; Quick random
0004CAr 3               ;----------------------------------------------------
0004CAr 3               
0004CAr 3               qrand:
0004CAr 3  20 rr rr     	jsr random		; r register.
0004CDr 3  45 rr        	eor seed3		; combine with seed.
0004CFr 3  85 rr        	sta seed3 		; new seed.
0004D1r 3  60           	rts
0004D2r 3               
0004D2r 3               ;----------------------------------------------------
0004D2r 3               ; Display all shrapnel.
0004D2r 3               ;----------------------------------------------------
0004D2r 3               
0004D2r 3               dshrp:
0004D2r 3  A9 rr        	lda #<plotde		; display routine.
0004D4r 3  8D rr rr     	sta proshx+1
0004D7r 3  A9 rr        	lda #>plotde
0004D9r 3  8D rr rr     	sta proshx+2
0004DCr 3  20 rr rr     	jsr proshr		; process shrapnel.
0004DFr 3               
0004DFr 3  A9 rr        	lda #<prosh1		; processing routine.
0004E1r 3  8D rr rr     	sta proshx+1
0004E4r 3  A9 rr        	lda #>prosh1
0004E6r 3  8D rr rr     	sta proshx+2
0004E9r 3  60           	rts
0004EAr 3               
0004EAr 3               ;------------------------------------------------------
0004EAr 3               ; Particle engine.
0004EAr 3               ;
0004EAr 3               ; Init particle data for 55 particles in SHRAPN table.
0004EAr 3               ; Every particle has 6 bytes.
0004EAr 3               ;
0004EAr 3               ; global:	-
0004EAr 3               ; local:	x,y,hl
0004EAr 3               ; calls:	-
0004EAr 3               ;------------------------------------------------------
0004EAr 3               
0004EAr 3               inishr:
0004EAr 3  A9 00        	lda #<SHRAPN 		; table.
0004ECr 3  85 rr        	sta z80_l
0004EEr 3  A9 09        	lda #>SHRAPN
0004F0r 3  85 rr        	sta z80_h
0004F2r 3               
0004F2r 3  A0 00        	ldy #0
0004F4r 3  A2 37        	ldx #NUMSHR		; shrapnel pieces to process.
0004F6r 3               inish0:
0004F6r 3  A9 FF        	lda #255 		; kill the shrapnel.
0004F8r 3  91 rr        	sta (z80_hl),y
0004FAr 3               
0004FAr 3  18           	clc 			; point there.
0004FBr 3  A5 rr        	lda z80_l
0004FDr 3  69 06        	adc #SHRSIZ		; distance to next.
0004FFr 3  85 rr        	sta z80_l
000501r 3  90 02        	bcc :+
000503r 3  E6 rr        	inc z80_h
000505r 3               :
000505r 3  CA           	dex
000506r 3  D0 EE        	bne inish0 		; round again.
000508r 3  60           	rts
000509r 3               
000509r 3               ;------------------------------------------------------
000509r 3               ; Check for collision between laser and sprite.
000509r 3               ;------------------------------------------------------
000509r 3               
000509r 3               lcol:
000509r 3  A9 00        	lda #<SHRAPN		; shrapnel table.
00050Br 3  85 rr        	sta z80_l
00050Dr 3  A9 09        	lda #>SHRAPN
00050Fr 3  85 rr        	sta z80_h
000511r 3               
000511r 3  A9 37        	lda #NUMSHR		; number of pieces in table.
000513r 3  85 rr        	sta z80_b
000515r 3               lcol0:
000515r 3  A0 00        	ldy #0
000517r 3  B1 rr        	lda (z80_hl),y 		; get type.
000519r 3  F0 11        	beq lcol1		; yes, check collision.
00051Br 3               lcol3:
00051Br 3  18           	clc			; point to more shrapnel.
00051Cr 3  A5 rr        	lda z80_l
00051Er 3  69 06        	adc #SHRSIZ
000520r 3  85 rr        	sta z80_l
000522r 3  90 02        	bcc :+
000524r 3  E6 rr        	inc z80_h
000526r 3               :
000526r 3  C6 rr        	dec z80_b		; repeat for all shrapnel.
000528r 3  D0 EB        	bne lcol0
00052Ar 3  18           	clc
00052Br 3  60           	rts 			; no collision, carry not set.
00052Cr 3               lcol1:
00052Cr 3  A0 03        	ldy #3
00052Er 3  B1 rr        	lda (z80_hl),y		; get y.
000530r 3  38           	sec
000531r 3  A0 08        	ldy #8
000533r 3  F1 rr        	sbc (z80_ix),y		; subtract sprite y.
000535r 3               lcolh:
000535r 3  C9 10        	cmp #SPR_HGT 		; within range?
000537r 3  90 03        	bcc :+
000539r 3  4C rr rr     	jmp lcol2		; no, missed.
00053Cr 3               :
00053Cr 3  A0 05        	ldy #5
00053Er 3  B1 rr        	lda (z80_hl),y 		; get x.
000540r 3  38           	sec
000541r 3  A0 09        	ldy #9
000543r 3  F1 rr        	sbc (z80_ix),y 		; subtract sprite y.
000545r 3  C9 10        	cmp #16			; within range?
000547r 3  B0 03        	bcs :+
000549r 3  4C rr rr     	jmp lcol4 		; yes, collision occurred.
00054Cr 3               :
00054Cr 3               lcol2:
00054Cr 3  4C rr rr     	jmp lcol3
00054Fr 3               lcol4:
00054Fr 3  38           	sec
000550r 3  60           	rts 			; return with carry set for collision.
000551r 3               .endif
000551r 3               
000551r 3               ;------------------------------------------------------
000551r 3               ; Main game engine code starts here.
000551r 3               ; After initialisation, mloop is the main loop
000551r 3               ;------------------------------------------------------
000551r 3               
000551r 3               game:
000551r 3               
000551r 3               ; Set up screen address table.
000551r 3               
000551r 3               setsat:
000551r 3  A9 00        	lda #<CharAddress	; start of screen.
000553r 3  85 rr        	sta scraddr
000555r 3  A9 10        	lda #>CharAddress
000557r 3  85 rr        	sta scraddr+1
000559r 3               
000559r 3  A0 00        	ldy #0			; vertical lines on screen.
00055Br 3               setsa0:
00055Br 3  A5 rr        	lda scraddr
00055Dr 3  99 00 07     	sta SCADTB_lb,y		; write low byte.
000560r 3  A5 rr        	lda scraddr+1
000562r 3  99 00 08     	sta SCADTB_hb,y		; write high byte.
000565r 3  20 rr rr     	jsr nline		; next line down.
000568r 3  C8           	iny			; next position in table.
000569r 3  D0 F0        	bne setsa0
00056Br 3               
00056Br 3               ; Set up colour address table
00056Br 3               
00056Br 3               setsof:
00056Br 3  A9 00        	lda #<ColorAttr		; start of colour attributes
00056Dr 3  85 rr        	sta bufaddr
00056Fr 3  A9 96        	lda #>ColorAttr
000571r 3  85 rr        	sta bufaddr+1
000573r 3               
000573r 3  A0 00        	ldy #0			; vertical lines on screen.
000575r 3               setof0:
000575r 3  A5 rr        	lda bufaddr
000577r 3  99 4A 0A     	sta COLATTTB_lb,y	; write low byte.
00057Ar 3  A5 rr        	lda bufaddr+1
00057Cr 3  99 55 0A     	sta COLATTTB_hb,y	; write high byte.
00057Fr 3  18           	clc			; next line down.
000580r 3  A5 rr        	lda bufaddr
000582r 3  69 16        	adc #ScrWidth
000584r 3  85 rr        	sta bufaddr
000586r 3  90 02        	bcc :+
000588r 3  E6 rr        	inc bufaddr+1
00058Ar 3               :
00058Ar 3  C8           	iny			; next position in table.
00058Br 3  C0 0B        	cpy #ScrHeight/2
00058Dr 3  D0 E6        	bne setof0
00058Fr 3               
00058Fr 3               ; Init graphics mode
00058Fr 3               
00058Fr 3  20 rr rr     	jsr init
000592r 3               
000592r 3               ; Init joysticks
000592r 3  20 rr rr     	jsr joyinit		; VIC20 joystick
000595r 3               
000595r 3               rpblc2:
000595r 3               .if pflag
000595r 3  20 rr rr     	jsr inishr 		; initialise particle engine.
000598r 3               .endif
000598r 3               evintr:
000598r 3  20 rr rr     	jsr evnt12 		; call intro/menu event.
00059Br 3               
00059Br 3  A9 02        	lda #WALL 		; write default property.
00059Dr 3  A2 00        	ldx #0
00059Fr 3               clrmap:
00059Fr 3  9D 00 04     	sta MAP,x 		; block properties.
0005A2r 3  9D 00 05     	sta MAP+256,x
0005A5r 3  E8           	inx
0005A6r 3  D0 F7        	bne clrmap
0005A8r 3               
0005A8r 3               .if oflag
0005A8r 3               	jsr iniob 		; initialise objects.
0005A8r 3               .endif
0005A8r 3  A9 00        	lda #0			; put zero in accumulator.
0005AAr 3  85 rr        	sta gamwon		; reset game won flag.
0005ACr 3               
0005ACr 3  20 rr rr     	jsr inisc 		; init the score.
0005AFr 3               mapst:
0005AFr 3  AD rr rr     	lda stmap 		; start position on map.
0005B2r 3  8D rr rr     	sta roomtb		; set up position in table, if there is one.
0005B5r 3               
0005B5r 3               inipbl:
0005B5r 3               .if aflag
0005B5r 3               	lda #<eop		; reset blockpointer
0005B5r 3               	sta pbptr
0005B5r 3               	lda #>eop
0005B5r 3               	sta pbptr+1
0005B5r 3               .endif
0005B5r 3  20 rr rr     	jsr initsc 		; set up first screen.
0005B8r 3               
0005B8r 3  A9 rr        	lda #<ssprit 		; default to spare sprite in table.
0005BAr 3  85 rr        	sta z80_x
0005BCr 3  A9 rr        	lda #>ssprit
0005BEr 3  85 rr        	sta z80_i
0005C0r 3               evini:
0005C0r 3  20 rr rr     	jsr evnt13 		; initialisation.
0005C3r 3               
0005C3r 3               ; Two restarts.
0005C3r 3               ; First restart - clear all sprites and initialise everything.
0005C3r 3               
0005C3r 3               rstrt:
0005C3r 3  20 rr rr     	jsr rsevt 		; restart events.
0005C6r 3  20 rr rr     	jsr xspr 		; clear sprite table.
0005C9r 3  20 rr rr     	jsr sprlst 		; fetch pointer to screen sprites.
0005CCr 3  20 rr rr     	jsr ispr 		; initialise sprite table.
0005CFr 3  4C rr rr     	jmp rstrt0
0005D2r 3               
0005D2r 3               ; Second restart - clear all but player, and don't initialise him.
0005D2r 3               
0005D2r 3               rstrtn:
0005D2r 3  20 rr rr     	jsr rsevt		; restart events.
0005D5r 3  20 rr rr     	jsr nspr 		; clear all non-player sprites.
0005D8r 3  20 rr rr     	jsr sprlst 		; fetch pointer to screen sprites.
0005DBr 3  20 rr rr     	jsr kspr 		; initialise sprite table, no more players.
0005DEr 3               
0005DEr 3               ; Set up the player and/or enemy sprites.
0005DEr 3               
0005DEr 3               rstrt0:
0005DEr 3  A9 00        	lda #0 			; zero in accumulator.
0005E0r 3  85 rr        	sta nexlev 		; reset next level flag.
0005E2r 3  85 rr        	sta restfl 		; reset restart flag.
0005E4r 3  85 rr        	sta deadf 		; reset dead flag.
0005E6r 3               
0005E6r 3  20 rr rr     	jsr droom 		; show screen layout.
0005E9r 3               rpblc0:
0005E9r 3               .if pflag
0005E9r 3  20 rr rr     	jsr inishr 		; initialise particle engine.
0005ECr 3               .endif
0005ECr 3               .if aflag
0005ECr 3               	jsr rbloc		; draw blocks for this screen
0005ECr 3               .endif
0005ECr 3               .if oflag
0005ECr 3               	jsr shwob		; draw objects.
0005ECr 3               .endif
0005ECr 3               
0005ECr 3  A9 rr        	lda #<sprtab 		; address of sprite table, even sprites.
0005EEr 3  85 rr        	sta z80_x
0005F0r 3  A9 rr        	lda #>sprtab
0005F2r 3  85 rr        	sta z80_i
0005F4r 3  20 rr rr     	jsr dspr 		; display sprites.
0005F7r 3  A9 rr        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
0005F9r 3  85 rr        	sta z80_x
0005FBr 3  A9 rr        	lda #>(sprtab+TABSIZ)
0005FDr 3  85 rr        	sta z80_i
0005FFr 3  20 rr rr     	jsr dspr 		; display sprites.
000602r 3               mloop:
000602r 3  20 rr rr     	jsr vsync 		; synchronise with display.
000605r 3               
000605r 3  A9 rr        	lda #<sprtab 		; address of sprite table, even sprites.
000607r 3  85 rr        	sta z80_x
000609r 3  A9 rr        	lda #>sprtab
00060Br 3  85 rr        	sta z80_i
00060Dr 3  20 rr rr     	jsr dspr 		; display even sprites.
000610r 3               
000610r 3               ;	jsr plsnd 		; play sounds.
000610r 3  20 rr rr     	jsr vsync 		; synchronise with display.
000613r 3  20 rr rr     	jsr proshr
000616r 3               
000616r 3  A9 rr        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
000618r 3  85 rr        	sta z80_x
00061Ar 3  A9 rr        	lda #>(sprtab+TABSIZ)
00061Cr 3  85 rr        	sta z80_i
00061Er 3  20 rr rr     	jsr dspr 		; display odd sprites.
000621r 3               
000621r 3  A9 rr        	lda #<(ssprit) 		; point to spare sprite for spawning purposes.
000623r 3  85 rr        	sta z80_x
000625r 3  A9 rr        	lda #>(ssprit)
000627r 3  85 rr        	sta z80_i
000629r 3               evlp1:
000629r 3  20 rr rr     	jsr evnt10 		; called once per main loop.
00062Cr 3  20 rr rr     	jsr pspr 		; process sprites.
00062Fr 3               
00062Fr 3               ; Main loop events.
00062Fr 3               
00062Fr 3  A9 rr        	lda #<ssprit 		; point to spare sprite for spawning purposes.
000631r 3  85 rr        	sta z80_x
000633r 3  A9 rr        	lda #>ssprit
000635r 3  85 rr        	sta z80_i
000637r 3               evlp2:
000637r 3  20 rr rr     	jsr evnt11 		; called once per main loop.
00063Ar 3               bsortx:
00063Ar 3  20 rr rr     	jsr bsort 		; sort sprites.
00063Dr 3               
00063Dr 3  A5 rr        	lda nexlev		; finished level flag.
00063Fr 3  D0 1F        	bne newlev		; is set, go to next level.
000641r 3  A5 rr        	lda gamwon		; finished game flag.
000643r 3  D0 2A        	bne evwon		; is set, finish the game.
000645r 3  A5 rr        	lda restfl 		; finished level flag.
000647r 3  C9 01        	cmp #1			; has it been set?
000649r 3  D0 03        	bne :+
00064Br 3  4C rr rr     	jmp rstrt		; yes, go to next level.
00064Er 3               :
00064Er 3  C9 02        	cmp #2			; has it been set?
000650r 3  D0 03        	bne :+
000652r 3  4C rr rr     	jmp rstrtn		; yes, go to next level.
000655r 3               :
000655r 3  A5 rr        	lda deadf 		; dead flag.
000657r 3  D0 1C        	bne pdead		; yes, player dead.
000659r 3               
000659r 3               ; back to start of main loop.
000659r 3               
000659r 3  E6 rr        	inc frmno
00065Br 3  E6 rr        	inc clock
00065Dr 3  4C rr rr     	jmp mloop		; switched to a jmp mloop during test mode.
000660r 3               
000660r 3               ;----------------------------------------------------------
000660r 3               ; Read blocks from list and update screen accordingly.
000660r 3               ;----------------------------------------------------------
000660r 3               
000660r 3               .if aflag
000660r 3               rbloc:
000660r 3               	lda #<eop		; reset blockpointer
000660r 3               	sta pbbuf
000660r 3               	lda #>eop
000660r 3               	sta pbbuf+1
000660r 3               
000660r 3               rbloc2:
000660r 3               	lda pbbuf			; check for last block
000660r 3               	cmp pbptr
000660r 3               	bne rbloc1
000660r 3               	lda pbbuf+1
000660r 3               	cmp pbptr+1
000660r 3               	bne rbloc1
000660r 3               	rts
000660r 3               rbloc1:
000660r 3               	ldy #0
000660r 3               	lda (pbbuf),y		; check if block for this scno
000660r 3               	cmp scno
000660r 3               	bne rbloc0		; if not, skip
000660r 3               	iny
000660r 3               	lda (pbbuf),y		; get y
000660r 3               	sta dispy
000660r 3               	iny
000660r 3               	lda (pbbuf),y		; get x
000660r 3               	sta dispx
000660r 3               	iny
000660r 3               	lda (pbbuf),y		; get blocknr
000660r 3               	jsr pattr2		; draw block
000660r 3               rbloc0:
000660r 3               	clc			; point to next block
000660r 3               	lda pbbuf
000660r 3               	adc #4
000660r 3               	sta pbbuf
000660r 3               	bcc rbloc2
000660r 3               	inc pbbuf+1
000660r 3               	jmp rbloc2
000660r 3               .endif
000660r 3               
000660r 3               ;----------------------------------------------------------
000660r 3               ; New level
000660r 3               ;----------------------------------------------------------
000660r 3               
000660r 3               newlev:
000660r 3  A5 rr        	lda scno 			; current screen.
000662r 3  18           	clc
000663r 3  69 01        	adc #1				; next screen.
000665r 3  CD rr rr     	cmp numsc 			; total number of screens.
000668r 3  B0 05        	bcs evwon			; yes, game finished.
00066Ar 3  85 rr        	sta scno			; set new level number.
00066Cr 3  4C rr rr     	jmp rstrt			; restart, clearing all aliens.
00066Fr 3               
00066Fr 3               evwon:
00066Fr 3  20 rr rr     	jsr evnt18		 	; game completed.
000672r 3  4C rr rr     	jmp tidyup			; tidy up and return to BASIC/calling routine.
000675r 3               
000675r 3               ;----------------------------------------------------------
000675r 3               ; Player dead.
000675r 3               ;----------------------------------------------------------
000675r 3               
000675r 3               pdead:
000675r 3  A9 00        	lda #0				; zeroise accumulator.
000677r 3  85 rr        	sta deadf			; reset dead flag.
000679r 3               evdie:
000679r 3  20 rr rr     	jsr evnt16 			; death subroutine.
00067Cr 3  A5 rr        	lda numlif			; number of lives.
00067Er 3  F0 03        	beq :+
000680r 3  4C rr rr     	jmp rstrt 			; restart game.
000683r 3               :
000683r 3               evfail:
000683r 3  20 rr rr     	jsr evnt17 			; failure event.
000686r 3  4C rr rr     	jmp game			; restart game
000689r 3               
000689r 3               ;----------------------------------------------------------
000689r 3               ; Tidy things up
000689r 3               ;----------------------------------------------------------
000689r 3               
000689r 3               tidyup:
000689r 3  A0 00        	ldy #0				; digits to check.
00068Br 3               tidyu2:
00068Br 3  B9 rr rr     	lda score,y 			; get score digit.
00068Er 3  CD rr rr     	cmp hiscor 			; are we larger than high score digit?
000691r 3  90 07        	bcc tidyu0			; high score is bigger.
000693r 3  D0 0E        	bne tidyu1			; score is greater, record new high score.
000695r 3  C8           	iny				; next digit of high score.
000696r 3  C0 06        	cpy #6
000698r 3  D0 F1        	bne tidyu2			; repeat for all digits
00069Ar 3               tidyu0:
00069Ar 3  A9 rr        	lda #<score			; return pointing to score.
00069Cr 3  85 rr        	sta z80_c
00069Er 3  A9 rr        	lda #>score
0006A0r 3  85 rr        	sta z80_b
0006A2r 3  60           	rts
0006A3r 3               tidyu1:
0006A3r 3  A0 05        	ldy #5
0006A5r 3               tidyu3:
0006A5r 3  B9 rr rr     	lda score,y			; score.
0006A8r 3  99 rr rr     	sta hiscor,y			; high score.
0006ABr 3  88           	dey
0006ACr 3  10 F7        	bpl tidyu3 			; copy score to high score.
0006AEr 3               evnewh:
0006AEr 3  20 rr rr     	jsr evnt19			; new high score event.
0006B1r 3  4C rr rr     	jmp tidyu0			; tidy up.
0006B4r 3               
0006B4r 3               ;--------------------------------------------------
0006B4r 3               ; Restart event.
0006B4r 3               ;--------------------------------------------------
0006B4r 3               
0006B4r 3               rsevt:
0006B4r 3  A9 rr        	lda #<ssprit 			; default to spare element in table.
0006B6r 3  85 rr        	sta z80_x
0006B8r 3  A9 rr        	lda #>ssprit
0006BAr 3  85 rr        	sta z80_i
0006BCr 3               
0006BCr 3               evrs:
0006BCr 3  4C rr rr     	jmp evnt14	 		; call restart event.
0006BFr 3               
0006BFr 3               ;------------------------------------------------------------------
0006BFr 3               ; Copy number passed in a to string position bc, right-justified.
0006BFr 3               ;
0006BFr 3               ; Input:
0006BFr 3               ;  A  = number
0006BFr 3               ;  BC = string address
0006BFr 3               ;
0006BFr 3               ; Output:
0006BFr 3               ;  BC = string with number
0006BFr 3               ;-----------------------------------------------------------------
0006BFr 3               
0006BFr 3               num2ch:
0006BFr 3  85 rr        	sta z80_d		; Save number
0006C1r 3               
0006C1r 3  A9 00        	lda #0
0006C3r 3  85 rr        	sta flag
0006C5r 3               numdg3:
0006C5r 3  A2 64        	ldx #100		; hundreds column.
0006C7r 3  86 rr        	stx z80_e
0006C9r 3  20 rr rr     	jsr numdg		; show digit.
0006CCr 3               numdg2:
0006CCr 3  A2 0A        	ldx #10			; tens column.
0006CEr 3  86 rr        	stx z80_e
0006D0r 3  20 rr rr     	jsr numdg		; show digit.
0006D3r 3               
0006D3r 3  E6 rr        	inc flag
0006D5r 3  A2 01        	ldx #1			; units column.
0006D7r 3  86 rr        	stx z80_e
0006D9r 3               numdg:
0006D9r 3  A9 30        	lda #48			; clear digit.
0006DBr 3  85 rr        	sta z80_a
0006DDr 3               numdg1:
0006DDr 3  A5 rr        	lda z80_d
0006DFr 3  C5 rr        	cmp z80_e
0006E1r 3  90 0E        	bcc numdg0		; nothing to show.
0006E3r 3  38           	sec
0006E4r 3  A5 rr        	lda z80_d
0006E6r 3  E5 rr        	sbc z80_e		; subtract from column.
0006E8r 3  85 rr        	sta z80_d
0006EAr 3  E6 rr        	inc z80_a		; increment digit.
0006ECr 3  E6 rr        	inc flag
0006EEr 3  4C rr rr     	jmp numdg1		; repeat until column is zero.
0006F1r 3               numdg0:
0006F1r 3  A0 00        	ldy #0
0006F3r 3  A5 rr        	lda z80_a
0006F5r 3  91 rr        	sta (z80_bc),y		; write digit to buffer.
0006F7r 3  A5 rr        	lda flag
0006F9r 3  F0 06        	beq :+
0006FBr 3  E6 rr        	inc z80_c		; next buffer position.
0006FDr 3  D0 02        	bne :+
0006FFr 3  E6 rr        	inc z80_b
000701r 3               :
000701r 3  60           	rts
000702r 3               num2dd:
000702r 3  85 rr        	sta z80_d		; Save number
000704r 3               
000704r 3  A9 01        	lda #1
000706r 3  85 rr        	sta flag
000708r 3               
000708r 3  4C rr rr     	jmp numdg2
00070Br 3               num2td:
00070Br 3  85 rr        	sta z80_d		; Save number
00070Dr 3               
00070Dr 3  A9 01        	lda #1
00070Fr 3  85 rr        	sta flag
000711r 3  4C rr rr     	jmp numdg3
000714r 3               
000714r 3               ;---------------------------------------------------------
000714r 3               ; Reset score to "000000"
000714r 3               ;---------------------------------------------------------
000714r 3               
000714r 3               inisc:
000714r 3  A9 30        	lda #'0'
000716r 3  A2 05        	ldx #5			; digits to initialise.
000718r 3               inisc0:
000718r 3  9D rr rr     	sta score,x 		; write zero digit.
00071Br 3  CA           	dex			; next column.
00071Cr 3  10 FA        	bpl inisc0		; repeat for all digits.
00071Er 3               
00071Er 3  60           	rts
00071Fr 3               
00071Fr 3               ;-----------------------------------------------------
00071Fr 3               ; Multiply h by d and return in hl.
00071Fr 3               ;
00071Fr 3               ; Input:
00071Fr 3               ;  H = first number
00071Fr 3               ;  D = second number
00071Fr 3               ;
00071Fr 3               ; Output:
00071Fr 3               ;  HL = result H x D
00071Fr 3               ;-----------------------------------------------------
00071Fr 3               
00071Fr 3               imul:
00071Fr 3  A5 rr        	lda z80_d		; HL = H * D
000721r 3  85 rr        	sta z80_e
000723r 3  A5 rr        	lda z80_h
000725r 3  85 rr        	sta z80_c		; make c first multiplier.
000727r 3               imul0:
000727r 3  A9 00        	lda #0			; zeroise total.
000729r 3  85 rr        	sta z80_l
00072Br 3  85 rr        	sta z80_h
00072Dr 3               
00072Dr 3  A5 rr        	lda z80_h
00072Fr 3  85 rr        	sta z80_d		; zeroise high byte.
000731r 3               
000731r 3  A9 08        	lda #8			; repeat 8 times.
000733r 3  85 rr        	sta z80_b
000735r 3               imul1:
000735r 3  46 rr        	lsr z80_c		; rotate rightmost bit into carry.
000737r 3  90 0E        	bcc imul2		; wasn't set.
000739r 3  18           	clc			; bit was set, so add de.
00073Ar 3  A5 rr        	lda z80_l
00073Cr 3  65 rr        	adc z80_e
00073Er 3  85 rr        	sta z80_l
000740r 3  A5 rr        	lda z80_h
000742r 3  65 rr        	adc z80_d
000744r 3  85 rr        	sta z80_h
000746r 3  18           	clc 			; reset carry.
000747r 3               imul2:
000747r 3  26 rr        	rol z80_e 		; shift de 1 bit left.
000749r 3  26 rr        	rol z80_d
00074Br 3  C6 rr        	dec z80_b
00074Dr 3  D0 E6        	bne imul1		; repeat 8 times.
00074Fr 3               
00074Fr 3  60           	rts
000750r 3               
000750r 3               ;-----------------------------------------------
000750r 3               ; Divide d by e and return in d, remainder in a.
000750r 3               ;
000750r 3               ; Input:
000750r 3               ;  D = first number
000750r 3               ;  E = second number
000750r 3               ;
000750r 3               ; Output:
000750r 3               ;  D = result D/E
000750r 3               ;  A = remainder
000750r 3               ;-----------------------------------------------
000750r 3               
000750r 3               idiv:
000750r 3  A9 00        	lda #0
000752r 3  A0 08        	ldy #8		 	; bits to shift.
000754r 3  06 rr        	asl z80_d
000756r 3               idiv0:
000756r 3  2A           	rol a 			; multiply d by 2.
000757r 3  C5 rr        	cmp z80_e 		; test if e is smaller.
000759r 3  90 02        	bcc idiv1		; e is greater, no division this time.
00075Br 3  E5 rr        	sbc z80_e		; subtract it.
00075Dr 3               idiv1:
00075Dr 3  26 rr        	rol z80_d		; rotate into d.
00075Fr 3  88           	dey
000760r 3  D0 F4        	bne idiv0		; repeat
000762r 3  60           	rts
000763r 3               
000763r 3               ;---------------------------------------------------
000763r 3               ; Play AY sound effect
000763r 3               ;---------------------------------------------------
000763r 3               
000763r 3               plsnd:
000763r 3  60           	rts
000764r 3               
000764r 3               ;---------------------------------------------------
000764r 3               ; Objects handling.
000764r 3               ; 32 bytes for image
000764r 3               ; 1 for colour
000764r 3               ; 3 for room, y and x
000764r 3               ; 3 for starting room, y and x.
000764r 3               ; 254 = disabled.
000764r 3               ; 255 = object in player"s pockets.
000764r 3               ;---------------------------------------------------
000764r 3               
000764r 3               ;---------------------------------------------------
000764r 3               ; Show items present.
000764r 3               ;---------------------------------------------------
000764r 3               
000764r 3               .if oflag
000764r 3               shwob:
000764r 3               	lda #<objdta			; objects table.
000764r 3               	sta z80_l
000764r 3               	lda #>objdta
000764r 3               	sta z80_h
000764r 3               	lda numob 			; number of objects in the game.
000764r 3               	sta sprcnt
000764r 3               shwob0:
000764r 3               	ldy #33 			; distance to room number.
000764r 3               	lda (z80_hl),y 			; same as an item?
000764r 3               	cmp scno 			; current location.
000764r 3               	bne :+
000764r 3               	jsr dobj 			; yes, display object.
000764r 3               :
000764r 3               	clc
000764r 3               	lda z80_l
000764r 3               	adc #39 			; distance to next item.
000764r 3               	sta z80_l
000764r 3               	lda z80_h
000764r 3               	adc #0
000764r 3               	sta z80_h	 		; point to it.
000764r 3               	dec sprcnt
000764r 3               	bne shwob0 			; repeat for others.
000764r 3               	rts
000764r 3               
000764r 3               ;---------------------------------------------------
000764r 3               ; Display object.
000764r 3               ; hl must point to object's start address.
000764r 3               ;
000764r 3               ; Input:
000764r 3               ;  HL = object address
000764r 3               ;---------------------------------------------------
000764r 3               
000764r 3               dobj:
000764r 3               	ldy #32
000764r 3               	lda (z80_hl),y 			; point to y.
000764r 3               	sta objcol
000764r 3               	ldy #34
000764r 3               	lda (z80_hl),y 			; point to y.
000764r 3               	sta dispy
000764r 3               	iny
000764r 3               	lda (z80_hl),y 			; point to x.
000764r 3               	sta dispx
000764r 3               dobj1:
000764r 3               	jmp sprite 			; draw this sprite.
000764r 3               
000764r 3               ;--------------------------------------
000764r 3               ; Remove an object.
000764r 3               ;
000764r 3               ; Input:
000764r 3               ;  A = object number
000764r 3               ;--------------------------------------
000764r 3               
000764r 3               remob:
000764r 3               	cmp numob			; number of objects in game.
000764r 3               	bcc :+				; are we checking past the end?
000764r 3               	rts				; yes, can't get non-existent item.
000764r 3               :
000764r 3               	pha				; remember object.
000764r 3               	jsr getob			; pick it up if we haven't already got it.
000764r 3               	pla				; retrieve object number.
000764r 3               	jsr gotob			; get its address.
000764r 3               	lda #254
000764r 3               	ldy #33
000764r 3               	sta (z80_hl),y			; remove it.
000764r 3               	rts
000764r 3               
000764r 3               ;---------------------------------------------------
000764r 3               ; Pick up object number held in the accumulator.
000764r 3               ;
000764r 3               ; Input:
000764r 3               ;  A = object number
000764r 3               ;---------------------------------------------------
000764r 3               
000764r 3               getob:
000764r 3               	cmp numob 		; number of objects in game.
000764r 3               	bcc :+			; are we checking past the end?
000764r 3               	rts			; yes, can't get non-existent item.
000764r 3               :
000764r 3               	jsr gotob 		; check if we already have it.
000764r 3               	cmp #255
000764r 3               	bne :+
000764r 3               	rts			; we already do.
000764r 3               :
000764r 3               	ldy #33
000764r 3               	lda (z80_hl),y		; is it on this screen?
000764r 3               	cmp scno 		; current screen.
000764r 3               	bne getob0		; not on screen, so nothing to delete.
000764r 3               
000764r 3               	lda #255
000764r 3               	sta (z80_hl),y		; pick it up.
000764r 3               	iny 			; point to y coord.
000764r 3               getob1:
000764r 3               	ldy #34
000764r 3               	lda (z80_hl),y		; y coord.
000764r 3               	sta dispy
000764r 3               	ldy #35
000764r 3               	lda (z80_hl),y 		; x coord.
000764r 3               	sta dispx
000764r 3               	jmp dobj1 		; delete object sprite.
000764r 3               getob0:
000764r 3               	lda #255
000764r 3               	sta (z80_hl),y 		; pick it up.
000764r 3               	rts
000764r 3               .endif
000764r 3               
000764r 3               ;-----------------------------------------------------------------
000764r 3               ; Got object check.
000764r 3               ; Call with object in accumulator, returns zero set if in pockets.
000764r 3               ;
000764r 3               ; Input:
000764r 3               ;  A = object number
000764r 3               ;-----------------------------------------------------------------
000764r 3               .if oflag .or mflag
000764r 3               gotob:
000764r 3               	cmp numob 		; number of objects in game.
000764r 3               	bcc :+ 			; are we checking past the end?
000764r 3               	jmp gotob0 		; yes, we can't have a non-existent object.
000764r 3               :
000764r 3               	jsr findob		; find the object.
000764r 3               gotob1:
000764r 3               	rts
000764r 3               
000764r 3               gotob0:
000764r 3               	lda #254 		; missing.
000764r 3               	jmp gotob1
000764r 3               
000764r 3               findob:
000764r 3               	pha			; save object number
000764r 3               	lda #<objdta 		; objects.
000764r 3               	sta z80_l
000764r 3               	lda #>objdta
000764r 3               	sta z80_h
000764r 3               	pla			; retreive object number
000764r 3               	beq fndob1 		; is it zero? yes, skip loop.
000764r 3               	tax 			; loop counter
000764r 3               fndob2:
000764r 3               	clc
000764r 3               	lda z80_l
000764r 3               	adc #39 		; size of each object.
000764r 3               	sta z80_l
000764r 3               	bcc :+
000764r 3               	inc z80_h
000764r 3               :
000764r 3               	dex 			; repeat until we find address.
000764r 3               	bne fndob2
000764r 3               fndob1:
000764r 3               	ldy #33			; distance to room it's in.
000764r 3               	lda (z80_hl),y		; fetch status.
000764r 3               	rts
000764r 3               .endif
000764r 3               
000764r 3               ;---------------------------------------------
000764r 3               ; Drop object number at (dispx, dispy).
000764r 3               ;
000764r 3               ; Input:
000764r 3               ;  A = object number
000764r 3               ;---------------------------------------------
000764r 3               
000764r 3               .if oflag
000764r 3               drpob:
000764r 3               	cmp numob 		; are we checking past the end?
000764r 3               	bcc :+
000764r 3               	rts			; yes, can't drop non-existent item.
000764r 3               :
000764r 3               	jsr gotob		; make sure object is in inventory.
000764r 3               	cmp scno		; already on this screen?
000764r 3               	bne :+
000764r 3               	rts			; yes, nothing to do.
000764r 3               :
000764r 3               	ldy #33
000764r 3               	lda scno
000764r 3               	sta (z80_hl),y		; bring onto screen.
000764r 3               	lda dispy		; sprite y coordinate.
000764r 3               	iny
000764r 3               	sta (z80_hl),y		; point to object y.
000764r 3               	lda dispx 		; sprite x coordinate.
000764r 3               	iny
000764r 3               	sta (z80_hl),y 		; point to object x
000764r 3               	jmp dobj		; draw the object sprite.
000764r 3               
000764r 3               ;-----------------------------------------------
000764r 3               ; Seek objects at sprite position.
000764r 3               ;
000764r 3               ; Output:
000764r 3               ;  A = object number, if not found A=255
000764r 3               ;-----------------------------------------------
000764r 3               
000764r 3               skobj:
000764r 3               	lda #<objdta 		; pointer to objects.
000764r 3               	sta z80_l
000764r 3               	lda #>objdta
000764r 3               	sta z80_h
000764r 3               
000764r 3               	lda numob 		; number of objects in game.
000764r 3               	sta z80_b 		; set up the loop counter.
000764r 3               skobj0:
000764r 3               	lda scno		; current room number.
000764r 3               	ldy #33
000764r 3               	cmp (z80_hl),y		; is object in here?
000764r 3               	bne :+
000764r 3               	jsr skobj1		; yes, check coordinates.
000764r 3               :
000764r 3               	clc			; point to next object in table.
000764r 3               	lda z80_l
000764r 3               	adc #39			; size of each object.
000764r 3               	sta z80_l
000764r 3               	bcc :+
000764r 3               	inc z80_h
000764r 3               :
000764r 3               	dec z80_b
000764r 3               	bne skobj0		; repeat for all objects.
000764r 3               
000764r 3               	lda #255		; end of list and nothing found, return 255.
000764r 3               	rts
000764r 3               
000764r 3               skobj1:
000764r 3               	ldy #34			; point to y coordinate.
000764r 3               	lda (z80_hl),y		; point to y coordinate.
000764r 3               	sec
000764r 3               	ldy #var_newY
000764r 3               	sbc (z80_ix),y 		; subtract sprite y.
000764r 3               	clc
000764r 3               	adc #15			; add sprite height minus one.
000764r 3               	cmp #31			; within range?
000764r 3               	bcs skobj2		; no, ignore object.
000764r 3               
000764r 3               	ldy #35			; point to x coordinate now.
000764r 3               	lda (z80_hl),y 		; get coordinate.
000764r 3               	sec
000764r 3               	ldy #var_newX
000764r 3               	sbc (z80_ix),y 		; subtract the sprite x.
000764r 3               	clc			; add sprite width minus one.
000764r 3               	adc #15
000764r 3               	cmp #31			; within range?
000764r 3               	bcs skobj2		; no, ignore object.
000764r 3               
000764r 3               	pla			; remove return address from stack.
000764r 3               	pla
000764r 3               
000764r 3               	lda numob 		; objects in game.
000764r 3               	sec
000764r 3               	sbc z80_b		; subtract loop counter.
000764r 3               skobj2:
000764r 3               	rts			; accumulator now points to object.
000764r 3               .endif
000764r 3               
000764r 3               ;---------------------------------------------------------------------
000764r 3               ; Spawn a new sprite.
000764r 3               ;---------------------------------------------------------------------
000764r 3               
000764r 3               spawn:
000764r 3  A9 rr        	lda #<sprtab		; sprite table.
000766r 3  85 rr        	sta z80_l
000768r 3  A9 rr        	lda #>sprtab
00076Ar 3  85 rr        	sta z80_h
00076Cr 3               numsp1:
00076Cr 3  A9 0C        	lda #NUMSPR		; number of sprites.
00076Er 3  85 rr        	sta spcnt
000770r 3               spaw0:
000770r 3  A0 00        	ldy #var_Type
000772r 3  B1 rr        	lda (z80_hl),y		; get sprite type.
000774r 3  C9 FF        	cmp #255		; is it an unused slot?
000776r 3  F0 0F        	beq spaw1 		; yes, we can use this one.
000778r 3               
000778r 3  18           	clc 			; point to next sprite in table.
000779r 3  A5 rr        	lda z80_l
00077Br 3  69 12        	adc #TABSIZ		; size of each entry.
00077Dr 3  85 rr        	sta z80_l
00077Fr 3  90 02        	bcc :+
000781r 3  E6 rr        	inc z80_h
000783r 3               :
000783r 3  C6 rr        	dec spcnt		; one less iteration.
000785r 3  D0 E9        	bne spaw0		; keep going until we find a slot.
000787r 3               
000787r 3               ; Didn't find one but drop through and set up a dummy sprite instead.
000787r 3               
000787r 3               spaw1:
000787r 3  A5 rr        	lda z80_i		; address of original sprite.
000789r 3  48           	pha
00078Ar 3  A5 rr        	lda z80_x
00078Cr 3  48           	pha
00078Dr 3               
00078Dr 3  A5 rr        	lda z80_l		; store spawned sprite address.
00078Fr 3  85 rr        	sta spptr
000791r 3  A5 rr        	lda z80_h
000793r 3  85 rr        	sta spptr+1
000795r 3               
000795r 3  A5 rr        	lda z80_c
000797r 3  A0 00        	ldy #var_Type
000799r 3  91 rr        	sta (z80_hl),y 		; set the type.
00079Br 3  A0 05        	ldy #var_newType
00079Dr 3  91 rr        	sta (z80_hl),y		; copy
00079Fr 3               
00079Fr 3  A5 rr        	lda z80_b
0007A1r 3  A0 01        	ldy #var_Image
0007A3r 3  91 rr        	sta (z80_hl),y		; set the image.
0007A5r 3  A0 06        	ldy #var_newImage
0007A7r 3  91 rr        	sta (z80_hl),y		; copy
0007A9r 3               
0007A9r 3  A9 00        	lda #0 				; frame zero.
0007ABr 3  A0 02        	ldy #var_Frame
0007ADr 3  91 rr        	sta (z80_hl),y		; set frame.
0007AFr 3  A0 07        	ldy #var_newFrame
0007B1r 3  91 rr        	sta (z80_hl),y		; copy
0007B3r 3               
0007B3r 3  A0 08        	ldy #8
0007B5r 3  B1 rr        	lda (z80_ix),y 		; x coordinate.
0007B7r 3  A0 03        	ldy #3
0007B9r 3  91 rr        	sta (z80_hl),y		; set sprite coordinate.
0007BBr 3  A0 08        	ldy #8
0007BDr 3  91 rr        	sta (z80_hl),y		; copy
0007BFr 3               
0007BFr 3  A0 09        	ldy #9
0007C1r 3  B1 rr        	lda (z80_ix),y 		; y coordinate.
0007C3r 3  A0 04        	ldy #4
0007C5r 3  91 rr        	sta (z80_hl),y		; set sprite coordinate.
0007C7r 3  A0 09        	ldy #9
0007C9r 3  91 rr        	sta (z80_hl),y		; copy
0007CBr 3               
0007CBr 3  A0 0A        	ldy #10				; direction of original.
0007CDr 3  B1 rr        	lda (z80_ix),y
0007CFr 3  91 rr        	sta (z80_hl),y		; direction
0007D1r 3               
0007D1r 3  A9 00        	lda #0
0007D3r 3  A0 0D        	ldy #var_jumpLo
0007D5r 3  91 rr        	sta (z80_hl),y		; reset parameter.
0007D7r 3  C8           	iny
0007D8r 3  91 rr        	sta (z80_hl),y		; reset parameter.
0007DAr 3  C8           	iny
0007DBr 3  91 rr        	sta (z80_hl),y		; reset parameter.
0007DDr 3  C8           	iny
0007DEr 3  91 rr        	sta (z80_hl),y		; reset parameter.
0007E0r 3               rtssp:
0007E0r 3  A5 rr        	lda spptr			; address of new sprite.
0007E2r 3  85 rr        	sta z80_x
0007E4r 3  A5 rr        	lda spptr+1
0007E6r 3  85 rr        	sta z80_i
0007E8r 3               evis1:
0007E8r 3  20 rr rr     	jsr evnt09 			; call sprite initialisation event.
0007EBr 3               
0007EBr 3  A5 rr        	lda spptr 			; address of new sprite.
0007EDr 3  85 rr        	sta z80_x
0007EFr 3  A5 rr        	lda spptr+1
0007F1r 3  85 rr        	sta z80_i
0007F3r 3               
0007F3r 3               	; _BEEB clipping code copied from CPC Engine - MISSING?!
0007F3r 3  A0 03        	ldy #var_Y
0007F5r 3  B1 rr        	lda (z80_hl), y		; old x coord
0007F7r 3  C9 A1        	cmp #SpriteMaxY     ; beyond maximum?
0007F9r 3  B0 03        	bcs :+				; yes, don't draw it.
0007FBr 3               
0007FBr 3  20 rr rr     	jsr sspria 			; display the new sprite.
0007FEr 3               :
0007FEr 3  68           	pla					; address of original sprite.
0007FFr 3  85 rr        	sta z80_x
000801r 3  68           	pla
000802r 3  85 rr        	sta z80_i
000804r 3               
000804r 3  60           	rts
000805r 3               
000805r 3  30 30 30 30  score:	.byte "000000"		; player"s score.
000809r 3  30 30        
00080Br 3  30 30 30 30  hiscor:	.byte "000000"		; high score.
00080Fr 3  30 30        
000811r 3  30 30 30 30  bonus:	.byte "000000"		; bonus.
000815r 3  30 30        
000817r 3  00 02        grbase:	.word ScreenAddr	; graphics base address.
000819r 3               
000819r 3               ;----------------------------------------------------
000819r 3               ; Check y-pos
000819r 3               ;----------------------------------------------------
000819r 3               
000819r 3               checkx:
000819r 3  A5 rr        	lda dispy		; y position.
00081Br 3  C9 16        	cmp #22			; off screen?
00081Dr 3  B0 01        	bcs :+
00081Fr 3  60           	rts			; no, it's okay.
000820r 3               :
000820r 3  68           	pla			; remove return address from stack.
000821r 3  85 rr        	sta z80_l
000823r 3  68           	pla
000824r 3  85 rr        	sta z80_h
000826r 3  60           	rts
000827r 3               
000827r 3               ;-----------------------------------------------
000827r 3               ; Displays the current high score.
000827r 3               ;-----------------------------------------------
000827r 3               
000827r 3               dhisc:
000827r 3  A9 rr        	lda #<hiscor 		; high score text.
000829r 3  8D rr rr     	sta dscor3+1
00082Cr 3  8D rr rr     	sta bscor3+1
00082Fr 3  A9 rr        	lda #>hiscor
000831r 3  8D rr rr     	sta dscor3+2
000834r 3  8D rr rr     	sta bscor3+2
000837r 3  4C rr rr     	jmp dscor1		; check in printable range then show 6 digits.
00083Ar 3               
00083Ar 3               ;------------------------------------------------------
00083Ar 3               ; Displays the current score.
00083Ar 3               ;------------------------------------------------------
00083Ar 3               
00083Ar 3               dscor:
00083Ar 3  A9 rr        	lda #<score		; score text.
00083Cr 3  8D rr rr     	sta dscor3+1
00083Fr 3  8D rr rr     	sta bscor3+1
000842r 3  A9 rr        	lda #>score
000844r 3  8D rr rr     	sta dscor3+2
000847r 3  8D rr rr     	sta bscor3+2
00084Ar 3               dscor1:
00084Ar 3  8C rr rr     	sty tmpscr
00084Dr 3  20 rr rr     	jsr preprt		; set up font and print position.
000850r 3  20 rr rr     	jsr checkx		; make sure we're in a printable range.
000853r 3               
000853r 3               ;	lda #6			; digits to display.
000853r 3               ;	sta z80_b
000853r 3  A5 rr        	lda prtmod		; get print mode.
000855r 3  F0 03        	beq :+			; standard size text?
000857r 3  4C rr rr     	jmp bscor0		; no, show double-height.
00085Ar 3               :
00085Ar 3               dscor0:
00085Ar 3               ;	ldy #0
00085Ar 3               ;	lda (z80_hl),y 		; fetch character.
00085Ar 3  AC rr rr     	ldy tmpscr
00085Dr 3               dscor3:
00085Dr 3  B9 rr rr     	lda score,y
000860r 3  20 rr rr     	jsr pchar 		; display character.
000863r 3  E6 rr        	inc dispx		; move along x coordinate
000865r 3               
000865r 3               ;	inc z80_l		; next score column.
000865r 3               ;	bne :+
000865r 3               ;	inc z80_h
000865r 3               ;:
000865r 3  EE rr rr     	inc tmpscr
000868r 3  C6 rr        	dec z80_b
00086Ar 3  D0 EE        	bne dscor0 		; repeat for all digits.
00086Cr 3               dscor2:
00086Cr 3  A5 rr        	lda dispx 		; set up display coordinates.
00086Er 3  85 rr        	sta charx
000870r 3  A5 rr        	lda dispy
000872r 3  85 rr        	sta chary
000874r 3  60           	rts
000875r 3               
000875r 3  00           tmpscr:	.byte 0
000876r 3               ;------------------------------------------------------
000876r 3               ; Displays the current score in double-height characters.
000876r 3               ;
000876r 3               ; Input:
000876r 3               ;  B  = digit number
000876r 3               ;  HL = score string
000876r 3               ;------------------------------------------------------
000876r 3               
000876r 3               bscor0:
000876r 3               ;	ldy #0
000876r 3               
000876r 3               ;	lda (z80_hl),y 		; fetch character.
000876r 3  A4 rr        	ldy tmp
000878r 3               bscor3:
000878r 3  B9 rr rr     	lda score,y
00087Br 3  20 rr rr     	jsr bchar 		; display big char.
00087Er 3               
00087Er 3               ;	inc z80_l 		; next score column.
00087Er 3               ;	bne :+
00087Er 3               ;	inc z80_h
00087Er 3               ;:
00087Er 3  E6 rr        	inc tmp
000880r 3  C6 rr        	dec z80_b
000882r 3  F0 03        	beq :+
000884r 3  4C rr rr     	jmp bscor0 		; repeat for all digits.
000887r 3               :
000887r 3  4C rr rr     	jmp dscor2 		; tidy up line and column variables.
00088Ar 3               
00088Ar 3               ;-----------------------------------------------------
00088Ar 3               ; Adds number in the hl pair to the score.
00088Ar 3               ;-----------------------------------------------------
00088Ar 3               
00088Ar 3               addsc:
00088Ar 3  A9 rr        	lda #<(score+1) 	; ten thousands column.
00088Cr 3  85 rr        	sta z80_e
00088Er 3  A9 rr        	lda #>(score+1)
000890r 3  85 rr        	sta z80_d
000892r 3  A9 10        	lda #<10000		; amount to add each time.
000894r 3  85 rr        	sta z80_c
000896r 3  A9 27        	lda #>10000
000898r 3  85 rr        	sta z80_b
00089Ar 3  20 rr rr     	jsr incsc		; add to score.
00089Dr 3               
00089Dr 3  E6 rr        	inc z80_e		; thousands column.
00089Fr 3  D0 02        	bne :+
0008A1r 3  E6 rr        	inc z80_d
0008A3r 3               :
0008A3r 3  A9 E8        	lda #<1000		; amount to add each time.
0008A5r 3  85 rr        	sta z80_c
0008A7r 3  A9 03        	lda #>1000
0008A9r 3  85 rr        	sta z80_b
0008ABr 3  20 rr rr     	jsr incsc 		; add to score.
0008AEr 3               
0008AEr 3  E6 rr        	inc z80_e		; hundreds column.
0008B0r 3  D0 02        	bne :+
0008B2r 3  E6 rr        	inc z80_d
0008B4r 3               :
0008B4r 3  A9 64        	lda #<100		; amount to add each time.
0008B6r 3  85 rr        	sta z80_c
0008B8r 3  A9 00        	lda #>100
0008BAr 3  85 rr        	sta z80_b
0008BCr 3  20 rr rr     	jsr incsc		; add to score.
0008BFr 3               
0008BFr 3  E6 rr        	inc z80_e 		; tens column.
0008C1r 3  D0 02        	bne :+
0008C3r 3  E6 rr        	inc z80_d
0008C5r 3               :
0008C5r 3  A9 0A        	lda #<10		; amount to add each time.
0008C7r 3  85 rr        	sta z80_c
0008C9r 3  A9 00        	lda #>10
0008CBr 3  85 rr        	sta z80_b
0008CDr 3  20 rr rr     	jsr incsc 		; add to score.
0008D0r 3               
0008D0r 3  E6 rr        	inc z80_e		; units column.
0008D2r 3  D0 02        	bne :+
0008D4r 3  E6 rr        	inc z80_d
0008D6r 3               :
0008D6r 3  A9 01        	lda #<1			; units.
0008D8r 3  85 rr        	sta z80_c
0008DAr 3  A9 00        	lda #>1
0008DCr 3  85 rr        	sta z80_b
0008DEr 3               incsc:
0008DEr 3  A5 rr        	lda z80_h		; store amount to add.
0008E0r 3  48           	pha
0008E1r 3  A5 rr        	lda z80_l
0008E3r 3  48           	pha
0008E4r 3               
0008E4r 3  38           	sec			; subtract from amount to add.
0008E5r 3  A5 rr        	lda z80_l
0008E7r 3  E5 rr        	sbc z80_c
0008E9r 3  85 rr        	sta z80_l
0008EBr 3  A5 rr        	lda z80_h
0008EDr 3  E5 rr        	sbc z80_b
0008EFr 3  85 rr        	sta z80_h
0008F1r 3  90 14        	bcc incsc0		; too much, restore value.
0008F3r 3               
0008F3r 3  68           	pla			; delete the previous amount from the stack.
0008F4r 3  68           	pla
0008F5r 3               
0008F5r 3  A5 rr        	lda z80_d 		; store column position.
0008F7r 3  48           	pha
0008F8r 3  A5 rr        	lda z80_e
0008FAr 3  48           	pha
0008FBr 3  20 rr rr     	jsr incsc2		; do the increment.
0008FEr 3               
0008FEr 3  68           	pla			; restore column.
0008FFr 3  85 rr        	sta z80_e
000901r 3  68           	pla
000902r 3  85 rr        	sta z80_d
000904r 3  4C rr rr     	jmp incsc		; repeat until all added.
000907r 3               
000907r 3               incsc0:
000907r 3  68           	pla			; restore previous value.
000908r 3  85 rr        	sta z80_l
00090Ar 3  68           	pla
00090Br 3  85 rr        	sta z80_h
00090Dr 3  60           	rts
00090Er 3               incsc2:
00090Er 3  A0 00        	ldy #0
000910r 3  B1 rr        	lda (z80_de),y 		; get amount.
000912r 3  18           	clc
000913r 3  69 01        	adc #1			; add one to column.
000915r 3  91 rr        	sta (z80_de),y		; write new column total.
000917r 3  C9 3A        	cmp #'9'+1		; gone beyond range of digits?
000919r 3  B0 01        	bcs :+
00091Br 3  60           	rts			; no, carry on.
00091Cr 3               :
00091Cr 3  A9 30        	lda #'0'		; make it zero.
00091Er 3  91 rr        	sta (z80_de),y		; write new column total.
000920r 3  C6 rr        	dec z80_e		; back one column.
000922r 3  D0 02        	bne :+
000924r 3  C6 rr        	dec z80_d
000926r 3               :
000926r 3  4C rr rr     	jmp incsc2
000929r 3               
000929r 3               ;------------------------------------
000929r 3               ; Add bonus to score and reset bonus
000929r 3               ;------------------------------------
000929r 3               
000929r 3               addbo:
000929r 3  A2 05        	ldx #5			; last digit.
00092Br 3  18           	clc
00092Cr 3               addbo0:
00092Cr 3  BD rr rr     	lda score,x		; get score.
00092Fr 3  7D rr rr     	adc bonus,x		; add bonus.
000932r 3  38           	sec			; 0 to 18.
000933r 3  E9 30        	sbc #48
000935r 3  48           	pha
000936r 3  A9 30        	lda #'0'
000938r 3  9D rr rr     	sta bonus,x
00093Br 3  68           	pla
00093Cr 3  C9 3A        	cmp #58
00093Er 3  90 03        	bcc addbo1
000940r 3  38           	sec
000941r 3  E9 0A        	sbc #10
000943r 3               addbo1:
000943r 3  9D rr rr     	sta score,x		; zeroise bonus.
000946r 3  CA           	dex			; next digit.
000947r 3  10 E3        	bpl addbo0		; repeat for all 6 digits.
000949r 3  60           	rts
00094Ar 3               
00094Ar 3               ;------------------------------------
00094Ar 3               ; Swap score and bonus.
00094Ar 3               ;------------------------------------
00094Ar 3               
00094Ar 3               swpsb:
00094Ar 3  A2 05        	ldx #5			; digits to add.
00094Cr 3               swpsb0:
00094Cr 3  BD rr rr     	lda score,x 		; get score digits.
00094Fr 3  48           	pha			; save digit
000950r 3  BD rr rr     	lda bonus,x 		; get bonus digits.
000953r 3  9D rr rr     	sta score,x		; switch score-bonus
000956r 3  68           	pla
000957r 3  9D rr rr     	sta bonus,x
00095Ar 3  CA           	dex 			; repeat for all 6 digits.
00095Br 3  10 EF        	bpl swpsb0
00095Dr 3  60           	rts
00095Er 3               
00095Er 3               ;----------------------------------------------------
00095Er 3               ; Get print address.
00095Er 3               ;----------------------------------------------------
00095Er 3               
00095Er 3               gprad:
00095Er 3  98           	tya
00095Fr 3  48           	pha
000960r 3               
000960r 3  A5 rr        	lda dispx 		; x coordinate.
000962r 3  85 rr        	sta scraddr
000964r 3  A9 00        	lda #0
000966r 3  85 rr        	sta scraddr+1
000968r 3  06 rr        	asl scraddr  		; multiply char by 16
00096Ar 3  26 rr        	rol scraddr+1
00096Cr 3  06 rr        	asl scraddr
00096Er 3  26 rr        	rol scraddr+1
000970r 3  06 rr        	asl scraddr
000972r 3  26 rr        	rol scraddr+1
000974r 3  06 rr        	asl scraddr
000976r 3  26 rr        	rol scraddr+1
000978r 3               
000978r 3  A5 rr        	lda dispy		; y coordinate.
00097Ar 3  0A           	asl a
00097Br 3  0A           	asl a
00097Cr 3  0A           	asl a			; multiply char by 8
00097Dr 3  A8           	tay
00097Er 3               
00097Er 3  18           	clc
00097Fr 3  A5 rr        	lda scraddr
000981r 3  79 00 07     	adc SCADTB_lb,y
000984r 3  85 rr        	sta scraddr
000986r 3  A5 rr        	lda scraddr+1
000988r 3  79 00 08     	adc SCADTB_hb,y
00098Br 3  85 rr        	sta scraddr+1
00098Dr 3               
00098Dr 3  A5 rr        	lda prtmod		; Double line if bigtxt
00098Fr 3  F0 08        	beq noskip
000991r 3  A5 rr        	lda dispx
000993r 3  29 E0        	and #$e0
000995r 3  F0 02        	beq noskip
000997r 3  E6 rr        	inc scraddr+1
000999r 3               noskip:
000999r 3               
000999r 3  68           	pla
00099Ar 3  A8           	tay
00099Br 3  60           	rts
00099Cr 3               ;--------------------------------------------------------------
00099Cr 3               ; Get property buffer address of char at (dispx, dispy) in hl.
00099Cr 3               ;
00099Cr 3               ; Output:
00099Cr 3               ;  buffaddr = bufaddr = MAP + dispy*22 + dispx
00099Cr 3               ;--------------------------------------------------------------
00099Cr 3               
00099Cr 3               pradd:
00099Cr 3  A5 rr        	lda dispy 		; y coordinate.
00099Er 3  85 rr        	sta bufaddr
0009A0r 3  A9 00        	lda #0
0009A2r 3  85 rr        	sta bufaddr+1
0009A4r 3  06 rr        	asl bufaddr  		; multiply char by 32
0009A6r 3  26 rr        	rol bufaddr+1
0009A8r 3  06 rr        	asl bufaddr
0009AAr 3  26 rr        	rol bufaddr+1
0009ACr 3  06 rr        	asl bufaddr
0009AEr 3  26 rr        	rol bufaddr+1
0009B0r 3  06 rr        	asl bufaddr
0009B2r 3  26 rr        	rol bufaddr+1
0009B4r 3  06 rr        	asl bufaddr
0009B6r 3  26 rr        	rol bufaddr+1
0009B8r 3  18           	clc			; add address of MAP graphics.
0009B9r 3  A5 rr        	lda bufaddr
0009BBr 3  65 rr        	adc dispx
0009BDr 3  69 00        	adc #<MAP
0009BFr 3  85 rr        	sta bufaddr
0009C1r 3  A5 rr        	lda bufaddr+1
0009C3r 3  69 04        	adc #>MAP
0009C5r 3  85 rr        	sta bufaddr+1
0009C7r 3  60           	rts
0009C8r 3               
0009C8r 3               ;--------------------------------------------------------------
0009C8r 3               ; Get attribute address at (dispx, dispy).
0009C8r 3               ;
0009C8r 3               ; Output:
0009C8r 3               ;  bufaddr = COLOR + dispy*22 + dispx
0009C8r 3               ;--------------------------------------------------------------
0009C8r 3               
0009C8r 3               gaadd:
0009C8r 3  A5 rr        	lda dispy
0009CAr 3  4A           	lsr a
0009CBr 3  A8           	tay
0009CCr 3  B9 55 0A     	lda COLATTTB_hb,y
0009CFr 3  85 rr        	sta bufaddr+1
0009D1r 3  B9 4A 0A     	lda COLATTTB_lb,y
0009D4r 3  18           	clc
0009D5r 3  65 rr        	adc dispx
0009D7r 3  85 rr        	sta bufaddr
0009D9r 3  60           	rts
0009DAr 3               
0009DAr 3               ;----------------------------------------------
0009DAr 3               ; Print attributes, properties and pixels.
0009DAr 3               ;
0009DAr 3               ; Input:
0009DAr 3               ;  A	= tile number
0009DAr 3               ;----------------------------------------------
0009DAr 3               
0009DAr 3               pbpattr:			; entry PUTBLOCK command
0009DAr 3  A4 rr        	ldy charx
0009DCr 3  84 rr        	sty dispx
0009DEr 3  A4 rr        	ldy chary
0009E0r 3  84 rr        	sty dispy
0009E2r 3               pattr:
0009E2r 3               .if aflag
0009E2r 3               	pha
0009E2r 3               	jsr wbloc		; save blockinfo
0009E2r 3               	pla
0009E2r 3               .endif
0009E2r 3               
0009E2r 3               pattr2:
0009E2r 3  85 rr        	sta z80_b		; store cell in b register for now.
0009E4r 3  AA           	tax
0009E5r 3  BD rr rr     	lda bprop,x 		; block properties.
0009E8r 3  85 rr        	sta z80_c
0009EAr 3  C9 08        	cmp #COLECT
0009ECr 3  D0 04        	bne :+
0009EEr 3  A5 rr        	lda z80_b
0009F0r 3  85 rr        	sta colpatt
0009F2r 3               :
0009F2r 3  20 rr rr     	jsr pradd 		; get property buffer address.
0009F5r 3  A5 rr        	lda z80_c
0009F7r 3  A0 00        	ldy #0
0009F9r 3  91 rr        	sta (bufaddr),y 	; write property.
0009FBr 3  A5 rr        	lda z80_b 		; restore cell.
0009FDr 3  4C rr rr     	jmp panp
000A00r 3               ; Print attributes, no properties.
000A00r 3               
000A00r 3               ;colpatt:	.byte 0
000A00r 3               
000A00r 3               panp:
000A00r 3  85 rr        	sta z80_e		; displacement in e.
000A02r 3  A9 00        	lda #0
000A04r 3  85 rr        	sta z80_d		; no high byte.
000A06r 3  06 rr        	asl z80_e  		; multiply char by 8.
000A08r 3  26 rr        	rol z80_d
000A0Ar 3  06 rr        	asl z80_e
000A0Cr 3  26 rr        	rol z80_d
000A0Er 3  06 rr        	asl z80_e
000A10r 3  26 rr        	rol z80_d
000A12r 3  18           	clc
000A13r 3  A5 rr        	lda z80_e
000A15r 3  69 rr        	adc #<chgfx 		; address of graphics.
000A17r 3  85 rr        	sta tileaddr
000A19r 3  A5 rr        	lda z80_d
000A1Br 3  69 rr        	adc #>chgfx
000A1Dr 3  85 rr        	sta tileaddr+1
000A1Fr 3               
000A1Fr 3  A6 rr        	ldx z80_b		; set colour attribute
000A21r 3  BD rr rr     	lda bCol,x
000A24r 3  48           	pha
000A25r 3  20 rr rr     	jsr gaadd
000A28r 3  A0 00        	ldy #0
000A2Ar 3  68           	pla
000A2Br 3  91 rr        	sta (bufaddr),y
000A2Dr 3               
000A2Dr 3  20 rr rr     	jsr gprad 		; get screen address.
000A30r 3  A2 07        	ldx #7			; number of pixel rows to write.
000A32r 3               panp0:
000A32r 3  A0 00        	ldy #0
000A34r 3  B1 rr        	lda (tileaddr),y 	; get image byte.
000A36r 3               .if iflag
000A36r 3               	eor #$ff		; Invert
000A36r 3               .endif
000A36r 3  BC rr rr     	ldy scrtab,x
000A39r 3  91 rr        	sta (scraddr),y 	; copy to screen.
000A3Br 3  E6 rr        	inc tileaddr 		; next image byte.
000A3Dr 3  D0 02        	bne :+
000A3Fr 3  E6 rr        	inc tileaddr+1
000A41r 3               :
000A41r 3  CA           	dex	 		; repeat for 8 pixel rows.
000A42r 3  10 EE        	bpl panp0
000A44r 3  E6 rr        	inc dispx 		; move along one.
000A46r 3  E6 rr        	inc charx
000A48r 3  60           	rts
000A49r 3               
000A49r 3               ;----------------------------------------------
000A49r 3               ; Write block
000A49r 3               ;----------------------------------------------
000A49r 3               
000A49r 3               .if aflag
000A49r 3               wbloc:
000A49r 3               	ldy #3
000A49r 3               	sta (pbptr),y		; store block number
000A49r 3               	dey
000A49r 3               	lda dispx
000A49r 3               	sta (pbptr),y		; write x position of block.
000A49r 3               	dey
000A49r 3               	lda dispy
000A49r 3               	sta (pbptr),y		; write y position of block.
000A49r 3               	dey
000A49r 3               	lda scno
000A49r 3               	sta (pbptr),y		; write screen.
000A49r 3               	clc			; point to next free location
000A49r 3               	lda pbptr
000A49r 3               	adc #4
000A49r 3               	sta pbptr
000A49r 3               	bcc :+
000A49r 3               	inc pbptr+1
000A49r 3               :
000A49r 3               	rts
000A49r 3               .endif
000A49r 3               
000A49r 3               ;.if kflag
000A49r 3               ;panp:
000A49r 3               ;.endif
000A49r 3               
000A49r 3               ;----------------------------------------------
000A49r 3               ; Print character pixels, no more.
000A49r 3               ;
000A49r 3               ; Input:
000A49r 3               ;  A	= character to print
000A49r 3               ;----------------------------------------------
000A49r 3               
000A49r 3               pchr:
000A49r 3  20 rr rr     	jsr pchar 		; show character in accumulator.
000A4Cr 3  E6 rr        	inc dispx		; move along one.
000A4Er 3  60           	rts
000A4Fr 3               
000A4Fr 3               ;----------------------------------------------------
000A4Fr 3               ; Shifter sprite routine for objects.
000A4Fr 3               ;----------------------------------------------------
000A4Fr 3               
000A4Fr 3               .if oflag
000A4Fr 3               sprit7:
000A4Fr 3               	lda z80_b
000A4Fr 3               	beq sprit0
000A4Fr 3               	sta z80_a
000A4Fr 3               sprit3:
000A4Fr 3               	lsr spr			; shift into position.
000A4Fr 3               	ror spr+1
000A4Fr 3               	ror spr+2
000A4Fr 3               	dec z80_a		; one less iteration.
000A4Fr 3               	bne sprit3
000A4Fr 3               sprit0:
000A4Fr 3               	rts 			; now apply to screen.
000A4Fr 3               .endif
000A4Fr 3               
000A4Fr 3               ;-----------------------------------------------------------
000A4Fr 3               ; Get room address.
000A4Fr 3               ;-----------------------------------------------------------
000A4Fr 3               
000A4Fr 3               groom:
000A4Fr 3  A6 rr        	ldx scno 		; screen number.
000A51r 3  A0 00        	ldy #0
000A53r 3               groomx:
000A53r 3  A9 rr        	lda #<scdat 		; pointer to screens.
000A55r 3  85 rr        	sta z80_l
000A57r 3  A9 rr        	lda #>scdat
000A59r 3  85 rr        	sta z80_h
000A5Br 3               groom1:
000A5Br 3  E0 00        	cpx #0			; is it the first one?
000A5Dr 3  F0 15        	beq groom0 		; no more screens to skip.
000A5Fr 3               
000A5Fr 3  18           	clc
000A60r 3  A5 rr        	lda z80_l
000A62r 3  79 rr rr     	adc scdat,y 		; low byte of screen size.
000A65r 3  85 rr        	sta z80_l
000A67r 3  C8           	iny			; point to high byte.
000A68r 3  A5 rr        	lda z80_h
000A6Ar 3  79 rr rr     	adc scdat,y 		; high byte of screen size.
000A6Dr 3  85 rr        	sta z80_h
000A6Fr 3  C8           	iny			; next address.
000A70r 3               
000A70r 3  CA           	dex 			; one less iteration.
000A71r 3  4C rr rr     	jmp groom1 		; loop until we reach the end.
000A74r 3               groom0:
000A74r 3  AD rr rr     	lda numsc		; add displacement.
000A77r 3  0A           	asl a
000A78r 3  18           	clc			; add double displacement to address.
000A79r 3  65 rr        	adc z80_l
000A7Br 3  85 rr        	sta z80_l
000A7Dr 3  A5 rr        	lda z80_h
000A7Fr 3  69 00        	adc #0
000A81r 3  85 rr        	sta z80_h
000A83r 3  60           	rts
000A84r 3               
000A84r 3               ;-----------------------------------------------------------
000A84r 3               ; Draw present room.
000A84r 3               ;-----------------------------------------------------------
000A84r 3               
000A84r 3               droom:
000A84r 3  AD rr rr     	lda wintop 		; window top.
000A87r 3  85 rr        	sta dispy		; set cursor y position.
000A89r 3               droom2:
000A89r 3  20 rr rr     	jsr groom 		; get address of current room.
000A8Cr 3  A9 00        	lda #0	 		; zero in accumulator.
000A8Er 3  85 rr        	sta comcnt 		; reset compression counter.
000A90r 3  AD rr rr     	lda winhgt 		; height of window.
000A93r 3  85 rr        	sta rrow		; set row counter
000A95r 3               droom0:
000A95r 3  AD rr rr     	lda winlft 		; window left edge.
000A98r 3  85 rr        	sta dispx 		; set cursor x position.
000A9Ar 3  AD rr rr     	lda winwid 		; width of window.
000A9Dr 3  85 rr        	sta rcol		; set column counter
000A9Fr 3               droom1:
000A9Fr 3  20 rr rr     	jsr flbyt 		; decompress next byte on the fly.
000AA2r 3               .if xflag
000AA2r 3               	jsr drwmeta
000AA2r 3               .else
000AA2r 3  20 rr rr     	jsr pattr2 		; show attributes and block.
000AA5r 3               .endif
000AA5r 3  C6 rr        	dec rcol		; one less column.
000AA7r 3  D0 F6        	bne droom1 		; repeat for entire line.
000AA9r 3  E6 rr        	inc dispy		; move down one line.
000AABr 3               .if xflag
000AABr 3               	inc dispy		; move down one line.
000AABr 3               .endif
000AABr 3  C6 rr        	dec rrow 		; one less row.
000AADr 3  D0 E6        	bne droom0 		; repeat for all rows.
000AAFr 3  60           	rts
000AB0r 3               
000AB0r 3               ;----------------------------------------------
000AB0r 3               ; Decompress bytes on-the-fly.
000AB0r 3               ;----------------------------------------------
000AB0r 3               
000AB0r 3               flbyt:
000AB0r 3  A5 rr        	lda comcnt 		; compression counter.
000AB2r 3  D0 21        	bne flbyt1		; any more to decompress?  yes.
000AB4r 3               
000AB4r 3  A0 00        	ldy #0
000AB6r 3  B1 rr        	lda (z80_hl),y 		; fetch next byte.
000AB8r 3  E6 rr        	inc z80_l 		; point to next cell.
000ABAr 3  D0 02        	bne :+
000ABCr 3  E6 rr        	inc z80_h
000ABEr 3               :
000ABEr 3  C9 FF        	cmp #255 		; is this byte a control code?
000AC0r 3  F0 01        	beq :+
000AC2r 3  60           	rts 			; no, this byte is uncompressed.
000AC3r 3               :
000AC3r 3  B1 rr        	lda (z80_hl),y 		; fetch byte type.
000AC5r 3  85 rr        	sta combyt 		; set up the type.
000AC7r 3  E6 rr        	inc z80_l 		; point to quantity.
000AC9r 3  D0 02        	bne :+
000ACBr 3  E6 rr        	inc z80_h
000ACDr 3               :
000ACDr 3  B1 rr        	lda (z80_hl),y 		; get quantity.
000ACFr 3  E6 rr        	inc z80_l 		; point to next byte.
000AD1r 3  D0 02        	bne :+
000AD3r 3  E6 rr        	inc z80_h
000AD5r 3               :
000AD5r 3               flbyt1:
000AD5r 3  85 rr        	sta comcnt 		; store new quantity.
000AD7r 3  C6 rr        	dec comcnt		; one less.
000AD9r 3  A5 rr        	lda combyt 		; byte to expand.
000ADBr 3  60           	rts
000ADCr 3               
000ADCr 3               ; ------------------------------------------------------------------------------------------------------------------------------------------
000ADCr 3               ; Drawing a MetaBlock (4 tiles 8x8 => 16x16)
000ADCr 3               ; param in regA tells the block number to use, if 0 use 0,0,0,0  else use N,N+2 || N+1,N+3
000ADCr 3               ; ------------------------------------------------------------------------------------------------------------------------------------------
000ADCr 3               .if xflag
000ADCr 3               drwmeta:
000ADCr 3               	sta tmpblk
000ADCr 3               	jsr pattr2
000ADCr 3               
000ADCr 3               	inc dispy
000ADCr 3               	dec dispx
000ADCr 3               	ldx tmpblk
000ADCr 3               	beq :+
000ADCr 3               	inx
000ADCr 3               :
000ADCr 3               	txa
000ADCr 3               	jsr pattr2
000ADCr 3               
000ADCr 3               	ldx tmpblk
000ADCr 3               	beq :+
000ADCr 3               	inx
000ADCr 3               	inx
000ADCr 3               	inx
000ADCr 3               :
000ADCr 3               	txa
000ADCr 3               	jsr pattr2
000ADCr 3               
000ADCr 3               	dec dispy
000ADCr 3               	dec dispx
000ADCr 3               	ldx tmpblk
000ADCr 3               	beq :+
000ADCr 3               	inx
000ADCr 3               	inx
000ADCr 3               :
000ADCr 3               	txa
000ADCr 3               	jsr pattr2
000ADCr 3               	rts
000ADCr 3               
000ADCr 3               tmpblk:	.byte 0
000ADCr 3               
000ADCr 3               .endif
000ADCr 3               
000ADCr 3               ;------------------------------------------
000ADCr 3               ; Ladder down check.
000ADCr 3               ;
000ADCr 3               ; Input:
000ADCr 3               ;  IX = sprite pointer
000ADCr 3               ;------------------------------------------
000ADCr 3               
000ADCr 3               .if lflag
000ADCr 3               laddd:
000ADCr 3  A0 09        	ldy #9
000ADEr 3  B1 rr        	lda (z80_ix),y		; x coordinate.
000AE0r 3  85 rr        	sta dispx
000AE2r 3               
000AE2r 3  A0 08        	ldy #8
000AE4r 3  B1 rr        	lda (z80_ix),y		; y coordinate.
000AE6r 3  29 FE        	and #254		; make it even.
000AE8r 3  91 rr        	sta (z80_ix),y 		; reset it.
000AEAr 3  18           	clc 			; look down 16 pixels.
000AEBr 3               numsp5:
000AEBr 3  69 10        	adc #SPR_HGT
000AEDr 3  85 rr        	sta dispy		; coords in dispx,dispy.
000AEFr 3  4C rr rr     	jmp laddv
000AF2r 3               
000AF2r 3               ;------------------------------------------
000AF2r 3               ; Ladder up check.
000AF2r 3               ;
000AF2r 3               ; Input:
000AF2r 3               ;  IX = sprite pointer
000AF2r 3               ;
000AF2r 3               ; Output:
000AF2r 3               ;  A  = 0 is ok, A <>0 is not ok
000AF2r 3               ;------------------------------------------
000AF2r 3               
000AF2r 3               laddu:
000AF2r 3  A0 09        	ldy #9
000AF4r 3  B1 rr        	lda (z80_ix),y		; x coordinate.
000AF6r 3  85 rr        	sta dispx
000AF8r 3               
000AF8r 3  A0 08        	ldy #8
000AFAr 3  B1 rr        	lda (z80_ix),y		; y coordinate.
000AFCr 3  29 FE        	and #254 		; make it even.
000AFEr 3  91 rr        	sta (z80_ix),y		; reset it.
000B00r 3  18           	clc 			; look 2 pixels above feet.
000B01r 3               numsp6:
000B01r 3  69 0E        	adc #SPR_HGT-2
000B03r 3  85 rr        	sta dispy		; coords in dispx,dispy.
000B05r 3               laddv:
000B05r 3  20 rr rr     	jsr tstbl 		; get map address.
000B08r 3  20 rr rr     	jsr ldchk 		; standard ladder check.
000B0Br 3  F0 01        	beq :+
000B0Dr 3  60           	rts 			; no way through.
000B0Er 3               :
000B0Er 3  E6 rr        	inc bufaddr 		; look right one cell.
000B10r 3  D0 02        	bne :+
000B12r 3  E6 rr        	inc bufaddr+1
000B14r 3               :
000B14r 3  20 rr rr     	jsr ldchk 		; do the check.
000B17r 3  F0 01        	beq :+
000B19r 3  60           	rts 			; impassable.
000B1Ar 3               :
000B1Ar 3  A5 rr        	lda dispx 		; y coordinate.
000B1Cr 3  29 07        	and #7 			; position straddling block cells.
000B1Er 3  D0 01        	bne :+
000B20r 3  60           	rts 			; no more checks needed.
000B21r 3               :
000B21r 3  E6 rr        	inc bufaddr 		; look to third cell.
000B23r 3  D0 02        	bne :+
000B25r 3  E6 rr        	inc bufaddr+1
000B27r 3               :
000B27r 3  20 rr rr     	jsr ldchk 		; do the check.
000B2Ar 3  60           	rts  			; return with zero flag set accordingly.
000B2Br 3               .endif
000B2Br 3               
000B2Br 3               ;---------------------------------------------------------
000B2Br 3               ; Can go up check.
000B2Br 3               ;
000B2Br 3               ; Input:
000B2Br 3               ;  IX = sprite pointer
000B2Br 3               ;
000B2Br 3               ; Output:
000B2Br 3               ;  A  = 0 is ok, A <>0 is not ok
000B2Br 3               ;---------------------------------------------------------
000B2Br 3               
000B2Br 3               cangu:
000B2Br 3  A0 09        	ldy #9
000B2Dr 3  B1 rr        	lda (z80_ix),y		; x coordinate.
000B2Fr 3  85 rr        	sta dispx
000B31r 3  A0 08        	ldy #8
000B33r 3  B1 rr        	lda (z80_ix),y 		; y coordinate.
000B35r 3  38           	sec
000B36r 3  E9 02        	sbc #2
000B38r 3  85 rr        	sta dispy		; coords in dispx,dispy.
000B3Ar 3  20 rr rr     	jsr tstbl 		; get map address.
000B3Dr 3  20 rr rr     	jsr lrchk 		; standard left/right check.
000B40r 3  F0 01        	beq :+
000B42r 3  60           	rts			; no way through.
000B43r 3               :
000B43r 3  E6 rr        	inc bufaddr		; look right one cell.
000B45r 3  D0 02        	bne :+
000B47r 3  E6 rr        	inc bufaddr+1
000B49r 3               :
000B49r 3  20 rr rr     	jsr lrchk 		; do the check.
000B4Cr 3  F0 01        	beq :+
000B4Er 3  60           	rts			; impassable.
000B4Fr 3               :
000B4Fr 3  A5 rr        	lda dispx		; x coordinate.
000B51r 3  29 07        	and #7			; position straddling block cells.
000B53r 3  D0 01        	bne :+
000B55r 3  60           	rts			; no more checks needed.
000B56r 3               :
000B56r 3  E6 rr        	inc bufaddr		; look to third cell.
000B58r 3  D0 02        	bne :+
000B5Ar 3  E6 rr        	inc bufaddr+1
000B5Cr 3               :
000B5Cr 3  20 rr rr     	jsr lrchk		; do the check.
000B5Fr 3  60           	rts 			; return with zero flag set accordingly.
000B60r 3               
000B60r 3               ;---------------------------------------------------------
000B60r 3               ; Can go down check.
000B60r 3               ;
000B60r 3               ; Input:
000B60r 3               ;  IX = sprite pointer
000B60r 3               ;
000B60r 3               ; Output:
000B60r 3               ;  A  = 0 is ok, A <>0 is not ok
000B60r 3               ;---------------------------------------------------------
000B60r 3               
000B60r 3               cangd:
000B60r 3  A0 09        	ldy #9
000B62r 3  B1 rr        	lda (z80_ix),y 		; x coordinate.
000B64r 3  85 rr        	sta dispx
000B66r 3  A0 08        	ldy #8
000B68r 3  B1 rr        	lda (z80_ix),y		; y coordinate.
000B6Ar 3  18           	clc
000B6Br 3               numsp3:
000B6Br 3  69 10        	adc #SPR_HGT 		; look down 16 pixels.
000B6Dr 3  85 rr        	sta dispy		; coords in dispx,dispy.
000B6Fr 3  20 rr rr     	jsr tstbl 		; get map address.
000B72r 3  20 rr rr     	jsr plchk 		; block, platform check.
000B75r 3  F0 01        	beq :+
000B77r 3  60           	rts			; no way through.
000B78r 3               :
000B78r 3  E6 rr        	inc bufaddr		; look right one cell.
000B7Ar 3  D0 02        	bne :+
000B7Cr 3  E6 rr        	inc bufaddr+1
000B7Er 3               :
000B7Er 3  20 rr rr     	jsr plchk		; block, platform check.
000B81r 3  F0 01        	beq :+
000B83r 3  60           	rts			; impassable.
000B84r 3               :
000B84r 3  A5 rr        	lda dispx		; x coordinate.
000B86r 3  29 07        	and #7			; position straddling block cells.
000B88r 3  D0 01        	bne :+
000B8Ar 3  60           	rts			; no more checks needed.
000B8Br 3               :
000B8Br 3  E6 rr        	inc bufaddr		; look to third cell.
000B8Dr 3  D0 02        	bne :+
000B8Fr 3  E6 rr        	inc bufaddr+1
000B91r 3               :
000B91r 3  20 rr rr     	jsr plchk		; block, platform check.
000B94r 3  60           	rts			; return with zero flag set accordingly.
000B95r 3               
000B95r 3               ;---------------------------------------------------------
000B95r 3               ; Can go left check.
000B95r 3               ;
000B95r 3               ; Input:
000B95r 3               ;  IX = sprite pointer
000B95r 3               ;
000B95r 3               ; Output:
000B95r 3               ;  A  = 0 is ok, A <>0 is not ok
000B95r 3               ;---------------------------------------------------------
000B95r 3               
000B95r 3               cangl:
000B95r 3  A0 08        	ldy #8
000B97r 3  B1 rr        	lda (z80_ix),y 		; y coordinate.
000B99r 3  85 rr        	sta dispy
000B9Br 3  A0 09        	ldy #9
000B9Dr 3  B1 rr        	lda (z80_ix),y 		; x coordinate.
000B9Fr 3  38           	sec
000BA0r 3  E9 02        	sbc #2			; look left 2 pixels.
000BA2r 3  85 rr        	sta dispx		; coords in dispx,dispy.
000BA4r 3  4C rr rr     	jmp cangh		; test if we can go there.
000BA7r 3               
000BA7r 3               ;---------------------------------------------------------
000BA7r 3               ; Can go right check.
000BA7r 3               ;
000BA7r 3               ; Input:
000BA7r 3               ;  IX = sprite pointer
000BA7r 3               ;
000BA7r 3               ; Output:
000BA7r 3               ;  A  = 0 is ok, A <>0 is not ok
000BA7r 3               ;---------------------------------------------------------
000BA7r 3               
000BA7r 3               cangr:
000BA7r 3  A0 08        	ldy #8
000BA9r 3  B1 rr        	lda (z80_ix),y		; y coordinate.
000BABr 3  85 rr        	sta dispy
000BADr 3  A0 09        	ldy #9
000BAFr 3  B1 rr        	lda (z80_ix),y		; x coordinate.
000BB1r 3  18           	clc
000BB2r 3  69 10        	adc #16			; look right 16 pixels.
000BB4r 3  85 rr        	sta dispx		; coords in dispx,dispy.
000BB6r 3               cangh:
000BB6r 3               cangh2:
000BB6r 3  A9 03        	lda #(SPR_HGT/8+1)	; default rows to write.
000BB8r 3  85 rr        	sta z80_b
000BBAr 3  A5 rr        	lda dispy		; y position.
000BBCr 3  29 07        	and #7			; does x straddle cells?
000BBEr 3  D0 02        	bne cangh0		; yes, loop counter is good.
000BC0r 3  C6 rr        	dec z80_b		; one less row to write.
000BC2r 3               cangh0:
000BC2r 3  20 rr rr     	jsr tstbl		; get map address.
000BC5r 3               cangh1:
000BC5r 3  20 rr rr     	jsr lrchk		; standard left/right check.
000BC8r 3  F0 01        	beq :+
000BCAr 3  60           	rts			; no way through.
000BCBr 3               :
000BCBr 3  48           	pha
000BCCr 3  18           	clc
000BCDr 3  A5 rr        	lda bufaddr
000BCFr 3  69 20        	adc #32		; look down.
000BD1r 3  85 rr        	sta bufaddr
000BD3r 3  90 02        	bcc :+
000BD5r 3  E6 rr        	inc bufaddr+1
000BD7r 3               :
000BD7r 3  68           	pla
000BD8r 3               
000BD8r 3  C6 rr        	dec z80_b
000BDAr 3  D0 E9        	bne cangh1
000BDCr 3  60           	rts
000BDDr 3               
000BDDr 3               ;-------------------------------------
000BDDr 3               ; Check left/right movement is okay.
000BDDr 3               ;
000BDDr 3               ; Input:
000BDDr 3               ;  bufaddr = MAP + x/8 + y/8*32
000BDDr 3               ;
000BDDr 3               ; Output:
000BDDr 3               ;  A  = 0 is ok, A <>0 is not ok
000BDDr 3               ;-------------------------------------
000BDDr 3               
000BDDr 3               lrchk:
000BDDr 3  A0 00        	ldy #0
000BDFr 3  B1 rr        	lda (bufaddr),y		; fetch map cell.
000BE1r 3  C9 02        	cmp #WALL 		; is it passable?
000BE3r 3  F0 0A        	beq lrchkx		; no.
000BE5r 3               
000BE5r 3  C9 04        	cmp #FODDER		; fodder has to be dug.
000BE7r 3  F0 06        	beq lrchkx		; not passable.
000BE9r 3  A9 00        	lda #0
000BEBr 3  60           	rts
000BECr 3               
000BECr 3               ;--------------------------------------------------------------
000BECr 3               ; Called by mmenu
000BECr 3               ;--------------------------------------------------------------
000BECr 3               
000BECr 3               always:
000BECr 3  A9 FF        	lda #255		; report it as okay.
000BEEr 3  60           	rts
000BEFr 3               
000BEFr 3               lrchkx:
000BEFr 3  A9 01        	lda #1 			; reset all bits.
000BF1r 3  60           	rts
000BF2r 3               
000BF2r 3               
000BF2r 3               ;--------------------------------------------------------------
000BF2r 3               ; Check platform or solid item is not in way.
000BF2r 3               ;
000BF2r 3               ; Input:
000BF2r 3               ;  bufaddr = MAP + x/8 + y/8*32
000BF2r 3               ;
000BF2r 3               ; Output:
000BF2r 3               ;  A  = 0 is ok, A <>0 is not ok
000BF2r 3               ;--------------------------------------------------------------
000BF2r 3               
000BF2r 3               plchk:
000BF2r 3  A0 00        	ldy #0
000BF4r 3  B1 rr        	lda (bufaddr),y 	; fetch map cell.
000BF6r 3  C9 02        	cmp #WALL 		; is it passable?
000BF8r 3  F0 F5        	beq lrchkx		; no.
000BFAr 3               .if pflag .or dflag
000BFAr 3  C9 04        	cmp #FODDER		; fodder has to be dug.
000BFCr 3  F0 F1        	beq lrchkx		; not passable.
000BFEr 3               .endif
000BFEr 3  C9 01        	cmp #PLATFM		; platform is solid.
000C00r 3  F0 07        	beq plchkx		; not passable.
000C02r 3               .if lflag
000C02r 3  C9 03        	cmp #LADDER		; is it a ladder?
000C04r 3  F0 E9        	beq lrchkx		; on ladder, deny movement.
000C06r 3               .endif
000C06r 3               plchk0:
000C06r 3  A9 00        	lda #0			; report as ok
000C08r 3  60           	rts
000C09r 3               plchkx:
000C09r 3  A5 rr        	lda dispy		; x coordinate.
000C0Br 3  29 07        	and #7			; position straddling blocks.
000C0Dr 3  F0 E0        	beq lrchkx		; on platform, deny movement.
000C0Fr 3  4C rr rr     	jmp plchk0
000C12r 3               
000C12r 3               ;--------------------------------------------------------------
000C12r 3               ; Check ladder is available.
000C12r 3               ;
000C12r 3               ; Input:
000C12r 3               ;  bufaddr = MAP + x/8 + y/8*32
000C12r 3               ;
000C12r 3               ; Output:
000C12r 3               ;  A  = 0 is ok, A <>0 is not ok
000C12r 3               ;--------------------------------------------------------------
000C12r 3               
000C12r 3               .if lflag
000C12r 3               ldchk:
000C12r 3  A0 00        	ldy #0
000C14r 3  B1 rr        	lda (bufaddr),y 	; fetch cell.
000C16r 3  C9 03        	cmp #LADDER 		; is it a ladder?
000C18r 3  F0 03        	beq ldchk1
000C1Ar 3  A9 01        	lda #1
000C1Cr 3  60           	rts  			; return with zero flag set accordingly.
000C1Dr 3               ldchk1:
000C1Dr 3  A9 00        	lda #0
000C1Fr 3  60           	rts
000C20r 3               .endif
000C20r 3               
000C20r 3               ;--------------------------------------------------------------
000C20r 3               ; Get collectables.
000C20r 3               ;--------------------------------------------------------------
000C20r 3               
000C20r 3               .if cflag
000C20r 3               getcol:
000C20r 3                       lda #COLECT             ; collectable blocks.
000C20r 3                       sta z80_b
000C20r 3                       jsr tded                ; test for collectable blocks.
000C20r 3                       cmp z80_b               ; did we find one?
000C20r 3                       beq :+
000C20r 3                       rts                     ; none were found, job done.
000C20r 3               :
000C20r 3                       jsr gtblk               ; get block.
000C20r 3                       jsr evnt20              ; collected block event.
000C20r 3                       jmp getcol              ; repeat until none left.
000C20r 3               
000C20r 3               ; Get collectable block.
000C20r 3               
000C20r 3               gtblk:
000C20r 3               	ldy #0
000C20r 3               	lda (bufaddr),y
000C20r 3               	sta z80_a
000C20r 3                       lda #0
000C20r 3                       sta (bufaddr),y		; make it empty now.
000C20r 3               
000C20r 3               	lda bufaddr		; set dispx
000C20r 3               	and #31
000C20r 3               	sta dispx
000C20r 3               
000C20r 3               	lda bufaddr+1		; Set dispy
000C20r 3               	sec
000C20r 3               	sbc #>MAP
000C20r 3               	sta bufaddr+1
000C20r 3               	asl bufaddr
000C20r 3               	rol bufaddr+1
000C20r 3               	asl bufaddr
000C20r 3               	rol bufaddr+1
000C20r 3               	asl bufaddr
000C20r 3               	rol bufaddr+1
000C20r 3               	lda bufaddr+1
000C20r 3               	sta dispy
000C20r 3               
000C20r 3               	lda colpatt		; get blocknr
000C20r 3               	sta z80_e		; displacement in e.
000C20r 3               	lda #0
000C20r 3               	sta z80_d		; no high byte.
000C20r 3               	asl z80_e  		; multiply char by 8.
000C20r 3               	rol z80_d
000C20r 3               	asl z80_e
000C20r 3               	rol z80_d
000C20r 3               	asl z80_e
000C20r 3               	rol z80_d
000C20r 3               	clc
000C20r 3               	lda z80_e
000C20r 3               	adc #<chgfx 		; address of graphics.
000C20r 3               	sta tileaddr
000C20r 3               	lda z80_d
000C20r 3               	adc #>chgfx
000C20r 3               	sta tileaddr+1
000C20r 3               
000C20r 3               	jsr gprad 		; get screen address.
000C20r 3               	ldx #7			; number of pixel rows to write.
000C20r 3               gtblk0:
000C20r 3               	ldy #0
000C20r 3               	lda (tileaddr),y 	; get image byte.
000C20r 3               	ldy scrtab,x
000C20r 3               	eor (scraddr),y 	; XOR tile on screen
000C20r 3               	sta (scraddr),y 	; copy to screen.
000C20r 3               	inc tileaddr 		; next image byte.
000C20r 3               	bne :+
000C20r 3               	inc tileaddr+1
000C20r 3               :
000C20r 3               	dex	 		; repeat for 8 pixel rows.
000C20r 3               	bpl gtblk0
000C20r 3               	rts
000C20r 3               .endif
000C20r 3               
000C20r 3               ;--------------------------------------------------------------
000C20r 3               ; Touched deadly block check.
000C20r 3               ; returns with DEADLY (must be non-zero) in accumulator if true.
000C20r 3               ;
000C20r 3               ; Input:
000C20r 3               ;  IX = sprite address
000C20r 3               ;
000C20r 3               ; Output:
000C20r 3               ;  A  = 0 is ok, A=5 is not ok
000C20r 3               ;--------------------------------------------------------------
000C20r 3               
000C20r 3               tded:
000C20r 3  A0 08        	ldy #8
000C22r 3  B1 rr        	lda (z80_ix),y 		; y coordinate.
000C24r 3  85 rr        	sta dispy
000C26r 3  C8           	iny
000C27r 3  B1 rr        	lda (z80_ix),y 		; x coordinate.
000C29r 3  85 rr        	sta dispx		; coords in dispx,dispy.
000C2Br 3  20 rr rr     	jsr tstbl		; get map address.
000C2Er 3  48           	pha
000C2Fr 3  A9 1F        	lda #31			; default distance to next line down.
000C31r 3  85 rr        	sta z80_e
000C33r 3  68           	pla
000C34r 3  C5 rr        	cmp z80_b		; is this the required block?
000C36r 3  D0 01        	bne :+
000C38r 3  60           	rts			; yes.
000C39r 3               :
000C39r 3  E6 rr        	inc bufaddr 		; next cell.
000C3Br 3  D0 02        	bne :+
000C3Dr 3  E6 rr        	inc bufaddr+1
000C3Fr 3               :
000C3Fr 3  A0 00        	ldy #0
000C41r 3  B1 rr        	lda (bufaddr),y		; fetch type.
000C43r 3  C5 rr        	cmp z80_b 		; is this deadly/custom?
000C45r 3  D0 01        	bne :+
000C47r 3  60           	rts			; yes.
000C48r 3               :
000C48r 3  A5 rr        	lda dispx		; horizontal position.
000C4Ar 3  85 rr        	sta z80_c 		; store column in c register.
000C4Cr 3  29 07        	and #7			; is it straddling cells?
000C4Er 3  D0 03        	bne :+
000C50r 3  4C rr rr     	jmp tded0		; no.
000C53r 3               :
000C53r 3  E6 rr        	inc bufaddr 		; last cell.
000C55r 3  D0 02        	bne :+
000C57r 3  E6 rr        	inc bufaddr+1
000C59r 3               :
000C59r 3  A0 00        	ldy #0
000C5Br 3  B1 rr        	lda (bufaddr),y 	; fetch type.
000C5Dr 3  C5 rr        	cmp z80_b		; is this the block?
000C5Fr 3  D0 01        	bne :+
000C61r 3  60           	rts			; yes.
000C62r 3               :
000C62r 3  C6 rr        	dec z80_e		; one less cell to next row down.
000C64r 3               tded0:
000C64r 3  18           	clc 			; point to next row.
000C65r 3  A5 rr        	lda bufaddr
000C67r 3  65 rr        	adc z80_e
000C69r 3  85 rr        	sta bufaddr
000C6Br 3  90 02        	bcc :+
000C6Dr 3  E6 rr        	inc bufaddr+1
000C6Fr 3               :
000C6Fr 3  A0 00        	ldy #0
000C71r 3  B1 rr        	lda (bufaddr),y		; fetch left cell block.
000C73r 3  C5 rr        	cmp z80_b		; is this fatal?
000C75r 3  D0 01        	bne :+
000C77r 3  60           	rts			; yes.
000C78r 3               :
000C78r 3  E6 rr        	inc bufaddr 		; next cell.
000C7Ar 3  D0 02        	bne :+
000C7Cr 3  E6 rr        	inc bufaddr+1
000C7Er 3               :
000C7Er 3  A0 00        	ldy #0
000C80r 3  B1 rr        	lda (bufaddr),y 	; fetch type.
000C82r 3  C5 rr        	cmp z80_b		; is this fatal?
000C84r 3  D0 01        	bne :+
000C86r 3  60           	rts			; yes.
000C87r 3               :
000C87r 3  A5 rr        	lda z80_c		; horizontal position.
000C89r 3  29 07        	and #7			; is it straddling cells?
000C8Br 3  D0 03        	bne :+
000C8Dr 3  4C rr rr     	jmp tded1 		; no.
000C90r 3               :
000C90r 3  E6 rr        	inc bufaddr		; last cell.
000C92r 3  D0 02        	bne :+
000C94r 3  E6 rr        	inc bufaddr+1
000C96r 3               :
000C96r 3  A0 00        	ldy #0
000C98r 3  B1 rr        	lda (bufaddr),y		; fetch type.
000C9Ar 3  C5 rr        	cmp z80_b		; is this fatal?
000C9Cr 3  D0 01        	bne :+
000C9Er 3  60           	rts			; yes.
000C9Fr 3               :
000C9Fr 3               tded1:
000C9Fr 3  A5 rr        	lda dispy		; vertical position.
000CA1r 3  29 07        	and #7 			; is it straddling cells?
000CA3r 3  D0 01        	bne :+
000CA5r 3  60           	rts			; no, job done.
000CA6r 3               :
000CA6r 3  18           	clc			; point to next row.
000CA7r 3  A5 rr        	lda bufaddr
000CA9r 3  65 rr        	adc z80_e
000CABr 3  85 rr        	sta bufaddr
000CADr 3  90 02        	bcc :+
000CAFr 3  E6 rr        	inc bufaddr+1
000CB1r 3               :
000CB1r 3  A0 00        	ldy #0
000CB3r 3  B1 rr        	lda (bufaddr),y 	; fetch left cell block.
000CB5r 3  C5 rr        	cmp z80_b		; is this fatal?
000CB7r 3  D0 01        	bne :+
000CB9r 3  60           	rts			; yes.
000CBAr 3               :
000CBAr 3  E6 rr        	inc bufaddr		; next cell.
000CBCr 3  D0 02        	bne :+
000CBEr 3  E6 rr        	inc bufaddr+1
000CC0r 3               :
000CC0r 3  A0 00        	ldy #0
000CC2r 3  B1 rr        	lda (bufaddr),y 	; fetch type.
000CC4r 3  C5 rr        	cmp z80_b		; is this fatal?
000CC6r 3  D0 01        	bne :+
000CC8r 3  60           	rts			; yes.
000CC9r 3               :
000CC9r 3  A5 rr        	lda z80_c		; horizontal position.
000CCBr 3  29 07        	and #7			; is it straddling cells?
000CCDr 3  D0 01        	bne :+
000CCFr 3  60           	rts			; no.
000CD0r 3               :
000CD0r 3  E6 rr        	inc bufaddr		; last cell.
000CD2r 3  D0 02        	bne :+
000CD4r 3  E6 rr        	inc bufaddr+1
000CD6r 3               :
000CD6r 3  A0 00        	ldy #0
000CD8r 3  B1 rr        	lda (bufaddr),y		; fetch final type.
000CDAr 3  60           	rts 			; return with final type in accumulator.
000CDBr 3               
000CDBr 3               ;---------------------------------------------------
000CDBr 3               ; Fetch block type at (dispx, dispy).
000CDBr 3               ;
000CDBr 3               ; Output:
000CDBr 3               ;  A = block type
000CDBr 3               ;---------------------------------------------------
000CDBr 3               
000CDBr 3               tstbl:
000CDBr 3  A5 rr        	lda dispy 		; fetch y coord.
000CDDr 3  4A           	lsr a			; bufaddr = y/8
000CDEr 3  4A           	lsr a
000CDFr 3  4A           	lsr a
000CE0r 3               ;	sta chary
000CE0r 3               
000CE0r 3  85 rr        	sta bufaddr
000CE2r 3  A9 00        	lda #0
000CE4r 3  85 rr        	sta bufaddr+1
000CE6r 3               
000CE6r 3  06 rr        	asl bufaddr  		; bufaddr = y/8 * 32
000CE8r 3  26 rr        	rol bufaddr+1
000CEAr 3  06 rr        	asl bufaddr
000CECr 3  26 rr        	rol bufaddr+1
000CEEr 3  06 rr        	asl bufaddr
000CF0r 3  26 rr        	rol bufaddr+1
000CF2r 3  06 rr        	asl bufaddr
000CF4r 3  26 rr        	rol bufaddr+1
000CF6r 3  06 rr        	asl bufaddr
000CF8r 3  26 rr        	rol bufaddr+1
000CFAr 3               
000CFAr 3  A5 rr        	lda dispx		; x/8
000CFCr 3  4A           	lsr a
000CFDr 3  4A           	lsr a
000CFEr 3  4A           	lsr a
000CFFr 3               ;	sta charx
000CFFr 3               
000CFFr 3  18           	clc			; bufaddr = MAP + x/8 + y/8*32
000D00r 3  65 rr        	adc bufaddr
000D02r 3  69 00        	adc #<MAP
000D04r 3  85 rr        	sta bufaddr
000D06r 3  A5 rr        	lda bufaddr+1
000D08r 3  69 04        	adc #>MAP
000D0Ar 3  85 rr        	sta bufaddr+1
000D0Cr 3               
000D0Cr 3  A0 00        	ldy #0
000D0Er 3  B1 rr        	lda (bufaddr),y 	; fetch byte there.
000D10r 3  60           	rts
000D11r 3               
000D11r 3               ;-------------------------------------------------------------------
000D11r 3               ; Jump - if we can.
000D11r 3               ; Requires initial speed to be set up in accumulator prior to call.
000D11r 3               ;
000D11r 3               ; Input:
000D11r 3               ;  IX = sprite address
000D11r 3               ;-------------------------------------------------------------------
000D11r 3               
000D11r 3               jump:
000D11r 3  A0 0D        	ldy #var_jumpLo
000D13r 3  B1 rr        	lda (z80_ix),y		; jump table low.
000D15r 3  A0 0E        	ldy #var_jumpHi
000D17r 3  11 rr        	ora (z80_ix),y		; jump table high.
000D19r 3  F0 01        	beq :+
000D1Br 3  60           	rts			; already in the air.
000D1Cr 3               :
000D1Cr 3  A9 rr        	lda #>jtab
000D1Er 3  A0 0E        	ldy #var_jumpHi
000D20r 3  91 rr        	sta (z80_ix),y		; set jump high.
000D22r 3  A9 rr        	lda #<jtab		; jump table start.
000D24r 3  A0 0D        	ldy #var_jumpLo
000D26r 3  91 rr        	sta (z80_ix),y		; set jump low.
000D28r 3  60           	rts
000D29r 3               
000D29r 3               ; Jump table.
000D29r 3               ; _BEEB - jump table must reside entirely in a page otherwise grav fn breaks
000D29r 3               ;.align 32
000D29r 3               ;jtab:
000D29r 3               ;	.byte 248,250,252
000D29r 3               ;	.byte 254,254,255
000D29r 3               ;	.byte 255,255,0,0
000D29r 3               ;	.byte 0,1,1,1,2,2
000D29r 3               ;	.byte 4,6,8,8,8,99
000D29r 3               
000D29r 3               ;------------------------------------------------
000D29r 3               ; Random numbers code.
000D29r 3               ; Pseudo-random number generator, 8-bit.
000D29r 3               ;
000D29r 3               ; Output:
000D29r 3               ;  RND = random number
000D29r 3               ;------------------------------------------------
000D29r 3               
000D29r 3               random:
000D29r 3  A5 rr        	lda seed
000D2Br 3  F0 05        	beq doEor
000D2Dr 3  0A           	asl a
000D2Er 3  F0 04        	beq noEor
000D30r 3  90 02        	bcc noEor
000D32r 3  49 1D        doEor:	eor #$1d
000D34r 3  85 rr        noEor:	sta seed
000D36r 3  60           	rts
000D37r 3               
000D37r 3               ;	lda seed		; get last random number.
000D37r 3               ;	asl a
000D37r 3               ;	asl a
000D37r 3               ;	clc
000D37r 3               ;	adc seed
000D37r 3               ;	clc
000D37r 3               ;	adc #$45
000D37r 3               ;	sta seed		; store new seed.
000D37r 3               ;	sta varrnd		; return number in variable.
000D37r 3               ;	rts
000D37r 3               
000D37r 3               ;-------------------------------------------------------
000D37r 3               ; Joystick and keyboard reading routines.
000D37r 3               ;
000D37r 3               ; contrl = 0, Keyboard
000D37r 3               ;          1, JoyKeyb
000D37r 3               ;          2, JoyMMC
000D37r 3               ;
000D37r 3               ;      joyval=x65FUDLR (bit cleared if key pressed)
000D37r 3               ;             ||||||||
000D37r 3               ;             |||||||+> Right    KEY 0  - X
000D37r 3               ;             ||||||+-> Left     KEY 1  - Z
000D37r 3               ;             |||||+--> Down     KEY 2  - .
000D37r 3               ;             ||||+---> Up       KEY 3  - ;
000D37r 3               ;             |||+----> Fire1    KEY 4  - SPC
000D37r 3               ;             ||+-----> Fire2    KEY 5  - Q
000D37r 3               ;             |+------> Fire3    KEY 6  - P
000D37r 3               ;             +-------> Not used
000D37r 3               ;
000D37r 3               ;                       Option1  KEY 7  - 1
000D37r 3               ;                       Option2  KEY 8  - 2
000D37r 3               ;                       Option3  KEY 9  - 3
000D37r 3               ;                       Option4  KEY 10 - 4
000D37r 3               ;-------------------------------------------------------
000D37r 3               
000D37r 3               joykey:
000D37r 3  A5 rr        	lda contrl 		; control flag.
000D39r 3  C9 01        	cmp #1
000D3Br 3  F0 1A        	beq joy1 		; scan joystick1
000D3Dr 3  C9 02        	cmp #2
000D3Fr 3  F0 1C        	beq joy2 		; scan joystick2
000D41r 3               
000D41r 3               ; Scan keyboard
000D41r 3               
000D41r 3  A9 00        	lda #0		 	; zero reading.
000D43r 3  85 rr        	sta z80_e
000D45r 3               
000D45r 3  A0 06        	ldy #6	 		; address of last key.
000D47r 3               joyke0:
000D47r 3  B9 rr rr     	lda keys,y 		; get key from table.
000D4Ar 3  20 rr rr     	jsr ktest		; being pressed?
000D4Dr 3  26 rr        	rol z80_e 		; rotate into reading.
000D4Fr 3               
000D4Fr 3  88           	dey		 	; next key.
000D50r 3  10 F5        	bpl joyke0 		; repeat for all keys.
000D52r 3               joyret:
000D52r 3  A5 rr        	lda z80_e
000D54r 3  85 rr        	sta joyval
000D56r 3  60           	rts
000D57r 3               
000D57r 3               ; Scan joystick 1
000D57r 3               
000D57r 3               joy1:
000D57r 3  20 rr rr     	jsr joy1scan
000D5Ar 3  4C rr rr     	jmp joyret 		; store the value.
000D5Dr 3               
000D5Dr 3               ; Scan joystick 2
000D5Dr 3               
000D5Dr 3               joy2:
000D5Dr 3  20 rr rr     	jsr joy2scan
000D60r 3  4C rr rr     	jmp joyret 		; store the value.
000D63r 3               
000D63r 3               ;---------------------------------------------------------------
000D63r 3               ; Display message.
000D63r 3               ;
000D63r 3               ; Input:
000D63r 3               ;  A = message number
000D63r 3               ;---------------------------------------------------------------
000D63r 3               
000D63r 3               dmsg:
000D63r 3  AA           	tax
000D64r 3  A9 rr        	lda #<msgdat		; pointer to messages.
000D66r 3  85 rr        	sta z80_l
000D68r 3  A9 rr        	lda #>msgdat
000D6Ar 3  85 rr        	sta z80_h
000D6Cr 3  20 rr rr     	jsr getwrd		; get message number.
000D6Fr 3               dmsg3:
000D6Fr 3  20 rr rr     	jsr preprt		; pre-printing stuff.
000D72r 3  20 rr rr     	jsr checkx		; make sure we"re in a printable range.
000D75r 3  A5 rr        	lda prtmod		; print mode.
000D77r 3  D0 47        	bne bmsg1		; no, double-height text.
000D79r 3               dmsg0:
000D79r 3  A5 rr        	lda z80_h		; store string pointer.
000D7Br 3  48           	pha
000D7Cr 3  A5 rr        	lda z80_l
000D7Er 3  48           	pha
000D7Fr 3               
000D7Fr 3  A0 00        	ldy #0
000D81r 3  B1 rr        	lda (z80_hl),y		; fetch byte to display.
000D83r 3  29 7F        	and #127		; remove any end marker.
000D85r 3  C9 0D        	cmp #ASCII_NEWLINE
000D87r 3  F0 24        	beq dmsg1
000D89r 3  20 rr rr     	jsr pchar		; display character.
000D8Cr 3  20 rr rr     	jsr nexpos 		; display position.
000D8Fr 3  D0 03        	bne dmsg2		; not on a new line.
000D91r 3  20 rr rr     	jsr nexlin		; next line down.
000D94r 3               dmsg2:
000D94r 3  68           	pla			; retrieve string pointer
000D95r 3  85 rr        	sta z80_l
000D97r 3  68           	pla
000D98r 3  85 rr        	sta z80_h
000D9Ar 3               
000D9Ar 3  A0 00        	ldy #0
000D9Cr 3  B1 rr        	lda (z80_hl),y		; fetch last character.
000D9Er 3  0A           	asl a  			; was it the end?
000D9Fr 3  90 03        	bcc :+
000DA1r 3  4C rr rr     	jmp dscor2		; yes, job done.
000DA4r 3               :
000DA4r 3  E6 rr        	inc z80_l		; next character to display.
000DA6r 3  D0 02        	bne :+
000DA8r 3  E6 rr        	inc z80_h
000DAAr 3               :
000DAAr 3  4C rr rr     	jmp dmsg0
000DADr 3               dmsg1:
000DADr 3  E6 rr        	inc dispy
000DAFr 3  A5 rr        	lda dispy
000DB1r 3  C9 18        	cmp #24
000DB3r 3  90 04        	bcc dmsg4
000DB5r 3  A9 00        	lda #0
000DB7r 3  85 rr        	sta dispy
000DB9r 3               dmsg4:
000DB9r 3  A9 00        	lda #0
000DBBr 3  85 rr        	sta dispx
000DBDr 3  4C rr rr     	jmp dmsg2
000DC0r 3               
000DC0r 3               
000DC0r 3               ;----------------------------------------------------------
000DC0r 3               ; Display message in big text.
000DC0r 3               ;
000DC0r 3               ; Input:
000DC0r 3               ;  HL = string pointer
000DC0r 3               ;----------------------------------------------------------
000DC0r 3               
000DC0r 3               bmsg1:
000DC0r 3  A0 00        	ldy #0
000DC2r 3  B1 rr        	lda (z80_hl),y 		; get character to display.
000DC4r 3  29 7F        	and #127		; only want 7 bits.
000DC6r 3  C9 0D        	cmp #ASCII_NEWLINE
000DC8r 3  F0 13        	beq bmsg2
000DCAr 3  20 rr rr     	jsr bchar 		; display big char.
000DCDr 3               bmsg3:
000DCDr 3  A0 00        	ldy #0
000DCFr 3  B1 rr        	lda (z80_hl),y 		; look at last character.
000DD1r 3  48           	pha
000DD2r 3  E6 rr        	inc z80_l 		; next character in list.
000DD4r 3  D0 02        	bne :+
000DD6r 3  E6 rr        	inc z80_h
000DD8r 3               :
000DD8r 3  68           	pla
000DD9r 3  0A           	asl a  			; was terminator flag set?
000DDAr 3  90 E4        	bcc bmsg1		; no, keep going.
000DDCr 3               
000DDCr 3  60           	rts
000DDDr 3               bmsg2:
000DDDr 3  A9 00        	lda #0
000DDFr 3  85 rr        	sta dispx
000DE1r 3  E6 rr        	inc dispy
000DE3r 3  E6 rr        	inc dispy
000DE5r 3  A5 rr        	lda dispy
000DE7r 3  C9 17        	cmp #23
000DE9r 3  90 E2        	bcc bmsg3
000DEBr 3  A9 00        	lda #0
000DEDr 3  85 rr        	sta dispy
000DEFr 3  4C rr rr     	jmp bmsg3
000DF2r 3               
000DF2r 3               ;----------------------------------------------------------
000DF2r 3               ; Big character display.
000DF2r 3               ;
000DF2r 3               ; Input:
000DF2r 3               ;  A = character
000DF2r 3               ;----------------------------------------------------------
000DF2r 3               
000DF2r 3               bchar:
000DF2r 3  85 rr        	sta z80_e		; save char in lb
000DF4r 3  A9 00        	lda #0
000DF6r 3  85 rr        	sta z80_d		; reset hb
000DF8r 3               
000DF8r 3  06 rr        	asl z80_e 		; multiply char by 8.
000DFAr 3  26 rr        	rol z80_d
000DFCr 3  06 rr        	asl z80_e
000DFEr 3  26 rr        	rol z80_d
000E00r 3  06 rr        	asl z80_e
000E02r 3  26 rr        	rol z80_d		; de = a*8
000E04r 3               
000E04r 3  18           	clc			; de = #<(FONT-256) + a*8
000E05r 3  A5 rr        	lda z80_e
000E07r 3  69 rr        	adc #<(FONT-256) 		; address of font.
000E09r 3  85 rr        	sta z80_e
000E0Br 3  A5 rr        	lda z80_d
000E0Dr 3  69 rr        	adc #>(FONT-256)
000E0Fr 3  85 rr        	sta z80_d
000E11r 3               
000E11r 3  20 rr rr     	jsr gaadd		; set colour attribute
000E14r 3  AD rr rr     	lda fontcol
000E17r 3  A0 00        	ldy #0
000E19r 3  91 rr        	sta (bufaddr),y
000E1Br 3               
000E1Br 3  20 rr rr     	jsr gprad 		; get screen address.
000E1Er 3               
000E1Er 3  A2 00        	ldx #0			; height of character in font.
000E20r 3               bchar0:
000E20r 3  A0 00        	ldy #0
000E22r 3  B1 rr        	lda (z80_de),y 		; get a bit of the font.
000E24r 3               
000E24r 3               .if iflag
000E24r 3               	eor #$ff
000E24r 3               .endif
000E24r 3               
000E24r 3  91 rr        	sta (scraddr),y
000E26r 3  48           	pha
000E27r 3  20 rr rr     	jsr nline 		; next line down.
000E2Ar 3  68           	pla
000E2Br 3  91 rr        	sta (scraddr),y
000E2Dr 3  20 rr rr     	jsr nline 		; next line down.
000E30r 3               
000E30r 3  18           	clc
000E31r 3  E6 rr        	inc z80_e 		; next line of font.
000E33r 3  D0 02        	bne :+
000E35r 3  E6 rr        	inc z80_d
000E37r 3               :
000E37r 3  E8           	inx
000E38r 3  E0 08        	cpx #8
000E3Ar 3  D0 E4        	bne bchar0
000E3Cr 3               
000E3Cr 3  20 rr rr     	jsr nexpos		; display position.
000E3Fr 3  D0 05        	bne bchar2 		; not on a new line.
000E41r 3               bchar3:
000E41r 3  E6 rr        	inc dispy
000E43r 3  20 rr rr     	jsr nexlin 		; next line check.
000E46r 3               bchar2:
000E46r 3  4C rr rr     	jmp dscor2		; tidy up line and column variables.
000E49r 3               
000E49r 3               
000E49r 3               ;-------------------------------------------------
000E49r 3               ; Display a character.
000E49r 3               ;
000E49r 3               ; Input:
000E49r 3               ;  A = character
000E49r 3               ;-------------------------------------------------
000E49r 3               
000E49r 3               achar:
000E49r 3  85 rr        	sta z80_b 		; copy to b.
000E4Br 3  20 rr rr     	jsr preprt 		; get ready to print.
000E4Er 3  A5 rr        	lda z80_b		; character in accumulator.
000E50r 3  A6 rr        	ldx prtmod 		; print mode.
000E52r 3  F0 03        	beq :+
000E54r 3  4C rr rr     	jmp bchar 		; no, double-height text.
000E57r 3               :
000E57r 3  20 rr rr     	jsr pchar 		; display character.
000E5Ar 3  20 rr rr     	jsr nexpos 		; display position.
000E5Dr 3  F0 E2        	beq bchar3		; next line down.
000E5Fr 3  4C rr rr     	jmp bchar2 		; tidy up.
000E62r 3               
000E62r 3               
000E62r 3               ;-------------------------------------------------
000E62r 3               ; Get next print column position.
000E62r 3               ;-------------------------------------------------
000E62r 3               
000E62r 3               nexpos:
000E62r 3  E6 rr        	inc dispx		; move along one position.
000E64r 3  A5 rr        	lda dispx 		; get coordinate.
000E66r 3  C9 16        	cmp #22
000E68r 3  D0 0E        	bne :+
000E6Ar 3  A9 00        	lda #0
000E6Cr 3  85 rr        	sta dispx
000E6Er 3  A5 rr        	lda prtmod
000E70r 3  F0 06        	beq :+
000E72r 3  20 rr rr     	jsr nexlin
000E75r 3  4C rr rr     	jmp nexlin
000E78r 3               :
000E78r 3  60           	rts
000E79r 3               
000E79r 3               ;-------------------------------------------------
000E79r 3               ; Get next print line position.
000E79r 3               ;-------------------------------------------------
000E79r 3               
000E79r 3               nexlin:
000E79r 3  E6 rr        	inc dispy 		; newline.
000E7Br 3  A5 rr        	lda dispy		; vertical position.
000E7Dr 3  C9 16        	cmp #22			; past screen edge?
000E7Fr 3  B0 01        	bcs :+
000E81r 3  60           	rts			; no, still okay.
000E82r 3               :
000E82r 3  A9 00        	lda #0			; restart at top.
000E84r 3  85 rr        	sta dispy
000E86r 3  60           	rts
000E87r 3               
000E87r 3               ;--------------------------------------------------------
000E87r 3               ; Pre-print preliminaries.
000E87r 3               ;--------------------------------------------------------
000E87r 3               
000E87r 3               preprt:
000E87r 3  A9 rr        	lda #<(FONT-256)		; font pointer.
000E89r 3  8D rr rr     	sta grbase		; set up graphics base.
000E8Cr 3  A9 rr        	lda #>(FONT-256)
000E8Er 3  8D rr rr     	sta grbase+1
000E91r 3               prescr:
000E91r 3  A5 rr        	lda charx 		; display coordinates.
000E93r 3  85 rr        	sta dispx		; set up general coordinates.
000E95r 3  A5 rr        	lda chary
000E97r 3  85 rr        	sta dispy
000E99r 3  60           	rts
000E9Ar 3               
000E9Ar 3               ;--------------------------------------------------------------
000E9Ar 3               ; Get messagenr x in hl
000E9Ar 3               ;
000E9Ar 3               ; Input:
000E9Ar 3               ;  HL = pointer to message list
000E9Ar 3               ;  X  = message number.
000E9Ar 3               ;--------------------------------------------------------------
000E9Ar 3               
000E9Ar 3               getwrd:
000E9Ar 3  E0 00        	cpx #0
000E9Cr 3  D0 01        	bne:+ 			; first word in list?
000E9Er 3  60           	rts 			; yep, don't search.
000E9Fr 3               :
000E9Fr 3  A0 00        	ldy #0
000EA1r 3               getwd0:
000EA1r 3  B1 rr        	lda (z80_hl),y
000EA3r 3  48           	pha
000EA4r 3  E6 rr        	inc z80_l
000EA6r 3  D0 02        	bne :+
000EA8r 3  E6 rr        	inc z80_h
000EAAr 3               :
000EAAr 3  68           	pla
000EABr 3  C9 80        	cmp #128		; found end?
000EADr 3  30 F2        	bmi getwd0		; no, carry on.
000EAFr 3  CA           	dex			; until we have right number.
000EB0r 3  D0 EF        	bne getwd0
000EB2r 3  60           	rts
000EB3r 3               
000EB3r 3               ;-----------------------------------------------------------
000EB3r 3               ; Bubble sort.
000EB3r 3               ;-----------------------------------------------------------
000EB3r 3               
000EB3r 3               bsort:
000EB3r 3  A9 0B        	lda #NUMSPR - 1		; sprites to swap.
000EB5r 3  85 rr        	sta qscnt
000EB7r 3               
000EB7r 3  A9 rr        	lda #<sprtab 		; sprite table.
000EB9r 3  85 rr        	sta z80_x
000EBBr 3  A9 rr        	lda #>sprtab
000EBDr 3  85 rr        	sta z80_i
000EBFr 3               bsort0:
000EBFr 3  A0 00        	ldy #0
000EC1r 3  B1 rr        	lda (z80_ix),y 		; first sprite type.
000EC3r 3  C9 FF        	cmp #255 		; is it switched off?
000EC5r 3  F0 30        	beq swemp		; yes, may need to switch another in here.
000EC7r 3               
000EC7r 3  A0 12        	ldy #TABSIZ
000EC9r 3  B1 rr        	lda (z80_ix),y 		; check next slot exists.
000ECBr 3  C9 FF        	cmp #255 		; is it enabled?
000ECDr 3  F0 0A        	beq bsort2 		; no, nothing to swap.
000ECFr 3               
000ECFr 3  A0 15        	ldy #TABSIZ+3
000ED1r 3  B1 rr        	lda (z80_ix),y 		; fetch next sprite's coordinate.
000ED3r 3  A0 03        	ldy #3
000ED5r 3  D1 rr        	cmp (z80_ix),y 		; compare with this x coordinate.
000ED7r 3  90 10        	bcc bsort1		; next sprite is higher - may need to switch.
000ED9r 3               bsort2:
000ED9r 3  18           	clc
000EDAr 3  A5 rr        	lda z80_x
000EDCr 3  69 12        	adc #TABSIZ 		; distance to next odd/even entry.
000EDEr 3  85 rr        	sta z80_x
000EE0r 3  90 02        	bcc :+
000EE2r 3  E6 rr        	inc z80_i
000EE4r 3               :
000EE4r 3  C6 rr        	dec qscnt
000EE6r 3  D0 D7        	bne bsort0		; repeat for remaining sprites.
000EE8r 3  60           	rts
000EE9r 3               
000EE9r 3               bsort1:
000EE9r 3  A0 12        	ldy #TABSIZ
000EEBr 3  B1 rr        	lda (z80_ix),y		; sprite on/off flag.
000EEDr 3  C9 FF        	cmp #255		; is it enabled?
000EEFr 3  F0 E8        	beq bsort2		; no, nothing to swap.
000EF1r 3  20 rr rr     	jsr swspr		; swap positions.
000EF4r 3  4C rr rr     	jmp bsort2
000EF7r 3               swemp:
000EF7r 3  A0 12        	ldy #TABSIZ
000EF9r 3  B1 rr        	lda (z80_ix),y		; next table entry.
000EFBr 3  C9 FF        	cmp #255		; is that one on?
000EFDr 3  F0 DA        	beq bsort2		; no, nothing to swap.
000EFFr 3  20 rr rr     	jsr swspr		; swap positions.
000F02r 3  4C rr rr     	jmp bsort2
000F05r 3               
000F05r 3               ; Swap sprites.
000F05r 3               
000F05r 3               swspr:
000F05r 3  A5 rr        	lda z80_x		; table address
000F07r 3  85 rr        	sta z80_e		; copy to de pair.
000F09r 3  85 rr        	sta z80_l		; copy to hl pair.
000F0Br 3  A5 rr        	lda z80_i
000F0Dr 3  85 rr        	sta z80_h
000F0Fr 3  85 rr        	sta z80_d
000F11r 3               
000F11r 3  18           	clc
000F12r 3  A5 rr        	lda z80_l
000F14r 3  69 12        	adc #TABSIZ		; distance to second entry.
000F16r 3  85 rr        	sta z80_l
000F18r 3  90 02        	bcc :+
000F1Ar 3  E6 rr        	inc z80_h
000F1Cr 3               :
000F1Cr 3  A9 12        	lda #TABSIZ		; bytes to swap.
000F1Er 3  85 rr        	sta z80_b
000F20r 3  A0 00        	ldy #0
000F22r 3               swspr0:
000F22r 3  B1 rr        	lda (z80_hl),y		; fetch second byte.
000F24r 3  48           	pha
000F25r 3  B1 rr        	lda (z80_de),y 		; fetch first byte.
000F27r 3  91 rr        	sta (z80_hl),y 		; copy to second.
000F29r 3  68           	pla
000F2Ar 3  91 rr        	sta (z80_de),y 		; copy to first sprite entry.
000F2Cr 3               
000F2Cr 3  E6 rr        	inc z80_e 		; next byte.
000F2Er 3  D0 02        	bne :+
000F30r 3  E6 rr        	inc z80_d
000F32r 3               :
000F32r 3  E6 rr        	inc z80_l 		; next byte.
000F34r 3  D0 02        	bne :+
000F36r 3  E6 rr        	inc z80_h
000F38r 3               :
000F38r 3  C6 rr        	dec z80_b
000F3Ar 3  D0 E6        	bne swspr0 		; swap all bytes in table entry.
000F3Cr 3  60           	rts
000F3Dr 3               
000F3Dr 3               ;----------------------------------------------------
000F3Dr 3               ; Process sprites.
000F3Dr 3               ;----------------------------------------------------
000F3Dr 3               
000F3Dr 3               pspr:
000F3Dr 3  A9 0C        	lda #NUMSPR		; sprites to process.
000F3Fr 3  85 rr        	sta sprptr
000F41r 3               
000F41r 3  A9 rr        	lda #<sprtab 		; sprite table.
000F43r 3  85 rr        	sta z80_x
000F45r 3  A9 rr        	lda #>sprtab
000F47r 3  85 rr        	sta z80_i
000F49r 3               pspr1:
000F49r 3  A0 00        	ldy #0
000F4Br 3  B1 rr        	lda (z80_ix),y		; fetch sprite type.
000F4Dr 3  C9 09        	cmp #9 			; within range of sprite types?
000F4Fr 3  B0 03        	bcs :+
000F51r 3  20 rr rr     	jsr pspr2 		; yes, process this one.
000F54r 3               :
000F54r 3  18           	clc
000F55r 3  A5 rr        	lda z80_x
000F57r 3  69 12        	adc #TABSIZ 		; distance to next odd/even entry.
000F59r 3  85 rr        	sta z80_x
000F5Br 3  90 02        	bcc :+
000F5Dr 3  E6 rr        	inc z80_i		; next sprite.
000F5Fr 3               :
000F5Fr 3  C6 rr        	dec sprptr 		; repeat for remaining sprites.
000F61r 3  D0 E6        	bne pspr1
000F63r 3  60           	rts
000F64r 3               
000F64r 3               pspr2:
000F64r 3  A5 rr        	lda z80_x 		; store original sprite pointer.
000F66r 3  85 rr        	sta ogptr
000F68r 3  A5 rr        	lda z80_i
000F6Ar 3  85 rr        	sta ogptr+1
000F6Cr 3  20 rr rr     	jsr pspr3		; do the routine.
000F6Fr 3               rtorg:
000F6Fr 3  A5 rr        	lda ogptr 		; restore original pointer to sprite.
000F71r 3  85 rr        	sta z80_x
000F73r 3  A5 rr        	lda ogptr+1
000F75r 3  85 rr        	sta z80_i
000F77r 3               rtorg0:
000F77r 3  60           	rts
000F78r 3               
000F78r 3               pspr3:
000F78r 3  A9 rr        	lda #<evtyp0		; sprite type events list.
000F7Ar 3  85 rr        	sta z80_l
000F7Cr 3  A9 rr        	lda #>evtyp0
000F7Er 3  85 rr        	sta z80_h
000F80r 3               pspr4:
000F80r 3  B1 rr        	lda (z80_ix),y
000F82r 3  0A           	asl a			; double accumulator.
000F83r 3  18           	clc
000F84r 3  65 rr        	adc z80_l
000F86r 3  85 rr        	sta z80_l
000F88r 3  90 02        	bcc :+
000F8Ar 3  E6 rr        	inc z80_h
000F8Cr 3               :
000F8Cr 3  B1 rr        	lda (z80_hl),y
000F8Er 3  85 rr        	sta z80_e 		; copy to de.
000F90r 3  48           	pha
000F91r 3               
000F91r 3  E6 rr        	inc z80_l 		; next byte of address.
000F93r 3  D0 02        	bne :+
000F95r 3  E6 rr        	inc z80_h
000F97r 3               :
000F97r 3  B1 rr        	lda (z80_hl),y 		; address high.
000F99r 3  85 rr        	sta z80_d
000F9Br 3               
000F9Br 3  48           	pha	 		; swap address into hl.
000F9Cr 3  A5 rr        	lda z80_h
000F9Er 3  85 rr        	sta z80_d
000FA0r 3  68           	pla
000FA1r 3  85 rr        	sta z80_h
000FA3r 3  68           	pla
000FA4r 3  85 rr        	sta z80_l
000FA6r 3  A5 rr        	lda z80_l
000FA8r 3  85 rr        	sta z80_e
000FAAr 3               
000FAAr 3  6C rr rr     	jmp (z80_hl) 		; go there.
000FADr 3               
000FADr 3               ; Address of each sprite type's routine.
000FADr 3               
000FADr 3  rr rr        evtyp0:	.word evnt00
000FAFr 3  rr rr        evtyp1:	.word evnt01
000FB1r 3  rr rr        evtyp2:	.word evnt02
000FB3r 3  rr rr        evtyp3:	.word evnt03
000FB5r 3  rr rr        evtyp4:	.word evnt04
000FB7r 3  rr rr        evtyp5:	.word evnt05
000FB9r 3  rr rr        evtyp6:	.word evnt06
000FBBr 3  rr rr        evtyp7:	.word evnt07
000FBDr 3  rr rr        evtyp8:	.word evnt08
000FBFr 3               
000FBFr 3               ;--------------------------------------------------------------
000FBFr 3               ; Display sprites.
000FBFr 3               ;
000FBFr 3               ; Input:
000FBFr 3               ;  IX = sprite table
000FBFr 3               ;--------------------------------------------------------------
000FBFr 3               
000FBFr 3               dspr:
000FBFr 3  A9 06        	lda #(NUMSPR/2)		; number of sprites to display.
000FC1r 3  85 rr        	sta sprcnt
000FC3r 3               
000FC3r 3               dspr0:
000FC3r 3  A0 00        	ldy #var_Type
000FC5r 3  B1 rr        	lda (z80_ix),y 		; get sprite type.
000FC7r 3  C9 FF        	cmp #255 		; is it enabled?
000FC9r 3  D0 45        	bne dspr1 		; yes, it needs deleting.
000FCBr 3               dspr5:
000FCBr 3  A0 05        	ldy #var_newType
000FCDr 3  B1 rr        	lda (z80_ix),y 		; new type.
000FCFr 3  C9 FF        	cmp #255		; is it enabled?
000FD1r 3  F0 03        	beq dspr2
000FD3r 3  4C rr rr     	jmp dspr3 		; yes, it needs drawing.
000FD6r 3               dspr2:
000FD6r 3  A0 05        	ldy #var_newType
000FD8r 3  B1 rr        	lda (z80_ix),y 		; copy new type.
000FDAr 3  A0 00        	ldy #var_Type
000FDCr 3  91 rr        	sta (z80_ix),y
000FDEr 3  A0 06        	ldy #var_newImage
000FE0r 3  B1 rr        	lda (z80_ix),y 		; copy new image number.
000FE2r 3  A0 01        	ldy #var_Image
000FE4r 3  91 rr        	sta (z80_ix),y
000FE6r 3  A0 07        	ldy #var_newFrame
000FE8r 3  B1 rr        	lda (z80_ix),y 		; copy new frame.
000FEAr 3  A0 02        	ldy #var_Frame
000FECr 3  91 rr        	sta (z80_ix),y
000FEEr 3  A0 08        	ldy #var_newY
000FF0r 3  B1 rr        	lda (z80_ix),y 		; copy new y.
000FF2r 3  A0 03        	ldy #var_Y
000FF4r 3  91 rr        	sta (z80_ix),y
000FF6r 3  A0 09        	ldy #var_newX
000FF8r 3  B1 rr        	lda (z80_ix),y 		; copy new x.
000FFAr 3  A0 04        	ldy #var_X
000FFCr 3  91 rr        	sta (z80_ix),y
000FFEr 3               
000FFEr 3  18           	clc
000FFFr 3  A5 rr        	lda z80_x
001001r 3  69 24        	adc #(TABSIZ*2)		; distance to next odd/even entry.
001003r 3  85 rr        	sta z80_x
001005r 3  A5 rr        	lda z80_i
001007r 3  69 00        	adc #0
001009r 3  85 rr        	sta z80_i 		; next sprite.
00100Br 3  C6 rr        	dec sprcnt
00100Dr 3  D0 B4        	bne dspr0		; repeat for remaining sprites.
00100Fr 3  60           	rts
001010r 3               
001010r 3               dspr1:
001010r 3               	; _BEEB clipping code copied from CPC Engine
001010r 3  A0 03        	ldy #var_Y
001012r 3  B1 rr        	lda (z80_ix), y		; old x coord
001014r 3  C9 A1        	cmp #SpriteMaxY     	; beyond maximum?
001016r 3  B0 B3        	bcs dspr5		; yes, don't delete it.
001018r 3               
001018r 3  A0 05        	ldy #var_newType
00101Ar 3  B1 rr        	lda (z80_ix),y 		; type of new sprite.
00101Cr 3  C9 FF        	cmp #255		; is this enabled?
00101Er 3  D0 06        	bne dspr4 		; yes, display both.
001020r 3               
001020r 3               dspr6:
001020r 3  20 rr rr     	jsr sspria 		; show single sprite.
001023r 3  4C rr rr     	jmp dspr2
001026r 3               
001026r 3               ; Displaying two sprites.  Don't bother redrawing if nothing has changed.
001026r 3               
001026r 3               dspr4:
001026r 3               	; _BEEB clipping code copied from CPC Engine
001026r 3  A0 08        	ldy #var_newY
001028r 3  B1 rr        	lda (z80_ix), y		; old x coord
00102Ar 3  C9 A1        	cmp #SpriteMaxY     	; beyond maximum?
00102Cr 3  B0 F2        	bcs dspr6		; yes, don't display it.
00102Er 3               
00102Er 3  A0 04        	ldy #var_X
001030r 3  B1 rr        	lda (z80_ix),y		; old x.
001032r 3  A0 09        	ldy #var_newX
001034r 3  D1 rr        	cmp (z80_ix),y 		; compare with new value.
001036r 3  D0 21        	bne dspr7 		; they differ, need to redraw.
001038r 3               
001038r 3  A0 03        	ldy #var_Y
00103Ar 3  B1 rr        	lda (z80_ix),y		; old y.
00103Cr 3  A0 08        	ldy #var_newY
00103Er 3  D1 rr        	cmp (z80_ix),y 		; compare against new value.
001040r 3  D0 17        	bne dspr7		; they differ, need to redraw.
001042r 3               
001042r 3  A0 02        	ldy #var_Frame
001044r 3  B1 rr        	lda (z80_ix),y 		; old frame.
001046r 3  A0 07        	ldy #var_newFrame
001048r 3  D1 rr        	cmp (z80_ix),y 		; compare against new value.
00104Ar 3  D0 0D        	bne dspr7 		; they differ, need to redraw.
00104Cr 3               
00104Cr 3  A0 01        	ldy #var_Image
00104Er 3  B1 rr        	lda (z80_ix),y 		; old image.
001050r 3  A0 06        	ldy #var_newImage
001052r 3  D1 rr        	cmp (z80_ix),y 		; compare against new value.
001054r 3  D0 03        	bne dspr7 		; they differ, need to redraw.
001056r 3  4C rr rr     	jmp dspr2		; everything is the same, don't redraw.
001059r 3               dspr7:
001059r 3  20 rr rr     	jsr sspric 		; delete old sprite, draw new one simultaneously.
00105Cr 3  4C rr rr     	jmp dspr2
00105Fr 3               dspr3:
00105Fr 3               	; _BEEB clipping code copied from CPC Engine
00105Fr 3  A0 08        	ldy #var_newY
001061r 3  B1 rr        	lda (z80_ix), y		; old x coord
001063r 3  C9 A1        	cmp #SpriteMaxY     	; beyond maximum?
001065r 3  90 03        	bcc :+			; no, continue
001067r 3  4C rr rr     	jmp dspr2		; yes, don't display it.
00106Ar 3               :
00106Ar 3  20 rr rr     	jsr ssprib 		; show single sprite.
00106Dr 3  4C rr rr     	jmp dspr2
001070r 3               
001070r 3               ;-----------------------------------------
001070r 3               ; Get sprite address calculations.
001070r 3               ; gspran = new sprite, gsprad = old sprite.
001070r 3               ;
001070r 3               ; Input:
001070r 3               ;  IX = sprite address
001070r 3               ;-----------------------------------------
001070r 3               
001070r 3               gspran:
001070r 3  A0 08        	ldy #var_newY
001072r 3  B1 rr        	lda (z80_ix),y 		; new y coordinate.
001074r 3  85 rr        	sta dispy
001076r 3  A0 09        	ldy #var_newX
001078r 3  B1 rr        	lda (z80_ix),y 		; new x coordinate.
00107Ar 3  85 rr        	sta dispx
00107Cr 3  A0 06        	ldy #var_newImage
00107Er 3  B1 rr        	lda (z80_ix),y 		; new sprite image.
001080r 3  20 rr rr     	jsr gfrm		; fetch start frame for this sprite.
001083r 3               
001083r 3  A0 00        	ldy #0
001085r 3  B1 rr        	lda (z80_hl),y 		; frame in accumulator.
001087r 3  A0 07        	ldy #var_newFrame
001089r 3  18           	clc
00108Ar 3  71 rr        	adc (z80_ix),y 		; new add frame number.
00108Cr 3  4C rr rr     	jmp gspra0
00108Fr 3               
00108Fr 3               ;-----------------------------------------
00108Fr 3               ; Calculate old sprite address
00108Fr 3               ;
00108Fr 3               ; Input:
00108Fr 3               ;  IX = sprite address
00108Fr 3               ;
00108Fr 3               ; Output:
00108Fr 3               ;  B  = right byte mask
00108Fr 3               ;  C  = left byte mask
00108Fr 3               ;  DE = spriteframe address
00108Fr 3               ;  scraddr = screenaddress(dispx,dispy)
00108Fr 3               ;-----------------------------------------
00108Fr 3               
00108Fr 3               gsprad:
00108Fr 3  A0 03        	ldy #var_Y
001091r 3  B1 rr        	lda (z80_ix),y		; y coordinate.
001093r 3  85 rr        	sta dispy
001095r 3  A0 04        	ldy #var_X
001097r 3  B1 rr        	lda (z80_ix),y		; x coordinate.
001099r 3  85 rr        	sta dispx
00109Br 3  A0 01        	ldy #var_Image
00109Dr 3  B1 rr        	lda (z80_ix),y 		; sprite image.
00109Fr 3  20 rr rr     	jsr gfrm 		; fetch start frame for this sprite.
0010A2r 3               
0010A2r 3  A0 00        	ldy #0
0010A4r 3  B1 rr        	lda (z80_hl),y 		; frame in accumulator.
0010A6r 3  A0 02        	ldy #var_Frame
0010A8r 3  18           	clc
0010A9r 3  71 rr        	adc (z80_ix),y 		; add frame number.
0010ABr 3               
0010ABr 3               gspra0:
0010ABr 3               .if rflag
0010ABr 3               	sta z80_e		; multiply by 32.
0010ABr 3               	lda #0
0010ABr 3               	sta z80_d
0010ABr 3               
0010ABr 3               	asl z80_e
0010ABr 3               	rol z80_d
0010ABr 3               	asl z80_e
0010ABr 3               	rol z80_d
0010ABr 3               	asl z80_e
0010ABr 3               	rol z80_d
0010ABr 3               	asl z80_e
0010ABr 3               	rol z80_d
0010ABr 3               .if bflag
0010ABr 3               	lda z80_e		; multiply by 48
0010ABr 3               	sta tmp1
0010ABr 3               	lda z80_d
0010ABr 3               	sta tmp2
0010ABr 3               .endif
0010ABr 3               	asl z80_e
0010ABr 3               	rol z80_d
0010ABr 3               .if bflag
0010ABr 3               	clc
0010ABr 3               	lda z80_e
0010ABr 3               	adc tmp1
0010ABr 3               	sta z80_e
0010ABr 3               	lda z80_d
0010ABr 3               	adc tmp2
0010ABr 3               	sta z80_d
0010ABr 3               .endif
0010ABr 3               .else
0010ABr 3  4A           	lsr a	  		; multiply by 128.
0010ACr 3  85 rr        	sta z80_d 		; store in d.
0010AEr 3  85 rr        	sta tmp1
0010B0r 3  A9 00        	lda #0
0010B2r 3  6A           	ror a
0010B3r 3  85 rr        	sta z80_e 		; got low byte.
0010B5r 3  85 rr        	sta tmp2
0010B7r 3               .if bflag
0010B7r 3               	lsr tmp1		; multiply by 192
0010B7r 3               	ror tmp2
0010B7r 3               	clc
0010B7r 3               	lda tmp2
0010B7r 3               	adc z80_e
0010B7r 3               	sta z80_e
0010B7r 3               	lda tmp1
0010B7r 3               	adc z80_d
0010B7r 3               	sta z80_d
0010B7r 3               .endif
0010B7r 3               .endif
0010B7r 3  18           	clc 			; address of play sprites.
0010B8r 3  A5 rr        	lda z80_e
0010BAr 3  69 rr        	adc #<sprgfx
0010BCr 3  85 rr        	sta z80_e
0010BEr 3  A5 rr        	lda z80_d
0010C0r 3  69 rr        	adc #>sprgfx
0010C2r 3  85 rr        	sta z80_d
0010C4r 3               
0010C4r 3  A5 rr        	lda dispx 		; y coordinate.
0010C6r 3  29 06        	and #6 			; position within byte boundary.
0010C8r 3  AA           	tax	 		; low byte of table displacement.
0010C9r 3               .if rflag
0010C9r 3               	stx sprshft
0010C9r 3               .else
0010C9r 3  0A           	asl a	  		; multiply by 32.
0010CAr 3  0A           	asl a  			; already a multiple
0010CBr 3  0A           	asl a  			; of 2, so just 4
0010CCr 3               .if bflag
0010CCr 3               	sta tmp1
0010CCr 3               	asl a  			; shifts needed.
0010CCr 3               	clc
0010CCr 3               	adc tmp1
0010CCr 3               .else
0010CCr 3  0A           	asl a  			; shifts needed.
0010CDr 3               .endif
0010CDr 3  18           	clc 			; add to sprite address.
0010CEr 3  65 rr        	adc z80_e
0010D0r 3  85 rr        	sta z80_e
0010D2r 3  90 02        	bcc :+
0010D4r 3  E6 rr        	inc z80_d
0010D6r 3               :
0010D6r 3               .endif
0010D6r 3  BD rr rr     	lda spmask,x		 ; pointer to mask table.
0010D9r 3  85 rr        	sta z80_c 		; left mask.
0010DBr 3  BD rr rr     	lda spmask+1,x
0010DEr 3  85 rr        	sta z80_b 		; right mask.
0010E0r 3               ; Drop into screen address routine.
0010E0r 3  4C rr rr     	jmp scadd
0010E3r 3               
0010E3r 3  FF 00 3F C0  spmask:	.byte 255,0,63,192,15,240,3,252
0010E7r 3  0F F0 03 FC  
0010EBr 3               
0010EBr 3               
0010EBr 3               ;-----------------------------------------------------------
0010EBr 3               ; Animates a sprite.
0010EBr 3               ;
0010EBr 3               ; Input:
0010EBr 3               ;  IX = sprite address
0010EBr 3               ;  HL = last sprite address
0010EBr 3               ;-----------------------------------------------------------
0010EBr 3               
0010EBr 3               animsp:
0010EBr 3  25 rr        	and frmno
0010EDr 3  F0 01        	beq :+
0010EFr 3  60           	rts
0010F0r 3               :
0010F0r 3  A0 06        	ldy #var_newImage
0010F2r 3  B1 rr        	lda (z80_ix),y		; sprite image
0010F4r 3  20 rr rr     	jsr gfrm		; get frame data.
0010F7r 3               
0010F7r 3  E6 rr        	inc z80_l		; point to frames.
0010F9r 3  D0 02        	bne :+
0010FBr 3  E6 rr        	inc z80_h
0010FDr 3               :
0010FDr 3  A0 07        	ldy #var_newFrame
0010FFr 3  B1 rr        	lda (z80_ix),y		; sprite frame.
001101r 3  18           	clc
001102r 3  69 01        	adc #1			; next one along.
001104r 3  A0 00        	ldy #0
001106r 3  D1 rr        	cmp (z80_hl),y		; reached the last frame?
001108r 3  90 02        	bcc anims0		; no, not yet.
00110Ar 3  A9 00        	lda #0			; start at first frame.
00110Cr 3               anims0:
00110Cr 3  A0 07        	ldy #var_newFrame
00110Er 3  91 rr        	sta (z80_ix),y		; new frame.
001110r 3  60           	rts
001111r 3               
001111r 3               ;--------------------------------------------------------------
001111r 3               ; Animate back
001111r 3               ;
001111r 3               ; Input:
001111r 3               ;  IX = sprite address
001111r 3               ;  HL = last sprite address
001111r 3               ;--------------------------------------------------------------
001111r 3               
001111r 3               animbk:
001111r 3  25 rr        	and frmno
001113r 3  F0 01        	beq :+
001115r 3  60           	rts
001116r 3               :
001116r 3  A0 06        	ldy #var_newImage
001118r 3  B1 rr        	lda (z80_ix),y		; sprite image.
00111Ar 3  20 rr rr     	jsr gfrm		; get frame data.
00111Dr 3               
00111Dr 3  E6 rr        	inc z80_l 		; point to frames.
00111Fr 3  D0 02        	bne :+
001121r 3  E6 rr        	inc z80_h
001123r 3               :
001123r 3  A0 07        	ldy #var_newFrame
001125r 3  B1 rr        	lda (z80_ix),y 		; sprite frame.
001127r 3  F0 03        	beq :+
001129r 3  4C rr rr     	jmp rtanb0 		; yes, start at end.
00112Cr 3               :
00112Cr 3  A0 00        	ldy #0
00112Er 3  B1 rr        	lda (z80_hl),y 		; last sprite.
001130r 3               rtanb0:
001130r 3  38           	sec
001131r 3  E9 01        	sbc #1			; next one along.
001133r 3  4C rr rr     	jmp anims0		; set new frame.
001136r 3               
001136r 3               ;--------------------------------------------------------------
001136r 3               ; Check for collision with other sprite, strict enforcement.
001136r 3               ;
001136r 3               ; Input:
001136r 3               ;  b		= sprite to test for
001136r 3               ;  ix		= current sprite pointer
001136r 3               ;
001136r 3               ; global:	b
001136r 3               ; local:	x,y,hl,de,skptr
001136r 3               ; calls:	-
001136r 3               ;--------------------------------------------------------------
001136r 3               
001136r 3               sktyp:
001136r 3  A9 rr        	lda #<sprtab				; sprite table.
001138r 3  85 rr        	sta z80_l
00113Ar 3  A9 rr        	lda #>sprtab
00113Cr 3  85 rr        	sta z80_h
00113Er 3               numsp2:
00113Er 3  A9 0C        	lda #NUMSPR				; number of sprites.
001140r 3  85 rr        	sta sktptr
001142r 3               sktyp0:
001142r 3  A5 rr        	lda z80_l 				; store pointer to sprite.
001144r 3  85 rr        	sta skptr
001146r 3  A5 rr        	lda z80_h
001148r 3  85 rr        	sta skptr+1
00114Ar 3               
00114Ar 3  A0 00        	ldy #0
00114Cr 3  B1 rr        	lda (z80_hl),y 				; get sprite type.
00114Er 3  C5 rr        	cmp z80_b				; is it the type we seek?
001150r 3  F0 1D        	beq coltyp				; yes, we can use this one.
001152r 3               sktyp1:
001152r 3  18           	clc
001153r 3  A5 rr        	lda skptr				; retrieve sprite pointer.
001155r 3  69 12        	adc #TABSIZ				; size of each entry.
001157r 3  85 rr        	sta z80_l
001159r 3  A5 rr        	lda skptr+1
00115Br 3  69 00        	adc #0
00115Dr 3  85 rr        	sta z80_h
00115Fr 3  C6 rr        	dec sktptr					; one less iteration.
001161r 3  D0 DF        	bne sktyp0				; keep going until we find a slot.
001163r 3  A9 00        	lda #0					; default to ROM address - no sprite.
001165r 3  85 rr        	sta z80_l
001167r 3  85 rr        	sta z80_h
001169r 3  85 rr        	sta skptr				; store pointer to sprite.
00116Br 3  85 rr        	sta skptr+1
00116Dr 3               
00116Dr 3  18           	clc					; don't return with zero flag set.
00116Er 3  60           	rts 					; didn't find one.
00116Fr 3               
00116Fr 3               coltyp:
00116Fr 3  A0 00        	ldy #0
001171r 3  B1 rr        	lda (z80_ix),y				; current sprite type.
001173r 3  C5 rr        	cmp z80_b				; seeking sprite of same type?
001175r 3  F0 3D        	beq colty1				; yes, need to check we're not detecting ourselves.
001177r 3               colty0:
001177r 3  A0 09        	ldy #9					; distance to x position in table.
001179r 3  B1 rr        	lda (z80_hl),y				; fetch x coordinate.
00117Br 3  85 rr        	sta z80_e
00117Dr 3  88           	dey
00117Er 3  B1 rr        	lda (z80_hl),y				; fetch y coordinate.
001180r 3  85 rr        	sta z80_d
001182r 3               
001182r 3               ; Drop into collision detection.
001182r 3               
001182r 3               colc16:
001182r 3  A0 09        	ldy #9
001184r 3  B1 rr        	lda (z80_ix),y			 	; x coord.
001186r 3  38           	sec					; subtract x.
001187r 3  E5 rr        	sbc z80_e
001189r 3  B0 05        	bcs  colc1a 				; result is positive.
00118Br 3  49 FF        	eor #$ff				; make negative positive.
00118Dr 3  18           	clc
00118Er 3  69 01        	adc #1
001190r 3               colc1a:
001190r 3  C9 10        	cmp #16 				; within x range?
001192r 3  B0 BE        	bcs sktyp1				; no - they"ve missed.
001194r 3  85 rr        	sta z80_c				; store difference.
001196r 3               
001196r 3  A0 08        	ldy #8
001198r 3  B1 rr        	lda (z80_ix),y				; y coord.
00119Ar 3  38           	sec
00119Br 3  E5 rr        	sbc z80_d				; subtract y.
00119Dr 3  B0 05        	bcs colc1b				; result is positive.
00119Fr 3  49 FF        	eor #$ff				; make negative positive.
0011A1r 3  18           	clc
0011A2r 3  69 01        	adc #1
0011A4r 3               colc1b:
0011A4r 3  C9 10        	cmp #16					; within y range?
0011A6r 3  B0 AA        	bcs sktyp1 				; no - they've missed.
0011A8r 3  18           	clc					; add x difference.
0011A9r 3  65 rr        	adc z80_c
0011ABr 3  C9 1A        	cmp #26					; only 5 corner pixels touching?
0011ADr 3  B0 02        	bcs :+
0011AFr 3  38           	sec
0011B0r 3  60           	rts 					; carry set if there's a collision.
0011B1r 3               :
0011B1r 3  4C rr rr     	jmp sktyp1				; try next sprite in table.
0011B4r 3               colty1:
0011B4r 3  A5 rr        	lda z80_x  				; compare the two.
0011B6r 3  C5 rr        	cmp z80_l
0011B8r 3  D0 09        	bne end_col
0011BAr 3  A5 rr        	lda z80_i
0011BCr 3  C5 rr        	cmp z80_h
0011BEr 3  D0 03        	bne end_col
0011C0r 3  4C rr rr     	jmp sktyp1 				; addresses are identical.
0011C3r 3               end_col:
0011C3r 3  4C rr rr     	jmp colty0
0011C6r 3               
0011C6r 3               ;-----------------------------------------------------------
0011C6r 3               ; Display number, left aligned
0011C6r 3               ;
0011C6r 3               ; Input:
0011C6r 3               ;  a		= number
0011C6r 3               ;
0011C6r 3               ; global:	-
0011C6r 3               ; local:	a,y,bc,hl,displ0
0011C6r 3               ; calls:	num2ch,dmsg3
0011C6r 3               ;-----------------------------------------------------------
0011C6r 3               
0011C6r 3               disply:
0011C6r 3  85 rr        	sta z80_a
0011C8r 3  A9 rr        	lda #<displ0				; display workspace.
0011CAr 3  85 rr        	sta z80_c
0011CCr 3  A9 rr        	lda #>displ0
0011CEr 3  85 rr        	sta z80_b
0011D0r 3  A5 rr        	lda z80_a
0011D2r 3  20 rr rr     	jsr num2ch				; convert accumulator to string.
0011D5r 3               displ1:
0011D5r 3  C6 rr        	dec z80_c				; back one character.
0011D7r 3  A5 rr        	lda z80_c
0011D9r 3  C9 FF        	cmp #$ff
0011DBr 3  D0 02        	bne :+
0011DDr 3  C6 rr        	dec z80_b
0011DFr 3               :
0011DFr 3  A0 00        	ldy #0
0011E1r 3  B1 rr        	lda (z80_bc),y				; fetch digit.
0011E3r 3  09 80        	ora #128				; insert end marker.
0011E5r 3  91 rr        	sta (z80_bc),y				; new value.
0011E7r 3               
0011E7r 3  A9 rr        	lda #<displ0				; display space.
0011E9r 3  85 rr        	sta z80_l
0011EBr 3  A9 rr        	lda #>displ0
0011EDr 3  85 rr        	sta z80_h
0011EFr 3  4C rr rr     	jmp dmsg3				; display the string.
0011F2r 3               
0011F2r 3  00 00 00 8D  displ0:	.byte 0,0,0,13+128
0011F6r 3               
0011F6r 3               ;----------------------------------------------------------------
0011F6r 3               ; Initialise screen.
0011F6r 3               ;
0011F6r 3               ; global:	roomtb,scno
0011F6r 3               ; local:	-
0011F6r 3               ; calls:	tstcs
0011F6r 3               ;----------------------------------------------------------------
0011F6r 3               
0011F6r 3               initsc:
0011F6r 3  AD rr rr     	lda roomtb 			; whereabouts in the map are we?
0011F9r 3  20 rr rr     	jsr tstsc 			; find displacement.
0011FCr 3  C9 FF        	cmp #255 			; is it valid?
0011FEr 3  F0 02        	beq init_end 			; no, it's rubbish.
001200r 3  85 rr        	sta scno			; store new room number.
001202r 3               init_end:
001202r 3  60           	rts
001203r 3               
001203r 3               ;----------------------------------------------------------------
001203r 3               ; Test screen.
001203r 3               ;
001203r 3               ; global:	-
001203r 3               ; local:	x
001203r 3               ; calls:	-
001203r 3               ;----------------------------------------------------------------
001203r 3               
001203r 3               tstsc:
001203r 3  85 rr        	sta tmproom
001205r 3  18           	clc
001206r 3  69 0B        	adc #MAPWID 			; add width in case we"re negative.
001208r 3  AA           	tax 				; add displacement to map data.
001209r 3  BD rr rr     	lda mapdat-MAPWID,x 		; find room number there.
00120Cr 3  60           	rts
00120Dr 3               
00120Dr 3               ;--------------------------
00120Dr 3               ; Screen left.
00120Dr 3               ;--------------------------
00120Dr 3               
00120Dr 3               scrl:
00120Dr 3  AD rr rr     	lda roomtb 			; present room table pointer.
001210r 3  38           	sec
001211r 3  E9 01        	sbc #1				; room left.
001213r 3               scrl0:
001213r 3  20 rr rr     	jsr tstsc			; test screen.
001216r 3  C9 FF        	cmp #255			; is there a screen this way?
001218r 3  D0 01        	bne :+
00121Ar 3  60           	rts				; no, return to loop.
00121Br 3               :
00121Br 3  A5 rr        	lda tmproom			; restore room displacement.
00121Dr 3  8D rr rr     	sta roomtb			; new room table position.
001220r 3               scrl1:
001220r 3  20 rr rr     	jsr initsc 			; set new screen.
001223r 3  A9 02        	lda #2
001225r 3  85 rr        	sta restfl 			; set it.
001227r 3  60           	rts
001228r 3               scrr:
001228r 3  AD rr rr     	lda roomtb 			; room table pointer.
00122Br 3  18           	clc
00122Cr 3  69 01        	adc #1				; room right.
00122Er 3  4C rr rr     	jmp scrl0
001231r 3               scru:
001231r 3  AD rr rr     	lda roomtb 			; room table pointer.
001234r 3  38           	sec
001235r 3  E9 0B        	sbc #MAPWID 			; room up.
001237r 3  4C rr rr     	jmp scrl0
00123Ar 3               scrd:
00123Ar 3  AD rr rr     	lda roomtb 			; room table pointer.
00123Dr 3  18           	clc
00123Er 3  69 0B        	adc #MAPWID 			; room down.
001240r 3  4C rr rr     	jmp scrl0
001243r 3               
001243r 3               ;-----------------------------------------
001243r 3               ; Jump to new screen.
001243r 3               ;-----------------------------------------
001243r 3               
001243r 3               nwscr:
001243r 3  A2 00        	ldx #0				; start of map data.
001245r 3               nwscr0:
001245r 3  DD rr rr     	cmp mapdat,x
001248r 3  F0 06        	beq nwscr1			; have we found a match for screen?
00124Ar 3  E8           	inx 				; next room.
00124Br 3  E0 50        	cpx #80				; zero room count, 80 to search.
00124Dr 3  D0 F6        	bne nwscr0			; keep looking.
00124Fr 3  60           	rts
001250r 3               nwscr1:
001250r 3  8E rr rr     	stx roomtb			; set the map position.
001253r 3  4C rr rr     	jmp scrl1			; draw new room.
001256r 3               
001256r 3               
001256r 3               ;----------------------------------------------------------
001256r 3               ; Gravity processing.
001256r 3               ;----------------------------------------------------------
001256r 3               
001256r 3               grav:
001256r 3  A0 0D        	ldy #13
001258r 3  B1 rr        	lda (z80_ix),y			; jump pointer low.
00125Ar 3  85 rr        	sta z80_l
00125Cr 3  A0 0E        	ldy #14
00125Er 3  B1 rr        	lda (z80_ix),y			; jump pointer high.
001260r 3  85 rr        	sta z80_h
001262r 3  05 rr        	ora z80_l			; merge in low byte.
001264r 3  D0 01        	bne :+
001266r 3  60           	rts				; if neither is set, we're not in the air.
001267r 3               :
001267r 3  A0 00        	ldy #0
001269r 3  B1 rr        	lda (z80_hl),y			; pixels to move.
00126Br 3  85 rr        	sta z80_a
00126Dr 3  C9 63        	cmp #99				; reached the end?
00126Fr 3  D0 0C        	bne grav0			; no, continue.
001271r 3               grav2:
001271r 3  C6 rr        	dec z80_l			; go back to previous value.
001273r 3  C9 FF        	cmp #$ff
001275r 3  D0 02        	bne :+
001277r 3  C6 rr        	dec z80_h
001279r 3               :
001279r 3  B1 rr        	lda (z80_hl),y			; fetch that from table.
00127Br 3  85 rr        	sta z80_a
00127Dr 3               grav0:
00127Dr 3  E6 rr        	inc z80_l			; point to next table entry.
00127Fr 3  D0 02        	bne :+
001281r 3  E6 rr        	inc z80_h
001283r 3               :
001283r 3  A5 rr        	lda z80_l
001285r 3  A0 0D        	ldy #13
001287r 3  91 rr        	sta (z80_ix),y			; store new pointer low.
001289r 3  A5 rr        	lda z80_h
00128Br 3  A0 0E        	ldy #14
00128Dr 3  91 rr        	sta (z80_ix),y			; store new pointer high.
00128Fr 3               grav1:
00128Fr 3  A5 rr        	lda z80_a
001291r 3  D0 01        	bne :+				; any movement required?
001293r 3  60           	rts				; no, not this time.
001294r 3               :
001294r 3  A5 rr        	lda z80_a
001296r 3  C9 80        	cmp #128			; is it up or down?
001298r 3  B0 15        	bcs gravu			; it's up.
00129Ar 3               gravd:
00129Ar 3  85 rr        	sta z80_b			; set pixels to move.
00129Cr 3               gravd0:
00129Cr 3  20 rr rr     	jsr cangd			; can we go down?
00129Fr 3  D0 28        	bne gravst			; can't move down, so stop.
0012A1r 3  A0 08        	ldy #8
0012A3r 3  B1 rr        	lda (z80_ix),y			; adjust new x coord.
0012A5r 3  18           	clc
0012A6r 3  69 01        	adc #1
0012A8r 3  91 rr        	sta (z80_ix),y
0012AAr 3  C6 rr        	dec z80_b
0012ACr 3  D0 EE        	bne gravd0
0012AEr 3  60           	rts
0012AFr 3               gravu:
0012AFr 3  49 FF        	eor #$ff			; flip the sign so it's positive.
0012B1r 3  18           	clc
0012B2r 3  69 01        	adc #1
0012B4r 3  85 rr        	sta z80_b			; set pixels to move.
0012B6r 3               gravu0:
0012B6r 3  20 rr rr     	jsr cangu			; can we go up?
0012B9r 3  D0 6E        	bne ifalls			; can't move up, go down next.
0012BBr 3  A0 08        	ldy #8
0012BDr 3  B1 rr        	lda (z80_ix),y
0012BFr 3  38           	sec
0012C0r 3  E9 01        	sbc #1
0012C2r 3  91 rr        	sta (z80_ix),y			; adjust new x coord.
0012C4r 3  C6 rr        	dec z80_b
0012C6r 3  D0 EE        	bne gravu0
0012C8r 3  60           	rts
0012C9r 3               gravst:
0012C9r 3  A0 0D        	ldy #var_jumpLo
0012CBr 3  B1 rr        	lda (z80_ix),y			; jump pointer low.
0012CDr 3  85 rr        	sta z80_l
0012CFr 3  A0 0E        	ldy #var_jumpHi
0012D1r 3  B1 rr        	lda (z80_ix),y			; jump pointer high.
0012D3r 3  85 rr        	sta z80_h
0012D5r 3               
0012D5r 3  A9 00        	lda #0				; null value in pointer.
0012D7r 3  A0 0D        	ldy #var_jumpLo
0012D9r 3  91 rr        	sta (z80_ix),y			; store new pointer low.
0012DBr 3  C8           	iny
0012DCr 3  91 rr        	sta (z80_ix),y			; store new pointer high.
0012DEr 3               
0012DEr 3  A0 00        	ldy #0
0012E0r 3  B1 rr        	lda (z80_hl),y			; fetch byte from table.
0012E2r 3  C9 63        	cmp #99				; is it the end marker?
0012E4r 3               evftf:
0012E4r 3  F0 01        	beq :+				; yes, fallen too far.
0012E6r 3  60           	rts
0012E7r 3               :
0012E7r 3  4C rr rr     	jmp evnt15			; EVENT FELLTOOFAR
0012EAr 3               
0012EAr 3               ;------------------------------------------------
0012EAr 3               ; Initiate fall check.
0012EAr 3               ;------------------------------------------------
0012EAr 3               
0012EAr 3               ifall:
0012EAr 3  A0 0D        	ldy #var_jumpLo
0012ECr 3  B1 rr        	lda (z80_ix),y 			; jump pointer low.
0012EEr 3  85 rr        	sta z80_l
0012F0r 3  A0 0E        	ldy #var_jumpHi
0012F2r 3  B1 rr        	lda (z80_ix),y 			; jump pointer high.
0012F4r 3  85 rr        	sta z80_h			; high byte in accumulator.
0012F6r 3  05 rr        	ora z80_l			; merge in low byte.
0012F8r 3  F0 01        	beq :+
0012FAr 3  60           	rts				; if either is set, we're already in the air.
0012FBr 3               :
0012FBr 3  A0 09        	ldy #9
0012FDr 3  B1 rr        	lda (z80_ix),y			; y coordinate.
0012FFr 3  85 rr        	sta dispx
001301r 3  A0 08        	ldy #8
001303r 3  B1 rr        	lda (z80_ix),y			; look x coordinate.
001305r 3  18           	clc
001306r 3               numsp7:
001306r 3  69 10        	adc #SPR_HGT			; add 16 pixels.
001308r 3  85 rr        	sta dispy			; set up test coordinates.
00130Ar 3  20 rr rr     	jsr tstbl			; get map address.
00130Dr 3  20 rr rr     	jsr plchk			; block, platform check.
001310r 3  F0 01        	beq :+
001312r 3  60           	rts				; it's solid, don't fall.
001313r 3               :
001313r 3  E6 rr        	inc bufaddr			; look right one cell.
001315r 3  20 rr rr     	jsr plchk			; block, platform check.
001318r 3  F0 01        	beq :+
00131Ar 3  60           	rts				; it's solid, don't fall.
00131Br 3               :
00131Br 3  A5 rr        	lda dispx			; y coordinate.
00131Dr 3  29 07        	and #7				; position straddling block cells.
00131Fr 3  F0 08        	beq ifalls			; no more checks needed.
001321r 3  E6 rr        	inc bufaddr			; look to third cell.
001323r 3  20 rr rr     	jsr plchk			; block, platform check.
001326r 3  F0 01        	beq :+
001328r 3  60           	rts				; it's solid, don't fall.
001329r 3               :
001329r 3               ifalls:
001329r 3  A9 rr        	lda #<jtab			; jump table start.
00132Br 3  85 rr        	sta z80_l
00132Dr 3  A9 rr        	lda #>jtab
00132Fr 3  85 rr        	sta z80_h
001331r 3               ifal0:
001331r 3  E6 rr        	inc z80_l			; point to next value.
001333r 3  D0 02        	bne :+
001335r 3  E6 rr        	inc z80_h
001337r 3               :
001337r 3  A0 00        	ldy #0
001339r 3  B1 rr        	lda (z80_hl),y			; fetch value.
00133Br 3  F0 F4        	beq ifal0			; no, get next value.
00133Dr 3  C9 63        	cmp #99				; reached end of table?
00133Fr 3  D0 01        	bne :+
001341r 3  60           	rts				; yes, don't fall.
001342r 3               :
001342r 3  C9 80        	cmp #128			; is it going up?
001344r 3  B0 EB        	bcs ifal0			; yes, looking for first movement down.
001346r 3               
001346r 3  A0 0D        	ldy #13
001348r 3  A5 rr        	lda z80_l
00134Ar 3  91 rr        	sta (z80_ix),y 			; set jump low.
00134Cr 3  A0 0E        	ldy #14
00134Er 3  A5 rr        	lda z80_h
001350r 3  91 rr        	sta (z80_ix),y 			; set jump high.
001352r 3  60           	rts
001353r 3               
001353r 3               
001353r 3               ;----------------------------------------------------
001353r 3               ; Get frame data for a particular sprite.
001353r 3               ; Input:
001353r 3               ;  a		= framenumer
001353r 3               ; Output:
001353r 3               ;  hl		= frame address
001353r 3               ;
001353r 3               ; global:	hl,frmptr
001353r 3               ; local:	-
001353r 3               ; calls:	-
001353r 3               ;----------------------------------------------------
001353r 3               
001353r 3               gfrm:
001353r 3  0A           	asl a	 		 	; multiple of 2.
001354r 3  18           	clc
001355r 3  6D rr rr     	adc frmptr 			; frames used by game.
001358r 3  85 rr        	sta z80_l
00135Ar 3  AD rr rr     	lda frmptr+1
00135Dr 3  69 00        	adc #0
00135Fr 3  85 rr        	sta z80_h 			; point to frame start.
001361r 3  60           	rts
001362r 3               
001362r 3               ;----------------------------------------------------
001362r 3               ; Find sprite list for current room.
001362r 3               ;
001362r 3               ; global:	hl
001362r 3               ; local:	x,y
001362r 3               ; calls:	-
001362r 3               ;----------------------------------------------------
001362r 3               
001362r 3               sprlst:
001362r 3  A9 rr        	lda #<nmedat 			; list of enemy sprites.
001364r 3  85 rr        	sta z80_l
001366r 3  A9 rr        	lda #>nmedat
001368r 3  85 rr        	sta z80_h
00136Ar 3  A6 rr        	ldx scno 			; screen number.
00136Cr 3  D0 01        	bne sprls2 			; is it the first screen?
00136Er 3  60           	rts 				; yes, don't need to search data.
00136Fr 3               sprls2:
00136Fr 3  A0 00        	ldy #0
001371r 3               sprls1:
001371r 3  B1 rr        	lda (z80_hl),y 			; fetch type of sprite.
001373r 3  C9 FF        	cmp #255			; is it an end marker?
001375r 3  F0 0E        	beq sprls0 			; yes, end of this room.
001377r 3               
001377r 3  18           	clc 				; point to next sprite in list.
001378r 3  A5 rr        	lda z80_l
00137Ar 3  69 04        	adc #NMESIZ
00137Cr 3  85 rr        	sta z80_l
00137Er 3  90 02        	bcc :+
001380r 3  E6 rr        	inc z80_h
001382r 3               :
001382r 3  4C rr rr     	jmp sprls1 			; continue until end of room.
001385r 3               sprls0:
001385r 3  E6 rr        	inc z80_l 			; point to start of next screen.s
001387r 3  D0 02        	bne :+
001389r 3  E6 rr        	inc z80_h
00138Br 3               :
00138Br 3  CA           	dex
00138Cr 3  D0 E3        	bne sprls1 			; continue until room found.
00138Er 3  60           	rts
00138Fr 3               
00138Fr 3               
00138Fr 3               ;----------------------------------------------------
00138Fr 3               ; Clear all but a single player sprite.
00138Fr 3               ;
00138Fr 3               ; global:	-
00138Fr 3               ; local:	x,y,ix
00138Fr 3               ; calls:	-
00138Fr 3               ;----------------------------------------------------
00138Fr 3               
00138Fr 3               nspr:
00138Fr 3  A9 0C        	lda #NUMSPR			; sprite slots in table.
001391r 3  85 rr        	sta sprcnt
001393r 3  A9 rr        	lda #<sprtab 			; sprite table.
001395r 3  85 rr        	sta z80_x
001397r 3  A9 rr        	lda #>sprtab
001399r 3  85 rr        	sta z80_i
00139Br 3               nspr0:
00139Br 3  A0 00        	ldy #0 				; fetch sprite type.
00139Dr 3  B1 rr        	lda (z80_ix),y 			; is it a player?
00139Fr 3  F0 1A        	beq nspr1 			; yes, keep this one.
0013A1r 3               
0013A1r 3  A9 FF        	lda #255
0013A3r 3  A0 00        	ldy #0 				; fetch sprite type.
0013A5r 3  91 rr        	sta (z80_ix),y 			; delete sprite.
0013A7r 3  A0 05        	ldy #5
0013A9r 3  91 rr        	sta (z80_ix),y 			; remove next type.
0013ABr 3               
0013ABr 3  18           	clc	 			; next sprite.
0013ACr 3  A5 rr        	lda z80_x
0013AEr 3  69 12        	adc #TABSIZ 			; distance to next odd/even entry.
0013B0r 3  85 rr        	sta z80_x
0013B2r 3  90 02        	bcc :+
0013B4r 3  E6 rr        	inc z80_i
0013B6r 3               :
0013B6r 3  C6 rr        	dec sprcnt	 			; one less space in the table.
0013B8r 3  D0 E1        	bne nspr0
0013BAr 3  60           	rts
0013BBr 3               nspr1:
0013BBr 3  A9 FF        	lda #255
0013BDr 3  A0 00        	ldy #0
0013BFr 3  91 rr        	sta (z80_ix),y 			; delete sprite.
0013C1r 3               
0013C1r 3  18           	clc	 			; point to next sprite.
0013C2r 3  A5 rr        	lda z80_x
0013C4r 3  69 12        	adc #TABSIZ 			; distance to next odd/even entry.
0013C6r 3  85 rr        	sta z80_x
0013C8r 3  90 02        	bcc :+
0013CAr 3  E6 rr        	inc z80_i
0013CCr 3               :
0013CCr 3  C6 rr        	dec sprcnt	 			; one less to do.
0013CEr 3  D0 01        	bne nspr2
0013D0r 3  60           	rts
0013D1r 3               nspr2:
0013D1r 3  A9 FF        	lda #255
0013D3r 3  A0 00        	ldy #0
0013D5r 3  91 rr        	sta (z80_ix),y 			; delete sprite.
0013D7r 3  A0 05        	ldy #5
0013D9r 3  91 rr        	sta (z80_ix),y 			; remove next type.
0013DBr 3               
0013DBr 3  18           	clc	 			; next sprite.
0013DCr 3  A5 rr        	lda z80_x
0013DEr 3  69 12        	adc #TABSIZ 			; distance to next odd/even entry.
0013E0r 3  85 rr        	sta z80_x
0013E2r 3  90 02        	bcc :+
0013E4r 3  E6 rr        	inc z80_i
0013E6r 3               :
0013E6r 3  C6 rr        	dec sprcnt	 			; one less space in table.
0013E8r 3  D0 E7        	bne nspr2
0013EAr 3  60           	rts
0013EBr 3               
0013EBr 3               ;----------------------------------------------------------
0013EBr 3               ; Two initialisation routines.
0013EBr 3               ; Initialise sprites - copy everything from list to table.
0013EBr 3               ;
0013EBr 3               ; global:	-
0013EBr 3               ; local:	x,y,ix
0013EBr 3               ; calls:	cpsp
0013EBr 3               ;----------------------------------------------------------
0013EBr 3               
0013EBr 3               ispr:
0013EBr 3  A9 0C        	lda #NUMSPR			; sprite slots in table.
0013EDr 3  85 rr        	sta sprcnt
0013EFr 3  A9 rr        	lda #<sprtab			; sprite table.
0013F1r 3  85 rr        	sta z80_x
0013F3r 3  A9 rr        	lda #>sprtab
0013F5r 3  85 rr        	sta z80_i
0013F7r 3               ispr2:
0013F7r 3  A0 00        	ldy #0
0013F9r 3  B1 rr        	lda (z80_hl),y 			; fetch byte.
0013FBr 3  C9 FF        	cmp #255 			; is it an end marker?
0013FDr 3  D0 01        	bne :+
0013FFr 3  60           	rts 				; yes, no more to do.
001400r 3               :
001400r 3               ispr1:
001400r 3  A0 00        	ldy #0
001402r 3  B1 rr        	lda (z80_ix),y 			; fetch sprite type.
001404r 3  C9 FF        	cmp #255 			; is it enabled yet?
001406r 3  D0 08        	bne ispr4			; yes, try another slot.
001408r 3               
001408r 3  A0 05        	ldy #5
00140Ar 3  B1 rr        	lda (z80_ix),y		 	; next type.
00140Cr 3  C9 FF        	cmp #255 			; is it enabled yet?
00140Er 3  F0 10        	beq ispr3 			; no, process this one.
001410r 3               ispr4:
001410r 3  18           	clc 				; next sprite.
001411r 3  A5 rr        	lda z80_x
001413r 3  69 12        	adc #TABSIZ		 	; distance to next odd/even entry.
001415r 3  85 rr        	sta z80_x
001417r 3  90 02        	bcc :+
001419r 3  E6 rr        	inc z80_i
00141Br 3               :
00141Br 3  C6 rr        	dec sprcnt
00141Dr 3  D0 E1        	bne ispr1 			; repeat for remaining sprites.
00141Fr 3  60           	rts  				; no more room in table.
001420r 3               ispr3:
001420r 3  20 rr rr     	jsr cpsp			; initialise a sprite.
001423r 3  C6 rr        	dec sprcnt			; one less space in the table.
001425r 3  D0 D0        	bne ispr2
001427r 3  60           	rts
001428r 3               
001428r 3               
001428r 3               ;-----------------------------------------------------------------------
001428r 3               ; Initialise sprites - but not player, we're keeping the old one.
001428r 3               ;
001428r 3               ; global:	-
001428r 3               ; local:	x,y,ix
001428r 3               ; calls:	cpsp
001428r 3               ;-----------------------------------------------------------------------
001428r 3               
001428r 3               kspr:
001428r 3  A2 0C        	ldx #NUMSPR			; sprite slots in table.
00142Ar 3  A9 rr        	lda #<sprtab 			; sprite table.
00142Cr 3  85 rr        	sta z80_x
00142Er 3  A9 rr        	lda #>sprtab
001430r 3  85 rr        	sta z80_i
001432r 3               kspr2:
001432r 3  A0 00        	ldy #0
001434r 3  B1 rr        	lda (z80_hl),y 			; fetch byte.
001436r 3  C9 FF        	cmp #255 			; is it an end marker?
001438r 3  D0 01        	bne :+
00143Ar 3  60           	rts 				; yes, no more to do.
00143Br 3               :
00143Br 3  C9 00        	cmp #0
00143Dr 3  D0 0E        	bne kspr1 			; no, add to table as normal.
00143Fr 3               
00143Fr 3  18           	clc 				; next sprite.
001440r 3  A5 rr        	lda z80_l
001442r 3  69 04        	adc #NMESIZ		 	; distance to next odd/even entry.
001444r 3  85 rr        	sta z80_l
001446r 3  90 02        	bcc :+
001448r 3  E6 rr        	inc z80_h
00144Ar 3               :
00144Ar 3  4C rr rr     	jmp kspr2
00144Dr 3               kspr1:
00144Dr 3  A0 00        	ldy #0 				; fetch sprite type.
00144Fr 3  B1 rr        	lda (z80_ix),y
001451r 3  C9 FF        	cmp #255 			; is it enabled yet?
001453r 3  D0 08        	bne kspr4 			; yes, try another slot.
001455r 3               
001455r 3  A0 05        	ldy #5 				; next type.
001457r 3  B1 rr        	lda (z80_ix),y
001459r 3  C9 FF        	cmp #255 			; is it enabled yet?
00145Br 3  F0 0F        	beq kspr3 			; no, process this one.
00145Dr 3               kspr4:
00145Dr 3  18           	clc 				; next sprite.
00145Er 3  A5 rr        	lda z80_x
001460r 3  69 12        	adc #TABSIZ		 	; distance to next odd/even entry.
001462r 3  85 rr        	sta z80_x
001464r 3  90 02        	bcc :+
001466r 3  E6 rr        	inc z80_i
001468r 3               :
001468r 3  CA           	dex	 			; repeat for remaining sprites.
001469r 3  D0 E2        	bne kspr1
00146Br 3  60           	rts  				; no more room in table.
00146Cr 3               kspr3:
00146Cr 3  20 rr rr     	jsr cpsp 			; copy sprite to table.
00146Fr 3  CA           	dex	 			; one less space in the table.
001470r 3  D0 C0        	bne kspr2
001472r 3  60           	rts
001473r 3               
001473r 3               ;----------------------------------------------
001473r 3               ; Copy sprite from list to table.
001473r 3               ;
001473r 3               ; global:	hl,ix
001473r 3               ; local:	y
001473r 3               ; calls:	evnt09
001473r 3               ;----------------------------------------------
001473r 3               
001473r 3               cpsp:
001473r 3  A0 00        	ldy #0				; fetch byte from table.
001475r 3  B1 rr        	lda (z80_hl),y
001477r 3               	; y=var_Type
001477r 3  91 rr        	sta (z80_ix),y			; set up type.
001479r 3  A0 05        	ldy #var_newType
00147Br 3  91 rr        	sta (z80_ix),y 			; set up type.
00147Dr 3               
00147Dr 3  E6 rr        	inc z80_l 			; move to next byte.
00147Fr 3  D0 02        	bne :+
001481r 3  E6 rr        	inc z80_h
001483r 3               :
001483r 3  A0 00        	ldy #0 				; fetch byte from table.
001485r 3  B1 rr        	lda (z80_hl),y
001487r 3  A0 06        	ldy #var_newImage
001489r 3  91 rr        	sta (z80_ix),y			; set up image.
00148Br 3               
00148Br 3  E6 rr        	inc z80_l 			; move to next byte.
00148Dr 3  D0 02        	bne :+
00148Fr 3  E6 rr        	inc z80_h
001491r 3               :
001491r 3  A0 00        	ldy #0
001493r 3  B1 rr        	lda (z80_hl),y 			; fetch byte from table.
001495r 3  A0 08        	ldy #var_newY
001497r 3  91 rr        	sta (z80_ix),y 			; set up coordinate.
001499r 3               
001499r 3  A9 C8        	lda #200 			; set initial coordinate off screen.
00149Br 3  A0 03        	ldy #var_Y
00149Dr 3  91 rr        	sta (z80_ix),y
00149Fr 3               
00149Fr 3  E6 rr        	inc z80_l 			; move to next byte.
0014A1r 3  D0 02        	bne :+
0014A3r 3  E6 rr        	inc z80_h
0014A5r 3               :
0014A5r 3  A0 00        	ldy #0 				; fetch byte from table.
0014A7r 3  B1 rr        	lda (z80_hl),y
0014A9r 3  A0 09        	ldy #var_newX
0014ABr 3  91 rr        	sta (z80_ix),y 			; set up coordinate.
0014ADr 3               
0014ADr 3  E6 rr        	inc z80_l 			; move to next byte.
0014AFr 3  D0 02        	bne :+
0014B1r 3  E6 rr        	inc z80_h
0014B3r 3               :
0014B3r 3  A9 00        	lda #0				; zeroes in accumulator.
0014B5r 3  A0 07        	ldy #var_newFrame 		; reset frame number.
0014B7r 3  91 rr        	sta (z80_ix),y
0014B9r 3  A0 0A        	ldy #var_Direction 		; reset direction.
0014BBr 3  91 rr        	sta (z80_ix),y
0014BDr 3  A0 0D        	ldy #var_jumpLo			; reset jump pointer low.
0014BFr 3  91 rr        	sta (z80_ix),y
0014C1r 3  A0 0E        	ldy #var_jumpHi	 		; reset jump pointer high.
0014C3r 3  91 rr        	sta (z80_ix),y
0014C5r 3               
0014C5r 3  A9 FF        	lda #255 			; reset data pointer to auto-restore.
0014C7r 3  A0 10        	ldy #var_dataHi
0014C9r 3  91 rr        	sta (z80_ix),y
0014CBr 3               
0014CBr 3  AD rr rr     	lda fontcol			; set background INK
0014CEr 3  A0 11        	ldy #var_colour
0014D0r 3  91 rr        	sta (z80_ix),y
0014D2r 3               
0014D2r 3               evis0:
0014D2r 3  A5 rr        	lda z80_i
0014D4r 3  48           	pha
0014D5r 3  A5 rr        	lda z80_x
0014D7r 3  48           	pha
0014D8r 3  A5 rr        	lda z80_h
0014DAr 3  48           	pha
0014DBr 3  A5 rr        	lda z80_l
0014DDr 3  48           	pha
0014DEr 3               
0014DEr 3  20 rr rr     	jsr evnt09 				; perform event.
0014E1r 3               
0014E1r 3  68           	pla
0014E2r 3  85 rr        	sta z80_l
0014E4r 3  68           	pla
0014E5r 3  85 rr        	sta z80_h
0014E7r 3  68           	pla
0014E8r 3  85 rr        	sta z80_x
0014EAr 3  68           	pla
0014EBr 3  85 rr        	sta z80_i
0014EDr 3               
0014EDr 3  18           	clc
0014EEr 3  A5 rr        	lda z80_x 			; distance to next odd/even entry.
0014F0r 3  69 12        	adc #TABSIZ		 	; next sprite.
0014F2r 3  85 rr        	sta z80_x
0014F4r 3  90 02        	bcc :+
0014F6r 3  E6 rr        	inc z80_i
0014F8r 3               :
0014F8r 3  60           	rts
0014F9r 3               
0014F9r 3               
0014F9r 3               ;-------------------------------------
0014F9r 3               ; Clear the play area window.
0014F9r 3               ;-------------------------------------
0014F9r 3               
0014F9r 3               clw:
0014F9r 3  AD rr rr     	lda wintop			; get coordinates of window.
0014FCr 3  85 rr        	sta dispy			; put into dispx for calculation.
0014FEr 3  AD rr rr     	lda winlft
001501r 3  85 rr        	sta dispx
001503r 3               
001503r 3  AD rr rr     	lda winhgt			; height of window.
001506r 3  85 rr        	sta rrow			; copy to b register.
001508r 3               clw3:
001508r 3  AD rr rr     	lda winwid 			; width of window.
00150Br 3  85 rr        	sta rcol
00150Dr 3               clw2:
00150Dr 3  20 rr rr     	jsr gprad 			; get print address.
001510r 3  A9 20        	lda #32
001512r 3  20 rr rr     	jsr pchar
001515r 3  E6 rr        	inc dispx			; next column.
001517r 3  C6 rr        	dec rcol			; one less to do.
001519r 3  D0 F2        	bne clw2			; repeat for remaining columns.
00151Br 3               
00151Br 3  AD rr rr     	lda winlft			; get left edge.
00151Er 3  85 rr        	sta dispx 			; reset x.
001520r 3  E6 rr        	inc dispy 			; next line down.
001522r 3               
001522r 3  C6 rr        	dec rrow
001524r 3  D0 E2        	bne clw3			; repeat down the screen.
001526r 3               
001526r 3  AD rr rr     	lda wintop			; get coordinates of window.
001529r 3  85 rr        	sta chary			; put into display position.
00152Br 3  AD rr rr     	lda winlft
00152Er 3  85 rr        	sta charx
001530r 3  60           	rts
001531r 3               
001531r 3               
001531r 3               ;----------------------------------------------------------
001531r 3               ; Effects code.
001531r 3               ; Ticker routine is called 25 times per second.
001531r 3               ;
001531r 3               ; txtini = text scroller address
001531r 3               ; txtscr = left text screen address
001531r 3               ; txtwid = scroller width
001531r 3               ; txtbit = 128
001531r 3               ; X      = message nr
001531r 3               ;----------------------------------------------------------
001531r 3               
001531r 3               .if sflag
001531r 3               
001531r 3               scrollpos_lb:	.byte $00,$10,$20,$30,$40,$50,$60,$70
001531r 3               		.byte $80,$90,$a0,$b0,$c0,$d0,$e0,$f0
001531r 3               		.byte $00,$10,$20,$30,$40,$50
001531r 3               scrollpos_hb:	.byte $00,$00,$00,$00,$00,$00,$00,$00
001531r 3               		.byte $00,$00,$00,$00,$00,$00,$00,$00
001531r 3               		.byte $01,$01,$01,$01,$01,$01
001531r 3               
001531r 3               scrly:
001531r 3               
001531r 3               ; Set scr_l = txtscr
001531r 3               
001531r 3               	rts
001531r 3               	.word txtscr         	; set scr_l = left screen address.
001531r 3               	sta scr_l
001531r 3               	sta scr_r
001531r 3               	lda txtscr+1
001531r 3               	sta scr_l+1
001531r 3               	sta scr_r+1
001531r 3               
001531r 3               	stx xtmp		; save x
001531r 3               
001531r 3               ; Calculate scr_r = scr_l + 16*(txtwid -1)
001531r 3               
001531r 3               	ldx txtwid
001531r 3               	dex
001531r 3               	lda scrollpos_lb,x
001531r 3               	clc
001531r 3               	adc scr_r
001531r 3               	sta scr_r		; set lb scr_r = scr_l + (txtwid - 1) * 8
001531r 3               	bcc :+
001531r 3               	inc scr_r+1
001531r 3               :
001531r 3               	clc
001531r 3               	lda scrollpos_hb,x
001531r 3               	adc scr_r+1
001531r 3               	sta scr_r+1
001531r 3               
001531r 3               ; Scroll string
001531r 3               
001531r 3               	lda #0
001531r 3               	sta line_cnt		; Set line counter
001531r 3               scrly1:
001531r 3               	clc
001531r 3               	lda scr_r
001531r 3               	adc line_cnt
001531r 3               	sta scr_tmp
001531r 3               	lda scr_r+1
001531r 3               	sta scr_tmp+1
001531r 3               
001531r 3               	ldx txtwid		; set column counter
001531r 3               	dex
001531r 3               	ldy #0
001531r 3               	clc			; Reset pixel to be shifted in
001531r 3               scrly0:
001531r 3               	lda (scr_tmp),y
001531r 3               	rol a			; Shift screenbyte
001531r 3               	sta (scr_tmp),y		; store screenbyte
001531r 3               	php			; save carry
001531r 3               
001531r 3               	sec			; subtract 16 form screenaddress
001531r 3               	lda scr_tmp
001531r 3               	sbc #$10
001531r 3               	sta scr_tmp
001531r 3               	bcs :+
001531r 3               	dec scr_tmp+1
001531r 3               :
001531r 3               	plp			; restore carry
001531r 3               	dex			; previous column
001531r 3               	bpl scrly0		; repeat for all columns
001531r 3               
001531r 3               	inc line_cnt		; next line
001531r 3               	lda line_cnt
001531r 3               	cmp #8
001531r 3               	bne scrly1		; repeat for 8 lines
001531r 3               
001531r 3               ; Get next character in string
001531r 3               
001531r 3               	lda txtpos 		; get text pointer.
001531r 3               	sta scr_txt
001531r 3               	lda txtpos+1
001531r 3               	sta scr_txt+1
001531r 3               
001531r 3               	ldy #0
001531r 3               	lda (scr_txt),y 	; find character we're displaying.
001531r 3               	and #127 		; remove end marker bit if applicable.
001531r 3               	cmp #13			; is it newline?
001531r 3               	bne scrly5 		; no, it's okay.
001531r 3               	lda #32			; convert to a space instead.
001531r 3               scrly5:
001531r 3               	sta fntaddr		; calculate char address
001531r 3               	lda #0
001531r 3               	sta fntaddr+1
001531r 3               	asl fntaddr  		; multiply char by 8.
001531r 3               	rol fntaddr+1
001531r 3               	asl fntaddr
001531r 3               	rol fntaddr+1
001531r 3               	asl fntaddr
001531r 3               	rol fntaddr+1
001531r 3               	lda fntaddr
001531r 3               	clc
001531r 3               	adc #<(FONT-256)
001531r 3               	sta scrly3+1		; that's the low byte.
001531r 3               	lda fntaddr+1
001531r 3               	adc #>(FONT-256)
001531r 3               	sta scrly3+2		; add displacement.
001531r 3               
001531r 3               	ldy #0
001531r 3               scrly3:
001531r 3               	lda $3333,y		; get image of char line.
001531r 3               	and txtbit
001531r 3               	beq scrly2		; don't plot pixel
001531r 3               	lda (scr_r),y
001531r 3               	clc
001531r 3               	ora #1
001531r 3               	sta (scr_r),y		; plot pixel
001531r 3               scrly2:
001531r 3               	iny			; next line of char.
001531r 3               	cpy #8
001531r 3               	bne scrly3
001531r 3               
001531r 3               	lsr txtbit		; bit of text to display.
001531r 3               	bcs :+
001531r 3               	rts
001531r 3               :
001531r 3               	ldy #0
001531r 3               	lda (scr_txt),y 	; what was the character?
001531r 3               	asl a	  		; end of message?
001531r 3               	bcs scrly4
001531r 3               	inc txtpos
001531r 3               	bne :+
001531r 3               	inc txtpos+1
001531r 3               :
001531r 3               	jmp scrly6 		; not yet - continue.
001531r 3               scrly4:
001531r 3               	lda txtini 		; start of scrolling message.
001531r 3               	sta txtpos
001531r 3               	lda txtini+1
001531r 3               	sta txtpos+1
001531r 3               scrly6:
001531r 3               	lda #128
001531r 3               	sta txtbit
001531r 3               	ldx xtmp
001531r 3               	rts
001531r 3               
001531r 3               tmp_byte:	.byte 0
001531r 3               line_cnt:	.byte 0
001531r 3               
001531r 3               ;-------------------------------------------------------
001531r 3               ; Entry TICKER command
001531r 3               ;
001531r 3               ; Entry:
001531r 3               ;  z80_b = message nr
001531r 3               ;  z80_c = width
001531r 3               ;-------------------------------------------------------
001531r 3               
001531r 3               iscrly:
001531r 3               	jsr prescr 		; set up display position.
001531r 3               	lda #<msgdat 		; text messages.
001531r 3               	sta z80_l
001531r 3               	lda #>msgdat
001531r 3               	sta z80_h
001531r 3               	lda z80_c 		; width.
001531r 3               	sec
001531r 3               	sbc #1			; subtract one.
001531r 3               	cmp #32 		; is it between 1 and 32?
001531r 3               	bcc :+
001531r 3               	lda #$60
001531r 3               	jmp iscrl0		; no, disable messages.
001531r 3               :
001531r 3               	ldx z80_b		; message number.
001531r 3               	jsr getwrd 		; find message start.
001531r 3               
001531r 3               	lda z80_l		; set initial text position.
001531r 3               	sta txtini
001531r 3               	lda z80_h
001531r 3               	sta txtini+1
001531r 3               
001531r 3               	lda #$ad		; code for lda adrr
001531r 3               iscrl0:
001531r 3               	sta scrly		; enable/disable scrolling routine.
001531r 3               
001531r 3               	jsr prescr 		; set up display position.
001531r 3               	jsr gprad 		; get print address.
001531r 3               
001531r 3               	lda scraddr 		; set text screen address.
001531r 3               	sta txtscr
001531r 3               	lda scraddr+1
001531r 3               	sta txtscr+1
001531r 3               
001531r 3               	lda z80_c		; width.
001531r 3               	sta txtwid		; set width in working storage.
001531r 3               
001531r 3               	lda #128 		; start with leftmost bit.
001531r 3               	sta txtbit
001531r 3               
001531r 3               	jmp scrly4
001531r 3               .endif
001531r 3               
001531r 3               ;------------------------------------------------------------------
001531r 3               ; Dig routine, conditional assembly depending on dflag
001531r 3               ;------------------------------------------------------------------
001531r 3               .if dflag
001531r 3               dig:
001531r 3               	and #3
001531r 3               	beq digr		; dig right
001531r 3               	cmp #1
001531r 3               	beq digl		; dig left
001531r 3               	cmp #2
001531r 3               	beq digd		; dig down
001531r 3               
001531r 3               ; Dig up.
001531r 3               
001531r 3               digu:				; dig up
001531r 3               	ldy #8
001531r 3               	lda (z80_ix),y
001531r 3               	sec
001531r 3               	sbc #2
001531r 3               	sta dispy		; set y
001531r 3               
001531r 3               	iny
001531r 3               	lda (z80_ix),y
001531r 3               	sta dispx		; set x
001531r 3               	jmp digv
001531r 3               
001531r 3               ; Dig down.
001531r 3               
001531r 3               digd:
001531r 3               	ldy #9
001531r 3               	lda (z80_ix),y
001531r 3               	sta dispx		; set y
001531r 3               
001531r 3               	dey
001531r 3               	clc
001531r 3               	lda (z80_ix),y
001531r 3               	adc #16
001531r 3               	sta dispy		; set y
001531r 3               	jmp digv
001531r 3               
001531r 3               ; Dig left.
001531r 3               
001531r 3               digl:
001531r 3               	ldy #8
001531r 3               	lda (z80_ix),y
001531r 3               	sta dispy		; set y
001531r 3               
001531r 3               	iny
001531r 3               	lda (z80_ix),y
001531r 3               	sec
001531r 3               	sbc #2			; x=x-2
001531r 3               	sta dispx		; set x
001531r 3               	jmp digh
001531r 3               
001531r 3               ; Dig right.
001531r 3               
001531r 3               digr:
001531r 3               	ldy #8
001531r 3               	lda (z80_ix),y
001531r 3               	sta dispy		; set y
001531r 3               
001531r 3               	iny
001531r 3               	lda (z80_ix),y
001531r 3               	clc
001531r 3               	adc #16
001531r 3               	sta dispx		; set x+16
001531r 3               	jmp digh
001531r 3               
001531r 3               ; Vertical digging
001531r 3               
001531r 3               digv:
001531r 3               	jsr tstbl		; check blocktype in MAP
001531r 3               	jsr fdchk		; test if FODDER
001531r 3               
001531r 3               	clc
001531r 3               	lda dispx		; look 1 cell down
001531r 3               	adc #8
001531r 3               	sta dispx
001531r 3               	jsr tstbl		; check blocktype in MAP
001531r 3               	jsr fdchk
001531r 3               	lda dispx
001531r 3               	and #7
001531r 3               	bne :+
001531r 3               	rts
001531r 3               :
001531r 3               	clc
001531r 3               	lda dispx		; look 1 cell down
001531r 3               	adc #8
001531r 3               	sta dispx
001531r 3               	jsr tstbl		; check blocktype in MAP
001531r 3               	jmp fdchk
001531r 3               
001531r 3               ; Horizontal digging
001531r 3               
001531r 3               digh:
001531r 3               	jsr tstbl		; check blocktype in MAP
001531r 3               	jsr fdchk		; test if FODDER
001531r 3               
001531r 3               	clc
001531r 3               	lda dispy		; look 1 cell down
001531r 3               	adc #8
001531r 3               	sta dispy
001531r 3               	jsr tstbl		; check blocktype in MAP
001531r 3               	jsr fdchk
001531r 3               	lda dispy
001531r 3               	and #7
001531r 3               	bne :+
001531r 3               	rts
001531r 3               :
001531r 3               	clc
001531r 3               	lda dispy		; look 1 cell down
001531r 3               	adc #8
001531r 3               	sta dispy
001531r 3               	jsr tstbl		; check blocktype in MAP
001531r 3               	jmp fdchk
001531r 3               
001531r 3               digcnt:	.byte 0
001531r 3               
001531r 3               .endif
001531r 3               
001531r 3               ;------------------------------------------------------------------
001531r 3               ; Sprite table
001531r 3               ;------------------------------------------------------------------
001531r 3               
001531r 3               
001531r 3               ; ix+0  = type.
001531r 3               ; ix+1  = sprite image number.
001531r 3               ; ix+2  = frame.
001531r 3               ; ix+3  = y coord.
001531r 3               ; ix+4  = x coord.
001531r 3               
001531r 3               ; ix+5  = new type.
001531r 3               ; ix+6  = new image number.
001531r 3               ; ix+7  = new frame.
001531r 3               ; ix+8  = new y coord.
001531r 3               ; ix+9  = new x coord.
001531r 3               
001531r 3               ; ix+10 = direction.
001531r 3               ; ix+11 = parameter 1.
001531r 3               ; ix+12 = parameter 2.
001531r 3               ; ix+13 = jump pointer low.
001531r 3               ; ix+14 = jump pointer high.
001531r 3               ; ix+15 = data pointer low.
001531r 3               ; ix+16 = data pointer high.
001531r 3               
001531r 3               ; block NUMSPR * TABSIZ,255
001531r 3               
001531r 3  FF FF FF FF  sprtab:	.res NUMSPR*TABSIZ,255
001535r 3  FF FF FF FF  
001539r 3  FF FF FF FF  
001609r 3  FF FF FF FF  ssprit:	.byte 255,255,255,255,255,255,255,0,192,120,0,0,0,255,255,255,255
00160Dr 3  FF FF FF 00  
001611r 3  C0 78 00 00  
00161Ar 3  07           roomtb:	.byte 7                      ; start room map offset.
00161Br 3               
00161Br 3               setfgcol:
00161Br 3               setbgcol:
00161Br 3  60           	rts
00161Cr 3               
00161Cr 3               ; User routine.  Put your own code in here to be called with USER instruction.
00161Cr 3               ; if USER has an argument it will be passed in the accumulator.
00161Cr 3               
00161Cr 3               user:
00161Cr 3               	.include "user.inc"
00161Cr 4  60           	rts
00161Dr 4               
00161Dr 3               
00161Dr 3               ; Everything below here will be generated by the editors.
00161Dr 3               
00161Dr 3               
00161Dr 3  60                   rts
00161Er 3               WINDOWTOP = 0
00161Er 3               WINDOWLFT = 0
00161Er 3               WINDOWHGT = 22
00161Er 3               WINDOWWID = 22 ;a
00161Er 3               MAPWID = 11
00161Er 3  FF FF FF FF          .byte 255,255,255,255,255,255,255,255,255,255,255
001622r 3  FF FF FF FF  
001626r 3  FF FF FF     
001629r 3               mapdat:
001629r 3  FF FF FF 00          .byte 255,255,255,0,1,2,255,255,255,255,255
00162Dr 3  01 02 FF FF  
001631r 3  FF FF FF     
001634r 3  FF FF FF FF          .byte 255,255,255,255,255,255,255,255,255,255,255
001638r 3  FF FF FF FF  
00163Cr 3  FF FF FF     
00163Fr 3  0A           stmap:  .byte 10
001640r 3               
001640r 3               evnt00:
001640r 3  A5 rr                lda joyval	; KEY
001642r 3  29 08                and #8
001644r 3  F0 03                beq :+
001646r 3  4C rr rr             jmp a00086
001649r 3               :
001649r 3  20 rr rr             jsr laddu	; CANGOUP
00164Cr 3  F0 03                beq :+
00164Er 3  4C rr rr             jmp a00086
001651r 3               :
001651r 3  A9 01                lda #1
001653r 3  A0 06                ldy #6
001655r 3  91 rr                sta (z80_ix),y
001657r 3  A9 00                lda #0		; ANIMATE
001659r 3  20 rr rr             jsr animsp
00165Cr 3  A0 08                ldy #8 		; SPRITEUP
00165Er 3  B1 rr                lda (z80_ix),y
001660r 3  38                   sec
001661r 3  E9 02                sbc #2
001663r 3  91 rr                sta (z80_ix),y
001665r 3  A5 rr        a00086: lda joyval	; KEY
001667r 3  29 04                and #4
001669r 3  F0 03                beq :+
00166Br 3  4C rr rr             jmp a00173
00166Er 3               :
00166Er 3  20 rr rr             jsr laddd	; LADDERBELOW
001671r 3  F0 03                beq :+
001673r 3  4C rr rr             jmp a00173
001676r 3               :
001676r 3  A9 01                lda #1
001678r 3  A0 06                ldy #6
00167Ar 3  91 rr                sta (z80_ix),y
00167Cr 3  A9 00                lda #0		; ANIMATE
00167Er 3  20 rr rr             jsr animsp
001681r 3  A0 08                ldy #8 		; SPRITEDOWN
001683r 3  B1 rr                lda (z80_ix),y
001685r 3  18                   clc
001686r 3  69 02                adc #2
001688r 3  91 rr                sta (z80_ix),y
00168Ar 3  A5 rr        a00173: lda joyval	; KEY
00168Cr 3  29 01                and #1
00168Er 3  F0 03                beq :+
001690r 3  4C rr rr             jmp a00266
001693r 3               :
001693r 3  20 rr rr             jsr cangr	; CANGORIGHT
001696r 3  F0 03                beq :+
001698r 3  4C rr rr             jmp a00266
00169Br 3               :
00169Br 3  20 rr rr             jsr vapour	; TRAIL
00169Er 3  A9 00                lda #0
0016A0r 3  A0 06                ldy #6
0016A2r 3  91 rr                sta (z80_ix),y
0016A4r 3  A9 00                lda #0		; ANIMATE
0016A6r 3  20 rr rr             jsr animsp
0016A9r 3  A0 09                ldy #9 		; SPRITERIGHT
0016ABr 3  B1 rr                lda (z80_ix),y
0016ADr 3  18                   clc
0016AEr 3  69 02                adc #2
0016B0r 3  91 rr                sta (z80_ix),y
0016B2r 3  A5 rr        a00266: lda joyval	; KEY
0016B4r 3  29 02                and #2
0016B6r 3  F0 03                beq :+
0016B8r 3  4C rr rr             jmp a00358
0016BBr 3               :
0016BBr 3  20 rr rr             jsr cangl	; CANGOLEFT
0016BEr 3  F0 03                beq :+
0016C0r 3  4C rr rr             jmp a00358
0016C3r 3               :
0016C3r 3  20 rr rr             jsr vapour	; TRAIL
0016C6r 3  A9 00                lda #0
0016C8r 3  A0 06                ldy #6
0016CAr 3  91 rr                sta (z80_ix),y
0016CCr 3  A9 00                lda #0		; ANIMATE
0016CEr 3  20 rr rr             jsr animsp
0016D1r 3  A0 09                ldy #9 		; SPRITELEFT
0016D3r 3  B1 rr                lda (z80_ix),y
0016D5r 3  38                   sec
0016D6r 3  E9 02                sbc #2
0016D8r 3  91 rr                sta (z80_ix),y
0016DAr 3  A9 06        a00358: lda #6
0016DCr 3  29 07                and #7
0016DEr 3  85 rr                sta z80_c
0016E0r 3  20 rr rr             jsr cspr
0016E3r 3                       ; SPRITEINK command
0016E3r 3  60                   rts
0016E4r 3               evnt01:
0016E4r 3  A9 00                lda #0
0016E6r 3  A0 0A                ldy #10
0016E8r 3  D1 rr                cmp (z80_ix),y
0016EAr 3  F0 03                beq *+5
0016ECr 3  4C rr rr             jmp b00153
0016EFr 3  20 rr rr             jsr laddu	; CANGOUP
0016F2r 3  F0 03                beq :+
0016F4r 3  4C rr rr             jmp b00070
0016F7r 3               :
0016F7r 3  A0 08                ldy #8 		; SPRITEUP
0016F9r 3  B1 rr                lda (z80_ix),y
0016FBr 3  38                   sec
0016FCr 3  E9 02                sbc #2
0016FEr 3  91 rr                sta (z80_ix),y
001700r 3  4C rr rr             jmp b00153
001703r 3  A9 02        b00070: lda #2
001705r 3  85 rr                sta z80_d	; GETRANDOM
001707r 3  20 rr rr             jsr random
00170Ar 3  85 rr                sta z80_h
00170Cr 3  20 rr rr             jsr imul
00170Fr 3  A5 rr                lda z80_h
001711r 3  85 rr                sta varrnd
001713r 3  A9 00                lda #0
001715r 3  C5 rr                cmp varrnd
001717r 3  F0 03                beq *+5
001719r 3  4C rr rr             jmp b00139
00171Cr 3  A9 02                lda #2
00171Er 3  A0 0A                ldy #10
001720r 3  91 rr                sta (z80_ix),y
001722r 3  4C rr rr             jmp b00153
001725r 3  A9 03        b00139: lda #3
001727r 3  A0 0A                ldy #10
001729r 3  91 rr                sta (z80_ix),y
00172Br 3  A9 01        b00153: lda #1
00172Dr 3  A0 0A                ldy #10
00172Fr 3  D1 rr                cmp (z80_ix),y
001731r 3  F0 03                beq *+5
001733r 3  4C rr rr             jmp b00306
001736r 3  20 rr rr             jsr laddd	; LADDERBELOW
001739r 3  F0 03                beq :+
00173Br 3  4C rr rr             jmp b00223
00173Er 3               :
00173Er 3  A0 08                ldy #8 		; SPRITEDOWN
001740r 3  B1 rr                lda (z80_ix),y
001742r 3  18                   clc
001743r 3  69 02                adc #2
001745r 3  91 rr                sta (z80_ix),y
001747r 3  4C rr rr             jmp b00306
00174Ar 3  A9 02        b00223: lda #2
00174Cr 3  85 rr                sta z80_d	; GETRANDOM
00174Er 3  20 rr rr             jsr random
001751r 3  85 rr                sta z80_h
001753r 3  20 rr rr             jsr imul
001756r 3  A5 rr                lda z80_h
001758r 3  85 rr                sta varrnd
00175Ar 3  A9 00                lda #0
00175Cr 3  C5 rr                cmp varrnd
00175Er 3  F0 03                beq *+5
001760r 3  4C rr rr             jmp b00292
001763r 3  A9 02                lda #2
001765r 3  A0 0A                ldy #10
001767r 3  91 rr                sta (z80_ix),y
001769r 3  4C rr rr             jmp b00306
00176Cr 3  A9 03        b00292: lda #3
00176Er 3  A0 0A                ldy #10
001770r 3  91 rr                sta (z80_ix),y
001772r 3  A9 02        b00306: lda #2
001774r 3  A0 0A                ldy #10
001776r 3  D1 rr                cmp (z80_ix),y
001778r 3  F0 03                beq *+5
00177Ar 3  4C rr rr             jmp b00518
00177Dr 3  20 rr rr             jsr cangl	; CANGOLEFT
001780r 3  F0 03                beq :+
001782r 3  4C rr rr             jmp b00388
001785r 3               :
001785r 3  A0 09                ldy #9 		; SPRITELEFT
001787r 3  B1 rr                lda (z80_ix),y
001789r 3  38                   sec
00178Ar 3  E9 02                sbc #2
00178Cr 3  91 rr                sta (z80_ix),y
00178Er 3  A9 00                lda #0
001790r 3  A0 07                ldy #7
001792r 3  91 rr                sta (z80_ix),y
001794r 3  4C rr rr             jmp b00402
001797r 3  A9 03        b00388: lda #3
001799r 3  A0 0A                ldy #10
00179Br 3  91 rr                sta (z80_ix),y
00179Dr 3  A9 04        b00402: lda #4
00179Fr 3  85 rr                sta z80_d	; GETRANDOM
0017A1r 3  20 rr rr             jsr random
0017A4r 3  85 rr                sta z80_h
0017A6r 3  20 rr rr             jsr imul
0017A9r 3  A5 rr                lda z80_h
0017ABr 3  85 rr                sta varrnd
0017ADr 3  A9 00                lda #0
0017AFr 3  C5 rr                cmp varrnd
0017B1r 3  F0 03                beq *+5
0017B3r 3  4C rr rr             jmp b00518
0017B6r 3  20 rr rr             jsr laddu	; CANGOUP
0017B9r 3  F0 03                beq :+
0017BBr 3  4C rr rr             jmp b00487
0017BEr 3               :
0017BEr 3  A9 00                lda #0
0017C0r 3  A0 0A                ldy #10
0017C2r 3  91 rr                sta (z80_ix),y
0017C4r 3  4C rr rr             jmp b00518
0017C7r 3  20 rr rr     b00487: jsr laddd	; LADDERBELOW
0017CAr 3  F0 03                beq :+
0017CCr 3  4C rr rr             jmp b00518
0017CFr 3               :
0017CFr 3  A9 01                lda #1
0017D1r 3  A0 0A                ldy #10
0017D3r 3  91 rr                sta (z80_ix),y
0017D5r 3  A9 03        b00518: lda #3
0017D7r 3  A0 0A                ldy #10
0017D9r 3  D1 rr                cmp (z80_ix),y
0017DBr 3  F0 03                beq *+5
0017DDr 3  4C rr rr             jmp b00730
0017E0r 3  20 rr rr             jsr cangr	; CANGORIGHT
0017E3r 3  F0 03                beq :+
0017E5r 3  4C rr rr             jmp b00601
0017E8r 3               :
0017E8r 3  A0 09                ldy #9 		; SPRITERIGHT
0017EAr 3  B1 rr                lda (z80_ix),y
0017ECr 3  18                   clc
0017EDr 3  69 02                adc #2
0017EFr 3  91 rr                sta (z80_ix),y
0017F1r 3  A9 01                lda #1
0017F3r 3  A0 07                ldy #7
0017F5r 3  91 rr                sta (z80_ix),y
0017F7r 3  4C rr rr             jmp b00614
0017FAr 3  A9 02        b00601: lda #2
0017FCr 3  A0 0A                ldy #10
0017FEr 3  91 rr                sta (z80_ix),y
001800r 3  A9 04        b00614: lda #4
001802r 3  85 rr                sta z80_d	; GETRANDOM
001804r 3  20 rr rr             jsr random
001807r 3  85 rr                sta z80_h
001809r 3  20 rr rr             jsr imul
00180Cr 3  A5 rr                lda z80_h
00180Er 3  85 rr                sta varrnd
001810r 3  A9 00                lda #0
001812r 3  C5 rr                cmp varrnd
001814r 3  F0 03                beq *+5
001816r 3  4C rr rr             jmp b00730
001819r 3  20 rr rr             jsr laddu	; CANGOUP
00181Cr 3  F0 03                beq :+
00181Er 3  4C rr rr             jmp b00700
001821r 3               :
001821r 3  A9 00                lda #0
001823r 3  A0 0A                ldy #10
001825r 3  91 rr                sta (z80_ix),y
001827r 3  4C rr rr             jmp b00730
00182Ar 3  20 rr rr     b00700: jsr laddd	; LADDERBELOW
00182Dr 3  F0 03                beq :+
00182Fr 3  4C rr rr             jmp b00730
001832r 3               :
001832r 3  A9 01                lda #1
001834r 3  A0 0A                ldy #10
001836r 3  91 rr                sta (z80_ix),y
001838r 3  A9 00        b00730: lda #0 	; COLLISION
00183Ar 3  85 rr                sta z80_b
00183Cr 3  20 rr rr             jsr sktyp
00183Fr 3  B0 03                bcs :+
001841r 3  4C rr rr             jmp b00766
001844r 3               :
001844r 3  A9 01                lda #1 		; KILL
001846r 3  85 rr                sta deadf
001848r 3  A9 02        b00766: lda #2
00184Ar 3  29 07                and #7
00184Cr 3  85 rr                sta z80_c
00184Er 3  20 rr rr             jsr cspr
001851r 3                       ; SPRITEINK command
001851r 3  60                   rts
001852r 3               evnt02:
001852r 3  A0 0C                ldy #12
001854r 3  B1 rr                lda (z80_ix),y
001856r 3  38                   sec
001857r 3  E9 01                sbc #1
001859r 3  A0 0C                ldy #12
00185Br 3  91 rr                sta (z80_ix),y
00185Dr 3  A9 00                lda #0
00185Fr 3  A0 0C                ldy #12
001861r 3  D1 rr                cmp (z80_ix),y
001863r 3  F0 03                beq *+5
001865r 3  4C rr rr             jmp c00134
001868r 3  A9 03                lda #3
00186Ar 3  A0 0C                ldy #12
00186Cr 3  91 rr                sta (z80_ix),y
00186Er 3  A9 07                lda #7
001870r 3  A0 0B                ldy #11
001872r 3  D1 rr                cmp (z80_ix),y
001874r 3  90 02                bcc *+4
001876r 3  D0 03                bne *+5
001878r 3  4C rr rr             jmp c00121
00187Br 3  A0 0B                ldy #11
00187Dr 3  B1 rr                lda (z80_ix),y
00187Fr 3  18                   clc
001880r 3  69 01                adc #1
001882r 3  A0 0B                ldy #11
001884r 3  91 rr                sta (z80_ix),y
001886r 3  4C rr rr             jmp c00134
001889r 3  A9 00        c00121: lda #0
00188Br 3  A0 0B                ldy #11
00188Dr 3  91 rr                sta (z80_ix),y
00188Fr 3  A0 0B        c00134: ldy #11
001891r 3  B1 rr                lda (z80_ix),y
001893r 3  29 07                and #7
001895r 3  85 rr                sta z80_c
001897r 3  20 rr rr             jsr cspr
00189Ar 3                       ; SPRITEINK command
00189Ar 3  A9 00                lda #0 	; COLLISION
00189Cr 3  85 rr                sta z80_b
00189Er 3  20 rr rr             jsr sktyp
0018A1r 3  B0 03                bcs :+
0018A3r 3  4C rr rr             jmp c00334
0018A6r 3               :
0018A6r 3  A9 FF                lda #255	; REMOVE
0018A8r 3  A0 05                ldy #5
0018AAr 3  91 rr                sta (z80_ix),y
0018ACr 3  A9 19                lda #25	; EXPLODE
0018AEr 3  20 rr rr             jsr explod
0018B1r 3  A5 rr                lda vara
0018B3r 3  38                   sec
0018B4r 3  E9 01                sbc #1
0018B6r 3  85 rr                sta vara
0018B8r 3  A9 00                lda #0
0018BAr 3  C5 rr                cmp vara
0018BCr 3  F0 03                beq *+5
0018BEr 3  4C rr rr             jmp c00259
0018C1r 3  A9 01                lda #1	; NEXTLEVEL
0018C3r 3  85 rr                sta nexlev
0018C5r 3  A9 64        c00259: lda #<100		; SCORE
0018C7r 3  85 rr                sta z80_l
0018C9r 3  A9 00                lda #>100
0018CBr 3  85 rr                sta z80_h
0018CDr 3  20 rr rr             jsr addsc
0018D0r 3  A9 01                lda #1;		SOUND command
0018D2r 3  20 rr rr             jsr playsound
0018D5r 3  A9 00                lda #0
0018D7r 3  85 rr                sta chary
0018D9r 3  A9 01                lda #1
0018DBr 3  85 rr                sta charx
0018DDr 3  A0 00                ldy #0		; SHOWSCORE
0018DFr 3  A9 06                lda #6
0018E1r 3  85 rr                sta z80_b
0018E3r 3  20 rr rr             jsr dscor
0018E6r 3  60           c00334: rts
0018E7r 3               evnt03:
0018E7r 3  60                   rts
0018E8r 3               evnt04:
0018E8r 3  60                   rts
0018E9r 3               evnt05:
0018E9r 3  60                   rts
0018EAr 3               evnt06:
0018EAr 3  60                   rts
0018EBr 3               evnt07:
0018EBr 3  60                   rts
0018ECr 3               evnt08:
0018ECr 3  60                   rts
0018EDr 3               evnt09:
0018EDr 3  A9 02                lda #2
0018EFr 3  A0 05                ldy #5
0018F1r 3  D1 rr                cmp (z80_ix),y
0018F3r 3  F0 03                beq *+5
0018F5r 3  4C rr rr             jmp j00051
0018F8r 3  A9 00                lda #0
0018FAr 3  A0 0B                ldy #11
0018FCr 3  91 rr                sta (z80_ix),y
0018FEr 3  A9 03                lda #3
001900r 3  A0 0C                ldy #12
001902r 3  91 rr                sta (z80_ix),y
001904r 3  60           j00051: rts
001905r 3               evnt10:
001905r 3  60                   rts
001906r 3               evnt11:
001906r 3  60                   rts
001907r 3               evnt12:
001907r 3  A9 00                lda #0 	; PAPER
001909r 3  0A                   asl a
00190Ar 3  0A                   asl a
00190Br 3  0A                   asl a
00190Cr 3  0A                   asl a
00190Dr 3  85 rr                sta tmp
00190Fr 3  AD 0F 90             lda RegF
001912r 3  29 0F                and #%00001111
001914r 3  05 rr                ora tmp
001916r 3  8D 0F 90             sta RegF
001919r 3  A9 01                lda #1 	; INK
00191Br 3  8D rr rr             sta fontcol
00191Er 3  20 rr rr             jsr cls		; CLS
001921r 3  60                   rts
001922r 3               evnt13:
001922r 3  A9 03                lda #3
001924r 3  85 rr                sta numlif
001926r 3  A9 00                lda #0
001928r 3  85 rr                sta scno
00192Ar 3  20 rr rr             jsr nwscr
00192Dr 3                       ; COLOUR command
00192Dr 3  A9 02                lda #2
00192Fr 3                       ; BORDER command
00192Fr 3  29 07                and #7
001931r 3  85 rr                sta tmp
001933r 3  AD 0F 90             lda RegF
001936r 3  29 F8                and #%11111000
001938r 3  05 rr                ora tmp
00193Ar 3  8D 0F 90             sta RegF
00193Dr 3  20 rr rr             jsr cls		; CLS
001940r 3  A9 02                lda #2
001942r 3  85 rr                sta chary
001944r 3  A9 12                lda #18
001946r 3  85 rr                sta charx
001948r 3  A9 02                lda #2  	; MESSAGE
00194Ar 3  20 rr rr             jsr dmsg
00194Dr 3  A9 05                lda #5
00194Fr 3  85 rr                sta chary
001951r 3  A9 12                lda #18
001953r 3  85 rr                sta charx
001955r 3  A9 03                lda #3  	; MESSAGE
001957r 3  20 rr rr             jsr dmsg
00195Ar 3  A9 00                lda #0
00195Cr 3  85 rr                sta chary
00195Er 3  A9 09                lda #9
001960r 3  85 rr                sta charx
001962r 3                       ; COLOUR command
001962r 3  A9 01                lda #1  	; MESSAGE
001964r 3  20 rr rr             jsr dmsg
001967r 3  A9 03                lda #3
001969r 3  85 rr                sta chary
00196Br 3  A9 12                lda #18
00196Dr 3  85 rr                sta charx
00196Fr 3  A0 00                ldy #0		; SHOWSCORE
001971r 3  A9 06                lda #6
001973r 3  85 rr                sta z80_b
001975r 3  20 rr rr             jsr dscor
001978r 3  60                   rts
001979r 3               evnt14:
001979r 3  A9 00                lda #0
00197Br 3  85 rr                sta vara
00197Dr 3  A9 06                lda #6
00197Fr 3  85 rr                sta chary
001981r 3  A9 14                lda #20
001983r 3  85 rr                sta charx
001985r 3  A5 rr                lda numlif	; DISPLAY
001987r 3  20 rr rr             jsr disply
00198Ar 3  60                   rts
00198Br 3               evnt15:
00198Br 3  A9 00                lda #0
00198Dr 3  A0 05                ldy #5
00198Fr 3  D1 rr                cmp (z80_ix),y
001991r 3  F0 03                beq *+5
001993r 3  4C rr rr             jmp p00034
001996r 3  A9 01                lda #1 		; KILL
001998r 3  85 rr                sta deadf
00199Ar 3  60           p00034: rts
00199Br 3               evnt16:
00199Br 3  A9 00                lda #0;		SOUND command
00199Dr 3  20 rr rr             jsr playsound
0019A0r 3  A5 rr                lda numlif
0019A2r 3  38                   sec
0019A3r 3  E9 01                sbc #1
0019A5r 3  85 rr                sta numlif
0019A7r 3  60                   rts
0019A8r 3               evnt17:
0019A8r 3  A9 32                lda #50 	; DELAY
0019AAr 3  20 rr rr             jsr delay
0019ADr 3  60                   rts
0019AEr 3               evnt18:
0019AEr 3  A9 32                lda #50 	; DELAY
0019B0r 3  20 rr rr             jsr delay
0019B3r 3  60                   rts
0019B4r 3               evnt19:
0019B4r 3  60                   rts
0019B5r 3  60           ptcusr: rts
0019B6r 3               data_start:
0019B6r 3               msgdat:
0019B6r 3  47 41 4D 45          .byte "GAME OVE",210
0019BAr 3  20 4F 56 45  
0019BEr 3  D2           
0019BFr 3  44 49 41 4D          .byte "DIAMOND GEEZE",210
0019C3r 3  4F 4E 44 20  
0019C7r 3  47 45 45 5A  
0019CDr 3  53 43 4F 52          .byte "SCOR",197
0019D1r 3  C5           
0019D2r 3  4C 49 56 45          .byte "LIVE",211
0019D6r 3  D3           
0019D7r 3  31 2E 20 4B          .byte "1. KEYBOAR",196
0019DBr 3  45 59 42 4F  
0019DFr 3  41 52 C4     
0019E2r 3  32 2E 20 4B          .byte "2. KEMPSTO",206
0019E6r 3  45 4D 50 53  
0019EAr 3  54 4F CE     
0019EDr 3  33 2E 20 53          .byte "3. SINCLAI",210
0019F1r 3  49 4E 43 4C  
0019F5r 3  41 49 D2     
0019F8r 3  20 20 57 65          .byte "  Welcome to Diamond Geezer...",13
0019FCr 3  6C 63 6F 6D  
001A00r 3  65 20 74 6F  
001A17r 3  4D 6F 76 65          .byte "Move around the levels",13
001A1Br 3  20 61 72 6F  
001A1Fr 3  75 6E 64 20  
001A2Er 3  63 6F 6C 6C          .byte "collecting diamonds and",13
001A32r 3  65 63 74 69  
001A36r 3  6E 67 20 64  
001A46r 3  61 76 6F 69          .byte "avoiding the deadly",13
001A4Ar 3  64 69 6E 67  
001A4Er 3  20 74 68 65  
001A5Ar 3  73 6B 75 6C          .byte "skulls   +",13
001A5Er 3  6C 73 20 20  
001A62r 3  20 2B 0D     
001A65r 3  8D                   .byte 141
001A66r 3               nummsg:
001A66r 3  08                   .byte 8
001A67r 3               chgfx:
001A67r 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
001A6Br 3  00 00 00 00  
001A6Fr 3  FE FE FE 00          .byte 254,254,254,0,239,239,239,0
001A73r 3  EF EF EF 00  
001A77r 3  00 00 FF 00          .byte 0,0,255,0,0,0,255,0
001A7Br 3  00 00 FF 00  
001A7Fr 3  AA 55 AA 55          .byte 170,85,170,85,170,85,170,85
001A83r 3  AA 55 AA 55  
001A87r 3               bCol:
001A87r 3  01                   .byte 1
001A88r 3  01                   .byte 1
001A89r 3  01                   .byte 1
001A8Ar 3  01                   .byte 1
001A8Br 3               bprop:
001A8Br 3  00                   .byte 0
001A8Cr 3  02                   .byte 2
001A8Dr 3  03                   .byte 3
001A8Er 3  04                   .byte 4
001A8Fr 3               sprgfx:
001A8Fr 3  43 80 37 C5          .byte 67,128,55,197,103,226,39,229,19,228,15,248,1,240,1,240,3,240,3,224,7,224,15,224,23,208,19,144,56,24,120,60
001A93r 3  67 E2 27 E5  
001A97r 3  13 E4 0F F8  
001AAFr 3  10 E0 4D F1          .byte 16,224,77,241,153,248,73,249,4,249,3,254,0,124,0,124,0,252,0,248,1,248,3,248,5,244,4,228,14,6,30,15
001AB3r 3  99 F8 49 F9  
001AB7r 3  04 F9 03 FE  
001ACFr 3  04 38 53 7C          .byte 4,56,83,124,38,126,82,126,65,62,128,255,0,31,0,31,0,63,0,62,0,126,0,254,1,125,1,57,131,129,199,131
001AD3r 3  26 7E 52 7E  
001AD7r 3  41 3E 80 FF  
001AEFr 3  01 0E 14 DF          .byte 1,14,20,223,137,159,148,159,144,79,224,63,192,7,192,7,192,15,128,15,128,31,128,63,64,95,64,78,96,224,241,224
001AF3r 3  89 9F 94 9F  
001AF7r 3  90 4F E0 3F  
001B0Fr 3  00 00 03 80          .byte 0,0,3,128,7,192,87,229,39,226,83,237,15,241,1,240,1,240,3,240,3,224,7,224,15,240,23,200,227,134,224,15
001B13r 3  07 C0 57 E5  
001B17r 3  27 E2 53 ED  
001B2Fr 3  00 00 00 E0          .byte 0,0,0,224,1,240,85,249,137,248,84,251,67,252,0,124,0,124,0,252,0,248,1,248,3,252,5,242,184,225,248,3
001B33r 3  01 F0 55 F9  
001B37r 3  89 F8 54 FB  
001B4Fr 3  00 00 00 38          .byte 0,0,0,56,0,124,85,126,34,126,213,62,16,255,0,31,0,31,0,63,0,62,0,126,0,255,129,124,110,56,254,0
001B53r 3  00 7C 55 7E  
001B57r 3  22 7E D5 3E  
001B6Fr 3  00 00 00 0E          .byte 0,0,0,14,0,31,149,95,136,159,181,79,196,63,192,7,192,7,192,15,128,15,128,31,192,63,32,95,27,142,63,128
001B73r 3  00 1F 95 5F  
001B77r 3  88 9F B5 4F  
001B8Fr 3  03 80 07 C0          .byte 3,128,7,192,7,224,7,224,67,224,35,241,253,250,33,247,3,242,3,225,7,224,15,224,23,208,19,144,56,24,120,60
001B93r 3  07 E0 07 E0  
001B97r 3  43 E0 23 F1  
001BAFr 3  00 E0 01 F0          .byte 0,224,1,240,1,248,1,248,16,248,72,252,191,126,200,125,128,252,64,248,1,248,3,248,5,244,4,228,14,6,30,15
001BB3r 3  01 F8 01 F8  
001BB7r 3  10 F8 48 FC  
001BCFr 3  00 38 00 7C          .byte 0,56,0,124,0,126,0,126,4,62,18,63,175,223,114,31,32,63,16,62,0,126,0,254,1,125,1,57,131,129,199,131
001BD3r 3  00 7E 00 7E  
001BD7r 3  04 3E 12 3F  
001BEFr 3  00 0E 00 1F          .byte 0,14,0,31,128,31,128,31,129,15,196,143,235,247,220,135,200,15,132,15,128,31,128,63,64,95,64,78,96,224,241,224
001BF3r 3  80 1F 80 1F  
001BF7r 3  81 0F C4 8F  
001C0Fr 3  03 80 07 C0          .byte 3,128,7,192,7,224,87,229,35,226,83,253,13,241,1,240,3,240,3,224,7,224,7,224,7,224,3,160,15,112,15,112
001C13r 3  07 E0 57 E5  
001C17r 3  23 E2 53 FD  
001C2Fr 3  00 E0 01 F0          .byte 0,224,1,240,1,248,85,249,136,248,84,255,67,124,0,124,0,252,0,248,1,248,1,248,1,248,0,232,3,220,3,220
001C33r 3  01 F8 55 F9  
001C37r 3  88 F8 54 FF  
001C4Fr 3  00 38 00 7C          .byte 0,56,0,124,0,126,85,126,34,62,213,63,16,223,0,31,0,63,0,62,0,126,0,126,0,126,0,58,0,247,0,247
001C53r 3  00 7E 55 7E  
001C57r 3  22 3E D5 3F  
001C6Fr 3  00 0E 00 1F          .byte 0,14,0,31,128,31,149,95,136,143,245,79,196,55,192,7,192,15,128,15,128,31,128,31,128,31,128,14,192,61,192,61
001C73r 3  80 1F 95 5F  
001C77r 3  88 8F F5 4F  
001C8Fr 3  01 C0 C3 E0          .byte 1,192,195,224,199,224,39,224,47,192,31,243,15,143,15,128,15,192,7,216,7,246,7,247,59,224,33,192,224,0,224,0
001C93r 3  C7 E0 27 E0  
001C97r 3  2F C0 1F F3  
001CAFr 3  00 70 30 F8          .byte 0,112,48,248,49,248,9,248,11,240,199,252,195,227,3,224,3,240,1,246,129,253,193,253,14,248,8,112,56,0,56,0
001CB3r 3  31 F8 09 F8  
001CB7r 3  0B F0 C7 FC  
001CCFr 3  00 1C 0C 3E          .byte 0,28,12,62,12,126,2,126,2,252,49,255,240,248,0,248,0,252,128,125,96,127,112,127,3,190,2,28,14,0,14,0
001CD3r 3  0C 7E 02 7E  
001CD7r 3  02 FC 31 FF  
001CEFr 3  00 07 83 0F          .byte 0,7,131,15,131,31,128,159,0,191,204,127,60,62,0,62,0,63,96,31,216,31,220,31,128,239,0,135,3,128,3,128
001CF3r 3  83 1F 80 9F  
001CF7r 3  00 BF CC 7F  
001D0Fr 3  01 C0 03 E0          .byte 1,192,3,224,7,224,199,227,207,207,63,240,15,128,15,128,15,192,7,192,55,232,47,244,227,231,225,199,0,0,0,0
001D13r 3  07 E0 C7 E3  
001D17r 3  CF CF 3F F0  
001D2Fr 3  00 70 00 F8          .byte 0,112,0,248,1,248,241,248,243,243,15,252,3,224,3,224,3,240,1,240,13,250,11,253,248,249,248,113,0,0,0,0
001D33r 3  01 F8 F1 F8  
001D37r 3  F3 F3 0F FC  
001D4Fr 3  00 1C 00 3E          .byte 0,28,0,62,0,126,60,126,252,252,3,255,0,248,0,248,0,252,0,124,131,126,66,255,126,62,126,28,0,0,0,0
001D53r 3  00 7E 3C 7E  
001D57r 3  FC FC 03 FF  
001D6Fr 3  00 07 80 0F          .byte 0,7,128,15,128,31,143,31,63,63,192,255,0,62,0,62,0,63,0,31,160,223,208,191,159,143,31,135,0,0,0,0
001D73r 3  80 1F 8F 1F  
001D77r 3  3F 3F C0 FF  
001D8Fr 3  01 C0 03 E3          .byte 1,192,3,227,7,227,7,228,15,200,207,240,223,128,47,128,15,192,63,192,231,224,231,240,3,232,1,196,0,7,0,7
001D93r 3  07 E3 07 E4  
001D97r 3  0F C8 CF F0  
001DAFr 3  00 70 C0 F8          .byte 0,112,192,248,193,248,1,249,3,242,51,252,55,224,11,224,3,240,15,240,57,248,57,252,0,250,0,113,192,1,192,1
001DB3r 3  C1 F8 01 F9  
001DB7r 3  03 F2 33 FC  
001DCFr 3  00 1C 30 3E          .byte 0,28,48,62,48,126,64,126,128,252,12,255,13,248,2,248,0,252,3,252,14,126,14,127,128,62,64,28,112,0,112,0
001DD3r 3  30 7E 40 7E  
001DD7r 3  80 FC 0C FF  
001DEFr 3  00 07 8C 0F          .byte 0,7,140,15,140,31,144,31,32,63,195,63,3,126,0,190,0,63,0,255,131,159,195,159,160,15,16,7,28,0,28,0
001DF3r 3  8C 1F 90 1F  
001DF7r 3  20 3F C3 3F  
001E0Fr 3  01 C0 03 E0          .byte 1,192,3,224,7,224,199,227,207,207,63,240,15,128,15,128,15,192,7,192,55,232,47,244,227,231,225,199,0,0,0,0
001E13r 3  07 E0 C7 E3  
001E17r 3  CF CF 3F F0  
001E2Fr 3  00 70 00 F8          .byte 0,112,0,248,1,248,241,248,243,243,15,252,3,224,3,224,3,240,1,240,13,250,11,253,248,249,248,113,0,0,0,0
001E33r 3  01 F8 F1 F8  
001E37r 3  F3 F3 0F FC  
001E4Fr 3  00 1C 00 3E          .byte 0,28,0,62,0,126,60,126,252,252,3,255,0,248,0,248,0,252,0,124,131,126,66,255,126,62,126,28,0,0,0,0
001E53r 3  00 7E 3C 7E  
001E57r 3  FC FC 03 FF  
001E6Fr 3  00 07 80 0F          .byte 0,7,128,15,128,31,143,31,63,63,192,255,0,62,0,62,0,63,0,31,160,223,208,191,159,143,31,135,0,0,0,0
001E73r 3  80 1F 8F 1F  
001E77r 3  3F 3F C0 FF  
001E8Fr 3  1F F0 3F FC          .byte 31,240,63,252,95,254,79,62,110,31,76,159,253,127,215,255,83,255,127,223,47,30,138,184,160,96,234,224,255,224,127,192
001E93r 3  5F FE 4F 3E  
001E97r 3  6E 1F 4C 9F  
001EAFr 3  07 FC 0F FF          .byte 7,252,15,255,151,255,147,207,219,135,211,39,255,95,245,255,212,255,223,247,139,199,34,174,40,24,58,184,63,248,31,240
001EB3r 3  97 FF 93 CF  
001EB7r 3  DB 87 D3 27  
001ECFr 3  01 FF C3 FF          .byte 1,255,195,255,229,255,228,243,246,225,244,201,255,215,253,127,245,63,247,253,226,241,136,171,10,6,14,174,15,254,7,252
001ED3r 3  E5 FF E4 F3  
001ED7r 3  F6 E1 F4 C9  
001EEFr 3  C0 7F F0 FF          .byte 192,127,240,255,249,127,249,60,125,184,125,50,255,245,255,95,253,79,125,255,120,188,226,42,130,129,131,171,131,255,1,255
001EF3r 3  F9 7F F9 3C  
001EF7r 3  7D B8 7D 32  
001F0Fr 3  0F F8 3F FC          .byte 15,248,63,252,127,250,124,242,248,118,249,50,254,191,255,235,255,202,251,254,120,244,29,81,6,5,7,87,7,255,3,254
001F13r 3  7F FA 7C F2  
001F17r 3  F8 76 F9 32  
001F2Fr 3  03 FE 0F FF          .byte 3,254,15,255,159,254,159,60,190,29,190,76,255,175,255,250,191,242,190,255,30,61,71,84,65,129,193,213,193,255,128,255
001F33r 3  9F FE 9F 3C  
001F37r 3  BE 1D BE 4C  
001F4Fr 3  80 FF C3 FF          .byte 128,255,195,255,167,255,39,207,111,135,47,147,255,235,191,254,175,252,239,191,71,143,17,213,80,96,112,117,240,127,224,63
001F53r 3  A7 FF 27 CF  
001F57r 3  6F 87 2F 93  
001F6Fr 3  E0 3F F0 FF          .byte 224,63,240,255,233,255,201,243,219,225,203,228,255,250,175,255,43,255,251,239,209,227,68,117,20,24,92,29,252,31,248,15
001F73r 3  E9 FF C9 F3  
001F77r 3  DB E1 CB E4  
001F8Fr 3  01 80 07 E0          .byte 1,128,7,224,27,56,103,142,159,195,224,63,159,193,159,193,207,195,103,134,51,140,27,24,13,48,6,96,3,192,1,128
001F93r 3  1B 38 67 8E  
001F97r 3  9F C3 E0 3F  
001FAFr 3  00 60 01 F8          .byte 0,96,1,248,6,206,153,227,231,240,248,15,103,240,103,240,243,240,153,225,12,227,6,198,3,76,1,152,0,240,0,96
001FB3r 3  06 CE 99 E3  
001FB7r 3  E7 F0 F8 0F  
001FCFr 3  00 18 00 7E          .byte 0,24,0,126,129,179,230,120,57,252,254,3,25,252,25,252,60,252,102,120,195,56,129,177,0,211,0,102,0,60,0,24
001FD3r 3  81 B3 E6 78  
001FD7r 3  39 FC FE 03  
001FEFr 3  00 06 80 1F          .byte 0,6,128,31,224,108,57,158,14,127,255,128,6,127,6,127,15,63,25,158,48,206,96,108,192,52,128,25,0,15,0,6
001FF3r 3  E0 6C 39 9E  
001FF7r 3  0E 7F FF 80  
00200Fr 3               frmlst:
00200Fr 3  00 04                .byte 0,4
002011r 3  04 04                .byte 4,4
002013r 3  08 02                .byte 8,2
002015r 3  0A 01 0B 00          .byte 10,1,11,0
002019r 3               scdat:
002019r 3  D3 00 CE 00          .word 211,206,259,248
00201Dr 3  03 01 F8 00  
002021r 3  01 FF 00 14          .byte 1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,255,1,8,2,2,255,1,10,2,2
002025r 3  01 01 FF 00  
002029r 3  14 01 01 FF  
002043r 3  01 01 FF 00          .byte 1,1,255,0,6,2,2,255,0,10,2,2,1,1,255,0,6,2,2,255,0,10,2,2,1,1,2,2,255,1,11,2,2
002047r 3  06 02 02 FF  
00204Br 3  00 0A 02 02  
002064r 3  FF 01 07 02          .byte 255,1,7,2,2,255,0,11,2,2,255,0,5,1,1,2,2,255,0,11,2,2,255,0,5,255,1,4,2,2,255,1,13
002068r 3  02 FF 00 0B  
00206Cr 3  02 02 FF 00  
002085r 3  02 02 01 01          .byte 2,2,1,1,1,0,0,2,2,255,0,13,2,2,0,1,1,0,0,2,2,255,0,13,2,2,0,255,1,6,2,2,255,1,6
002089r 3  01 00 00 02  
00208Dr 3  02 FF 00 0D  
0020A8r 3  02 02 FF 01          .byte 2,2,255,1,8,255,0,4,2,2,255,0,6,2,2,255,0,6,1,1,255,0,4,2,2,255,0,6,2,2,255,0,6
0020ACr 3  08 FF 00 04  
0020B0r 3  02 02 FF 00  
0020C9r 3  FF 01 0A 02          .byte 255,1,10,2,2,255,1,7,2,2,1,1,1,255,0,8,2,2,255,0,7,2,2,0,1,1,255,0,8,2,2,255,0,7
0020CDr 3  02 FF 01 07  
0020D1r 3  02 02 01 01  
0020EBr 3  02 02 00 FF          .byte 2,2,0,255,1,23,255,0,22
0020EFr 3  01 17 FF 00  
0020F3r 3  16           
0020F4r 3  01 FF 00 14          .byte 1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,2,2,255,1,16,2,2
0020F8r 3  01 01 FF 00  
0020FCr 3  14 01 01 FF  
002115r 3  01 01 02 02          .byte 1,1,2,2,255,0,16,2,2,1,1,2,2,255,0,16,2,2,255,1,11,2,2,255,1,11,255,0,9,2,2,1,1,1
002119r 3  FF 00 10 02  
00211Dr 3  02 01 01 02  
002137r 3  FF 00 06 01          .byte 255,0,6,1,1,255,0,9,2,2,1,1,1,255,0,6,255,1,9,2,2,255,1,7,2,2,255,1,4,255,0,7,2,2
00213Br 3  01 FF 00 09  
00213Fr 3  02 02 01 01  
002159r 3  FF 00 07 02          .byte 255,0,7,2,2,0,0,1,1,255,0,7,2,2,255,0,7,2,2,0,0,255,1,5,2,2,255,1,7,2,2,255,1,8
00215Dr 3  02 00 00 01  
002161r 3  01 FF 00 07  
00217Br 3  00 00 00 02          .byte 0,0,0,2,2,255,0,7,2,2,255,0,6,1,1,0,0,0,2,2,255,0,7,2,2,255,0,6,255,1,8,2,2
00217Fr 3  02 FF 00 07  
002183r 3  02 02 FF 00  
00219Cr 3  FF 01 09 02          .byte 255,1,9,2,2,1,1,1,255,0,6,2,2,255,0,9,2,2,0,1,1,255,0,6,2,2,255,0,9,2,2,0,255,1,23
0021A0r 3  02 01 01 01  
0021A4r 3  FF 00 06 02  
0021BFr 3  FF 00 16             .byte 255,0,22
0021C2r 3  FF 01 04 FF          .byte 255,1,4,255,0,10,1,255,0,6,255,1,5,255,0,10,1,255,0,6,255,1,5,255,0,10,1,255,0,6,255,1,9
0021C6r 3  00 0A 01 FF  
0021CAr 3  00 06 FF 01  
0021E3r 3  02 02 FF 01          .byte 2,2,255,1,9,2,2,1,1,255,0,7,2,2,255,0,8,1,2,2,1,1,255,0,7,2,2,255,0,8,1,2,2
0021E7r 3  09 02 02 01  
0021EBr 3  01 FF 00 07  
002204r 3  FF 01 04 02          .byte 255,1,4,2,2,255,1,8,2,2,255,1,4,2,2,1,1,0,0,2,2,255,0,8,2,2,255,0,4,2,2,1,1
002208r 3  02 FF 01 08  
00220Cr 3  02 02 FF 01  
002225r 3  00 00 02 02          .byte 0,0,2,2,255,0,8,2,2,255,0,4,2,2,255,1,8,2,2,255,1,14,255,0,6,2,2,255,0,12,1,1,255,0,6
002229r 3  FF 00 08 02  
00222Dr 3  02 FF 00 04  
002248r 3  02 02 FF 00          .byte 2,2,255,0,12,255,1,5,2,2,255,1,9,2,2,255,1,6,0,0,0,2,2,255,0,9,2,2,255,0,4,1,1
00224Cr 3  0C FF 01 05  
002250r 3  02 02 FF 01  
002269r 3  00 00 00 02          .byte 0,0,0,2,2,255,0,9,2,2,255,0,4,1,1,2,2,255,1,16,2,2,1,1,2,2,255,0,16,2,2,1,1
00226Dr 3  02 FF 00 09  
002271r 3  02 02 FF 00  
00228Ar 3  02 02 FF 00          .byte 2,2,255,0,16,2,2,255,1,6,2,2,255,1,8,2,2,255,1,6,255,0,4,2,2,255,0,4,1,0,0,0,2,2
00228Er 3  10 02 02 FF  
002292r 3  01 06 02 02  
0022ACr 3  FF 00 04 01          .byte 255,0,4,1,1,255,0,4,2,2,255,0,4,1,0,0,0,2,2,255,0,4,255,1,23
0022B0r 3  01 FF 00 04  
0022B4r 3  02 02 FF 00  
0022C5r 3  FF 01 0B FF          .byte 255,1,11,255,0,20,1,1,255,0,20,1,1,255,0,20,255,1,12,2,2,1,2,2,255,1,7,255,0,10,2,2,1
0022C9r 3  00 14 01 01  
0022CDr 3  FF 00 14 01  
0022E6r 3  02 02 FF 00          .byte 2,2,255,0,5,1,1,255,0,10,2,2,1,2,2,255,0,5,255,1,6,2,2,255,1,10,2,2,255,1,4,255,0,4
0022EAr 3  05 01 01 FF  
0022EEr 3  00 0A 02 02  
002308r 3  02 02 FF 00          .byte 2,2,255,0,10,2,2,0,0,1,1,255,0,4,2,2,255,0,10,2,2,0,0,255,1,15,2,2,255,1,7,255,0,6
00230Cr 3  0A 02 02 00  
002310r 3  00 01 01 FF  
00232Ar 3  01 FF 00 06          .byte 1,255,0,6,2,2,255,0,5,1,1,255,0,6,1,255,0,6,2,2,255,0,5,255,1,6,2,2,1,1,2,2,255,1,8
00232Er 3  02 02 FF 00  
002332r 3  05 01 01 FF  
00234Dr 3  02 02 01 01          .byte 2,2,1,1,255,0,4,2,2,0,0,2,2,255,0,8,2,2,1,1,255,0,4,2,2,0,0,2,2,255,0,8,2,2
002351r 3  FF 00 04 02  
002355r 3  02 00 00 02  
00236Fr 3  01 01 02 02          .byte 1,1,2,2,255,1,11,2,2,255,1,7,2,2,255,0,11,2,2,1,255,0,4,1,1,2,2,255,0,11,2,2,1
002373r 3  FF 01 0B 02  
002377r 3  02 FF 01 07  
002390r 3  FF 00 04 FF          .byte 255,0,4,255,1,5,2,2,255,1,11,2,2,255,1,4,0,0,0,2,2,255,0,11,2,2,0,0,1,1,0,0,0
002394r 3  01 05 02 02  
002398r 3  FF 01 0B 02  
0023B1r 3  02 02 FF 00          .byte 2,2,255,0,11,2,2,0,0,255,1,13
0023B5r 3  0B 02 02 00  
0023B9r 3  00 FF 01 0D  
0023BDr 3               numsc:
0023BDr 3  04                   .byte 4
0023BEr 3               nmedat:
0023BEr 3  00 00 60 78          .byte 0,0,96,120,1,2,120,16,2,3,144,16,2,3,48,80,2,3,72,152,2,3,24,16,255
0023C2r 3  01 02 78 10  
0023C6r 3  02 03 90 10  
0023D7r 3  00 00 48 40          .byte 0,0,72,64,1,2,120,16,1,2,24,16,2,3,24,80,2,3,48,112,2,3,72,128,2,3,120,88,255
0023DBr 3  01 02 78 10  
0023DFr 3  01 02 18 10  
0023F4r 3  00 00 38 88          .byte 0,0,56,136,1,2,32,56,1,2,104,64,2,3,8,40,2,3,8,128,2,3,80,152,2,3,124,88,2,3,152,16,2,3,152,160,255
0023F8r 3  01 02 20 38  
0023FCr 3  01 02 68 40  
002419r 3  00 00 98 10          .byte 0,0,152,16,1,2,8,104,1,2,56,80,1,2,104,112,2,3,8,16,2,3,80,16,2,3,124,160,2,3,8,152,2,3,56,24,255
00241Dr 3  01 02 08 68  
002421r 3  01 02 38 50  
00243Er 3               NUMOBJ = 1
00243Er 3               objdta:
00243Er 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,254,56,120,254,56,120
002442r 3  00 00 00 00  
002446r 3  00 00 00 00  
002465r 3               font:
002465r 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
002469r 3  00 00 00 00  
00246Dr 3  00 30 30 30          .byte 0,48,48,48,48,0,48,0
002471r 3  30 00 30 00  
002475r 3  00 6C 6C 00          .byte 0,108,108,0,0,0,0,0
002479r 3  00 00 00 00  
00247Dr 3  00 6C FE 6C          .byte 0,108,254,108,108,254,108,0
002481r 3  6C FE 6C 00  
002485r 3  00 18 7E 78          .byte 0,24,126,120,126,30,126,24
002489r 3  7E 1E 7E 18  
00248Dr 3  00 E6 EC 18          .byte 0,230,236,24,48,110,206,0
002491r 3  30 6E CE 00  
002495r 3  00 30 78 30          .byte 0,48,120,48,126,204,126,0
002499r 3  7E CC 7E 00  
00249Dr 3  00 18 30 00          .byte 0,24,48,0,0,0,0,0
0024A1r 3  00 00 00 00  
0024A5r 3  00 0C 18 18          .byte 0,12,24,24,24,24,12,0
0024A9r 3  18 18 0C 00  
0024ADr 3  00 60 30 30          .byte 0,96,48,48,48,48,96,0
0024B1r 3  30 30 60 00  
0024B5r 3  00 00 3C 18          .byte 0,0,60,24,126,24,60,0
0024B9r 3  7E 18 3C 00  
0024BDr 3  00 00 18 18          .byte 0,0,24,24,126,24,24,0
0024C1r 3  7E 18 18 00  
0024C5r 3  00 00 00 00          .byte 0,0,0,0,0,24,24,48
0024C9r 3  00 18 18 30  
0024CDr 3  00 00 00 00          .byte 0,0,0,0,126,0,0,0
0024D1r 3  7E 00 00 00  
0024D5r 3  00 00 00 00          .byte 0,0,0,0,0,56,56,0
0024D9r 3  00 38 38 00  
0024DDr 3  00 00 06 0C          .byte 0,0,6,12,24,48,96,0
0024E1r 3  18 30 60 00  
0024E5r 3  00 7C CE DE          .byte 0,124,206,222,246,230,124,0
0024E9r 3  F6 E6 7C 00  
0024EDr 3  00 38 78 18          .byte 0,56,120,24,24,24,126,0
0024F1r 3  18 18 7E 00  
0024F5r 3  00 7C C6 06          .byte 0,124,198,6,124,192,254,0
0024F9r 3  7C C0 FE 00  
0024FDr 3  00 7C C6 1C          .byte 0,124,198,28,6,198,124,0
002501r 3  06 C6 7C 00  
002505r 3  00 18 38 78          .byte 0,24,56,120,216,254,24,0
002509r 3  D8 FE 18 00  
00250Dr 3  00 FE C0 FC          .byte 0,254,192,252,6,198,124,0
002511r 3  06 C6 7C 00  
002515r 3  00 7C C0 FC          .byte 0,124,192,252,198,198,124,0
002519r 3  C6 C6 7C 00  
00251Dr 3  00 FE 06 0C          .byte 0,254,6,12,24,48,48,0
002521r 3  18 30 30 00  
002525r 3  00 7C C6 7C          .byte 0,124,198,124,198,198,124,0
002529r 3  C6 C6 7C 00  
00252Dr 3  00 7C C6 C6          .byte 0,124,198,198,126,6,124,0
002531r 3  7E 06 7C 00  
002535r 3  00 00 00 30          .byte 0,0,0,48,0,0,48,0
002539r 3  00 00 30 00  
00253Dr 3  00 00 30 00          .byte 0,0,48,0,0,48,48,96
002541r 3  00 30 30 60  
002545r 3  00 00 0C 18          .byte 0,0,12,24,48,24,12,0
002549r 3  30 18 0C 00  
00254Dr 3  00 00 00 7E          .byte 0,0,0,126,0,126,0,0
002551r 3  00 7E 00 00  
002555r 3  00 00 30 18          .byte 0,0,48,24,12,24,48,0
002559r 3  0C 18 30 00  
00255Dr 3  00 7C C6 0C          .byte 0,124,198,12,24,0,24,0
002561r 3  18 00 18 00  
002565r 3  00 7C DE FE          .byte 0,124,222,254,254,192,124,0
002569r 3  FE C0 7C 00  
00256Dr 3  00 7C C6 C6          .byte 0,124,198,198,254,198,198,0
002571r 3  FE C6 C6 00  
002575r 3  00 FC C6 FC          .byte 0,252,198,252,198,198,252,0
002579r 3  C6 C6 FC 00  
00257Dr 3  00 7C C6 C0          .byte 0,124,198,192,192,198,124,0
002581r 3  C0 C6 7C 00  
002585r 3  00 F8 CC C6          .byte 0,248,204,198,198,204,248,0
002589r 3  C6 CC F8 00  
00258Dr 3  00 FE C0 FC          .byte 0,254,192,252,192,192,254,0
002591r 3  C0 C0 FE 00  
002595r 3  00 FE C0 FC          .byte 0,254,192,252,192,192,192,0
002599r 3  C0 C0 C0 00  
00259Dr 3  00 7C C6 C0          .byte 0,124,198,192,222,198,124,0
0025A1r 3  DE C6 7C 00  
0025A5r 3  00 C6 C6 FE          .byte 0,198,198,254,198,198,198,0
0025A9r 3  C6 C6 C6 00  
0025ADr 3  00 7E 18 18          .byte 0,126,24,24,24,24,126,0
0025B1r 3  18 18 7E 00  
0025B5r 3  00 06 06 06          .byte 0,6,6,6,198,198,124,0
0025B9r 3  C6 C6 7C 00  
0025BDr 3  00 CC D8 F0          .byte 0,204,216,240,216,204,198,0
0025C1r 3  D8 CC C6 00  
0025C5r 3  00 C0 C0 C0          .byte 0,192,192,192,192,192,254,0
0025C9r 3  C0 C0 FE 00  
0025CDr 3  00 C6 EE FE          .byte 0,198,238,254,198,198,198,0
0025D1r 3  C6 C6 C6 00  
0025D5r 3  00 C6 E6 F6          .byte 0,198,230,246,222,206,198,0
0025D9r 3  DE CE C6 00  
0025DDr 3  00 7C C6 C6          .byte 0,124,198,198,198,198,124,0
0025E1r 3  C6 C6 7C 00  
0025E5r 3  00 FC C6 C6          .byte 0,252,198,198,252,192,192,0
0025E9r 3  FC C0 C0 00  
0025EDr 3  00 7C C6 C6          .byte 0,124,198,198,246,222,124,0
0025F1r 3  F6 DE 7C 00  
0025F5r 3  00 FC C6 C6          .byte 0,252,198,198,252,204,198,0
0025F9r 3  FC CC C6 00  
0025FDr 3  00 7C C0 7C          .byte 0,124,192,124,6,198,124,0
002601r 3  06 C6 7C 00  
002605r 3  00 FE 30 30          .byte 0,254,48,48,48,48,48,0
002609r 3  30 30 30 00  
00260Dr 3  00 C6 C6 C6          .byte 0,198,198,198,198,198,124,0
002611r 3  C6 C6 7C 00  
002615r 3  00 C6 C6 C6          .byte 0,198,198,198,198,108,56,0
002619r 3  C6 6C 38 00  
00261Dr 3  00 C6 C6 C6          .byte 0,198,198,198,198,254,108,0
002621r 3  C6 FE 6C 00  
002625r 3  00 C6 6C 38          .byte 0,198,108,56,56,108,198,0
002629r 3  38 6C C6 00  
00262Dr 3  00 86 CC 78          .byte 0,134,204,120,48,48,48,0
002631r 3  30 30 30 00  
002635r 3  00 FE 0C 18          .byte 0,254,12,24,48,96,254,0
002639r 3  30 60 FE 00  
00263Dr 3  00 1E 18 18          .byte 0,30,24,24,24,24,30,0
002641r 3  18 18 1E 00  
002645r 3  00 00 C0 60          .byte 0,0,192,96,48,24,12,0
002649r 3  30 18 0C 00  
00264Dr 3  00 F0 30 30          .byte 0,240,48,48,48,48,240,0
002651r 3  30 30 F0 00  
002655r 3  00 30 78 FC          .byte 0,48,120,252,48,48,48,0
002659r 3  30 30 30 00  
00265Dr 3  00 00 00 00          .byte 0,0,0,0,0,0,0,255
002661r 3  00 00 00 FF  
002665r 3  00 3C 66 F8          .byte 0,60,102,248,96,96,254,0
002669r 3  60 60 FE 00  
00266Dr 3  00 00 78 0C          .byte 0,0,120,12,124,204,124,0
002671r 3  7C CC 7C 00  
002675r 3  00 60 60 7C          .byte 0,96,96,124,102,102,124,0
002679r 3  66 66 7C 00  
00267Dr 3  00 00 3C 60          .byte 0,0,60,96,96,96,60,0
002681r 3  60 60 3C 00  
002685r 3  00 0C 0C 7C          .byte 0,12,12,124,204,204,124,0
002689r 3  CC CC 7C 00  
00268Dr 3  00 00 78 CC          .byte 0,0,120,204,248,192,124,0
002691r 3  F8 C0 7C 00  
002695r 3  00 1C 30 38          .byte 0,28,48,56,48,48,48,0
002699r 3  30 30 30 00  
00269Dr 3  00 00 7C CC          .byte 0,0,124,204,204,124,12,120
0026A1r 3  CC 7C 0C 78  
0026A5r 3  00 C0 C0 F8          .byte 0,192,192,248,204,204,204,0
0026A9r 3  CC CC CC 00  
0026ADr 3  00 30 00 70          .byte 0,48,0,112,48,48,120,0
0026B1r 3  30 30 78 00  
0026B5r 3  00 0C 00 0C          .byte 0,12,0,12,12,12,108,56
0026B9r 3  0C 0C 6C 38  
0026BDr 3  00 60 78 70          .byte 0,96,120,112,112,120,108,0
0026C1r 3  70 78 6C 00  
0026C5r 3  00 30 30 30          .byte 0,48,48,48,48,48,28,0
0026C9r 3  30 30 1C 00  
0026CDr 3  00 00 F8 FC          .byte 0,0,248,252,252,252,252,0
0026D1r 3  FC FC FC 00  
0026D5r 3  00 00 F8 CC          .byte 0,0,248,204,204,204,204,0
0026D9r 3  CC CC CC 00  
0026DDr 3  00 00 78 CC          .byte 0,0,120,204,204,204,120,0
0026E1r 3  CC CC 78 00  
0026E5r 3  00 00 F8 CC          .byte 0,0,248,204,204,248,192,192
0026E9r 3  CC F8 C0 C0  
0026EDr 3  00 00 7C CC          .byte 0,0,124,204,204,124,12,14
0026F1r 3  CC 7C 0C 0E  
0026F5r 3  00 00 3C 60          .byte 0,0,60,96,96,96,96,0
0026F9r 3  60 60 60 00  
0026FDr 3  00 00 78 C0          .byte 0,0,120,192,120,12,248,0
002701r 3  78 0C F8 00  
002705r 3  00 30 78 30          .byte 0,48,120,48,48,48,28,0
002709r 3  30 30 1C 00  
00270Dr 3  00 00 CC CC          .byte 0,0,204,204,204,204,120,0
002711r 3  CC CC 78 00  
002715r 3  00 00 CC CC          .byte 0,0,204,204,120,120,48,0
002719r 3  78 78 30 00  
00271Dr 3  00 00 CC FC          .byte 0,0,204,252,252,252,120,0
002721r 3  FC FC 78 00  
002725r 3  00 00 CC 78          .byte 0,0,204,120,48,120,204,0
002729r 3  30 78 CC 00  
00272Dr 3  00 00 CC CC          .byte 0,0,204,204,204,124,12,120
002731r 3  CC 7C 0C 78  
002735r 3  00 00 FC 18          .byte 0,0,252,24,48,96,252,0
002739r 3  30 60 FC 00  
00273Dr 3  00 1E 18 70          .byte 0,30,24,112,24,24,30,0
002741r 3  18 18 1E 00  
002745r 3  00 18 18 18          .byte 0,24,24,24,24,24,24,0
002749r 3  18 18 18 00  
00274Dr 3  00 F0 30 1C          .byte 0,240,48,28,48,48,240,0
002751r 3  30 30 F0 00  
002755r 3  00 3C 78 00          .byte 0,60,120,0,0,0,0,0
002759r 3  00 00 00 00  
00275Dr 3  7C C6 BB E3          .byte 124,198,187,227,227,187,198,124
002761r 3  E3 BB C6 7C  
002765r 3               jtab:
002765r 3  63                   .byte 99
002766r 3  65 14 51 10  keys:   .byte 101,20,81,16,48,68,52,112,0,113,1
00276Ar 3  30 44 34 70  
00276Er 3  00 71 01     
002771r 3               
002771r 2               
002771r 1               	.include "lib.inc"
002771r 2               ;----------------------------------------------------------------------
002771r 2               ; VIC20 Platform Specific functions
002771r 2               ;----------------------------------------------------------------------
002771r 2               
002771r 2               ;============================================================
002771r 2               ; PLATFORM VARIABLES
002771r 2               ;============================================================
002771r 2               ;
002771r 2               ; Memory map:
002771r 2               ;
002771r 2               ;	$0000-$01ff	 0.5kB	CPU WS
002771r 2               ;	$0200-$03ff	 0.5kB	VIDEO RAM
002771r 2               ;	$0400-$0fff	 3,0kB	RAM
002771r 2               ;	$1000-$1fff	 4,0kB	CHAR RAM
002771r 2               ;	$2000-$7fff	24,0kB	RAM
002771r 2               ;	$8000-$8fff	 4,0kB	CHAR ROM
002771r 2               ;	$9000-$93ff	 1,0kB	VIC VIA's
002771r 2               ;	$9600-$97ff	 1,0kB	COLOUR RAM
002771r 2               ;	$9800-$9fff	 2,0kB	I/O
002771r 2               ;	$a000-$bfff	 8,0kB	RAM
002771r 2               ;	$c000-$dfff	 8,0kB	BASIC ROM
002771r 2               ;	$e000-$ffff	 8,0kB	KERNAL ROM
002771r 2               ;
002771r 2               ; Keyboard matrix:
002771r 2               ;                          	  $9121
002771r 2               ;          $9120	b7  b6  b5  b4  b3  b2  b1  b0
002771r 2               ; 	127-0111 1111 	F7  Hom  -   0   8   6   4   2
002771r 2               ;               ASCII   ??  ??  45  48  56  54  52  50
002771r 2               ;                 VIC   07  06  05  04  03  02  01  00
002771r 2               ;
002771r 2               ; 	191-1011 1111 	F5       @   O   U   T   E   Q
002771r 2               ;               ASCII   ??  ??  64  79  85  84  69  81
002771r 2               ;                 VIC   17  16  15  14  13  12  11  10
002771r 2               ;
002771r 2               ; 	223-1101 1111 	F3   =   :   K   H   F   S  Com
002771r 2               ;               ASCII   ??  61  58  75  72  70  83  ??
002771r 2               ;                 VIC   27  26  25  24  23  22  21  20
002771r 2               ;
002771r 2               ; 	239-1110 1111 	F1  RSh  .   M   B   C   Z  Spc
002771r 2               ;               ASCII   ??  ??  46  77  66  67  90  32
002771r 2               ;                 VIC   37  36  35  34  33  32  31  30
002771r 2               ;
002771r 2               ; 	247-1111 0111	Cur  /   ,   N   V   X  LSh Run
002771r 2               ;               ASCII   ??  47  44  78  86  88  ??  ??
002771r 2               ;                 VIC   47  46  45  44  43  42  41  40
002771r 2               ;
002771r 2               ; 	251-1111 1011	Cur  ;   L   J   G   D   A  Ctr
002771r 2               ;               ASCII   ??  59  76  74  71  68  65  ??
002771r 2               ;                 VIC   57  56  55  54  53  52  51  50
002771r 2               ;
002771r 2               ; 	253-1111 1101	Ret  *   P   I   Y   R   W
002771r 2               ;               ASCII   13  42  80  73  89  82  87
002771r 2               ;                 VIC   67  66  65  64  63  62  61  60
002771r 2               ;
002771r 2               ; 	254-1111 1110	Del Pnd  +   9   7   5   3   1
002771r 2               ;               ASCII   08  ??  43  57  55  53  51  49
002771r 2               ;                 VIC   77  76  75  74  73  72  71  70
002771r 2               ;
002771r 2               ;	 P =$65,O=$14,A=$51,Q=$10
002771r 2               ;	SPC=$30,N=$44,M=$34
002771r 2               ;	 1 =$70,2=$00,3=$71,4=$01
002771r 2               ;
002771r 2               ; Joysticks:
002771r 2               ;
002771r 2               ;               b7    b6    b5    b4    b3    b2    b1    b0
002771r 2               ;	$9111	-     -     Fire  Left  Down  Up    -     -
002771r 2               ;	$9120	Right -     -     -     -     -     -     -
002771r 2               ;
002771r 2               ;	$9122	DDRB = Data Direction Register port $9120
002771r 2               ;               0 = input, 1 = output
002771r 2               ;		Bit7 should be 0 to read joystick $9120
002771r 2               ;
002771r 2               ; Video registers:
002771r 2               ;
002771r 2               ;	$9000	horizontal centering
002771r 2               ;		bits 0-6 horizontal centering
002771r 2               ;		bit  7 sets interlace scan
002771r 2               ;	$9001	vertical centering
002771r 2               ;	$9002	set # of columns
002771r 2               ;		bits 0-6 set # of columns
002771r 2               ;		bit 7 is part of video matrix address
002771r 2               ;	$9003	set # of rows
002771r 2               ;		bit 0 sets 8x8 or 16x8 chars
002771r 2               ;		bits 1-6 set # of rows
002771r 2               ;	$9004	TV raster beam line
002771r 2               ;	$9005	start of character memory
002771r 2               ;		bits 0-3 start of character memory (default = 0)
002771r 2               ;		bits 4-7 is rest of video address (default= F)
002771r 2               ;		BITS 3,2,1,0 CM startinq address
002771r 2               ;			     HEX   DEC
002771r 2               ;		0000   ROM   8000  32768
002771r 2               ;		0001	     8400  33792
002771r 2               ;		0010	     8800  34816
002771r 2               ;		0011	     8C00  35840
002771r 2               ;		1000   RAM   0000  0000
002771r 2               ;		1001  xxxx
002771r 2               ;		1010  xxxx   unavail.
002771r 2               ;		1011  xxxx
002771r 2               ;		1100	     1000  4096
002771r 2               ;		1101	     1400  5120
002771r 2               ;		1110	     1800  6144
002771r 2               ;		1111	     1C00  7168
002771r 2               ;
002771r 2               ; Sound registers:
002771r 2               ;
002771r 2               ;	$900a	Frequency for oscillator 1 (low)
002771r 2               ;		(on: 128-255)
002771r 2               ;	$900b	Frequency for oscillator 2 (medium)
002771r 2               ;		(on: 128-255)
002771r 2               ;	$900c	Frequency for oscillator 3 (high)
002771r 2               ;		(on: 128-255)
002771r 2               ;	$900d	Frequency of noise source
002771r 2               ;	$900e	bit 0-3 sets volume of all sound
002771r 2               ;		bits 4-7 are auxiliary color information
002771r 2               ;	$900f	Screen and border color register
002771r 2               ;		bits 4-7 select background color
002771r 2               ;		bits 0-2 select border color
002771r 2               ;		bit 3 selects inverted or normal mode
002771r 2               ;
002771r 2               ; I/O:
002771r 2               ;	VIA1 -VIA2
002771r 2               ;-----------------------------------------------------------
002771r 2               ;	$9110,$9120 	Port B output register
002771r 2               ;	$9111,$9121 	Port A output register
002771r 2               ;			(PA0) Bit 0=Serial CLK IN
002771r 2               ;			(PA1) Bit 1=Serial DATA IN
002771r 2               ;			(PA2) Bit 2=Joy 0
002771r 2               ;			(PA3) Bit 3=Joy 1
002771r 2               ;			(PA4) Bit 4=Joy 2
002771r 2               ;			(PA5) Bit 5 = Lightpen/Fire button
002771r 2               ;			(PA6) Bit 6=Cassette switch sense
002771r 2               ;			(PA7) Bit 7=Serial ATN out
002771r 2               ;	$9112,$9122	Data direction register B
002771r 2               ;	$9113,$9123	Data direction register A
002771r 2               ;	$9114,$9124	Timer 1 low byte
002771r 2               ;	$9115,$9125	Timer 1 high byte & counter
002771r 2               ;	$9116,$9126	Timer 1 low byte
002771r 2               ;	$9117,$9127	Timer 1 high byte
002771r 2               ;	$9118,$9128	Timer 2 low byte
002771r 2               ;	$9119,$9129	Timer 2 high byte
002771r 2               ;	$911A,$912A	Shift register
002771r 2               ;	$911B,$912B	Auxiliary control register
002771r 2               ;	$911C,$912C	Peripheral control register
002771r 2               ;			(CA1, CA2, CB1, CB2)
002771r 2               ;			CA1 = restore key (Bit 0)
002771r 2               ;			CA2 = cassette motor control (Bits 1-3)
002771r 2               ;			CB1 = interrupt signal for received
002771r 2               ;			RS-232 data (Bit 4)
002771r 2               ;			CB2=transmitted RS-232 data (Bits 5-7)
002771r 2               ;	$911D,$912D	Interrupt flag register
002771r 2               ;	$911E,$912E	Interrupt enable register
002771r 2               ;	$911F,$912F	Port A (Sense cassette switch)
002771r 2               
002771r 2               ; VIC constants
002771r 2               
002771r 2               	ScreenSize	= ScrWidth * ScrHeight * 8	; Screen size bytes
002771r 2               	ScreenRowBytes	= ScrWidth * 16			; bytes/line
002771r 2               	SpriteMaxY	= 161				; maxlines - 16 + 1
002771r 2               
002771r 2               ; VIC variables:
002771r 2               
002771r 2  00           	fontcol:	.byte 0		; Frontcolour text
002772r 2  00           	mode:		.byte 0		; 0=MPAGD, 1=MiniPaint
002773r 2               .if modelflag				; Set crtflag to identify machine, NTSC or PAL
002773r 2               	crtflag:	.byte 1		; PAL
002773r 2               .else
002773r 2  00           	crtflag:	.byte 0		; NTSC
002774r 2               .endif
002774r 2               
002774r 2               ; Addresses
002774r 2               
002774r 2               	ScreenAddr	= $0200		; VIDEO RAM
002774r 2               	MapAddr		= $0400		; RAM
002774r 2               	CharAddress	= $1000		; CHAR RAM
002774r 2               	Reg0		= $9000		; Horizontal centering
002774r 2               	Reg1		= $9001		; Vertical centering
002774r 2               	Reg2		= $9002		; Set # of columns
002774r 2               	Reg3		= $9003		; Set # of rows
002774r 2               	Reg4		= $9004		; Vsync signal
002774r 2               	Reg5		= $9005		; Start of character memory
002774r 2               	RegA		= $900a		; Colour and auxcolour register
002774r 2               	RegB		= $900b		; Colour and auxcolour register
002774r 2               	RegC		= $900c		; Colour and auxcolour register
002774r 2               	RegD		= $900d		; Colour and auxcolour register
002774r 2               	RegE		= $900e		; Colour and auxcolour register
002774r 2               	RegF		= $900f		; Screen and border color register
002774r 2               
002774r 2               	JoyAddr1	= $9111		; Joystick address 1
002774r 2               	Timer11_Low  	= $9114		; Timer 1 low byte
002774r 2               	Timer11_High 	= $9115		; Timer 1 high byte
002774r 2               	Timer12_Low  	= $9118		; Timer 2 low byte
002774r 2               	Timer12_High 	= $9119		; Timer 2 high byte
002774r 2               	AUX1		= $911b		; Auxiliary control register
002774r 2               	IFR1		= $911d		; Interrupt Flag Register
002774r 2               	IER1		= $911e		; Interrupt Enable Register
002774r 2               
002774r 2               	KeyColAddr	= $9120		; Keyboard column (write)
002774r 2               	JoyAddr2	= $9120		; Joystick address 2
002774r 2               	KeyRowAddr	= $9121		; Keyboard row (read)
002774r 2               	DDRB		= $9122		; Bit7 must be 0 for joystick read
002774r 2               	Timer21_Low  	= $9124		; Timer 1 low byte
002774r 2               	Timer21_High 	= $9125		; Timer 1 high byte
002774r 2               	AUX2		= $912b		; Auxiliary control register
002774r 2               	IFR2		= $912d		; Interrupt Flag Register
002774r 2               	IER2		= $912e		; Interrupt Enable Register
002774r 2               
002774r 2               	ColorAttr	= $9600		; Color attributes
002774r 2               	HiRAM		= $a000		; Hi RAM 8kB
002774r 2               
002774r 2               ;----------------------------------------------------------------------
002774r 2               ; VIC20 video hardware fns
002774r 2               ;----------------------------------------------------------------------
002774r 2               
002774r 2               init:
002774r 2               
002774r 2               ; Disable interrupts
002774r 2               
002774r 2  A9 7F        	lda #$7f
002776r 2  8D 1E 91     	sta IER1
002779r 2  8D 2D 91     	sta IFR2
00277Cr 2  8D 2E 91     	sta IER2
00277Fr 2               
00277Fr 2               ; Set audio volume and flag to 0 to check when disabling
00277Fr 2               ; beep and crash
00277Fr 2               
00277Fr 2  A9 00        	lda #0
002781r 2  8D 0A 90     	sta RegA
002784r 2  8D 0B 90     	sta RegB
002787r 2  8D 0C 90     	sta RegC
00278Ar 2  8D 0D 90     	sta RegD
00278Dr 2  A9 00        	lda #$00
00278Fr 2  85 rr        	sta SOUNDS_STATUS
002791r 2               
002791r 2  AD 0E 90     	lda RegE
002794r 2  09 0F        	ora #$0f		; Set volume max
002796r 2  8D 0E 90     	sta RegE
002799r 2               
002799r 2               ; Init screen for NTSC
002799r 2               ; this sets the background and border color of the screen
002799r 2               ; in this case border black and background black
002799r 2               
002799r 2  A9 18        	lda #%00011000
00279Br 2  8D 0F 90     	sta RegF
00279Er 2               
00279Er 2               ; Reset fontcolor
00279Er 2  A9 00        	lda #0		; Black
0027A0r 2  8D rr rr     	sta fontcol
0027A3r 2               
0027A3r 2               
0027A3r 2  A9 00        	lda #0		; Mode 0 = MPAGD
0027A5r 2  20 rr rr     	jsr SetReg
0027A8r 2               
0027A8r 2               ; Init screencharacters
0027A8r 2               ; Fill screen with characters from left to right, up to down
0027A8r 2               
0027A8r 2  A2 00        	ldx #0
0027AAr 2  A0 00        	ldy #0
0027ACr 2               scrinit:
0027ACr 2  8A           	txa
0027ADr 2  9D 00 02     	sta ScreenAddr,x
0027B0r 2  98           	tya
0027B1r 2  9D 00 96     	sta ColorAttr,x
0027B4r 2  E8           	inx
0027B5r 2  E0 F2        	cpx#242
0027B7r 2  D0 F3        	bne scrinit
0027B9r 2               
0027B9r 2               ; Reset fontcolor
0027B9r 2               
0027B9r 2  A9 00        	lda #0			; Black
0027BBr 2  8D rr rr     	sta fontcol
0027BEr 2               
0027BEr 2               ; Init music
0027BEr 2               
0027BEr 2               ;	jsr initmusic
0027BEr 2               
0027BEr 2               ; Init VIA1 timer11 for timeout 1/25 sec
0027BEr 2               
0027BEr 2  A9 E0        	lda #$e0		; T1 continuous
0027C0r 2  8D 1B 91     	sta AUX1
0027C3r 2  A9 7F        	lda #$7f		; No int
0027C5r 2  8D 1E 91     	sta IER1
0027C8r 2  A9 00        	lda #0
0027CAr 2  8D 1D 91     	sta IFR1		; Clear interrupt flags
0027CDr 2  A9 20        	lda #<timervalue	; Timer 1/25 sec
0027CFr 2  8D 14 91     	sta Timer11_Low
0027D2r 2  A9 4E        	lda #>timervalue
0027D4r 2  8D 15 91     	sta Timer11_High
0027D7r 2               
0027D7r 2               ; Pre-shifted byte tables if parameter 'r' given
0027D7r 2               ; 4 tables are created which 0,2,4 ad 6 bits pre-shifted
0027D7r 2               ; The bits are shifted to the right and overflow bits are
0027D7r 2               ; inserted to the left. So 1 byte contains a left and right part
0027D7r 2               
0027D7r 2               .if rflag
0027D7r 2               shift0 = HiRAM
0027D7r 2               shift2 = HiRAM+256
0027D7r 2               shift4 = HiRAM+512
0027D7r 2               shift6 = HiRAM+768
0027D7r 2               
0027D7r 2               ; Pre-shifted table 0 pixels
0027D7r 2               
0027D7r 2               	ldx #0
0027D7r 2               shf0:
0027D7r 2               	txa
0027D7r 2               	sta shift0,x
0027D7r 2               	inx
0027D7r 2               	bne shf0
0027D7r 2               
0027D7r 2               ; Pre-shifted table 2 pixels
0027D7r 2               
0027D7r 2               	ldx #0
0027D7r 2               shf2:
0027D7r 2               	ldy #2
0027D7r 2               	txa
0027D7r 2               shf2loop:
0027D7r 2               	lsr a
0027D7r 2               	bcc :+
0027D7r 2               	ora #$80
0027D7r 2               :
0027D7r 2               	dey
0027D7r 2               	bne shf2loop
0027D7r 2               	sta shift2,x
0027D7r 2               	inx
0027D7r 2               	bne shf2
0027D7r 2               
0027D7r 2               ; Pre-shifted table 4 pixels
0027D7r 2               
0027D7r 2               	ldx #0
0027D7r 2               shf4:
0027D7r 2               	ldy #4
0027D7r 2               	txa
0027D7r 2               shf4loop:
0027D7r 2               	lsr a
0027D7r 2               	bcc :+
0027D7r 2               	ora #$80
0027D7r 2               :
0027D7r 2               	dey
0027D7r 2               	bne shf4loop
0027D7r 2               	sta shift4,x
0027D7r 2               	inx
0027D7r 2               	bne shf4
0027D7r 2               
0027D7r 2               ; Pre-shifted table 6 pixels
0027D7r 2               
0027D7r 2               	ldx #0
0027D7r 2               shf6:
0027D7r 2               	ldy #6
0027D7r 2               	txa
0027D7r 2               shf6loop:
0027D7r 2               	lsr a
0027D7r 2               	bcc :+
0027D7r 2               	ora #$80
0027D7r 2               :
0027D7r 2               	dey
0027D7r 2               	bne shf6loop
0027D7r 2               	sta shift6,x
0027D7r 2               	inx
0027D7r 2               	bne shf6
0027D7r 2               .endif
0027D7r 2               
0027D7r 2  60           	rts
0027D8r 2               
0027D8r 2               ;========================================================
0027D8r 2               ; KEY AND JOYSTICK ROUTINES
0027D8r 2               ;--------------------------------------------------------
0027D8r 2               ; Keys
0027D8r 2               ;
0027D8r 2               ; Out: joyval=x65FUDLR (bit cleared if key pressed)
0027D8r 2               ;             ||||||||
0027D8r 2               ;             |||||||+> Right    KEY 0  - X
0027D8r 2               ;             ||||||+-> Left     KEY 1  - Z
0027D8r 2               ;             |||||+--> Down     KEY 2  - .
0027D8r 2               ;             ||||+---> Up       KEY 3  - ;
0027D8r 2               ;             |||+----> Fire1    KEY 4  - SPC
0027D8r 2               ;             ||+-----> Fire2    KEY 5  - Q
0027D8r 2               ;             |+------> Fire3    KEY 6  - P
0027D8r 2               ;             +-------> Not used
0027D8r 2               ;
0027D8r 2               ;                       Option1  KEY 7  - 1
0027D8r 2               ;                       Option2  KEY 8  - 2
0027D8r 2               ;                       Option3  KEY 9  - 3
0027D8r 2               ;                       Option4  KEY 10 - 4
0027D8r 2               ;--------------------------------------------------------
0027D8r 2               
0027D8r 2               ;----------------------------------------------------
0027D8r 2               ; Interrupt service
0027D8r 2               ;----------------------------------------------------
0027D8r 2               
0027D8r 2               intserv:
0027D8r 2  EE 01 96     	inc $9601	; scroll colour char topleft
0027DBr 2  68           	pla
0027DCr 2  A8           	tay
0027DDr 2  68           	pla
0027DEr 2  AA           	tax
0027DFr 2  68           	pla
0027E0r 2  40           	rti
0027E1r 2               
0027E1r 2               ;--------------------------------------------------------
0027E1r 2               ; PRSKEY
0027E1r 2               ;
0027E1r 2               ; Wait for keypress.
0027E1r 2               ;--------------------------------------------------------
0027E1r 2               
0027E1r 2               prskey:
0027E1r 2  98           	tya
0027E2r 2  48           	pha
0027E3r 2               prsloop:
0027E3r 2  20 rr rr     	jsr vsync
0027E6r 2  20 rr rr     	jsr joykey
0027E9r 2  09 80        	ora #$80
0027EBr 2  C9 FF        	cmp #$ff
0027EDr 2  D0 07        	bne :+
0027EFr 2  20 rr rr     	jsr readkey
0027F2r 2  C9 FF        	cmp #255
0027F4r 2  F0 ED        	beq prsloop		; wait until key pressed
0027F6r 2               :
0027F6r 2               prsrelease:
0027F6r 2  20 rr rr     	jsr vsync
0027F9r 2  20 rr rr     	jsr joykey
0027FCr 2  09 80        	ora #$80
0027FEr 2  C9 FF        	cmp #$ff
002800r 2  F0 07        	beq :+
002802r 2  20 rr rr     	jsr readkey
002805r 2  C9 FF        	cmp #255
002807r 2  D0 ED        	bne prsrelease		; wait until key released
002809r 2               :
002809r 2  68           	pla
00280Ar 2  A8           	tay
00280Br 2  60           	rts
00280Cr 2               
00280Cr 2               ;--------------------------------------------------------
00280Cr 2               ; KTEST
00280Cr 2               ;
00280Cr 2               ; Keyboard test routine with key in A.
00280Cr 2               ; Scan key and clear carry if key pressed
00280Cr 2               ;--------------------------------------------------------
00280Cr 2               
00280Cr 2               ktest:
00280Cr 2  85 rr        	sta z80_a		; save key
00280Er 2               
00280Er 2  4A           	lsr a
00280Fr 2  4A           	lsr a
002810r 2  4A           	lsr a
002811r 2  4A           	lsr a
002812r 2  AA           	tax
002813r 2  BD rr rr     	lda colmask,x
002816r 2  8D 20 91     	sta KeyColAddr		; set row
002819r 2               
002819r 2  A5 rr        	lda z80_a
00281Br 2  29 0F        	and #$0f
00281Dr 2  AA           	tax			; get column
00281Er 2               
00281Er 2  AD 21 91     	lda KeyRowAddr		; read column
002821r 2  3D rr rr     	and keymask,x		; check if key pressed
002824r 2  F0 02        	beq pressed		; Skip if pressed
002826r 2  38           	sec			; key not pressed
002827r 2  60           	rts
002828r 2               pressed:
002828r 2  18           	clc			; key pressed
002829r 2  60           	rts
00282Ar 2               
00282Ar 2  7F BF DF EF  colmask:	.byte 127,191,223,239,247,251,253,254
00282Er 2  F7 FB FD FE  
002832r 2  01 02 04 08  keymask:	.byte $01,$02,$04,$08,$10,$20,$40,$80
002836r 2  10 20 40 80  
00283Ar 2               
00283Ar 2               ;---------------------------------------------------------------
00283Ar 2               ; KGET
00283Ar 2               ;
00283Ar 2               ; Read keyboard matrix if a key is pressed.
00283Ar 2               ; Return A = high nibble=row and low nibble=col
00283Ar 2               ;---------------------------------------------------------------
00283Ar 2               
00283Ar 2               kget:
00283Ar 2  86 rr        	stx xtmp		; Save x-reg
00283Cr 2               kget0:
00283Cr 2  A2 00        	ldx #0			; reset row
00283Er 2               kget1:
00283Er 2  BD rr rr     	lda colmask,x		; Get mask
002841r 2  8D 20 91     	sta KeyColAddr		; Set row
002844r 2  AD 21 91     	lda KeyRowAddr		; Read columns
002847r 2  85 rr        	sta tmp			; Save colums
002849r 2  C9 FF        	cmp #$ff		; Key pressed?
00284Br 2  D0 08        	bne kget2		; Yes, skip
00284Dr 2  E8           	inx			; Next row
00284Er 2  E0 08        	cpx #8			; All rows scanned?
002850r 2  D0 EC        	bne kget1		; No, repeat
002852r 2  4C rr rr     	jmp kget0		; No key pressed, a=$ff
002855r 2               kget2:
002855r 2  A0 00        	ldy #0			; Reset column
002857r 2               kget3:
002857r 2  46 rr        	lsr tmp			; Test bit
002859r 2  90 04        	bcc kget4		; If clear, key pressed
00285Br 2  C8           	iny			; Next column
00285Cr 2  4C rr rr     	jmp kget3		; Repeat
00285Fr 2               kget4:
00285Fr 2  86 rr        	stx tmp			; Get row
002861r 2  06 rr        	asl tmp			; Make high nibble
002863r 2  06 rr        	asl tmp
002865r 2  06 rr        	asl tmp
002867r 2  06 rr        	asl tmp
002869r 2  98           	tya			; Get column
00286Ar 2  18           	clc
00286Br 2  65 rr        	adc tmp			; Add row as low nibble
00286Dr 2  85 rr        	sta tmp
00286Fr 2               kget5:
00286Fr 2  AD 21 91     	lda KeyRowAddr		; Read columns
002872r 2  C9 FF        	cmp #$ff
002874r 2  D0 F9        	bne kget5
002876r 2               
002876r 2  A5 rr        	lda tmp			; Return keycode
002878r 2  A6 rr        	ldx xtmp		; Restore X-reg
00287Ar 2  60           	rts			; Return
00287Br 2               
00287Br 2               ;-------------------------------------------------------------
00287Br 2               ; READKEY
00287Br 2               ;
00287Br 2               ; Check keyboard matrix if a key is pressed
00287Br 2               ; Return keymask in Y
00287Br 2               ;-------------------------------------------------------------
00287Br 2               
00287Br 2               readkey:
00287Br 2  A9 FF        	lda #$ff		; Keymask
00287Dr 2  85 rr        	sta tmp
00287Fr 2  A2 07        	ldx #7
002881r 2               scanrow:
002881r 2  BD rr rr     	lda colmask,x
002884r 2  8D 20 91     	sta KeyColAddr		; set row
002887r 2  AD 21 91     	lda KeyRowAddr		; read column
00288Ar 2  25 rr        	and tmp			; Reset bit is key pressed
00288Cr 2  85 rr        	sta tmp
00288Er 2  CA           	dex
00288Fr 2  10 F0        	bpl scanrow
002891r 2  A5 rr        	lda tmp
002893r 2  A8           	tay
002894r 2  60           	rts
002895r 2               
002895r 2               ;-------------------------------------------------------------
002895r 2               ; JOY1SCAN
002895r 2               ;
002895r 2               ; Initializes joystick
002895r 2               ;-------------------------------------------------------------
002895r 2               
002895r 2               joyinit:
002895r 2  60           	rts
002896r 2               
002896r 2               ;-------------------------------------------------------------
002896r 2               ; JOY1SCAN
002896r 2               ;
002896r 2               ; Scan joystick1 and return key in z80_e
002896r 2               ; Up, down, left, right and fire are read from the joystick
002896r 2               ; Fire2 and fire3 are read from the keyboard
002896r 2               ;-------------------------------------------------------------
002896r 2               
002896r 2               joy1scan:
002896r 2  A9 FF        	lda #$ff
002898r 2  85 rr        	sta z80_e
00289Ar 2               
00289Ar 2  AD 11 91     	lda JoyAddr1		; Read joystick input
00289Dr 2  4A           	lsr a
00289Er 2  4A           	lsr a
00289Fr 2               
00289Fr 2  4A           	lsr a
0028A0r 2  26 rr        	rol z80_e		; Up
0028A2r 2  4A           	lsr a
0028A3r 2  26 rr        	rol z80_e		; Down
0028A5r 2  4A           	lsr a
0028A6r 2  26 rr        	rol z80_e		; Left
0028A8r 2               
0028A8r 2  A9 7F        	lda #%01111111
0028AAr 2  8D 22 91     	sta DDRB		; Bit7 = input joystick b7
0028ADr 2  AD 20 91     	lda JoyAddr2
0028B0r 2  0A           	asl a
0028B1r 2  26 rr        	rol z80_e		; Right
0028B3r 2  A9 FF        	lda #%11111111
0028B5r 2  8D 22 91     	sta DDRB		; Reset
0028B8r 2               
0028B8r 2  AD 11 91     	lda JoyAddr1
0028BBr 2  29 20        	and #%00100000
0028BDr 2  D0 06        	bne :+
0028BFr 2  A5 rr        	lda z80_e
0028C1r 2  29 EF        	and #%11101111		; Fire
0028C3r 2  85 rr        	sta z80_e
0028C5r 2               :
0028C5r 2  AD rr rr     	lda keys+6		; Scan keys for Fire3
0028C8r 2  20 rr rr     	jsr ktest
0028CBr 2  B0 06        	bcs :+
0028CDr 2  A5 rr        	lda z80_e
0028CFr 2  29 BF        	and #%10111111
0028D1r 2  85 rr        	sta z80_e
0028D3r 2               :
0028D3r 2  AD rr rr     	lda keys+5		; Scan keys for Fire2
0028D6r 2  20 rr rr     	jsr ktest
0028D9r 2  B0 06        	bcs :+
0028DBr 2  A5 rr        	lda z80_e
0028DDr 2  29 DF        	and #%11011111
0028DFr 2  85 rr        	sta z80_e
0028E1r 2               :
0028E1r 2  60           	rts
0028E2r 2               
0028E2r 2               ;-------------------------------------------------------------
0028E2r 2               ; JOY2SCAN
0028E2r 2               ;
0028E2r 2               ; TODO, Scan joystick2 and return key in z80_e
0028E2r 2               ;-------------------------------------------------------------
0028E2r 2               
0028E2r 2               joy2scan:
0028E2r 2  60           	rts
0028E3r 2               
0028E3r 2               
0028E3r 2               
0028E3r 2               ;========================================================
0028E3r 2               ; HARDWARE DEPENDING ROUTINES
0028E3r 2               ;========================================================
0028E3r 2               
0028E3r 2               ;----------------------------------------------------
0028E3r 2               ; DELAY
0028E3r 2               ;
0028E3r 2               ; Delay routine A * 1/50 sec
0028E3r 2               ;----------------------------------------------------
0028E3r 2               
0028E3r 2               delay:
0028E3r 2  85 rr        	sta xtmp		; set delaycounter
0028E5r 2               del_loop:
0028E5r 2  AD 04 90     	lda Reg4
0028E8r 2  D0 FB        	bne del_loop		; wait for flyback (1/60 sec)
0028EAr 2               
0028EAr 2  A0 D0        	ldy #208		; wait 208 x 16 = 3328 usec
0028ECr 2               delay1:
0028ECr 2  61 80        	adc ($80,x)		;	 6 usec
0028EEr 2  61 80        	adc ($80,x)		;	 6 usec
0028F0r 2  88           	dey			;	 2 usec
0028F1r 2  D0 F9        	bne delay1		;	 2 usec
0028F3r 2  EA           	nop			; 2 usec
0028F4r 2  EA           	nop			; 2 usec
0028F5r 2               				; tot: 20000 usec
0028F5r 2  C6 rr        	dec xtmp		; Next 1/50 sec delay
0028F7r 2  D0 EC        	bne del_loop
0028F9r 2  60           	rts
0028FAr 2               
0028FAr 2               ;-------------------------------------------------------------
0028FAr 2               ; VSYNC
0028FAr 2               ;
0028FAr 2               ; - read joystick/keyboard
0028FAr 2               ; - sync framerate with timer 25Hz
0028FAr 2               ; - handle shrapnel every even frame
0028FAr 2               ; - handle sound
0028FAr 2               ;-------------------------------------------------------------
0028FAr 2               
0028FAr 2               vsync:
0028FAr 2  48           	pha			; save registers
0028FBr 2  98           	tya
0028FCr 2  48           	pha
0028FDr 2  8A           	txa
0028FEr 2  48           	pha
0028FFr 2               
0028FFr 2               ;-------------------------------------------------------------
0028FFr 2               ; Read joystick/keyboard.
0028FFr 2               ;-------------------------------------------------------------
0028FFr 2               
0028FFr 2  20 rr rr     	jsr joykey
002902r 2               
002902r 2               ;-------------------------------------------------------------
002902r 2               ; Sync framerate with timer 25Hz
002902r 2               ;-------------------------------------------------------------
002902r 2               
002902r 2  A9 40        	lda #$40		; set Timer1 expired bit
002904r 2               vsync1:
002904r 2  2C 1D 91     	bit IFR1		; check Interrupt Flag Register
002907r 2  F0 FB        	beq vsync1		; wait if timer not expired
002909r 2  AD 14 91     	lda Timer11_Low		; clear Timer interrupt
00290Cr 2               
00290Cr 2               rasterwait:
00290Cr 2  AD 04 90     	lda Reg4
00290Fr 2  D0 FB        	bne rasterwait
002911r 2               
002911r 2               ;-------------------------------------------------------------
002911r 2               ; Handle sound command
002911r 2               ;-------------------------------------------------------------
002911r 2               
002911r 2  20 rr rr     	jsr make_sound2
002914r 2               
002914r 2               ;-------------------------------------------------------------
002914r 2               ; Handle shrapnel every even frame
002914r 2               ;-------------------------------------------------------------
002914r 2               
002914r 2  A5 rr        	lda clock		; get clock
002916r 2  29 01        	and #1			; 2 frames expired
002918r 2  D0 03        	bne:+
00291Ar 2  20 rr rr     	jsr proshr		; process shrapnel
00291Dr 2               :
00291Dr 2               
00291Dr 2               ;-------------------------------------------------------------
00291Dr 2               ; Handle sound BEEP and CRASH
00291Dr 2               ;-------------------------------------------------------------
00291Dr 2               
00291Dr 2  AD rr rr     	lda sndtyp
002920r 2  F0 4E        	beq sndskip
002922r 2               
002922r 2               sndloop:
002922r 2  AC rr rr     	ldy sndtyp
002925r 2               sndwait:
002925r 2  88           	dey
002926r 2  D0 FD        	bne sndwait
002928r 2               
002928r 2  AD rr rr     	lda sndtyp
00292Br 2  30 1E        	bmi crashaudio
00292Dr 2               
00292Dr 2               ; BEEP command:
00292Dr 2               ; enable sound on channel 2
00292Dr 2               ; range 0-127
00292Dr 2               
00292Dr 2               beepaudio:
00292Dr 2  AD 0E 90     	lda RegE
002930r 2  09 0F        	ora #$0f
002932r 2  8D 0E 90     	sta RegE
002935r 2               
002935r 2  A5 rr        	lda SOUNDS_STATUS
002937r 2  09 40        	ora #%01000000
002939r 2  85 rr        	sta SOUNDS_STATUS
00293Br 2  A9 FF        	lda #$ff
00293Dr 2  38           	sec
00293Er 2  ED rr rr     	sbc sndtyp
002941r 2  4A           	lsr
002942r 2  4A           	lsr
002943r 2  09 C0        	ora #%11000000
002945r 2  8D 0C 90     	sta RegC
002948r 2  4C rr rr     	jmp endaudiotype
00294Br 2               
00294Br 2               ; CRASH command:
00294Br 2               ; enable sound on channel 3
00294Br 2               ; range 128-255
00294Br 2               
00294Br 2               crashaudio:
00294Br 2  AD 0E 90     	lda RegE
00294Er 2  09 0F        	ora #$0f
002950r 2  8D 0E 90     	sta RegE
002953r 2  A5 rr        	lda SOUNDS_STATUS
002955r 2  09 80        	ora #%10000000
002957r 2  85 rr        	sta SOUNDS_STATUS
002959r 2  A9 FF        	lda #$ff
00295Br 2  38           	sec
00295Cr 2  ED rr rr     	sbc sndtyp
00295Fr 2  09 80        	ora #%10000000
002961r 2  8D 0D 90     	sta RegD
002964r 2               
002964r 2               endaudiotype:
002964r 2  CE rr rr     	dec sndtyp
002967r 2  F0 07        	beq sndskip
002969r 2  C9 80        	cmp #128
00296Br 2  F0 03        	beq sndskip
00296Dr 2  4C rr rr     	jmp sndloop
002970r 2               
002970r 2               ; disable sound
002970r 2               
002970r 2               sndskip:
002970r 2  24 rr        	bit SOUNDS_STATUS
002972r 2  50 0B        	bvc :+
002974r 2  A5 rr        	lda SOUNDS_STATUS
002976r 2  29 BF        	and #%10111111
002978r 2  85 rr        	sta SOUNDS_STATUS
00297Ar 2  A9 00        	lda #$00
00297Cr 2  8D 0C 90     	sta RegC
00297Fr 2               :
00297Fr 2  24 rr        	bit SOUNDS_STATUS
002981r 2  10 0B        	bpl :+
002983r 2               
002983r 2  A5 rr        	lda SOUNDS_STATUS
002985r 2  29 7F        	and #%01111111
002987r 2  85 rr        	sta SOUNDS_STATUS
002989r 2  A9 00        	lda #$00
00298Br 2  8D 0D 90     	sta RegD
00298Er 2               :
00298Er 2  68           	pla
00298Fr 2  AA           	tax
002990r 2  68           	pla
002991r 2  A8           	tay
002992r 2  68           	pla
002993r 2  60           	rts
002994r 2               
002994r 2  00           sndtyp:		.byte 0		; Beep sound parameter
002995r 2               
002995r 2               ;========================================================
002995r 2               ; SPRITE HANDLING ROUTINES
002995r 2               ;========================================================
002995r 2               
002995r 2               ;----------------------------------------------------
002995r 2               ; SPRITE
002995r 2               ;
002995r 2               ; Draw object sprite
002995r 2               ;----------------------------------------------------
002995r 2               
002995r 2               .if oflag
002995r 2               sprite:
002995r 2               	stx xtmp		; Save X-reg
002995r 2               	jsr scadd 		; get screen address in scraddr.
002995r 2               
002995r 2               	lda dispx 		; x position.
002995r 2               	and #7 			; position straddling cells.
002995r 2               	sta z80_b		; store in b register.
002995r 2               
002995r 2               	lda z80_l		; store sprite graphic address.
002995r 2               	sta sprit1+1
002995r 2               	sta sprit2+1
002995r 2               	lda z80_h
002995r 2               	sta sprit1+2
002995r 2               	sta sprit2+2
002995r 2               
002995r 2               	ldx #0			; pixel height.
002995r 2               	ldy #0
002995r 2               sprit1:
002995r 2               	lda objdta,x		; fetch first byte.
002995r 2               	sta spr
002995r 2               	inx
002995r 2               sprit2:
002995r 2               	lda objdta,x
002995r 2               	sta spr+1
002995r 2               
002995r 2               	lda #0
002995r 2               	sta spr+2
002995r 2               	jsr sprit7		; shift sprite
002995r 2               
002995r 2               	lda spr			; fetch graphic.
002995r 2               	ldy #0			; _BEEB
002995r 2               	eor (scraddr),y		; merge with screen image.
002995r 2               	sta (scraddr),y		; write to screen.
002995r 2               
002995r 2               	lda spr+1		; fetch graphic.
002995r 2               	ldy #16			; _BEEB
002995r 2               	eor (scraddr),y		; merge with screen image.
002995r 2               	sta (scraddr),y		; write to screen.
002995r 2               
002995r 2               	lda spr+2		; fetch graphic.
002995r 2               	ldy #32			; _BEEB
002995r 2               	eor (scraddr),y		; merge with screen image.
002995r 2               	sta (scraddr),y		; write to screen.
002995r 2               
002995r 2               	jsr nline
002995r 2               
002995r 2               	inx			; next source byte.
002995r 2               	cpx #32
002995r 2               	bne sprit1		; repeat
002995r 2               
002995r 2               	ldx xtmp		; retreive X-reg
002995r 2               	rts
002995r 2               
002995r 2               .endif
002995r 2               
002995r 2               ;------------------------------------------------------------------
002995r 2               ; SCADD
002995r 2               ;
002995r 2               ; This routine returns a screen address for X,Y in scraddr.
002995r 2               ;------------------------------------------------------------------
002995r 2               
002995r 2               scadd:
002995r 2  A5 rr        	lda dispx		; get x
002997r 2  29 F8        	and #$f8		; reset bit 0-2 for get block pos
002999r 2  85 rr        	sta scraddr		; set lb scraddr
00299Br 2  A9 00        	lda #0
00299Dr 2  85 rr        	sta scraddr+1		; set hb scraddr
00299Fr 2  06 rr        	asl scraddr		; multiply X by 2
0029A1r 2  26 rr        	rol scraddr+1
0029A3r 2               
0029A3r 2               ; Add line address Y pos to X
0029A3r 2               
0029A3r 2  A6 rr        	ldx dispy		; get row address Y pos
0029A5r 2  18           	clc
0029A6r 2  A5 rr        	lda scraddr
0029A8r 2  7D 00 07     	adc SCADTB_lb,x
0029ABr 2  85 rr        	sta scraddr
0029ADr 2  A5 rr        	lda scraddr+1
0029AFr 2  7D 00 08     	adc SCADTB_hb,x
0029B2r 2  85 rr        	sta scraddr+1
0029B4r 2               
0029B4r 2  60           	rts
0029B5r 2               
0029B5r 2               ;------------------------------------------------------------------
0029B5r 2               ; SSPRIA
0029B5r 2               ;
0029B5r 2               ; Erase single sprite, old (ix+0).
0029B5r 2               ;------------------------------------------------------------------
0029B5r 2               
0029B5r 2               sspria:
0029B5r 2  20 rr rr     	jsr gsprad		; get old sprite address.
0029B8r 2               sspri2:
0029B8r 2               .if rflag
0029B8r 2               	lda z80_e		; 3c
0029B8r 2               	sta dline_spraddr1+1	; 4c
0029B8r 2               	sta dline_spraddr2+1	; 4c
0029B8r 2               	lda z80_d		; 3c
0029B8r 2               	sta dline_spraddr1+2	; 4c
0029B8r 2               	sta dline_spraddr2+2	; 4c
0029B8r 2               
0029B8r 2               	ldx sprshft
0029B8r 2               	lda shift_table,x
0029B8r 2               	sta dline_shift1+1
0029B8r 2               	sta dline_shift2+1
0029B8r 2               	lda shift_table+1,x
0029B8r 2               	sta dline_shift1+2
0029B8r 2               	sta dline_shift2+2
0029B8r 2               
0029B8r 2               	ldx #0			; byte counter.
0029B8r 2               sspri0:
0029B8r 2               	jsr dline		; draw a line.
0029B8r 2                 .if bflag
0029B8r 2               	cpx #48			; big sprites have 24 bytes
0029B8r 2                 .else
0029B8r 2               	cpx #32			; normal sprites have 32 bytes
0029B8r 2                 .endif
0029B8r 2               	bne sspri0		; repeat 16 times x 2 bytes
0029B8r 2               	rts
0029B8r 2               .else
0029B8r 2                 .if bflag
0029B8r 2               	lda #24			; big sprites have 24 lines
0029B8r 2                 .else
0029B8r 2  A9 10        	lda #16			; normal sprites have 16 lines.
0029BAr 2                 .endif
0029BAr 2  8D rr rr     	sta acnt
0029BDr 2               sspri0:
0029BDr 2  20 rr rr     	jsr dline		; draw a line.
0029C0r 2  CE rr rr     	dec acnt
0029C3r 2  D0 F8        	bne sspri0		; repeat 16 times
0029C5r 2  60           	rts
0029C6r 2               
0029C6r 2  00           acnt:	.byte 0			; line counter
0029C7r 2               
0029C7r 2               .endif
0029C7r 2               
0029C7r 2               ;------------------------------------------------------------------
0029C7r 2               ; SSPRIB
0029C7r 2               ;
0029C7r 2               ; Display single sprite, new (ix+5).
0029C7r 2               ;------------------------------------------------------------------
0029C7r 2               
0029C7r 2               ssprib:
0029C7r 2  20 rr rr     	jsr gspran 		; get new sprite address.
0029CAr 2  4C rr rr     	jmp sspri2		; Display sprite
0029CDr 2               
0029CDr 2               ;------------------------------------------------------------------
0029CDr 2               ; SSPRIC
0029CDr 2               ;
0029CDr 2               ; Erase old (ix+0) and display new (ix+5) sprite line by line.
0029CDr 2               ;------------------------------------------------------------------
0029CDr 2               
0029CDr 2               sspric:
0029CDr 2  A9 01        	lda #1
0029CFr 2  85 rr        	sta z80_c
0029D1r 2  20 rr rr     	jsr cspr_old
0029D4r 2               
0029D4r 2  A0 11        	ldy #17
0029D6r 2  B1 rr        	lda (z80_ix),y
0029D8r 2  85 rr        	sta z80_c
0029DAr 2  20 rr rr     	jsr cspr_new
0029DDr 2               
0029DDr 2               .if rflag
0029DDr 2               	jsr gsprad 		; get old sprite address.
0029DDr 2               
0029DDr 2               	lda z80_e		; 3c
0029DDr 2               	sta ddline_spraddr3+1	; 4c
0029DDr 2               	sta ddline_spraddr4+1	; 4c
0029DDr 2               
0029DDr 2               	lda z80_d		; 3c
0029DDr 2               	sta ddline_spraddr3+2	; 4c
0029DDr 2               	sta ddline_spraddr4+2	; 4c
0029DDr 2               
0029DDr 2               	ldx sprshft		; set spriteshift table addresses
0029DDr 2               	lda shift_table,x
0029DDr 2               	sta ddline_shift3+1
0029DDr 2               	sta ddline_shift4+1
0029DDr 2               	lda shift_table+1,x
0029DDr 2               	sta ddline_shift3+2
0029DDr 2               	sta ddline_shift4+2
0029DDr 2               
0029DDr 2               	jsr exx  		; store addresses.
0029DDr 2               	jsr gspran 		; get new sprite addresses.
0029DDr 2               
0029DDr 2               	lda z80_e		; 3c
0029DDr 2               	sta ddline_spraddr1+1	; 4c
0029DDr 2               	sta ddline_spraddr2+1	; 4c
0029DDr 2               
0029DDr 2               	lda z80_d		; 3c
0029DDr 2               	sta ddline_spraddr1+2	; 4c
0029DDr 2               	sta ddline_spraddr2+2	; 4c
0029DDr 2               
0029DDr 2               	ldx sprshft
0029DDr 2               	lda shift_table,x
0029DDr 2               	sta ddline_shift1+1
0029DDr 2               	sta ddline_shift2+1
0029DDr 2               	lda shift_table+1,x
0029DDr 2               	sta ddline_shift1+2
0029DDr 2               	sta ddline_shift2+2
0029DDr 2               
0029DDr 2               	ldx #0
0029DDr 2               lloop:
0029DDr 2               	jsr ddline 		; draw a line.
0029DDr 2                 .if bflag
0029DDr 2               	cpx #48
0029DDr 2                 .else
0029DDr 2               	cpx #32
0029DDr 2                 .endif
0029DDr 2               	bne lloop
0029DDr 2               	rts
0029DDr 2               
0029DDr 2               shift_table:
0029DDr 2               	.word shift0
0029DDr 2               	.word shift2
0029DDr 2               	.word shift4
0029DDr 2               	.word shift6
0029DDr 2               
0029DDr 2               ;------------------------------------------------------------------
0029DDr 2               ; DLINE
0029DDr 2               ;
0029DDr 2               ; Draw a sprite line, now work out next target address.
0029DDr 2               ;
0029DDr 2               ; Input:
0029DDr 2               ;  B  = right mask
0029DDr 2               ;  C  = left mask
0029DDr 2               ;  DE = spriteaddress
0029DDr 2               ;  scraddr = screen address
0029DDr 2               ;------------------------------------------------------------------
0029DDr 2               
0029DDr 2               dline:
0029DDr 2               
0029DDr 2               dline_spraddr1:
0029DDr 2               	ldy $ffff,x 		; get graphic data as pointer.
0029DDr 2               dline_shift1:
0029DDr 2               	lda $ffff,y		; get pre-shifted data
0029DDr 2               	sta sprtmp		; save byte
0029DDr 2               	and z80_c 		; mask right for left byte
0029DDr 2               
0029DDr 2               	ldy #0
0029DDr 2               	eor (scraddr),y 	; XOR with what's there.
0029DDr 2               	sta (scraddr),y 	; display left byte
0029DDr 2               
0029DDr 2               ; carry to next screen byte
0029DDr 2               
0029DDr 2               	lda sprtmp		; fetch data.
0029DDr 2               	and z80_b 		; mask for left part
0029DDr 2               	sta sprtmp
0029DDr 2               
0029DDr 2               ; middle screen byte
0029DDr 2               
0029DDr 2               	inx
0029DDr 2               dline_spraddr2:
0029DDr 2               	ldy $ffff,x 		; second bit of data.
0029DDr 2               dline_shift2:
0029DDr 2               	lda $ffff,y
0029DDr 2               	sta sprtmp2
0029DDr 2               	and z80_c 		; mask away what's not needed.
0029DDr 2               	ora sprtmp
0029DDr 2               	ldy #16
0029DDr 2               	eor (scraddr),y 	; XOR with what's there.
0029DDr 2               	sta (scraddr),y 	; display middle bye.
0029DDr 2               
0029DDr 2               ; carry to last screen byte
0029DDr 2               
0029DDr 2               	lda sprtmp2
0029DDr 2               	and z80_b 		; mask away unwanted
0029DDr 2               
0029DDr 2               	ldy #32
0029DDr 2               	eor (scraddr),y 	; XOR with what's there.
0029DDr 2               	sta (scraddr),y 	; display right byte.
0029DDr 2               
0029DDr 2               	inx
0029DDr 2               .else
0029DDr 2               
0029DDr 2  20 rr rr     	jsr gsprad 		; get old sprite address.
0029E0r 2  20 rr rr     	jsr exx  		; store addresses.
0029E3r 2  20 rr rr     	jsr gspran 		; get new sprite addresses.
0029E6r 2               
0029E6r 2               .if bflag
0029E6r 2               	lda #23
0029E6r 2               .else
0029E6r 2  A9 0F        	lda #15
0029E8r 2               .endif
0029E8r 2  85 rr        	sta ccnt
0029EAr 2               lloop:
0029EAr 2  20 rr rr     	jsr dline 		; draw a line.
0029EDr 2  20 rr rr     	jsr exx  		; restore old addresses.
0029F0r 2  20 rr rr     	jsr dline 		; delete a line.
0029F3r 2  20 rr rr     	jsr exx  		; flip to new sprite addresses.
0029F6r 2  C6 rr        	dec ccnt
0029F8r 2  D0 F0        	bne lloop
0029FAr 2               
0029FAr 2  20 rr rr     	jsr dline		; draw a line.
0029FDr 2  20 rr rr     	jsr exx 		; restore old addresses.
002A00r 2               
002A00r 2               ;-------------------------------------------------------------
002A00r 2               ; Drop through.
002A00r 2               ; Line drawn, now work out next target address.
002A00r 2               ;
002A00r 2               ; Input:
002A00r 2               ;  B  = right mask
002A00r 2               ;  C  = left mask
002A00r 2               ;  DE = spriteaddress
002A00r 2               ;  scraddr = screen address
002A00r 2               ;-------------------------------------------------------------
002A00r 2               
002A00r 2               dline:
002A00r 2  A0 00        	ldy #0
002A02r 2  B1 rr        	lda (z80_de),y 		; graphic data.
002A04r 2  48           	pha
002A05r 2  25 rr        	and z80_c 		; mask away what's not needed.
002A07r 2  51 rr        	eor (scraddr),y 	; XOR with what's there.
002A09r 2  91 rr        	sta (scraddr),y 	; left byte on screen.
002A0Br 2               
002A0Br 2  68           	pla
002A0Cr 2  25 rr        	and z80_b 		; mask away unwanted bits.
002A0Er 2  A0 20        	ldy #32
002A10r 2  51 rr        	eor (scraddr),y 	; XOR with what's there.
002A12r 2  91 rr        	sta (scraddr),y 	; right byte on screen
002A14r 2               
002A14r 2  E6 rr        	inc z80_e 		; next graphic.
002A16r 2  D0 02        	bne :+
002A18r 2  E6 rr        	inc z80_d
002A1Ar 2               :
002A1Ar 2               ; _BEEB screen arrangement
002A1Ar 2               ;	sec
002A1Ar 2               ;	lda scraddr 		; one character cell to the left.
002A1Ar 2               ;	sbc #8
002A1Ar 2               ;	sta scraddr
002A1Ar 2               ;	lda scraddr+1
002A1Ar 2               ;	sbc #0
002A1Ar 2               ;	sta scraddr+1
002A1Ar 2  A0 00        	ldy #0
002A1Cr 2  B1 rr        	lda (z80_de),y 		; second bit of data.
002A1Er 2  A0 10        	ldy #16
002A20r 2  51 rr        	eor (scraddr),y 	; XOR with what's there.
002A22r 2  91 rr        	sta (scraddr),y 	; middle byte on screen.
002A24r 2               
002A24r 2  E6 rr        	inc z80_e 		; point to next line of data.
002A26r 2  D0 02        	bne :+
002A28r 2  E6 rr        	inc z80_d
002A2Ar 2               :
002A2Ar 2               ; _BEEB screen arrangement
002A2Ar 2               ;	sec
002A2Ar 2               ;	lda scraddr 		; another char left.
002A2Ar 2               ;	sbc #8
002A2Ar 2               ;	sta scraddr
002A2Ar 2               ;	lda scraddr+1
002A2Ar 2               ;	sbc #0
002A2Ar 2               ;	sta scraddr+1
002A2Ar 2               .endif
002A2Ar 2               
002A2Ar 2               ;----------------------------------------------------------------------
002A2Ar 2               ; Line drawn, now work out next target address.
002A2Ar 2               ;----------------------------------------------------------------------
002A2Ar 2               
002A2Ar 2               ; _BEEB screen arrangement
002A2Ar 2               
002A2Ar 2               nline:
002A2Ar 2  A5 rr        	lda scraddr 			; get low byte of address.
002A2Cr 2  29 0F        	and #15
002A2Er 2  C9 0F        	cmp #15				; is this last line of row?
002A30r 2  F0 03        	beq beeb_next_row
002A32r 2               
002A32r 2               	; within same row
002A32r 2  E6 rr        	inc scraddr			; new low byte of address.
002A34r 2  60           	rts
002A35r 2               
002A35r 2               beeb_next_row:
002A35r 2  18           	clc
002A36r 2  A5 rr        	lda scraddr
002A38r 2  69 51        	adc #<(ScreenRowBytes-15)
002A3Ar 2  85 rr        	sta scraddr			; new low byte of address.
002A3Cr 2  A5 rr        	lda scraddr+1
002A3Er 2  69 01        	adc #>(ScreenRowBytes-15)
002A40r 2  85 rr        	sta scraddr+1			; new high byte of address.
002A42r 2  60           	rts
002A43r 2               
002A43r 2               .if rflag
002A43r 2               ;-------------------------------------------------------------
002A43r 2               ; Drop through.
002A43r 2               ; Line drawn, now work out next target address.
002A43r 2               ;
002A43r 2               ; Input:
002A43r 2               ;  B  = right mask
002A43r 2               ;  C  = left mask
002A43r 2               ;  DE = spriteaddress
002A43r 2               ;  scraddr = screen address
002A43r 2               ;-------------------------------------------------------------
002A43r 2               
002A43r 2               ddline:
002A43r 2               
002A43r 2               ; NEW SPRITE
002A43r 2               
002A43r 2               ; first screen byte
002A43r 2               
002A43r 2               ddline_spraddr1:
002A43r 2               	ldy $ffff,x 		; graphic data.
002A43r 2               ddline_shift1:
002A43r 2               	lda $ffff,y
002A43r 2               	sta sprtmp
002A43r 2               	and z80_c 			; mask away what's not needed.
002A43r 2               
002A43r 2               	ldy #0
002A43r 2               	eor (scraddr),y 	; XOR with what's there.
002A43r 2               	sta (scraddr),y 	; bung it in.
002A43r 2               
002A43r 2               ; carry to next screen byte
002A43r 2               
002A43r 2               	lda sprtmp			; fetch data.
002A43r 2               	and z80_b 			; mask away unwanted
002A43r 2               	sta sprtmp
002A43r 2               
002A43r 2               ; middle screen byte
002A43r 2               
002A43r 2               	inx
002A43r 2               ddline_spraddr2:
002A43r 2               	ldy $ffff,x 		; second bit of data.
002A43r 2               ddline_shift2:
002A43r 2               	lda $ffff,y
002A43r 2               	sta sprtmp2
002A43r 2               	and z80_c 			; mask away what's not needed.
002A43r 2               	ora sprtmp
002A43r 2               
002A43r 2               	ldy #16
002A43r 2               	eor (scraddr),y 	; XOR with what's there.
002A43r 2               	sta (scraddr),y 	; bung it in.
002A43r 2               
002A43r 2               ; carry to last screen byte
002A43r 2               
002A43r 2               	lda sprtmp2
002A43r 2               	and z80_b 			; mask away unwanted
002A43r 2               
002A43r 2               	ldy #32
002A43r 2               	eor (scraddr),y 	; XOR with what's there.
002A43r 2               	sta (scraddr),y 	; bung it in.
002A43r 2               
002A43r 2               ; _BEEB next row
002A43r 2               
002A43r 2               	lda scraddr 		; get low byte of address.
002A43r 2               	and #15
002A43r 2               	cmp #15				; is this last line of row?
002A43r 2               	beq :+
002A43r 2               
002A43r 2               	; within same row can't increment page
002A43r 2               	inc scraddr			; new low byte of address.
002A43r 2               	bne ddline2
002A43r 2               
002A43r 2               :
002A43r 2               	clc
002A43r 2               	lda scraddr
002A43r 2               	adc #<(ScreenRowBytes-15)
002A43r 2               	sta scraddr			; new low byte of address.
002A43r 2               	lda scraddr+1
002A43r 2               	adc #>(ScreenRowBytes-15)
002A43r 2               	sta scraddr+1		; new high byte of address.
002A43r 2               
002A43r 2               ; OLD SPRITE
002A43r 2               
002A43r 2               ddline2:
002A43r 2               
002A43r 2               ; still first row but different data!
002A43r 2               
002A43r 2               	dex
002A43r 2               
002A43r 2               ; first screen byte
002A43r 2               
002A43r 2               ddline_spraddr3:
002A43r 2               	ldy $ffff,x			; graphic data.
002A43r 2               ddline_shift3:
002A43r 2               	lda $ffff,y
002A43r 2               	sta sprtmp
002A43r 2               	and z80_cp 			; mask away what's not needed.
002A43r 2               
002A43r 2               	ldy #0
002A43r 2               	eor (z80_hlp),y 	; XOR with what's there.
002A43r 2               	sta (z80_hlp),y 	; bung it in.
002A43r 2               
002A43r 2               ; carry to next screen byte
002A43r 2               
002A43r 2               	lda sprtmp			; fetch data.
002A43r 2               	and z80_bp 			; mask away unwanted
002A43r 2               	sta sprtmp
002A43r 2               
002A43r 2               ; middle screen byte
002A43r 2               
002A43r 2               	inx
002A43r 2               ddline_spraddr4:
002A43r 2               	ldy $ffff,x 		; second bit of data.
002A43r 2               ddline_shift4:
002A43r 2               	lda $ffff,y
002A43r 2               	sta sprtmp2
002A43r 2               	and z80_cp 			; mask away what's not needed.
002A43r 2               	ora sprtmp
002A43r 2               
002A43r 2               	ldy #16
002A43r 2               	eor (z80_hlp),y 	; XOR with what's there.
002A43r 2               	sta (z80_hlp),y 	; bung it in.
002A43r 2               
002A43r 2               ; last screen byte
002A43r 2               
002A43r 2               	lda sprtmp2			; fetch data.
002A43r 2               	and z80_bp 			; mask away unwanted
002A43r 2               
002A43r 2               	ldy #32
002A43r 2               	eor (z80_hlp),y 	; XOR with what's there.
002A43r 2               	sta (z80_hlp),y 	; bung it in.
002A43r 2               
002A43r 2               ; next row of sprite data
002A43r 2               
002A43r 2               	inx
002A43r 2               
002A43r 2               ; _BEEB screen arrangement
002A43r 2               
002A43r 2               	lda z80_lp 			; get low byte of address.
002A43r 2               	and #15
002A43r 2               	cmp #15				; is this last line of row?
002A43r 2               	beq :+
002A43r 2               
002A43r 2               	; within same row can't increment page
002A43r 2               	inc z80_lp			; new low byte of address.
002A43r 2               	rts
002A43r 2               
002A43r 2               :
002A43r 2               	clc
002A43r 2               	lda z80_lp
002A43r 2               	adc #<(ScreenRowBytes-15)
002A43r 2               	sta z80_lp			; new low byte of address.
002A43r 2               	lda z80_lp+1
002A43r 2               	adc #>(ScreenRowBytes-15)
002A43r 2               	sta z80_lp+1		; new high byte of address.
002A43r 2               	rts
002A43r 2               .endif
002A43r 2               
002A43r 2               ;----------------------------------------------------
002A43r 2               ; SPRINTEINK
002A43r 2               ;----------------------------------------------------
002A43r 2               
002A43r 2               cspr:
002A43r 2  A5 rr        	lda z80_c
002A45r 2  A0 11        	ldy #17
002A47r 2  91 rr        	sta (z80_ix),y
002A49r 2  20 rr rr     	jsr cspr_new
002A4Cr 2  60           	rts
002A4Dr 2               
002A4Dr 2               cspr_new:
002A4Dr 2  A0 08        	ldy #8
002A4Fr 2  B1 rr        	lda (z80_ix),y			; Get sprite y
002A51r 2  4C rr rr     	jmp cspr_go
002A54r 2               cspr_old:
002A54r 2  A0 03        	ldy #3
002A56r 2  B1 rr        	lda(z80_ix),y
002A58r 2               cspr_go:
002A58r 2  85 rr        	sta dispy
002A5Ar 2  C9 B1        	cmp #8*ScrHeight+1		; Check if on screen
002A5Cr 2  90 01        	bcc :+
002A5Er 2  60           	rts
002A5Fr 2               :
002A5Fr 2  C8           	iny
002A60r 2  B1 rr        	lda (z80_ix),y			; Get sprite x
002A62r 2  85 rr        	sta dispx
002A64r 2               
002A64r 2               ; Calculate colour attribte address in scraddr
002A64r 2               
002A64r 2  20 rr rr     	jsr coladdr
002A67r 2               
002A67r 2               ; Set number of rows
002A67r 2               
002A67r 2  A9 02        	lda #2
002A69r 2  85 rr        	sta z80_b
002A6Br 2  A5 rr        	lda dispy
002A6Dr 2  29 0F        	and #15
002A6Fr 2  D0 02        	bne :+
002A71r 2  C6 rr        	dec z80_b
002A73r 2               :
002A73r 2               ; Loop to colour row blocks
002A73r 2               
002A73r 2               cspr0:
002A73r 2  A0 00        	ldy #0
002A75r 2  A5 rr        	lda z80_c
002A77r 2  91 rr        	sta (scraddr),y
002A79r 2               cspr6:
002A79r 2  A0 01        	ldy #1
002A7Br 2  91 rr        	sta (scraddr),y
002A7Dr 2               cspr7:
002A7Dr 2  A5 rr        	lda dispx
002A7Fr 2  29 07        	and #7
002A81r 2  F0 06        	beq cspr1
002A83r 2               
002A83r 2  A0 02        	ldy #2
002A85r 2  A5 rr        	lda z80_c
002A87r 2  91 rr        	sta (scraddr),y
002A89r 2               cspr1:
002A89r 2  A5 rr        	lda scraddr
002A8Br 2  18           	clc
002A8Cr 2  69 16        	adc #22
002A8Er 2  85 rr        	sta scraddr
002A90r 2  90 02        	bcc :+
002A92r 2  E6 rr        	inc scraddr+1
002A94r 2               :
002A94r 2  C6 rr        	dec z80_b
002A96r 2  D0 DB        	bne cspr0
002A98r 2  60           	rts
002A99r 2               
002A99r 2               ; Calculate colour attribte address
002A99r 2               ; scraddr = COLOR + dispy/16 + dispx/8
002A99r 2               
002A99r 2               coladdr:
002A99r 2  A5 rr        	lda dispy
002A9Br 2  4A           	lsr a
002A9Cr 2  4A           	lsr a
002A9Dr 2  4A           	lsr a
002A9Er 2  4A           	lsr a
002A9Fr 2  A8           	tay
002AA0r 2  B9 55 0A     	lda COLATTTB_hb,y
002AA3r 2  85 rr        	sta scraddr+1
002AA5r 2  B9 4A 0A     	lda COLATTTB_lb,y
002AA8r 2  85 rr        	sta scraddr
002AAAr 2  A5 rr        	lda dispx
002AACr 2  4A           	lsr a
002AADr 2  4A           	lsr a
002AAEr 2  4A           	lsr a
002AAFr 2  18           	clc
002AB0r 2  65 rr        	adc scraddr
002AB2r 2  85 rr        	sta scraddr
002AB4r 2  90 02        	bcc :+
002AB6r 2  E6 rr        	inc scraddr+1
002AB8r 2               :
002AB8r 2  60           	rts
002AB9r 2               
002AB9r 2               ;----------------------------------------------------
002AB9r 2               ; Display character in A at dispx,dispy.
002AB9r 2               ;
002AB9r 2               ; Input:
002AB9r 2               ;  A 	   = character to print
002AB9r 2               ;----------------------------------------------------
002AB9r 2               
002AB9r 2               pchar:
002AB9r 2  85 rr        	sta fntaddr
002ABBr 2  A9 00        	lda #0
002ABDr 2  85 rr        	sta fntaddr+1
002ABFr 2  06 rr        	asl fntaddr  		; multiply char by 8.
002AC1r 2  26 rr        	rol fntaddr+1
002AC3r 2  06 rr        	asl fntaddr
002AC5r 2  26 rr        	rol fntaddr+1
002AC7r 2  06 rr        	asl fntaddr
002AC9r 2  26 rr        	rol fntaddr+1
002ACBr 2               
002ACBr 2  A5 rr        	lda fntaddr
002ACDr 2  18           	clc
002ACEr 2  69 rr        	adc #<(FONT-256)
002AD0r 2  85 rr        	sta fntaddr		; that's the low byte.
002AD2r 2  A5 rr        	lda fntaddr+1
002AD4r 2  69 rr        	adc #>(FONT-256)
002AD6r 2  85 rr        	sta fntaddr+1		; add displacement.
002AD8r 2               
002AD8r 2               pchark:
002AD8r 2  20 rr rr     	jsr gaadd		; set colour attribute
002ADBr 2  AD rr rr     	lda fontcol
002ADEr 2  A0 00        	ldy #0
002AE0r 2  91 rr        	sta (bufaddr),y
002AE2r 2               
002AE2r 2  20 rr rr     	jsr gprad		; get screen address.
002AE5r 2  A2 07        	ldx #7			; lines to write.
002AE7r 2               pchar0:
002AE7r 2  A0 00        	ldy #0
002AE9r 2  B1 rr        	lda (fntaddr),y 	; get image byte.
002AEBr 2  BC rr rr     	ldy scrtab,x		; Get rowoffset
002AEEr 2               .if iflag
002AEEr 2               	eor #TxtInvert		; Invert
002AEEr 2               .endif
002AEEr 2  91 rr        	sta (scraddr),y 	; copy to screen.
002AF0r 2  E6 rr        	inc fntaddr		; next image byte.
002AF2r 2  D0 02        	bne :+
002AF4r 2  E6 rr        	inc fntaddr+1
002AF6r 2               :
002AF6r 2  CA           	dex			; next screen row down.
002AF7r 2  10 EE        	bpl pchar0		; repeat.
002AF9r 2               
002AF9r 2  60           	rts
002AFAr 2               
002AFAr 2  07 06 05 04  scrtab:		.byte $07,$06,$05,$04,$03,$02,$01,$00
002AFEr 2  03 02 01 00  
002B02r 2               
002B02r 2               ;----------------------------------------------------
002B02r 2               ; LoadFile
002B02r 2               ;----------------------------------------------------
002B02r 2               
002B02r 2               loadfile:
002B02r 2  AA           	tax
002B03r 2  A9 rr        	lda #<msgdat		; pointer to messages.
002B05r 2  85 rr        	sta z80_l
002B07r 2  A9 rr        	lda #>msgdat
002B09r 2  85 rr        	sta z80_h
002B0Br 2  20 rr rr     	jsr getwrd		; get message number.
002B0Er 2               
002B0Er 2               ; Init screen for NTSC
002B0Er 2               ; this sets the background and border color of the screen
002B0Er 2               ; in this case border black and background black
002B0Er 2               
002B0Er 2  A9 08        	lda #%00001000
002B10r 2  8D 0F 90     	sta RegF
002B13r 2               
002B13r 2               ; z80_hl should point to the textstring now.
002B13r 2               ; Read filename +length into buffer
002B13r 2               
002B13r 2  A0 00        	ldy #0
002B15r 2               nameloop:
002B15r 2  B1 rr        	lda (z80_hl),y
002B17r 2  30 07        	bmi lastchar
002B19r 2  99 rr rr     	sta filename,y
002B1Cr 2  C8           	iny
002B1Dr 2  4C rr rr     	jmp nameloop
002B20r 2               lastchar:
002B20r 2  29 7F        	and #$7f
002B22r 2  99 rr rr     	sta filename,y
002B25r 2  C8           	iny
002B26r 2  8C rr rr     	sty filelen
002B29r 2               
002B29r 2               ; Which device to use (in A the file num 1 is OK - x with 8 is the type of device
002B29r 2               ;                       usually the first drive, and y set to 1 reads from the header
002B29r 2               ;                       of the file the location where to save it)
002B29r 2  A9 01        	lda #1
002B2Br 2  A2 08        	ldx #8		; Disk device
002B2Dr 2  A0 01        	ldy #1
002B2Fr 2  20 BA FF     	jsr $ffba
002B32r 2               
002B32r 2               ; Load the file name (in accumulator the size of the string
002B32r 2               ;                      containing the name, x low address for FileName,
002B32r 2               ;                      y high address for FileName)
002B32r 2  AD rr rr     	lda filelen
002B35r 2  A2 rr        	ldx #<filename
002B37r 2  A0 rr        	ldy #>filename
002B39r 2  20 BD FF     	jsr $ffbd
002B3Cr 2               
002B3Cr 2               ; load from disk to ram
002B3Cr 2  A9 00        	lda #0		; accumulator must be set to 0 to load the image
002B3Er 2  A2 FF        	ldx #<$ff	; target location low not set (got from header)
002B40r 2  A0 00        	ldy #>$ff	; target location high (got from header)
002B42r 2  20 D5 FF     	jsr $ffd5
002B45r 2               
002B45r 2  60           	rts
002B46r 2               
002B46r 2               filename:
002B46r 2  00 00 00 00  	.byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
002B4Ar 2  00 00 00 00  
002B4Er 2  00 00 00 00  
002B56r 2  00 00 00 00  	.byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
002B5Ar 2  00 00 00 00  
002B5Er 2  00 00 00 00  
002B66r 2               filelen:
002B66r 2  00           	.byte 0
002B67r 2               
002B67r 2               ;----------------------------------------------------
002B67r 2               ; Sound
002B67r 2               ;----------------------------------------------------
002B67r 2               
002B67r 2               ; Actual memory locations
002B67r 2               
002B67r 2               CHANNEL1_ENABLED  = $ea
002B67r 2               CHANNEL2_ENABLED  = $eb
002B67r 2               CHANNEL3_ENABLED  = $ec
002B67r 2               CHANNEL4_ENABLED  = $ed
002B67r 2               MUSIC_ON		  = $ee
002B67r 2               
002B67r 2  0A 19 10 40  SetSoundVars:		.byte $0a, $19, $10, $40
002B6Br 2  0A 19 10 40  SetSoundDuration:	.byte $0a, $19, $10, $40
002B6Fr 2  DE           SetSoundTone: 		.byte $de
002B70r 2               
002B70r 2               ;--------------------------------------------
002B70r 2               ;                      SOUND    0   1   2   3
002B70r 2               ;--------------------------------------------
002B70r 2  C8 C8 DE DC  SndTone:		.byte 200,200,222,220
002B74r 2  01 00 03 01  SndChannel:		.byte   1,  0,  3,  1
002B78r 2  3C 3C 3C 28  SndDuration:		.byte  60, 60, 60, 40
002B7Cr 2               
002B7Cr 2               ;--------------------------------------------
002B7Cr 2               ; Called by SOUND with parameter in A
002B7Cr 2               ;--------------------------------------------
002B7Cr 2               
002B7Cr 2               playsound:
002B7Cr 2  A8           	tay
002B7Dr 2  B9 rr rr     	lda SndTone,y		; lda $a0
002B80r 2  8D rr rr     	sta SetSoundTone	; sta SetSoundTone
002B83r 2  B9 rr rr     	lda SndDuration,y	; lda $a2
002B86r 2  BE rr rr     	ldx SndChannel,y	; ldx $a1
002B89r 2  9D rr rr     	sta SetSoundDuration,x	; sta SetSoundDuration,x
002B8Cr 2  B9 rr rr     	lda SndTone,y		; lda $a0
002B8Fr 2  9D rr rr     	sta SetSoundVars,x	; sta SetSoundVars,x
002B92r 2  60           	rts
002B93r 2               
002B93r 2               ;--------------------------------------------
002B93r 2               ; Make sound
002B93r 2               ; Called by vsync every frame
002B93r 2               ;--------------------------------------------
002B93r 2               
002B93r 2               make_sound2:
002B93r 2  A0 00        	ldy #$00
002B95r 2  AE rr rr     	ldx SetSoundTone
002B98r 2  AD rr rr     	lda SetSoundVars
002B9Br 2  CD rr rr     	cmp SetSoundDuration
002B9Er 2  B0 1C        	bcs l0366
002BA0r 2               
002BA0r 2  AD rr rr     	lda SetSoundVars
002BA3r 2  CD rr rr     	cmp SetSoundDuration
002BA6r 2  D0 07        	bne :+
002BA8r 2  A5 EE        	lda MUSIC_ON
002BAAr 2  85 EA        	sta CHANNEL1_ENABLED	; Enable channel 1
002BACr 2  4C rr rr     	jmp l0374
002BAFr 2               :
002BAFr 2               
002BAFr 2  A9 00        	lda #$0
002BB1r 2  85 EA        	sta CHANNEL1_ENABLED	; Enable channel 1
002BB3r 2  EE rr rr     	inc SetSoundVars
002BB6r 2  EE 0A 90     	inc RegA
002BB9r 2  4C rr rr     	jmp l0374
002BBCr 2               
002BBCr 2  8C 0A 90     l0366:	sty RegA
002BBFr 2  EC rr rr     	cpx SetSoundVars
002BC2r 2  D0 06        	bne l0374
002BC4r 2  8C rr rr     	sty SetSoundVars
002BC7r 2  8E 0A 90     	stx RegA
002BCAr 2               
002BCAr 2  AD rr rr     l0374:	lda SetSoundVars+1
002BCDr 2  CD rr rr     	cmp SetSoundDuration+1
002BD0r 2  D0 07        	bne :+
002BD2r 2  A5 EE        	lda MUSIC_ON
002BD4r 2  85 EB        	sta CHANNEL2_ENABLED	; Enable channel 1
002BD6r 2  4C rr rr     	jmp l0392
002BD9r 2               :
002BD9r 2  A9 00        	lda #$0
002BDBr 2  85 EB        	sta CHANNEL2_ENABLED	; Enable channel 2
002BDDr 2  AD rr rr     	lda SetSoundVars+1
002BE0r 2  CD rr rr     	cmp SetSoundDuration+1
002BE3r 2  B0 09        	bcs l0384
002BE5r 2  EE rr rr     	inc SetSoundVars+1
002BE8r 2  EE 0B 90     	inc RegB
002BEBr 2  4C rr rr     	jmp l0392
002BEEr 2               
002BEEr 2  8C 0B 90     l0384:	sty RegB
002BF1r 2  EC rr rr     	cpx SetSoundVars+1
002BF4r 2  D0 06        	bne l0392
002BF6r 2  8C rr rr     	sty SetSoundVars+1
002BF9r 2  8E 0B 90     	stx RegB
002BFCr 2               
002BFCr 2  AD rr rr     l0392:	lda SetSoundVars+2
002BFFr 2  CD rr rr     	cmp SetSoundDuration+2
002C02r 2  D0 07        	bne :+
002C04r 2  A5 EE        	lda MUSIC_ON
002C06r 2  85 EC        	sta CHANNEL3_ENABLED	; Enable channel 1
002C08r 2  4C rr rr     	jmp l03b0
002C0Br 2               :
002C0Br 2  A9 00        	lda #$0
002C0Dr 2  85 EC        	sta CHANNEL3_ENABLED	; Enable channel 3
002C0Fr 2  AD rr rr     	lda SetSoundVars+2
002C12r 2  CD rr rr     	cmp SetSoundDuration+2
002C15r 2  B0 09        	bcs l03a2
002C17r 2  EE rr rr     	inc SetSoundVars+2
002C1Ar 2  CE 0C 90     	dec RegC
002C1Dr 2  4C rr rr     	jmp l03b0
002C20r 2               
002C20r 2  8C 0C 90     l03a2:	sty RegC
002C23r 2  EC rr rr     	cpx SetSoundVars+2
002C26r 2  D0 06        	bne l03b0
002C28r 2  8C rr rr     	sty SetSoundVars+2
002C2Br 2  8E 0C 90     	stx RegC
002C2Er 2               
002C2Er 2  AD rr rr     l03b0:	lda SetSoundVars+3
002C31r 2  CD rr rr     	cmp SetSoundDuration+3
002C34r 2  D0 07        	bne :+
002C36r 2  A5 EE        	lda MUSIC_ON
002C38r 2  85 ED        	sta CHANNEL4_ENABLED	; Enable channel 1
002C3Ar 2  4C rr rr     	jmp l03d3
002C3Dr 2               :
002C3Dr 2               
002C3Dr 2               	; lda SetSoundVars+3
002C3Dr 2               	; cmp SetSoundDuration+3
002C3Dr 2               	; beq l03e1
002C3Dr 2               
002C3Dr 2  A9 00        	lda #$0
002C3Fr 2  85 ED        	sta CHANNEL4_ENABLED	; Enable channel 4
002C41r 2               
002C41r 2  AD rr rr     	lda SetSoundVars+3
002C44r 2  CD rr rr         cmp SetSoundDuration+3 ; $03b3 $03b4
002C47r 2  B0 1C            bcs l03d3
002C49r 2               
002C49r 2  EE rr rr     	inc SetSoundVars+3
002C4Cr 2  AD rr rr     	lda SetSoundVars+3
002C4Fr 2  C9 16        	cmp #$16
002C51r 2  D0 07        	bne l03c8
002C53r 2  A9 B0        	lda #$b0
002C55r 2  8D 0D 90     	sta RegD
002C58r 2  F0 19        	beq l03e1
002C5Ar 2  C9 2B        l03c8:	cmp #$2b
002C5Cr 2  D0 15        	bne l03e1
002C5Er 2  A9 A0        	lda #$a0
002C60r 2  8D 0D 90     	sta RegD
002C63r 2  F0 0E        	beq l03e1
002C65r 2  8C 0D 90     l03d3:	sty RegD
002C68r 2  EC rr rr     	cpx SetSoundVars+3
002C6Br 2  D0 06        	bne l03e1
002C6Dr 2  8C rr rr     	sty SetSoundVars+3
002C70r 2  8E 0D 90     	stx RegD
002C73r 2               
002C73r 2  60           l03e1:	rts
002C74r 2               
002C74r 2               ;----------------------------------------------------
002C74r 2               ; Set video registers
002C74r 2               ;----------------------------------------------------
002C74r 2               
002C74r 2               SetReg:
002C74r 2  8D rr rr     	sta mode
002C77r 2  0A           	asl a
002C78r 2  18           	clc
002C79r 2  6D rr rr     	adc crtflag
002C7Cr 2  AA           	tax
002C7Dr 2  BD rr rr     	lda centreX,x
002C80r 2  8D 00 90     	sta Reg0
002C83r 2  BD rr rr     	lda centreY,x
002C86r 2  8D 01 90     	sta Reg1
002C89r 2  BD rr rr     	lda scrW,x
002C8Cr 2  8D 02 90     	sta Reg2
002C8Fr 2  BD rr rr     	lda scrH,x
002C92r 2  8D 03 90     	sta Reg3
002C95r 2  BD rr rr     	lda RAMset,x
002C98r 2  8D 05 90     	sta Reg5
002C9Br 2  60           	rts
002C9Cr 2               
002C9Cr 2  04 0C 06 0E  centreX:	.byte $04,$0c,$06,$0e
002CA0r 2  1B 26 18 24  centreY:	.byte $1b,$26,$18,$24
002CA4r 2  96 96 14 14  scrW:		.byte $96,$96,$14,$14
002CA8r 2  17 17 19 19  scrH:		.byte $17,$17,$19,$19
002CACr 2  8C 8C CC CC  RAMset:		.byte $8c,$8c,$cc,$cc
002CB0r 2  84 A0 84 A0  BottomScr:	.byte $84,$a0,$84,$a0
002CB4r 2               
002CB4r 2               ;----------------------------------------------------
002CB4r 2               ; Display functions
002CB4r 2               ;
002CB4r 2               ; DISPLAYON   resets CentreY
002CB4r 2               ; DISPLAYOFF  locates screen below bottom
002CB4r 2               ; DISPLAYUP   scrolls screen up until default CentreY
002CB4r 2               ; DISPLAYDOWN scrolls screen down until below bottom
002CB4r 2               ;----------------------------------------------------
002CB4r 2               
002CB4r 2               dispon:
002CB4r 2  AD rr rr     	lda mode
002CB7r 2  0A           	asl a
002CB8r 2  18           	clc
002CB9r 2  6D rr rr     	adc crtflag
002CBCr 2  AA           	tax
002CBDr 2  BD rr rr     	lda centreY,x
002CC0r 2  8D 01 90     	sta Reg1
002CC3r 2  60           	rts
002CC4r 2               
002CC4r 2               dispoff:
002CC4r 2  AD rr rr     	lda mode
002CC7r 2  0A           	asl a
002CC8r 2  18           	clc
002CC9r 2  6D rr rr     	adc crtflag
002CCCr 2  AA           	tax
002CCDr 2  BD rr rr     	lda BottomScr,x
002CD0r 2  8D 01 90     	sta Reg1
002CD3r 2  60           	rts
002CD4r 2               
002CD4r 2               dispup:
002CD4r 2  AD rr rr     	lda mode
002CD7r 2  0A           	asl a
002CD8r 2  18           	clc
002CD9r 2  6D rr rr     	adc crtflag
002CDCr 2  AA           	tax
002CDDr 2  BD rr rr     	lda centreY,x
002CE0r 2  85 rr        	sta tmp
002CE2r 2               scr_down_loop:
002CE2r 2  A9 01        	lda #1
002CE4r 2  20 rr rr     	jsr delay
002CE7r 2  CE 01 90     	dec Reg1
002CEAr 2  AD 01 90     	lda Reg1
002CEDr 2  C5 rr        	cmp tmp
002CEFr 2  D0 F1        	bne scr_down_loop
002CF1r 2  60           	rts
002CF2r 2               
002CF2r 2               dispdown:
002CF2r 2  AD rr rr     	lda mode
002CF5r 2  0A           	asl a
002CF6r 2  18           	clc
002CF7r 2  6D rr rr     	adc crtflag
002CFAr 2  AA           	tax
002CFBr 2  A9 01        	lda #1
002CFDr 2  20 rr rr     	jsr delay
002D00r 2  EE 01 90     	inc Reg1
002D03r 2  AD 01 90     	lda Reg1
002D06r 2  DD rr rr     	cmp BottomScr,x
002D09r 2  D0 E7        	bne dispdown
002D0Br 2  60           	rts
002D0Cr 2               
002D0Cr 1               ;	.include "music.inc"
002D0Cr 1               ;colscr:	.incbin "..\pictures\slasher3c"
002D0Cr 1               ;datscr:	.incbin "..\pictures\slasher3d"
002D0Cr 1               
002D0Cr 1               	.include "z80.asm"
002D0Cr 2               ;------------------------------------------------------
002D0Cr 2               ; z80.asm
002D0Cr 2               ; spectrum stuff
002D0Cr 2               ; adresses
002D0Cr 2               
002D0Cr 2               ;ws	 = $60
002D0Cr 2               
002D0Cr 2               ;z80_f	 = ws+$00
002D0Cr 2               ;z80_a	 = ws+$01
002D0Cr 2               ;z80_af	 = z80_f
002D0Cr 2               
002D0Cr 2               ;z80_c	 = ws+$02
002D0Cr 2               ;z80_b	 = ws+$03
002D0Cr 2               ;z80_bc	 = z80_c
002D0Cr 2               
002D0Cr 2               ;z80_e	 = ws+$04
002D0Cr 2               ;z80_d	 = ws+$05
002D0Cr 2               ;z80_de	 = z80_e
002D0Cr 2               
002D0Cr 2               ;z80_l	 = ws+$06
002D0Cr 2               ;z80_h	 = ws+$07
002D0Cr 2               ;z80_hl	 = z80_l
002D0Cr 2               
002D0Cr 2               ;z80_x    = ws+$08
002D0Cr 2               ;z80_i    = ws+$09
002D0Cr 2               ;z80_ix	 = z80_x
002D0Cr 2               
002D0Cr 2               ;z80_iy	 = ws+$0a
002D0Cr 2               
002D0Cr 2               ;z80_fp	 = ws+$0c
002D0Cr 2               ;z80_ap	 = ws+$0d
002D0Cr 2               
002D0Cr 2               ;z80_cp	 = ws+$0e
002D0Cr 2               ;z80_bp	 = ws+$0f
002D0Cr 2               ;z80_bcp = z80_cp
002D0Cr 2               
002D0Cr 2               ;z80_ep	 = ws+$10
002D0Cr 2               ;z80_dp	 = ws+$11
002D0Cr 2               ;z80_dep = z80_ep
002D0Cr 2               
002D0Cr 2               ;z80_lp	 = ws+$12
002D0Cr 2               ;z80_hp	 = ws+$13
002D0Cr 2               ;z80_hlp = z80_lp
002D0Cr 2               
002D0Cr 2               ;z80_sp   = ws+$14
002D0Cr 2               
002D0Cr 2               ;z80_reg0 = ws+$16
002D0Cr 2               ;z80_reg1 = ws+$17
002D0Cr 2               ;z80_reg2 = ws+$18
002D0Cr 2               ;z80_reg3 = ws+$19
002D0Cr 2               
002D0Cr 2               ;z80_r	 = ws+$1a
002D0Cr 2               
002D0Cr 2               ; Contains seperatly 1 bit set
002D0Cr 2               ; _BEEB this is not safe memory to use as required by MOS
002D0Cr 2               
002D0Cr 2               _bitmem0	= $f8
002D0Cr 2               _bitmem1	= $f9
002D0Cr 2               _bitmem2	= $fa
002D0Cr 2               _bitmem3	= $fb
002D0Cr 2               _bitmem4	= $fc
002D0Cr 2               _bitmem5	= $fd
002D0Cr 2               _bitmem6	= $fe
002D0Cr 2               _bitmem7	= $ff
002D0Cr 2               
002D0Cr 2               ; constants
002D0Cr 2               _bitvalue0	= $01
002D0Cr 2               _bitvalue1	= $02
002D0Cr 2               _bitvalue2	= $04
002D0Cr 2               _bitvalue3	= $08
002D0Cr 2               _bitvalue4	= $10
002D0Cr 2               _bitvalue5	= $20
002D0Cr 2               _bitvalue6	= $40
002D0Cr 2               _bitvalue7	= $80
002D0Cr 2               
002D0Cr 2               _notbitvalue0	= $fe
002D0Cr 2               _notbitvalue1	= $fd
002D0Cr 2               _notbitvalue2	= $fb
002D0Cr 2               _notbitvalue3	= $f7
002D0Cr 2               _notbitvalue4	= $ef
002D0Cr 2               _notbitvalue5	= $df
002D0Cr 2               _notbitvalue6	= $bf
002D0Cr 2               _notbitvalue7	= $7f
002D0Cr 2               
002D0Cr 2               
002D0Cr 2               ;add_hl_bc:
002D0Cr 2               ;		lda z80_l
002D0Cr 2               ;		clc
002D0Cr 2               ;		adc z80_c
002D0Cr 2               ;		sta z80_l
002D0Cr 2               ;		lda z80_h
002D0Cr 2               ;		adc z80_b
002D0Cr 2               ;		sta z80_h
002D0Cr 2               ;		rts
002D0Cr 2               ;
002D0Cr 2               ;add_ix_de:
002D0Cr 2               ;		lda z80_ix
002D0Cr 2               ;		clc
002D0Cr 2               ;		adc z80_e
002D0Cr 2               ;		sta z80_ix
002D0Cr 2               ;		lda z80_ix+1
002D0Cr 2               ;		adc z80_d
002D0Cr 2               ;		sta z80_ix+1
002D0Cr 2               ;		rts
002D0Cr 2               ;
002D0Cr 2               ;add_iy_de:
002D0Cr 2               ;		lda z80_iy
002D0Cr 2               ;		clc
002D0Cr 2               ;		adc z80_e
002D0Cr 2               ;		sta z80_iy
002D0Cr 2               ;		lda z80_iy+1
002D0Cr 2               ;		adc z80_d
002D0Cr 2               ;		sta z80_iy+1
002D0Cr 2               ;		rts
002D0Cr 2               ;
002D0Cr 2               ;add_hl_de:
002D0Cr 2               ;		lda z80_l
002D0Cr 2               ;		clc
002D0Cr 2               ;		adc z80_e
002D0Cr 2               ;		sta z80_l
002D0Cr 2               ;		lda z80_h
002D0Cr 2               ;		adc z80_d
002D0Cr 2               ;		sta z80_h
002D0Cr 2               ;		rts
002D0Cr 2               ;
002D0Cr 2               ;add_ix_bc:
002D0Cr 2               ;		lda z80_ix
002D0Cr 2               ;		clc
002D0Cr 2               ;		adc z80_c
002D0Cr 2               ;		sta z80_ix
002D0Cr 2               ;		lda z80_ix+1
002D0Cr 2               ;		adc z80_b
002D0Cr 2               ;		sta z80_ix+1
002D0Cr 2               ;		rts
002D0Cr 2               ;
002D0Cr 2               ;add_iy_bc:
002D0Cr 2               ;		lda z80_iy
002D0Cr 2               ;		clc
002D0Cr 2               ;		adc z80_c
002D0Cr 2               ;		sta z80_iy
002D0Cr 2               ;		lda z80_iy+1
002D0Cr 2               ;		adc z80_b
002D0Cr 2               ;		sta z80_iy+1
002D0Cr 2               ;		rts
002D0Cr 2               ;
002D0Cr 2               ;sbc_hl_de:
002D0Cr 2               ;		lda z80_l
002D0Cr 2               ;		sbc z80_e
002D0Cr 2               ;		sta z80_l
002D0Cr 2               ;		lda z80_h
002D0Cr 2               ;		sbc z80_d
002D0Cr 2               ;		sta z80_h
002D0Cr 2               ;		rts
002D0Cr 2               ;
002D0Cr 2               ;sbc_hl_bc:
002D0Cr 2               ;		lda z80_l
002D0Cr 2               ;		sbc z80_c
002D0Cr 2               ;		sta z80_l
002D0Cr 2               ;		lda z80_h
002D0Cr 2               ;		sbc z80_b
002D0Cr 2               ;		sta z80_h
002D0Cr 2               ;		rts
002D0Cr 2               ;
002D0Cr 2               ;cmp_hl_bc:
002D0Cr 2               ;		lda z80_l
002D0Cr 2               ;		cmp z80_c
002D0Cr 2               ;		bne cmp_hl_bc_end
002D0Cr 2               ;		lda z80_h
002D0Cr 2               ;		cmp z80_b
002D0Cr 2               ;cmp_hl_bc_end:
002D0Cr 2               ;		rts
002D0Cr 2               ;
002D0Cr 2               ;cmp_iy_ix:
002D0Cr 2               ;		lda z80_iy
002D0Cr 2               ;		cmp z80_ix
002D0Cr 2               ;		bne cmp_iy_ix_end
002D0Cr 2               ;		lda z80_iy+1
002D0Cr 2               ;		cmp z80_ix+1
002D0Cr 2               ;cmp_iy_ix_end:
002D0Cr 2               ;		rts
002D0Cr 2               ;
002D0Cr 2               ;dec_hl:
002D0Cr 2               ;		lda z80_l
002D0Cr 2               ;		bne dec_hl_no_dec_h
002D0Cr 2               ;		dec z80_h
002D0Cr 2               ;dec_hl_no_dec_h:
002D0Cr 2               ;		dec z80_l
002D0Cr 2               ;		rts
002D0Cr 2               ;
002D0Cr 2               ;dec_ix:
002D0Cr 2               ;		lda z80_ix
002D0Cr 2               ;		bne dec_ix_no_dec_h
002D0Cr 2               ;		dec z80_ix+1
002D0Cr 2               ;dec_ix_no_dec_h:
002D0Cr 2               ;		dec z80_ix
002D0Cr 2               ;		rts
002D0Cr 2               ;
002D0Cr 2               ;dec_bc:
002D0Cr 2               ;		lda z80_c
002D0Cr 2               ;		bne dec_bc_no_dec_b
002D0Cr 2               ;		dec z80_b
002D0Cr 2               ;dec_bc_no_dec_b:
002D0Cr 2               ;		dec z80_c
002D0Cr 2               ;		rts
002D0Cr 2               ;
002D0Cr 2               ;dec_de:
002D0Cr 2               ;		lda z80_e
002D0Cr 2               ;		bne dec_de_no_dec_d
002D0Cr 2               ;		dec z80_d
002D0Cr 2               ;dec_de_no_dec_d:
002D0Cr 2               ;		dec z80_e
002D0Cr 2               ;		rts
002D0Cr 2               ;
002D0Cr 2               ;ex_af_afs:
002D0Cr 2               ;	rts
002D0Cr 2               ;ex_de_hl:
002D0Cr 2               ;		lda z80_e
002D0Cr 2               ;		ldx z80_l
002D0Cr 2               ;		stx z80_e
002D0Cr 2               ;		sta z80_l
002D0Cr 2               ;		lda z80_d
002D0Cr 2               ;		ldx z80_h
002D0Cr 2               ;		stx z80_d
002D0Cr 2               ;		sta z80_h
002D0Cr 2               ;		rts
002D0Cr 2               ;
002D0Cr 2               exx:
002D0Cr 2  A5 rr        		lda z80_c
002D0Er 2  A4 rr        		ldy z80_cp
002D10r 2  84 rr        		sty z80_c
002D12r 2  85 rr        		sta z80_cp
002D14r 2  A5 rr        		lda z80_b
002D16r 2  A4 rr        		ldy z80_bp
002D18r 2  84 rr        		sty z80_b
002D1Ar 2  85 rr        		sta z80_bp
002D1Cr 2  A5 rr        		lda z80_e
002D1Er 2  A4 rr        		ldy z80_ep
002D20r 2  84 rr        		sty z80_e
002D22r 2  85 rr        		sta z80_ep
002D24r 2  A5 rr        		lda z80_d
002D26r 2  A4 rr        		ldy z80_dp
002D28r 2  84 rr        		sty z80_d
002D2Ar 2  85 rr        		sta z80_dp
002D2Cr 2  A5 rr        		lda scraddr
002D2Er 2  A4 rr        		ldy z80_lp
002D30r 2  84 rr        		sty scraddr
002D32r 2  85 rr        		sta z80_lp
002D34r 2  A5 rr        		lda scraddr+1
002D36r 2  A4 rr        		ldy z80_hp
002D38r 2  84 rr        		sty scraddr+1
002D3Ar 2  85 rr        		sta z80_hp
002D3Cr 2  60           		rts
002D3Dr 2               
002D3Dr 2               ;ex_sp_hl:
002D3Dr 2               ;		tsx
002D3Dr 2               ;		lda $0103,x
002D3Dr 2               ;		ldy z80_h
002D3Dr 2               ;		sta z80_h
002D3Dr 2               ;		tya
002D3Dr 2               ;		sta $0103,x
002D3Dr 2               ;		lda $0104,x
002D3Dr 2               ;		ldy z80_l
002D3Dr 2               ;		sta z80_l
002D3Dr 2               ;		tya
002D3Dr 2               ;		sta $104,x
002D3Dr 2               ;		rts
002D3Dr 2               ;
002D3Dr 2               ;ldi:
002D3Dr 2               ;	rts
002D3Dr 2               ;ldir:
002D3Dr 2               ;		ldy #$00
002D3Dr 2               ;		ldx z80_b
002D3Dr 2               ;		beq ldir_last_page
002D3Dr 2               ;ldir_loop:
002D3Dr 2               ;		lda (z80_hl),y
002D3Dr 2               ;		sta (z80_de),y
002D3Dr 2               ;		iny
002D3Dr 2               ;		bne ldir_loop
002D3Dr 2               ;		inc z80_h
002D3Dr 2               ;		inc z80_d
002D3Dr 2               ;		dex
002D3Dr 2               ;		bne ldir_loop
002D3Dr 2               ;ldir_last_page:
002D3Dr 2               ;		lda z80_c
002D3Dr 2               ;		beq ldir_end
002D3Dr 2               ;ldir_last_page_loop:
002D3Dr 2               ;		lda (z80_hl),y
002D3Dr 2               ;		sta (z80_de),y
002D3Dr 2               ;		iny
002D3Dr 2               ;		cpy z80_c
002D3Dr 2               ;		bne ldir_last_page_loop
002D3Dr 2               ;ldir_end:
002D3Dr 2               ;		stx z80_c
002D3Dr 2               ;		stx z80_b
002D3Dr 2               ;		tya
002D3Dr 2               ;		clc
002D3Dr 2               ;		adc z80_l
002D3Dr 2               ;		sta z80_l
002D3Dr 2               ;		bcc *+4
002D3Dr 2               ;		inc z80_h
002D3Dr 2               ;		tya
002D3Dr 2               ;		clc
002D3Dr 2               ;		adc z80_e
002D3Dr 2               ;		sta z80_e
002D3Dr 2               ;		bcc *+4
002D3Dr 2               ;		inc z80_d
002D3Dr 2               ;		rts
002D3Dr 2               ;
002D3Dr 2               ;lddr:		ldy #$00
002D3Dr 2               ;lddr_loop:
002D3Dr 2               ;		lda (z80_hl),y
002D3Dr 2               ;		sta (z80_de),y
002D3Dr 2               ;		jsr dec_hl
002D3Dr 2               ;		jsr dec_de
002D3Dr 2               ;		jsr dec_bc
002D3Dr 2               ;		lda z80_b
002D3Dr 2               ;		ora z80_c
002D3Dr 2               ;		bne lddr_loop
002D3Dr 2               ;		rts
002D3Dr 2               ;ei:
002D3Dr 2               ;		rts
002D3Dr 2               ;di:
002D3Dr 2               ;		rts
002D3Dr 2               
002D3Dr 2               ;-------------------------------------------------------------
002D3Dr 2               ; Set bits in bitmem
002D3Dr 2               ;-------------------------------------------------------------
002D3Dr 2               
002D3Dr 2               .if 0
002D3Dr 2               z80_init:
002D3Dr 2               	ldx #$00
002D3Dr 2               	lda #$01
002D3Dr 2               z80_init_loop:
002D3Dr 2               	sta _bitmem0,x
002D3Dr 2               	inx
002D3Dr 2               	asl a
002D3Dr 2               	bne z80_init_loop
002D3Dr 2               	rts
002D3Dr 2               .endif
002D3Dr 2               
002D3Dr 2               push_af:
002D3Dr 2               push_bc:
002D3Dr 2               push_de:
002D3Dr 2               push_hl:
002D3Dr 2               
002D3Dr 2               pop_af:
002D3Dr 2               pop_bc:
002D3Dr 2               pop_de:
002D3Dr 2               pop_ix:
002D3Dr 2               pop_hl:
002D3Dr 2               
002D3Dr 2               add_hl_hl:
002D3Dr 2               
002D3Dr 2               inc_bc:
002D3Dr 2               inc_de:
002D3Dr 2               inc_hl:
002D3Dr 2               inc_ix:
002D3Dr 2               inc_sp:
002D3Dr 2               
002D3Dr 2               cpir:
002D3Dr 2               
002D3Dr 2               ex_af_af:
002D3Dr 2               ;	rts
002D3Dr 2               
002D3Dr 1               
002D3Dr 1               eind_asm:
002D3Dr 1               eop:					; End Of Program
002D3Dr 1               
002D3Dr 1               .out .sprintf("Gamecode size = %d bytes, free space = %d bytes", (eind_asm - main),(24576-eind_asm + main))
002D3Dr 1               
