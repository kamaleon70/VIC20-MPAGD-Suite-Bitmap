ca65 V2.13.3 - (C) Copyright 1998-2012 Ullrich von Bassewitz
Main file   : game.asm
Current file: game.asm

000000r 1               ;----------------------------------------------
000000r 1               ; Common AGD engine
000000r 1               ; VIC20 conversion by Kees van Oss 2024
000000r 1               ;----------------------------------------------
000000r 1               
000000r 1               .segment "ZEROPAGE"
000000r 1               	.include "game.cfg"
000000r 2               ; Flags saved by AGD Compiler
000000r 2               
000000r 2               mflag = 0 ;
000000r 2               pflag = 0 ;
000000r 2               sflag = 0 ;
000000r 2               dflag = 0 ;
000000r 2               cflag = 0 ;
000000r 2               oflag = 1 ;
000000r 2               lflag = 0 ;
000000r 2               bflag = 1 ;
000000r 2               rflag = 0 ;
000000r 2               kflag = 0 ;
000000r 2               
000000r 1               	.include "engine-zp.inc"
000000r 2               ;----------------------------------------------------------------------
000000r 2               ; AGD 6502 Engine Zero Page Variables
000000r 2               ;----------------------------------------------------------------------
000000r 2               
000000r 2               ; Variables start here.
000000r 2               
000000r 2  xx           scno:	.res 1			; present screen number.
000001r 2  xx           numlif:	.res 1			; number of lives.
000002r 2               
000002r 2  xx           vara:	.res 1			; general-purpose variable.
000003r 2  xx           varb:	.res 1			; general-purpose variable.
000004r 2  xx           varc:	.res 1			; general-purpose variable.
000005r 2  xx           vard:	.res 1			; general-purpose variable.
000006r 2  xx           vare:	.res 1			; general-purpose variable.
000007r 2  xx           varf:	.res 1			; general-purpose variable.
000008r 2  xx           varg:	.res 1			; general-purpose variable.
000009r 2  xx           varh:	.res 1			; general-purpose variable.
00000Ar 2  xx           vari:	.res 1			; general-purpose variable.
00000Br 2  xx           varj:	.res 1			; general-purpose variable.
00000Cr 2  xx           vark:	.res 1			; general-purpose variable.
00000Dr 2  xx           varl:	.res 1			; general-purpose variable.
00000Er 2  xx           varm:	.res 1			; general-purpose variable.
00000Fr 2  xx           varn:	.res 1			; general-purpose variable.
000010r 2  xx           varo:	.res 1			; general-purpose variable.
000011r 2  xx           varp:	.res 1			; general-purpose variable.
000012r 2  xx           varq:	.res 1			; general-purpose variable.
000013r 2  xx           varr:	.res 1			; general-purpose variable.
000014r 2  xx           vars:	.res 1			; general-purpose variable.
000015r 2  xx           vart:	.res 1			; general-purpose variable.
000016r 2  xx           varu:	.res 1			; general-purpose variable.
000017r 2  xx           varv:	.res 1			; general-purpose variable.
000018r 2  xx           varw:	.res 1			; general-purpose variable.
000019r 2  xx           varz:	.res 1			; general-purpose variable.
00001Ar 2               
00001Ar 2  xx           charx:	.res 1			; cursor x position.
00001Br 2  xx           chary:	.res 1			; cursor y position.
00001Cr 2               
00001Cr 2  xx           clock:	.res 1			; last clock reading.
00001Dr 2  xx           varrnd:	.res 1	        ; last random number.
00001Er 2  xx           varobj:	.res 1  	    ; last object number.
00001Fr 2  xx           varopt:	.res 1     		; last option chosen from menu.
000020r 2  xx           varblk:	.res 1  		; block type.
000021r 2  xx           nexlev:	.res 1			; next level flag.
000022r 2  xx           restfl:	.res 1			; restart screen flag.
000023r 2  xx           deadf:	.res 1			; dead flag.
000024r 2  xx           gamwon:	.res 1			; game won flag.
000025r 2  xx           dispx:	.res 1			; cursor x position.
000026r 2  xx           dispy:	.res 1			; cursor y position.
000027r 2               
000027r 2  xx           contrl:	.res 1			; control = keyboard, 1 = Kempston, 2 = Sinclair, 3 = Mouse.
000028r 2  xx           joyval:	.res 1			; joystick reading.
000029r 2  xx           frmno:	.res 1			; selected frame.
00002Ar 2               
00002Ar 2               ;----------------------------------------------------
00002Ar 2               ; Missing vars
00002Ar 2               ;----------------------------------------------------
00002Ar 2               
00002Ar 2  xx           loopa:	    .res 1
00002Br 2  xx           loopb:	    .res 1
00002Cr 2  xx           loopc:	    .res 1
00002Dr 2  xx xx        FontPtr:    .res 2
00002Fr 2               
00002Fr 2               ; Local vars
00002Fr 2               
00002Fr 2  xx xx        scraddr:    .res 2
000031r 2  xx xx        fntaddr:    .res 2
000033r 2  xx xx        tileaddr:   .res 2
000035r 2  xx xx        bufaddr:    .res 2
000037r 2               
000037r 2  xx xx        tmp:        .res 2
000039r 2  xx xx        scr_l:      .res 2
00003Br 2  xx xx        scr_r:      .res 2
00003Dr 2  xx xx        scr_txt:    .res 2
00003Fr 2               
00003Fr 2  xx           xtmp:	    .res 1
000040r 2  xx           spcnt:	    .res 1
000041r 2  xx xx        spptr:	    .res 2		; spawned sprite pointer.
000043r 2  xx           seed:	    .res 1		; seed for random numbers.
000044r 2               
000044r 2  xx           ccnt:       .res 1
000045r 2  xx           flag:	    .res 1
000046r 2  xx           rcol:	    .res 1
000047r 2  xx           rrow:	    .res 1
000048r 2               
000048r 2  xx           combyt:	    .res 1		; byte type compressed.
000049r 2  xx           comcnt:	    .res 1		; compression counter.
00004Ar 2  xx           prtmod:	    .res 1      ; print mode, 0 = standard, 1 = double-height.
00004Br 2  xx           qscnt:	    .res 1
00004Cr 2               
00004Cr 2  xx           sprptr:	    .res 1      ; not a ptr
00004Dr 2  xx           sprcnt:	    .res 1
00004Er 2               
00004Er 2  xx xx        skptr:	    .res 2		; search pointer.
000050r 2  xx           sktptr:	    .res 1      ; not a ptr
000051r 2  xx           tmproom:    .res 1
000052r 2  xx xx        ogptr:	    .res 2		; original sprite pointer.
000054r 2               
000054r 2  xx xx xx     spr:	    .res 3      ; static sprite data
000057r 2  xx           vsync_count:.res 1
000058r 2  xx           colpatt:    .res 1
000059r 2  xx           sprtmp:     .res 1
00005Ar 2  xx           sprtmp2:    .res 1
00005Br 2  xx           sprshft:    .res 1
00005Cr 2               
00005Cr 2  xx           spriteink:  .res 1
00005Dr 2  xx           colour_byte:.res 1
00005Er 2  xx           colour_xor: .res 1
00005Fr 2  xx           objcol:	    .res 1
000060r 2               
000060r 2               .if mflag
000060r 2               TmpAddr:    .res 2
000060r 2               bwid:	    .res 1     ; box/menu width.
000060r 2               blen:	    .res 1     ; box/menu height.
000060r 2               btop:	    .res 1     ; box coordinates.
000060r 2               blft:	    .res 1
000060r 2               .endif
000060r 2               
000060r 2               .if pflag
000060r 2               shrctr:	    .res 1
000060r 2               explcnt:    .res 1
000060r 2               seed3:	    .res 1
000060r 2               .endif
000060r 2               
000060r 2               .if aflag
000060r 2               pbptr:      .res 2
000060r 2               .endif
000060r 2               
000060r 2  xx           tmp1:       .res 1
000061r 2  xx           tmp2:       .res 1
000062r 2               
000062r 2               ;----------------------------------------------------
000062r 2               ; Music player variables
000062r 2               ;----------------------------------------------------
000062r 2               
000062r 2  xx           SONG_POS:		.res 1	; = $90
000063r 2  xx           PATTERN_POS:		.res 1	; = $91
000064r 2  xx           FRAME_COUNT:		.res 1	; = $92
000065r 2  xx           FRAME_LENGTH:		.res 1	; = $93
000066r 2  xx           SONG_NEXT_TRUE:		.res 1	; = $94
000067r 2  xx           SONG_END_TRUE:		.res 1	; = $95
000068r 2               
000068r 2               ; 2 byte address of pattern data
000068r 2  xx xx        CH1_PATTERN_POS:	.res 2	; = $96
00006Ar 2  xx xx        CH2_PATTERN_POS:	.res 2	; = $98
00006Cr 2  xx xx        CH3_PATTERN_POS:	.res 2	; = $9a
00006Er 2  xx xx        CH4_PATTERN_POS:	.res 2	; = $9c
000070r 2               
000070r 2               ; #$00 == inactive mode
000070r 2  xx           CH1_ACTIVE:		.res 1	; = $a0
000071r 2  xx           CH2_ACTIVE:		.res 1	; = $a1
000072r 2  xx           CH3_ACTIVE:		.res 1	; = $a2
000073r 2  xx           CH4_ACTIVE:		.res 1	; = $a3
000074r 2               
000074r 2  xx           TEMP_GUY:		.res 1	; = $a4
000075r 2  xx           CHAN_NOTE_DATA:		.res 1	; = $a5
000076r 2  xx           CHANS_INACTIVE:		.res 1	; = $a6
000077r 2  xx           FAST_COUNTER:		.res 1	; = $a7
000078r 2  xx           MEGA_COUNTER:		.res 1	; = $a8
000079r 2               
000079r 1               	.include "z80-zp.inc"
000079r 2               ;ws	 = $60
000079r 2               
000079r 2  xx           z80_f: .res 1;	 = ws+$00
00007Ar 2  xx           z80_a: .res 1;	 = ws+$01
00007Br 2               z80_af	 = z80_f
00007Br 2               
00007Br 2  xx           z80_c: .res 1;	 = ws+$02
00007Cr 2  xx           z80_b: .res 1;	 = ws+$03
00007Dr 2               z80_bc	 = z80_c
00007Dr 2               
00007Dr 2  xx           z80_e: .res 1;	 = ws+$04
00007Er 2  xx           z80_d: .res 1;	 = ws+$05
00007Fr 2               z80_de	 = z80_e
00007Fr 2               
00007Fr 2  xx           z80_l: .res 1;	 = ws+$06
000080r 2  xx           z80_h: .res 1;	 = ws+$07
000081r 2               z80_hl	 = z80_l
000081r 2               
000081r 2  xx           z80_x: .res 1;    = ws+$08
000082r 2  xx           z80_i: .res 1;    = ws+$09
000083r 2               z80_ix	 = z80_x
000083r 2               
000083r 2  xx xx        z80_iy: .res 2;	 = ws+$0a
000085r 2               
000085r 2  xx           z80_fp: .res 1;	 = ws+$0c
000086r 2  xx           z80_ap: .res 1;	 = ws+$0d
000087r 2               
000087r 2  xx           z80_cp: .res 1;	 = ws+$0e
000088r 2  xx           z80_bp: .res 1;	 = ws+$0f
000089r 2               z80_bcp	 = z80_cp
000089r 2               
000089r 2  xx           z80_ep: .res 1;	 = ws+$10
00008Ar 2  xx           z80_dp: .res 1;	 = ws+$11
00008Br 2               z80_dep	 = z80_ep
00008Br 2               
00008Br 2  xx           z80_lp: .res 1;	 = ws+$12
00008Cr 2  xx           z80_hp: .res 1;	 = ws+$13
00008Dr 2               z80_hlp	 = z80_lp
00008Dr 2               
00008Dr 2  xx xx        z80_sp: .res 2;   = ws+$14
00008Fr 2               
00008Fr 2  xx           z80_reg0: .res 1; = ws+$16
000090r 2  xx           z80_reg1: .res 1; = ws+$17
000091r 2  xx           z80_reg2: .res 1; = ws+$18
000092r 2  xx           z80_reg3: .res 1; = ws+$19
000093r 2               
000093r 2               ;z80_r: .res 1;	 = ws+$1a
000093r 2               
000093r 1               
000093r 1               ;----------------------------------------------
000093r 1               ; BASIC header
000093r 1               ;----------------------------------------------
000093r 1               
000093r 1               .segment "BASIC"
000000r 1               
000000r 1  rr rr        	.word load
000002r 1  rr rr        load:   .word @end
000004r 1  02 00        	.word 2
000006r 1  9E           	.byte $9e
000007r 1  rr           	.byte .lobyte(main/1000 .mod 10) + $30
000008r 1  rr           	.byte .lobyte(main/100 .mod 10) + $30
000009r 1  rr           	.byte .lobyte(main/10 .mod 10) + $30
00000Ar 1  rr           	.byte .lobyte(main/1 .mod 10) + $30
00000Br 1  00           	.byte 0
00000Cr 1  00 00        @end:   .word 0
00000Er 1               
00000Er 1               ;----------------------------------------------
00000Er 1               
00000Er 1               .segment "CODE"
000000r 1               main:
000000r 1               	.include "game.inc"
000000r 2               .include "test24.inc"
000000r 3               ; Game engine code --------------------------------------------------------------
000000r 3               
000000r 3               ; Arcade Game Designer.
000000r 3               ; (C) 2008 Jonathan Cauldwell.
000000r 3               ; ZX Spectrum Next Engine v0.1.
000000r 3               
000000r 3               ; Conditional compilation flags
000000r 3               ; Code is installed if flag is set
000000r 3               ; Flags are set in commandline assembly or by the compiler
000000r 3               
000000r 3               ; Flags set by AGD compiler
000000r 3               ;	mflag  			; MENU + INV
000000r 3               ;	pflag 			; particle engine
000000r 3               ;	sflag 			; scrollytext
000000r 3               ;	dflag 			; digging mode
000000r 3               ;	cflag			; collectable blocks
000000r 3               ;	oflag			; objects
000000r 3               ;	lflag			; ladders
000000r 3               ;
000000r 3               ; Flags set manually
000000r 3               ;	aflag			; adventure mode
000000r 3               ;	bflag			; big sprites (16x24)
000000r 3               ;	fflag			; floppy version (skip #0axx)
000000r 3               ;	gflag			; graphic colour mode
000000r 3               ;	hflag			; hidden sprite mode
000000r 3               ;	iflag			; invert mode
000000r 3               
000000r 3               swrflag = 0
000000r 3               
000000r 3               .if mflag
000000r 3               	.out "- MEN/INV enabled"
000000r 3               .endif
000000r 3               .if pflag
000000r 3               	.out "- Particles enabled"
000000r 3               .endif
000000r 3               .if sflag
000000r 3               	.out "- Scrolling enabled"
000000r 3               .endif
000000r 3               .if dflag
000000r 3               	.out "- Digging enabled"
000000r 3               .endif
000000r 3               .if cflag
000000r 3               	.out "- Collectable blocks enabled"
000000r 3               .endif
000000r 3               .if oflag
000000r 3               	.out "- Objects enabled"
000000r 3               .endif
000000r 3               .if lflag
000000r 3               	.out "- Ladders enabled"
000000r 3               .endif
000000r 3               .if aflag
000000r 3               	.out "- Adventure mode enabled"
000000r 3               .endif
000000r 3               .if bflag
000000r 3               	.out "- Big Sprites (16x24) enabled"
000000r 3               .endif
000000r 3               .if gflag
000000r 3               	.out "- Colourmode enabled"
000000r 3               .endif
000000r 3               .if hflag
000000r 3               	.out "- Hidden sprites/foregroundblocks enabled"
000000r 3               .endif
000000r 3               .if iflag
000000r 3               	.out "- Invert mode enabled"
000000r 3               .endif
000000r 3               .if rflag
000000r 3               	.out "- RAM saving sprites enabled"
000000r 3               .endif
000000r 3               .if xflag
000000r 3               	.out "- Metablocks 16x6"
000000r 3               .endif
000000r 3               
000000r 3               ;------------------------------------------------------------
000000r 3               ; VIC20 check for PAL or NTSC
000000r 3               ;------------------------------------------------------------
000000r 3               
000000r 3               .if modelflag
000000r 3               	ScrWidth	= 22	; PAL settings
000000r 3               	ScrHeight	= 22
000000r 3               	CentreX		= 4
000000r 3               	CentreY		= 28
000000r 3               	timervalue	= 20000
000000r 3               	timerint	= 20000			; Interrupt timer 1/50 sec
000000r 3               	.out "- PAL"
000000r 3               .else
000000r 3               	ScrWidth	= 22	; NTSC settings
000000r 3               	ScrHeight	= 22
000000r 3               	CentreX		= 4
000000r 3               	CentreY		= 27
000000r 3               	timervalue	= 20000
000000r 3               	timerint	= 20000			; Interrupt timer 1/50 sec
000000r 3                	.out "- NTSC"
000000r 3               .endif
000000r 3               .out ""
000000r 3               
000000r 3               ;------------------------------------------------------------
000000r 3               ; Constants MPAGD
000000r 3               ;------------------------------------------------------------
000000r 3               
000000r 3               ; Global definitions
000000r 3               
000000r 3               	FONT 		= font
000000r 3               	MAP 		= MapAddr		; properties map buffer (3x256 bytes)
000000r 3               	SCADTB_lb	= MAP + $300		; Screen address table
000000r 3               	SCADTB_hb	= SCADTB_lb + $100
000000r 3               	SHRAPN 		= SCADTB_hb + $100	; shrapnel table (55x6 bytes)
000000r 3               	COLATTTB_lb	= SHRAPN + 55*6		; Colour attribute address table
000000r 3               	COLATTTB_hb	= COLATTTB_lb + 11
000000r 3               
000000r 3               ; Block characteristics.
000000r 3               
000000r 3               	PLATFM	= 1		; platform.
000000r 3               	WALL	= PLATFM + 1	; solid wall.
000000r 3               	LADDER	= WALL + 1	; ladder.
000000r 3               	FODDER	= LADDER + 1	; fodder block.
000000r 3               	DEADLY	= FODDER + 1	; deadly block.
000000r 3               	CUSTOM	= DEADLY + 1	; custom block.
000000r 3               	WATER	= CUSTOM + 1	; water block.
000000r 3                       COLECT	= WATER + 1	; collectable block.
000000r 3                       NUMTYP	= COLECT + 1	; number of types.
000000r 3               
000000r 3               ; Sprites.
000000r 3               
000000r 3               .if bflag
000000r 3               	SPR_HGT	= 24		; Sprite height
000000r 3               	SPR_WID = 16		; Sprite width
000000r 3               	NUMSPR	= 8		; number of sprites.
000000r 3               .else				; 16x16 sprites
000000r 3               	SPR_HGT = 16		; Sprite height
000000r 3               	SPR_WID = 16		; Sprite width
000000r 3               	NUMSPR	= 12		; number of sprites.
000000r 3               .endif
000000r 3               	TABSIZ = 17			; size of each entry.
000000r 3               	SPRBUF = NUMSPR * TABSIZ; size of entire table.
000000r 3               	NMESIZ = 4			; bytes stored in nmetab for each sprite.
000000r 3               
000000r 3               ; Sprite table variable offsets.
000000r 3               
000000r 3               	var_Type = 0		; sprite type
000000r 3               	var_Image = 1		; sprite time number
000000r 3               	var_Frame = 2		; sprite frame
000000r 3               	var_Y = 3			; sprite y coordinate
000000r 3               	var_X = 4			; sprite X coordinate
000000r 3               
000000r 3               	var_newType = 5		; sprite new type
000000r 3               	var_newImage = 6	; sprite new image number
000000r 3               	var_newFrame = 7	; sprite new frame
000000r 3               	var_newY = 8		; sprite new y coordinate
000000r 3               	var_newX = 9		; sprite new x coordinate
000000r 3               
000000r 3               	var_Direction = 10	; sprite direction
000000r 3               	var_Param1 = 11		; sprite parameter 1
000000r 3               	var_Param2 = 12		; sprite parameter 2
000000r 3               
000000r 3               	var_jumpLo = 13		; sprite jump ptr low
000000r 3               	var_jumpHi = 14		; sprite jump ptr high
000000r 3               	var_dataLo = 15		; sprite data ptr low
000000r 3               	var_dataHi = 16		; sprite data ptr high
000000r 3               
000000r 3               ; Particle engine.
000000r 3               
000000r 3               	NUMSHR = 55			; pieces of shrapnel.
000000r 3               	SHRSIZ = 6			; bytes per particle.
000000r 3               
000000r 3               .if iflag
000000r 3               	TxtInvert   = $ff	; Invert byte for character printing
000000r 3               	ScrFillByte = $ff	; Screen fill byte for CLS
000000r 3               .else
000000r 3               	TxtInvert   = $00	; Invert byte for character printing
000000r 3               	ScrFillByte = $00	; Screen fill byte for CLS
000000r 3               .endif
000000r 3               
000000r 3               	ASCII_NEWLINE = 13
000000r 3               
000000r 3               ;===============================================================
000000r 3               ; Game starts here
000000r 3               ;===============================================================
000000r 3               
000000r 3               ;--------------------------------------------------------------
000000r 3               ; If a font is required...
000000r 3               ;--------------------------------------------------------------
000000r 3               
000000r 3               start:
000000r 3  20 rr rr     	jsr game	 		; start the game.
000003r 3  60           	rts
000004r 3               
000004r 3               ; Don't change the order of these four.
000004r 3               ; Menu routine relies on winlft following wintop.
000004r 3               
000004r 3  01           wintop:	.byte WINDOWTOP		; top of window.
000005r 3  00           winlft:	.byte WINDOWLFT		; left edge.
000006r 3  14           winhgt:	.byte WINDOWHGT		; window height.
000007r 3  16           winwid:	.byte WINDOWWID		; window width.
000008r 3  03           numob:	.byte NUMOBJ		; number of objects in game.
000009r 3               
000009r 3               ; Pixel versions of wintop, winlft, winhgt, winwid.
000009r 3               
000009r 3  08           wntopx:	.byte (8 * WINDOWTOP)
00000Ar 3  00           wnlftx:	.byte (8 * WINDOWLFT)
00000Br 3  98           wnbotx:	.byte ((WINDOWTOP * 8) + (WINDOWHGT * 8) - 16)
00000Cr 3  9E           wnrgtx:	.byte ((WINDOWLFT * 8) + (WINDOWWID * 8) - 16)-2
00000Dr 3               
00000Dr 3               ; Make sure pointers are arranged in the same order as the data itself.
00000Dr 3               
00000Dr 3  rr rr        frmptr:	.word frmlst        ; sprite frames.
00000Fr 3               
00000Fr 3               ; Assorted game routines which can go in contended memory.
00000Fr 3               
00000Fr 3               ;--------------------------------------------------------------
00000Fr 3               ; Modify for inventory.
00000Fr 3               ; called by the INV command
00000Fr 3               ;
00000Fr 3               ; Input:
00000Fr 3               ;  X   = message nr with objects seperated with ,
00000Fr 3               ;
00000Fr 3               ; Output:
00000Fr 3               ;  OPT = selected line nr of INV menu
00000Fr 3               ;--------------------------------------------------------------
00000Fr 3               
00000Fr 3               .if mflag
00000Fr 3               minve:
00000Fr 3               .if xflag
00000Fr 3               	lda #WINDOWHGT
00000Fr 3               	asl a
00000Fr 3               	sta winhgt
00000Fr 3               	lda #WINDOWWID
00000Fr 3               	asl a
00000Fr 3               	sta winwid
00000Fr 3               .endif
00000Fr 3               	lda #<(invdis)		; routine address.
00000Fr 3               	sta mod0+1		; set up menu routine.
00000Fr 3               	sta mod2+1		; set up count routine.
00000Fr 3               	lda #>(invdis)
00000Fr 3               	sta mod0+2
00000Fr 3               	sta mod2+2
00000Fr 3               	lda #<(fopt)		; find option from available objects.
00000Fr 3               	sta mod1+1		; set up routine.
00000Fr 3               	lda #>(fopt)
00000Fr 3               	sta mod1+1+1
00000Fr 3               	jmp dbox		; do menu routine.
00000Fr 3               
00000Fr 3               ;--------------------------------------------------------------
00000Fr 3               ; Modify for menu.
00000Fr 3               ; called by the MENU command
00000Fr 3               ;
00000Fr 3               ; Input:
00000Fr 3               ;  X   = message nr with menu items seperated with ,
00000Fr 3               ;
00000Fr 3               ; Output:
00000Fr 3               ;  OPT = selected line nr of MENU menu
00000Fr 3               ;--------------------------------------------------------------
00000Fr 3               
00000Fr 3               mmenu:
00000Fr 3               	lda #<(always)		; routine address.
00000Fr 3               	sta mod0+1		; set up routine.
00000Fr 3               	sta mod2+1		; set up count routine.
00000Fr 3               	lda #>(always)
00000Fr 3               	sta mod0+2
00000Fr 3               	sta mod2+2
00000Fr 3               
00000Fr 3               	lda #<(fstd)		; standard option selection.
00000Fr 3               	sta mod1+1		; set up routine.
00000Fr 3               	lda #>(fstd)
00000Fr 3               	sta mod1+2
00000Fr 3               
00000Fr 3               ; Drop through into box routine.
00000Fr 3               
00000Fr 3               ;--------------------------------------------------------------
00000Fr 3               ; Work out size of box for message or menu.
00000Fr 3               ;--------------------------------------------------------------
00000Fr 3               
00000Fr 3               dbox:
00000Fr 3               	lda #<msgdat		; pointer to messages.
00000Fr 3               	sta z80_l
00000Fr 3               	lda #>msgdat
00000Fr 3               	sta z80_h
00000Fr 3               
00000Fr 3               	jsr getwrd		; get message number.
00000Fr 3               
00000Fr 3               	lda z80_h		; store pointer to message.
00000Fr 3               	sta TmpAddr
00000Fr 3               	lda z80_l
00000Fr 3               	sta TmpAddr+1
00000Fr 3               
00000Fr 3               	lda #1			; height.
00000Fr 3               	sta z80_d
00000Fr 3               	lda #0			; start at object zero.
00000Fr 3               	sta combyt		; store number of object in combyt.
00000Fr 3               	sta z80_e		; maximum width.
00000Fr 3               dbox5:
00000Fr 3               	lda #0			; this line"s width.
00000Fr 3               	sta z80_b
00000Fr 3               mod2:
00000Fr 3               	jsr always		; item in player"s possession?
00000Fr 3               	cmp #255
00000Fr 3               	bne dbox6		; not in inventory, skip this line.
00000Fr 3               	inc z80_d		; add to tally.
00000Fr 3               dbox6:
00000Fr 3               	ldy #0			; get character.
00000Fr 3               	lda (z80_hl),y
00000Fr 3               	sta z80_a
00000Fr 3               	inc z80_l		; next character.
00000Fr 3               	bne :+
00000Fr 3               	inc z80_h
00000Fr 3               :
00000Fr 3               	lda z80_a		; reached end of line?
00000Fr 3               	cmp #','
00000Fr 3               	beq dbox3		; yes.
00000Fr 3               	cmp #ASCII_NEWLINE
00000Fr 3               	beq dbox3		; yes.
00000Fr 3               	inc z80_b		; add to this line"s width.
00000Fr 3               	lda z80_a
00000Fr 3               	bmi dbox4		; end of message? yes, end count.
00000Fr 3               	jmp dbox6		; repeat until we find the end.
00000Fr 3               dbox3:
00000Fr 3               	lda z80_e		; maximum line width.
00000Fr 3               	cmp z80_b		; have we exceeded longest so far?
00000Fr 3               	bpl dbox5		; no, carry on looking.
00000Fr 3               	lda z80_b		; make this the widest so far.
00000Fr 3               	sta z80_e
00000Fr 3               	jmp dbox5		; keep looking.
00000Fr 3               dbox4:
00000Fr 3               	lda z80_e		; maximum line width.
00000Fr 3               	cmp z80_b		; have we exceeded longest so far?
00000Fr 3               	bpl dbox8		; no, carry on looking.
00000Fr 3               	lda z80_b		; final line is the longest so far.
00000Fr 3               	sta z80_e
00000Fr 3               dbox8:
00000Fr 3               	dec z80_d		; decrement items found.
00000Fr 3               	bne :+			; total was zero.
00000Fr 3               	lda #255
00000Fr 3               	sta varopt
00000Fr 3               	jmp dbox15
00000Fr 3               :
00000Fr 3               	lda z80_e		; longest line.
00000Fr 3               	bne :+			; was it zero?
00000Fr 3               	jmp dbox15		; total was zero.
00000Fr 3               :
00000Fr 3               	sta bwid		; set up size.
00000Fr 3               	lda z80_d
00000Fr 3               	sta blen
00000Fr 3               
00000Fr 3               ;--------------------------------------------------------------
00000Fr 3               ; That's set up our box size.
00000Fr 3               ;--------------------------------------------------------------
00000Fr 3               
00000Fr 3               	lda winhgt		; window height in characters.
00000Fr 3               	sec
00000Fr 3               	sbc z80_d		; subtract height of box.
00000Fr 3               	lsr a			; divide by 2.
00000Fr 3               	clc
00000Fr 3               	adc wintop		; add top edge of window.
00000Fr 3               	sta btop		; set up box top.
00000Fr 3               
00000Fr 3               	lda winwid		; window width in characters.
00000Fr 3               	sec
00000Fr 3               	sbc z80_e		; subtract box width.
00000Fr 3               	lsr a			; divide by 2.
00000Fr 3               	clc
00000Fr 3               	adc winlft		; add left edge of window.
00000Fr 3               	sta blft		; box left.
00000Fr 3               
00000Fr 3               	lda #<(FONT-256)		; font.
00000Fr 3               	sta grbase		; set up for text display.
00000Fr 3               	lda #>(FONT-256)
00000Fr 3               	sta grbase+1
00000Fr 3               
00000Fr 3               	lda TmpAddr+1		; restore message pointer.
00000Fr 3               	sta z80_l
00000Fr 3               	lda TmpAddr
00000Fr 3               	sta z80_h
00000Fr 3               
00000Fr 3               	lda btop		; box top.
00000Fr 3               	sta dispy		; set display coordinate.
00000Fr 3               	lda #0			; start at object zero.
00000Fr 3               	sta combyt		; store number of object in combyt.
00000Fr 3               dbox2:
00000Fr 3               	lda combyt		; get object number.
00000Fr 3               	sta z80_a
00000Fr 3               mod0:
00000Fr 3               	jsr always		; check inventory for display.
00000Fr 3               	cmp #255
00000Fr 3               	beq :+
00000Fr 3               	jmp dbox13		; not in inventory, skip this line.
00000Fr 3               :
00000Fr 3               	lda blft		; box left.
00000Fr 3               	sta dispx		; set left display position.
00000Fr 3               	lda bwid		; box width.
00000Fr 3               	sta z80_b		; store width.
00000Fr 3               dbox0:
00000Fr 3               	ldy #0			; get character.
00000Fr 3               	lda (z80_hl),y
00000Fr 3               	cmp #','		; end of line?
00000Fr 3               	beq dbox1		; yes, next one.
00000Fr 3               	cmp #ASCII_NEWLINE			; end of line?
00000Fr 3               	beq dbox1		; yes, next one.
00000Fr 3               
00000Fr 3               	cmp #141			; end of line?
00000Fr 3               	bne :+
00000Fr 3               	dec bwid
00000Fr 3               	jmp dbox7		; yes, next one.
00000Fr 3               :
00000Fr 3               	dec z80_b		; one less to display.
00000Fr 3               	and #127		; remove terminator.
00000Fr 3               
00000Fr 3               	jsr pchr		; display on screen.
00000Fr 3               
00000Fr 3               	ldy #0
00000Fr 3               	lda (z80_hl),y		; get character.
00000Fr 3               	sta z80_a
00000Fr 3               	inc z80_l		; next character.
00000Fr 3               	bne :+
00000Fr 3               	inc z80_h
00000Fr 3               :
00000Fr 3               	lda z80_a
00000Fr 3               	cmp #128		; end of message?
00000Fr 3               	bmi :+
00000Fr 3               	jmp dbox7		; yes, job done.
00000Fr 3               :
00000Fr 3               	lda z80_b		; chars remaining.
00000Fr 3               	beq :+			; are any left?
00000Fr 3               	jmp dbox0		; yes, continue.
00000Fr 3               :
00000Fr 3               ;---------------------------------------------------
00000Fr 3               ; Reached limit of characters per line.
00000Fr 3               ;---------------------------------------------------
00000Fr 3               
00000Fr 3               dbox9:
00000Fr 3               	ldy #0
00000Fr 3               	lda (z80_hl),y		; get character.
00000Fr 3               	inc z80_l		; next one.
00000Fr 3               	bne :+
00000Fr 3               	inc z80_h
00000Fr 3               :
00000Fr 3               	cmp #','		; another line?
00000Fr 3               	beq dbox10		; yes, do next line.
00000Fr 3               	cmp #ASCII_NEWLINE	; another line?
00000Fr 3               	beq dbox10		; yes, do next line.
00000Fr 3               	cmp #128		; end of message?
00000Fr 3               	bcs :+
00000Fr 3               	jmp dbox11		; yes, finish message.
00000Fr 3               :
00000Fr 3               	jmp dbox9
00000Fr 3               
00000Fr 3               ;---------------------------------------------------
00000Fr 3               ; Fill box to end of line.
00000Fr 3               ;---------------------------------------------------
00000Fr 3               
00000Fr 3               dboxf:
00000Fr 3               	lda #32			; space character.
00000Fr 3               	jsr pchr		; display character.
00000Fr 3               	dec z80_b
00000Fr 3               	beq :+
00000Fr 3               	jmp dboxf		; repeat for remaining chars on line.
00000Fr 3               :
00000Fr 3               	rts
00000Fr 3               dbox1:
00000Fr 3               	inc z80_l		; skip character.
00000Fr 3               	bne :+
00000Fr 3               	inc z80_h
00000Fr 3               :
00000Fr 3               	jsr dboxf		; fill box out to right side.
00000Fr 3               dbox10:
00000Fr 3               	inc dispy		; y coordinate down a line next position.
00000Fr 3               	jmp dbox2		; next line.
00000Fr 3               dbox7:
00000Fr 3               	lda z80_b		; chars remaining.
00000Fr 3               	bne :+			; are any left?
00000Fr 3               	jmp dbox11		; no, nothing to draw.
00000Fr 3               :
00000Fr 3               	jsr dboxf		; fill message to line.
00000Fr 3               
00000Fr 3               ;------------------------------------------------------
00000Fr 3               ; Drawn the box menu, now select option.
00000Fr 3               ;------------------------------------------------------
00000Fr 3               
00000Fr 3               dbox11:
00000Fr 3               	lda btop		; box top.
00000Fr 3               	sta dispy		; set bar position.
00000Fr 3               dbox14:
00000Fr 3               	jsr joykey		; get controls.
00000Fr 3               	cmp #$7f		; anything pressed?
00000Fr 3               	bne dbox14		; yes, debounce it.
00000Fr 3               	jsr dbar		; draw bar.
00000Fr 3               dbox12:
00000Fr 3               	jsr joykey		; get controls.
00000Fr 3               	cmp #$7f		; anything pressed?
00000Fr 3               	beq dbox12		; no, nothing.
00000Fr 3               	and #16			; fire button pressed?
00000Fr 3               	bne :+
00000Fr 3               mod1:
00000Fr 3               	jmp fstd		; yes, job done.
00000Fr 3               :
00000Fr 3               	jsr dbar		; delete bar.
00000Fr 3               
00000Fr 3               	lda joyval		; joystick reading.
00000Fr 3               	and #8			; going up?
00000Fr 3               	beq dboxu		; yes, go up.
00000Fr 3               
00000Fr 3               	ldx dispy		; vertical position of bar.
00000Fr 3               	inx			; look down.
00000Fr 3               	txa
00000Fr 3               	sec
00000Fr 3               	sbc btop		; find distance from top.
00000Fr 3               	cmp blen		; top of box.
00000Fr 3               	bne :+
00000Fr 3               	jmp dbox14		; yes, go no further.
00000Fr 3               :
00000Fr 3               	inc dispy		; move bar.
00000Fr 3               	jmp dbox14		; continue.
00000Fr 3               dboxu:
00000Fr 3               	lda dispy		; vertical position of bar.
00000Fr 3               	cmp btop		; are we at the top?
00000Fr 3               	bne :+
00000Fr 3               	jmp dbox14		; yes, go no further.
00000Fr 3               :
00000Fr 3               	dec dispy		; move bar.
00000Fr 3               	jmp dbox14		; continue.
00000Fr 3               fstd:
00000Fr 3               	lda dispy		; bar position.
00000Fr 3               	sec
00000Fr 3               	sbc btop		; find selected option.
00000Fr 3               	sta varopt		; store the option.
00000Fr 3               	jmp redraw		; redraw the screen.
00000Fr 3               
00000Fr 3               ;------------------------------------------------------
00000Fr 3               ; Option not available.  Skip this line.
00000Fr 3               ;------------------------------------------------------
00000Fr 3               
00000Fr 3               dbox13:
00000Fr 3               	ldy #0
00000Fr 3               	lda (z80_hl),y		; get character.
00000Fr 3               	inc z80_l		; next one.
00000Fr 3               
00000Fr 3               	bne :+
00000Fr 3               	inc z80_h
00000Fr 3               :
00000Fr 3               	cmp #','		; another line?
00000Fr 3               	bne :+
00000Fr 3               	jmp dbox2		; yes, do next line.
00000Fr 3               :
00000Fr 3               	cmp #ASCII_NEWLINE			; another line?
00000Fr 3               	bne :+
00000Fr 3               	jmp dbox2		; yes, do next line.
00000Fr 3               :
00000Fr 3               
00000Fr 3               	bpl :+			; end of message?
00000Fr 3               	jmp dbox11		; yes, finish message.
00000Fr 3               :
00000Fr 3               	jmp dbox13
00000Fr 3               dbox15:
00000Fr 3               .if xflag
00000Fr 3               	lda #WINDOWWID
00000Fr 3               	sta winwid
00000Fr 3               	lda #WINDOWHGT
00000Fr 3               	sta winhgt
00000Fr 3               .endif
00000Fr 3               	lda TmpAddr		; pop message pointer from the stack.
00000Fr 3               	sta z80_h
00000Fr 3               	lda TmpAddr+1
00000Fr 3               	sta z80_l
00000Fr 3               	rts
00000Fr 3               
00000Fr 3               ;------------------------------------------------------
00000Fr 3               ; Invert bar
00000Fr 3               ;------------------------------------------------------
00000Fr 3               
00000Fr 3               dbar:
00000Fr 3               	lda blft		; box left.
00000Fr 3               	sta dispx		; set display coordinate.
00000Fr 3               	jsr gprad		; get printing address.
00000Fr 3               
00000Fr 3               	lda bwid		; box width.
00000Fr 3               	sta z80_c		; loop counter in c.
00000Fr 3               	lda z80_h
00000Fr 3               	sta z80_d		; store screen address high byte.
00000Fr 3               dbar1:
00000Fr 3               	ldx #7			; pixel height in b.
00000Fr 3               dbar0:
00000Fr 3               	ldy scrtab,x
00000Fr 3               	lda (scraddr),y		; get screen byte.
00000Fr 3               	eor #255		; reverse all bits.
00000Fr 3               	sta (scraddr),y		; write back to screen.
00000Fr 3               	dex			; next line down.
00000Fr 3               	bpl dbar0		; draw rest of character.
00000Fr 3               
00000Fr 3               	lda scraddr
00000Fr 3               	adc #16
00000Fr 3               	sta scraddr
00000Fr 3               	bcc :+
00000Fr 3               	inc scraddr+1
00000Fr 3               :
00000Fr 3               	dec z80_c		; decrement character counter.
00000Fr 3               	bne dbar1		; repeat for whole line.
00000Fr 3               	rts
00000Fr 3               
00000Fr 3               ;------------------------------------------------------
00000Fr 3               ; Point to object
00000Fr 3               ;
00000Fr 3               ; Input:
00000Fr 3               ;  -
00000Fr 3               ;
00000Fr 3               ; Output:
00000Fr 3               ;  A = object number, A=255 if already in possession
00000Fr 3               ;------------------------------------------------------
00000Fr 3               
00000Fr 3               invdis:
00000Fr 3               	lda z80_l		; store message text pointer.
00000Fr 3               	pha
00000Fr 3               	lda z80_h
00000Fr 3               	pha
00000Fr 3               	lda combyt		; object number.
00000Fr 3               	inc combyt		; ready for next one.
00000Fr 3               	jsr gotob		; check if we have object.
00000Fr 3               	tay
00000Fr 3               	pla
00000Fr 3               	sta z80_h
00000Fr 3               	pla
00000Fr 3               	sta z80_l
00000Fr 3               	tya
00000Fr 3               	rts
00000Fr 3               
00000Fr 3               ;------------------------------------------------------
00000Fr 3               ; Find option selected.
00000Fr 3               ;
00000Fr 3               ; Input:
00000Fr 3               ;  -
00000Fr 3               ;
00000Fr 3               ; Output:
00000Fr 3               ;  OPT = selected object
00000Fr 3               ;------------------------------------------------------
00000Fr 3               
00000Fr 3               fopt:
00000Fr 3               	lda dispy
00000Fr 3               	sec
00000Fr 3               	sbc btop		; find selected option.
00000Fr 3               	sta tmp+2		; option selected in b register.
00000Fr 3               	inc tmp+2
00000Fr 3               
00000Fr 3               	lda #0			; set to first item.
00000Fr 3               	sta combyt		; object number.
00000Fr 3               fopt0:
00000Fr 3               	jsr fobj		; find next object in inventory.
00000Fr 3               	dec tmp+2
00000Fr 3               	bne fopt0		; repeat for relevant steps down the list.
00000Fr 3               
00000Fr 3               	lda combyt		; get option.
00000Fr 3               	sta varopt		; store the option.
00000Fr 3               	dec varopt		; one less, due to where we increment combyt.
00000Fr 3               	jmp redraw		; redraw the screen.
00000Fr 3               fobj:
00000Fr 3               	ldy combyt		; object number.
00000Fr 3               	inc combyt		; ready for next item.
00000Fr 3               	tya
00000Fr 3               	jsr gotob		; do we have this item?
00000Fr 3               	cmp #255
00000Fr 3               	bne :+
00000Fr 3               	rts
00000Fr 3               :
00000Fr 3               	jmp fobj		; yes, it's on the list.
00000Fr 3               .endif
00000Fr 3               
00000Fr 3               ;----------------------------------------------------
00000Fr 3               ; Clear sprite table.
00000Fr 3               ;
00000Fr 3               ; sprtab[0] - sprtab[SPRBUF-1] = 255
00000Fr 3               ;----------------------------------------------------
00000Fr 3               
00000Fr 3               xspr:
00000Fr 3  A9 FF        	lda #255		; clear byte.
000011r 3  A2 00        	ldx #0			; length of table.
000013r 3               xspr0:
000013r 3  9D rr rr     	sta sprtab,x		; sprite table.
000016r 3  E8           	inx			; move to next byte.
000017r 3  E0 88        	cpx #SPRBUF
000019r 3  D0 F8        	bne xspr0		; repeat for rest of table.
00001Br 3  60           	rts
00001Cr 3               
00001Cr 3               ;-------------------------------------------------------------
00001Cr 3               ; Initialise all objects.
00001Cr 3               ;
00001Cr 3               ; Reset current room,y,x to start room,y,x for all objects
00001Cr 3               ;-------------------------------------------------------------
00001Cr 3               
00001Cr 3               .if oflag
00001Cr 3               iniob:
00001Cr 3  A9 rr        	lda #<objdta		; objects table.
00001Er 3  85 rr        	sta z80_x
000020r 3  A9 rr        	lda #>objdta
000022r 3  85 rr        	sta z80_i
000024r 3               
000024r 3  AE rr rr     	ldx numob 		; number of objects in the game.
000027r 3               iniob0:
000027r 3  A0 24        	ldy #36
000029r 3  B1 rr        	lda (z80_ix),y 		; start screen.
00002Br 3  A0 21        	ldy #33
00002Dr 3  91 rr        	sta (z80_ix),y 		; set start screen.
00002Fr 3               
00002Fr 3  A0 25        	ldy #37
000031r 3  B1 rr        	lda (z80_ix),y 		; find start y.
000033r 3  A0 22        	ldy #34
000035r 3  91 rr        	sta (z80_ix),y 		; set start y.
000037r 3               
000037r 3  A0 26        	ldy #38
000039r 3  B1 rr        	lda (z80_ix),y 		; get initial x.
00003Br 3  A0 23        	ldy #35
00003Dr 3  91 rr        	sta (z80_ix),y 		; set x coord.
00003Fr 3               
00003Fr 3  18           	clc 			; point to next object.
000040r 3  A5 rr        	lda z80_x
000042r 3  69 27        	adc #39			; distance between objects.
000044r 3  85 rr        	sta z80_x
000046r 3  90 02        	bcc :+
000048r 3  E6 rr        	inc z80_i
00004Ar 3               :
00004Ar 3  CA           	dex 			; repeat.
00004Br 3  D0 DA        	bne iniob0
00004Dr 3               
00004Dr 3  60           	rts
00004Er 3               .endif
00004Er 3               
00004Er 3               ;-----------------------------------------------
00004Er 3               ; Redraw the screen.
00004Er 3               ;
00004Er 3               ; Remove old copy of all sprites for redraw.
00004Er 3               ;-----------------------------------------------
00004Er 3               
00004Er 3               redraw:
00004Er 3               .if xflag
00004Er 3               	lda #WINDOWWID
00004Er 3               	sta winwid
00004Er 3               	lda #WINDOWHGT
00004Er 3               	sta winhgt
00004Er 3               .endif
00004Er 3  A5 rr        	lda z80_i 		; place sprite pointer on stack.
000050r 3  48           	pha
000051r 3  A5 rr        	lda z80_x
000053r 3  48           	pha
000054r 3               
000054r 3  20 rr rr     	jsr droom		; show screen layout.
000057r 3               .if oflag
000057r 3  20 rr rr     	jsr shwob		; draw objects.
00005Ar 3               .endif
00005Ar 3               numsp0:
00005Ar 3  A9 08        	lda #NUMSPR		; sprites to draw.
00005Cr 3  85 rr        	sta tmp
00005Er 3               
00005Er 3  A9 rr        	lda #<sprtab		; sprite table.
000060r 3  85 rr        	sta z80_x
000062r 3  A9 rr        	lda #>sprtab
000064r 3  85 rr        	sta z80_i
000066r 3               redrw0:
000066r 3  A0 00        	ldy #0
000068r 3  B1 rr        	lda (z80_ix),y		; old sprite type.
00006Ar 3  C9 FF        	cmp #255		; is it enabled?
00006Cr 3  F0 0B        	beq redrw1 		; no, find next one.
00006Er 3               
00006Er 3  A0 03        	ldy #var_Y
000070r 3  B1 rr        	lda (z80_ix),y 		; sprite y.
000072r 3  C9 A1        	cmp #SpriteMaxY		; beyond maximum?
000074r 3  B0 03        	bcs redrw1		; yes, nothing to draw.
000076r 3               
000076r 3  20 rr rr     	jsr sspria		; show single sprite.
000079r 3               
000079r 3               redrw1:
000079r 3  18           	clc			; next sprite.
00007Ar 3  A5 rr        	lda z80_x
00007Cr 3  69 11        	adc #TABSIZ		; distance to next odd/even entry.
00007Er 3  85 rr        	sta z80_x
000080r 3  90 02        	bcc :+
000082r 3  E6 rr        	inc z80_i
000084r 3               :
000084r 3  C6 rr        	dec tmp			; repeat for remaining sprites.
000086r 3  D0 DE        	bne redrw0
000088r 3               
000088r 3               rpblc1:
000088r 3               ;	jsr dshrp		; redraw shrapnel.
000088r 3               
000088r 3               .if aflag
000088r 3               	jsr rbloc		; draw blocks for this screen
000088r 3               .endif
000088r 3  68           	pla			; retrieve sprite pointer.
000089r 3  85 rr        	sta z80_x
00008Br 3  68           	pla
00008Cr 3  85 rr        	sta z80_i
00008Er 3               
00008Er 3  60           	rts
00008Fr 3               
00008Fr 3               ;----------------------------------------------------------------------
00008Fr 3               ; Clear screen routine.
00008Fr 3               ;
00008Fr 3               ; Fill screenmem $8000-$97ff with ScrFillByte
00008Fr 3               ;----------------------------------------------------------------------
00008Fr 3               
00008Fr 3               cls:
00008Fr 3  A9 10        	lda #>CharAddress	; Character RAM address.
000091r 3  8D rr rr     	sta clsloop+2
000094r 3               
000094r 3  A9 00        	lda #ScrFillByte	; Clear screen
000096r 3  A0 00        	ldy #0
000098r 3  A2 10        	ldx #16
00009Ar 3               clsloop:
00009Ar 3  99 00 10     	sta CharAddress,y
00009Dr 3  C8           	iny
00009Er 3  D0 FA        	bne clsloop
0000A0r 3  EE rr rr     	inc clsloop+2
0000A3r 3  CA           	dex
0000A4r 3  D0 F4        	bne clsloop
0000A6r 3  60           	rts
0000A7r 3               
0000A7r 3               ;----------------------------------------------------------------------
0000A7r 3               ; Clear colour attributes
0000A7r 3               ;
0000A7r 3               ; Reset colour attributes to fontcol
0000A7r 3               ;----------------------------------------------------------------------
0000A7r 3               
0000A7r 3               clrcol:
0000A7r 3  AD rr rr     	lda fontcol		; Clear colour attributes
0000AAr 3  A2 00        	ldx #0
0000ACr 3               clscol:
0000ACr 3  9D 00 96     	sta ColorAttr,x
0000AFr 3  E8           	inx
0000B0r 3  E0 F2        	cpx #242
0000B2r 3  D0 F8        	bne clscol
0000B4r 3               
0000B4r 3  60           	rts
0000B5r 3               
0000B5r 3               ;----------------------------------------------------------------------
0000B5r 3               ; FODDER check
0000B5r 3               ;----------------------------------------------------------------------
0000B5r 3               
0000B5r 3               .if pflag .or dflag
0000B5r 3               fdchk:
0000B5r 3               	cmp #FODDER 		; is it fodder?
0000B5r 3               	beq :+
0000B5r 3               	rts 			; no.
0000B5r 3               :
0000B5r 3               	lda #0			; wipe fodder in MAP
0000B5r 3               	ldy #0
0000B5r 3               	sta (bufaddr),y 	; rewrite block type.
0000B5r 3               
0000B5r 3               	lda dispx		; x=x/8
0000B5r 3               	pha
0000B5r 3               	lsr a
0000B5r 3               	lsr a
0000B5r 3               	lsr a
0000B5r 3               	sta dispx
0000B5r 3               
0000B5r 3               	lda dispy		; y=y/8
0000B5r 3               	pha
0000B5r 3               	lsr a
0000B5r 3               	lsr a
0000B5r 3               	lsr a
0000B5r 3               	sta dispy
0000B5r 3               
0000B5r 3               	lda #0 			; block to write.
0000B5r 3               	jsr pattr 		; write block.
0000B5r 3               
0000B5r 3               	pla
0000B5r 3               	sta dispy
0000B5r 3               	pla
0000B5r 3               	sta dispx
0000B5r 3               	rts
0000B5r 3               .endif
0000B5r 3               
0000B5r 3               ;----------------------------------------------------
0000B5r 3               ; Scrolly text and puzzle variables.
0000B5r 3               ;----------------------------------------------------
0000B5r 3               
0000B5r 3               .if sflag
0000B5r 3               txtbit:	.byte 128		; bit to write.
0000B5r 3               txtwid:	.byte 16		; width of ticker message.
0000B5r 3               txtpos:	.word msgdat
0000B5r 3               txtini:	.word msgdat
0000B5r 3               txtscr:	.word ScreenAddr
0000B5r 3               .endif
0000B5r 3               
0000B5r 3               ;----------------------------------------------------
0000B5r 3               ; Specialist routines.
0000B5r 3               ; Process shrapnel.
0000B5r 3               ;----------------------------------------------------
0000B5r 3               proshr:
0000B5r 3               .if pflag
0000B5r 3               	lda #<SHRAPN		; table.
0000B5r 3               	sta z80_x
0000B5r 3               	lda #>SHRAPN
0000B5r 3               	sta z80_i
0000B5r 3               
0000B5r 3               	lda #NUMSHR		; shrapnel pieces to process.
0000B5r 3               	sta shrctr
0000B5r 3               prosh0:
0000B5r 3               	ldy #0
0000B5r 3               	lda (z80_ix),y		; on/off marker.
0000B5r 3               	asl a
0000B5r 3               proshx:
0000B5r 3               	bcs :+
0000B5r 3               	jsr prosh1 		; on, so process it.
0000B5r 3               :
0000B5r 3               	clc
0000B5r 3               	lda z80_x
0000B5r 3               	adc #SHRSIZ
0000B5r 3               	sta z80_x
0000B5r 3               	bcc :+
0000B5r 3               	inc z80_i
0000B5r 3               :
0000B5r 3               	dec shrctr		; round again.
0000B5r 3               	bne prosh0
0000B5r 3               .endif
0000B5r 3               .if sflag
0000B5r 3               	jsr scrly
0000B5r 3               .endif
0000B5r 3  60           	rts
0000B6r 3               
0000B6r 3               .if pflag
0000B6r 3               ;----------------------------------------------------
0000B6r 3               ; Proces shrapnel piece
0000B6r 3               ;----------------------------------------------------
0000B6r 3               
0000B6r 3               prosh1:
0000B6r 3               	jsr plot 		; delete the pixel.
0000B6r 3               
0000B6r 3               	lda #<shrptr		; shrapnel routine pointers.
0000B6r 3               	sta z80_l
0000B6r 3               	lda #>shrptr
0000B6r 3               	sta z80_h
0000B6r 3               
0000B6r 3               	ldy #0
0000B6r 3               	lda (z80_ix),y		; restore shrapnel type.
0000B6r 3               	jsr prosh2 		; run the routine.
0000B6r 3               	jsr chkxy		; check x and y are good before we redisplay.
0000B6r 3               
0000B6r 3               	lda #<SHRSIZ 		; distance to next.
0000B6r 3               	sta z80_e
0000B6r 3               	lda #>SHRSIZ
0000B6r 3               	sta z80_d
0000B6r 3               	rts
0000B6r 3               
0000B6r 3               ;----------------------------------------------------
0000B6r 3               ; Run the routine
0000B6r 3               ;----------------------------------------------------
0000B6r 3               
0000B6r 3               prosh2:
0000B6r 3               	asl a 			; 2 bytes per address.
0000B6r 3               	tay
0000B6r 3               	lda shrptr,y
0000B6r 3               	sta z80_l
0000B6r 3               	lda shrptr+1,y 		; fetch high byte from table.
0000B6r 3               	sta z80_h
0000B6r 3               	jmp (z80_hl) 		; jump to routine.
0000B6r 3               
0000B6r 3               ;----------------------------------------------------
0000B6r 3               ; Paricle routine table
0000B6r 3               ;----------------------------------------------------
0000B6r 3               
0000B6r 3               shrptr:	.word laser		; laser.
0000B6r 3               	.word trail		; vapour trail.
0000B6r 3               	.word shrap		; shrapnel from explosion.
0000B6r 3               	.word dotl		; horizontal starfield left.
0000B6r 3               	.word dotr		; horizontal starfield right.
0000B6r 3               	.word dotu		; vertical starfield up.
0000B6r 3               	.word dotd		; vertical starfield down.
0000B6r 3               	.word ptcusr		; user particle.
0000B6r 3               
0000B6r 3               ;----------------------------------------------------
0000B6r 3               ; Explosion shrapnel.
0000B6r 3               ;----------------------------------------------------
0000B6r 3               
0000B6r 3               shrap:
0000B6r 3               	ldy #1
0000B6r 3               	lda (z80_ix),y 		; get the angle.
0000B6r 3               	clc
0000B6r 3               	adc #<shrsin		; shrapnel sine table.
0000B6r 3               	sta z80_l
0000B6r 3               	lda #>shrsin
0000B6r 3               	adc #0
0000B6r 3               	sta z80_h
0000B6r 3               
0000B6r 3               	ldy #0
0000B6r 3               	lda (z80_hl),y 		; fetch value from table.
0000B6r 3               	sta z80_e
0000B6r 3               	inc z80_l 		; next byte of table.
0000B6r 3               	bne :+
0000B6r 3               	inc z80_h
0000B6r 3               :
0000B6r 3               	ldy #0
0000B6r 3               	lda (z80_hl),y		; fetch value from table.
0000B6r 3               	sta z80_d
0000B6r 3               	inc z80_l		; next byte of table.
0000B6r 3               	bne :+
0000B6r 3               	inc z80_h
0000B6r 3               :
0000B6r 3               	ldy #0
0000B6r 3               	lda (z80_hl),y 		; fetch value from table.
0000B6r 3               	sta z80_c
0000B6r 3               	inc z80_l 		; next byte of table.
0000B6r 3               	bne :+
0000B6r 3               	inc z80_h
0000B6r 3               :
0000B6r 3               	ldy #0
0000B6r 3               	lda (z80_hl),y 		; fetch value from table.
0000B6r 3               	sta z80_b
0000B6r 3               
0000B6r 3               	ldy #2
0000B6r 3               	lda (z80_ix),y 		; x coordinate in hl.
0000B6r 3               	clc
0000B6r 3               	adc z80_e		; add sine lb
0000B6r 3               	sta (z80_ix),y		; store new coordinate lb.
0000B6r 3               	ldy #3
0000B6r 3               	lda (z80_ix),y
0000B6r 3               	adc z80_d		; add sine hb
0000B6r 3               	sta (z80_ix),y		; store new coordinate hb.
0000B6r 3               
0000B6r 3               	ldy #4
0000B6r 3               	lda (z80_ix),y	 	; y coordinate in hl.
0000B6r 3               	clc
0000B6r 3               	adc z80_c		; add cosine lb
0000B6r 3               	sta (z80_ix),y		; store new coordinate lb.
0000B6r 3               	ldy #5
0000B6r 3               	lda (z80_ix),y
0000B6r 3               	adc z80_b		; add cosine lb
0000B6r 3               	sta (z80_ix),y		; store new coordinate hb.
0000B6r 3               
0000B6r 3               	rts
0000B6r 3               
0000B6r 3               ;----------------------------------------------------
0000B6r 3               ; Move dots
0000B6r 3               ;----------------------------------------------------
0000B6r 3               
0000B6r 3               dotl:
0000B6r 3               	ldy #5
0000B6r 3               	lda (z80_ix),y
0000B6r 3               	sec
0000B6r 3               	sbc #1		 	; move left.
0000B6r 3               	sta (z80_ix),y
0000B6r 3               	rts
0000B6r 3               dotr:
0000B6r 3               	ldy #5
0000B6r 3               	lda (z80_ix),y
0000B6r 3               	clc
0000B6r 3               	adc #1		 	; move left.
0000B6r 3               	sta (z80_ix),y
0000B6r 3               	rts
0000B6r 3               dotu:
0000B6r 3               	ldy #3
0000B6r 3               	lda (z80_ix),y
0000B6r 3               	sec
0000B6r 3               	sbc #1		 	; move up.
0000B6r 3               	sta (z80_ix),y
0000B6r 3               	rts
0000B6r 3               dotd:
0000B6r 3               	ldy #3
0000B6r 3               	lda (z80_ix),y
0000B6r 3               	clc
0000B6r 3               	adc #1			; move down.
0000B6r 3               	sta (z80_ix),y
0000B6r 3               	rts
0000B6r 3               
0000B6r 3               ;----------------------------------------------------
0000B6r 3               ; Check if coordinates are ok before redrawing at new position.
0000B6r 3               ;
0000B6r 3               ; left:   X>L		X=L	Ok
0000B6r 3               ; right:  R+15>X	X=R	Ok
0000B6r 3               ; top:    Y>T		Y=T	Ok
0000B6r 3               ; bottom: B+15>Y	Y=B	Ok
0000B6r 3               ;----------------------------------------------------
0000B6r 3               
0000B6r 3               chkxy:
0000B6r 3               
0000B6r 3               ; top:    Y>T		Y=T	Ok
0000B6r 3               
0000B6r 3               	ldy #3
0000B6r 3               	lda (z80_ix),y	 	; fetch shrapnel coordinate.
0000B6r 3               	cmp wntopx		; window top.
0000B6r 3               	bcs :+			; compare with top window limit.
0000B6r 3               	jmp kilshr		; out of window, kill shrapnel.
0000B6r 3               :
0000B6r 3               ; left:   X>L		X=L	Ok
0000B6r 3               
0000B6r 3               	ldy #5
0000B6r 3               	lda (z80_ix),y	 	; fetch shrapnel coordinate.
0000B6r 3               	cmp wnlftx		; left edge.
0000B6r 3               	bcs :+			; compare with left window limit.
0000B6r 3               	jmp kilshr		; out of window, kill shrapnel.
0000B6r 3               :
0000B6r 3               ; bottom: B+15>Y	Y=B	Ok
0000B6r 3               
0000B6r 3               	lda wnbotx		; point to bottom.
0000B6r 3               	clc
0000B6r 3               	adc #15
0000B6r 3               	ldy #3
0000B6r 3               	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
0000B6r 3               	bcs :+			; compare with shrapnel x coordinate.
0000B6r 3               	jmp kilshr		; off screen, kill shrapnel..
0000B6r 3               :
0000B6r 3               ; right:  R+15>X	X=R	Ok
0000B6r 3               
0000B6r 3               	lda wnrgtx		; point to right edge.
0000B6r 3               	clc
0000B6r 3               	adc #15
0000B6r 3               	ldy #5
0000B6r 3               	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
0000B6r 3               	bcs :+			; compare with window limit.
0000B6r 3               	jmp kilshr		; off screen, kill shrapnel.
0000B6r 3               :
0000B6r 3               
0000B6r 3               ;----------------------------------------------------
0000B6r 3               ; Drop through.
0000B6r 3               ; Display shrapnel.
0000B6r 3               ;----------------------------------------------------
0000B6r 3               
0000B6r 3               plot:
0000B6r 3               	ldy #3
0000B6r 3               	lda (z80_ix),y		; y integer.
0000B6r 3               	sta dispy	 	; workspace coordinates.
0000B6r 3               	ldy #5
0000B6r 3               	lda (z80_ix),y	 	; x integer.
0000B6r 3               	sta dispx 		; workspace coordinates.
0000B6r 3               
0000B6r 3               	ldy #0
0000B6r 3               	lda (z80_ix),y 		; type.
0000B6r 3               	bne :+			; is it a laser?
0000B6r 3               	jmp plot1 		; yes, draw laser instead.
0000B6r 3               :
0000B6r 3               plot0:
0000B6r 3               	lda dispx		; which pixel within byte do we
0000B6r 3               	and #7			; want to set first?
0000B6r 3               	tay
0000B6r 3               	lda dots,y 		; table of small pixel positions.
0000B6r 3               	sta z80_e 		; get value.
0000B6r 3               
0000B6r 3               	jsr scadd 		; screen address.
0000B6r 3               	ldy #0
0000B6r 3               	lda (scraddr),y		; see what's already there.
0000B6r 3               	eor z80_e
0000B6r 3               	sta (scraddr),y 	; put back on screen.
0000B6r 3               	rts
0000B6r 3               
0000B6r 3               plot1:
0000B6r 3               	jsr scadd 		; screen address.
0000B6r 3               	ldy #0
0000B6r 3               	lda (scraddr),y 	; fetch byte there.
0000B6r 3               	eor #255 		; toggle all bits.
0000B6r 3               	sta (scraddr),y 	; new byte.
0000B6r 3               	rts
0000B6r 3               
0000B6r 3               ;----------------------------------------------------
0000B6r 3               ; Switch off shrapnel
0000B6r 3               ;----------------------------------------------------
0000B6r 3               
0000B6r 3               kilshr:
0000B6r 3               	lda #128
0000B6r 3               	ldy #0
0000B6r 3               	sta (z80_ix),y	; switch off shrapnel.
0000B6r 3               	rts
0000B6r 3               
0000B6r 3               ;----------------------------------------------------
0000B6r 3               ; Sine/cosine table
0000B6r 3               ;----------------------------------------------------
0000B6r 3               
0000B6r 3               shrsin:	.word 0,1024,391,946,724,724,946,391
0000B6r 3               	.word 1024,0,946,65144,724,64811,391,64589
0000B6r 3               	.word 0,64512,65144,64589,64811,64811,64589,65144
0000B6r 3               	.word 64512,0,64589,391,64811,724,65144,946
0000B6r 3               
0000B6r 3               ;----------------------------------------------------
0000B6r 3               ; Create trail
0000B6r 3               ;----------------------------------------------------
0000B6r 3               
0000B6r 3               trail:
0000B6r 3               	ldy #1
0000B6r 3               	lda (z80_ix),y 	; time remaining.
0000B6r 3               	sec
0000B6r 3               	sbc #1
0000B6r 3               	sta (z80_ix),y
0000B6r 3               	bne :+
0000B6r 3               	jmp trailk		; time to switch it off.
0000B6r 3               :
0000B6r 3               	jsr qrand		; get a random number.
0000B6r 3               	lsr a 			; x or y axis?
0000B6r 3               	bcc :+
0000B6r 3               	jmp trailv		; use y.
0000B6r 3               :
0000B6r 3               ; Trail horizontal
0000B6r 3               
0000B6r 3               	lsr a 			; which direction?
0000B6r 3               	bcc :+
0000B6r 3               	jmp traill		; go left.
0000B6r 3               :
0000B6r 3               ; Trail right
0000B6r 3               
0000B6r 3               	ldy #5
0000B6r 3               	lda (z80_ix),y
0000B6r 3               	clc
0000B6r 3               	adc #1	 		; go right.
0000B6r 3               	sta (z80_ix),y
0000B6r 3               	rts
0000B6r 3               
0000B6r 3               ; Trail left
0000B6r 3               
0000B6r 3               traill:
0000B6r 3               	ldy #5
0000B6r 3               	lda (z80_ix),y
0000B6r 3               	sec
0000B6r 3               	sbc #1 			; go left.
0000B6r 3               	sta (z80_ix),y
0000B6r 3               	rts
0000B6r 3               
0000B6r 3               ; Trail vertical
0000B6r 3               
0000B6r 3               trailv:
0000B6r 3               	lsr a		 	; which direction?
0000B6r 3               	bcc :+
0000B6r 3               	jmp trailu		; go up.
0000B6r 3               :
0000B6r 3               ; Trail down
0000B6r 3               
0000B6r 3               	ldy #3
0000B6r 3               	lda (z80_ix),y
0000B6r 3               	clc
0000B6r 3               	adc #1 			; go down.
0000B6r 3               	sta (z80_ix),y
0000B6r 3               	rts
0000B6r 3               
0000B6r 3               ; Trail up
0000B6r 3               
0000B6r 3               trailu:
0000B6r 3               	ldy #3
0000B6r 3               	lda (z80_ix),y
0000B6r 3               	sec
0000B6r 3               	sbc #1 			; go up.
0000B6r 3               	sta (z80_ix),y
0000B6r 3               	rts
0000B6r 3               
0000B6r 3               ; Kill trail
0000B6r 3               
0000B6r 3               trailk:
0000B6r 3               	lda #200		; set off-screen to kill vapour trail.
0000B6r 3               	ldy #3
0000B6r 3               	sta (z80_ix),y
0000B6r 3               	rts
0000B6r 3               
0000B6r 3               ;----------------------------------------------------
0000B6r 3               ; Create laser beam
0000B6r 3               ;----------------------------------------------------
0000B6r 3               
0000B6r 3               laser:
0000B6r 3               	ldy #1
0000B6r 3               	lda (z80_ix),y 		; direction.
0000B6r 3               	ror a 			; left or right?
0000B6r 3               	bcs :+
0000B6r 3               	jmp laserl		; move left.
0000B6r 3               :
0000B6r 3               ; Laser right
0000B6r 3               
0000B6r 3               	lda #8			; distance to travel.
0000B6r 3               	sta z80_b
0000B6r 3               	jmp laserm		; move laser.
0000B6r 3               
0000B6r 3               ; Laser left
0000B6r 3               
0000B6r 3               laserl:
0000B6r 3               	lda #248		; distance to travel.
0000B6r 3               	sta z80_b
0000B6r 3               laserm:
0000B6r 3               	ldy #5
0000B6r 3               	lda (z80_ix),y		; x position.
0000B6r 3               	clc
0000B6r 3               	adc z80_b		; add distance.
0000B6r 3               	sta (z80_ix),y		; set new x coordinate.
0000B6r 3               
0000B6r 3               ; Test new block.
0000B6r 3               
0000B6r 3               	sta dispx 		; set x for block collision detection purposes.
0000B6r 3               	ldy #3
0000B6r 3               	lda (z80_ix),y 		; get y.
0000B6r 3               	sta dispy		; set coordinate for collision test.
0000B6r 3               	jsr tstbl 		; get block type there.
0000B6r 3               	cmp #WALL		; is it solid?
0000B6r 3               	bne :+
0000B6r 3               	jmp trailk		; yes, it cannot pass.
0000B6r 3               :
0000B6r 3               .if pflag .or dflag
0000B6r 3                       cmp #FODDER             ; is it fodder?
0000B6r 3                       bne :+
0000B6r 3                       jsr fdchk               ; remove fodder block.
0000B6r 3                       jmp trailk              ; destroy laser.
0000B6r 3               :
0000B6r 3               .endif
0000B6r 3               	rts
0000B6r 3               
0000B6r 3               ;----------------------------------------------------
0000B6r 3               ; Dots mask
0000B6r 3               ;----------------------------------------------------
0000B6r 3               
0000B6r 3               dots:	.byte 128,64,32,16,8,4,2,1
0000B6r 3               
0000B6r 3               
0000B6r 3               ;----------------------------------------------------
0000B6r 3               ; Plot, preserving de.
0000B6r 3               ;----------------------------------------------------
0000B6r 3               
0000B6r 3               plotde:
0000B6r 3               	lda z80_d 		; put de on stack.
0000B6r 3               	pha
0000B6r 3               	lda z80_e
0000B6r 3               	pha
0000B6r 3               
0000B6r 3               	jsr plot 		; plot pixel.
0000B6r 3               
0000B6r 3               	pla			; restore de from stack.
0000B6r 3               	sta z80_e
0000B6r 3               	pla
0000B6r 3               	sta z80_d
0000B6r 3               
0000B6r 3               	rts
0000B6r 3               
0000B6r 3               ;----------------------------------------------------
0000B6r 3               ; Shoot a laser.
0000B6r 3               ;----------------------------------------------------
0000B6r 3               
0000B6r 3               shoot:
0000B6r 3               	sta z80_c		; store direction in c register.
0000B6r 3               	ldy #8
0000B6r 3               	lda (z80_ix),y 		; y coordinate.
0000B6r 3               	clc
0000B6r 3               shoot1:
0000B6r 3               	adc #(SPR_HGT/2-1)	; down 7 pixels.
0000B6r 3               	sta z80_l 		; puty y coordinate in l.
0000B6r 3               
0000B6r 3               	ldy #9
0000B6r 3               	lda (z80_ix),y 		; x coordinate in h.
0000B6r 3               	sta z80_h
0000B6r 3               
0000B6r 3               	lda z80_i		; store pointer to sprite.
0000B6r 3               	pha
0000B6r 3               	lda z80_x
0000B6r 3               	pha
0000B6r 3               
0000B6r 3               	jsr fpslot 		; find particle slot.
0000B6r 3               	bcs :+
0000B6r 3               	jmp vapou2		; failed, restore ix.
0000B6r 3               :
0000B6r 3               	lda #0
0000B6r 3               	ldy #0
0000B6r 3               	sta (z80_ix),y 		; set up a laser.
0000B6r 3               
0000B6r 3               	lda z80_c
0000B6r 3               	ldy #1
0000B6r 3               	sta (z80_ix),y 		; set the direction.
0000B6r 3               
0000B6r 3               	lda z80_l
0000B6r 3               	ldy #3
0000B6r 3               	sta (z80_ix),y		; set y coordinate.
0000B6r 3               
0000B6r 3               	ror z80_c		; check direction we want.
0000B6r 3               	bcc :+
0000B6r 3               	jmp shootr		; shoot right.
0000B6r 3               :
0000B6r 3               	lda z80_h		; X position.
0000B6r 3               shoot0:
0000B6r 3               	and #248		; align on character boundary.
0000B6r 3               	ldy #5
0000B6r 3               	sta (z80_ix),y		; set x coordinate.
0000B6r 3               	jmp vapou0 		; draw first image.
0000B6r 3               shootr:
0000B6r 3               	lda z80_h		; x position.
0000B6r 3               	clc
0000B6r 3               	adc #15			; look right.
0000B6r 3               	jmp shoot0		; align and continue.
0000B6r 3               
0000B6r 3               ;----------------------------------------------------
0000B6r 3               ; Create a bit of vapour trail.
0000B6r 3               ;----------------------------------------------------
0000B6r 3               
0000B6r 3               vapour:
0000B6r 3               	lda z80_i		; store pointer to sprite.
0000B6r 3               	pha
0000B6r 3               	lda z80_x
0000B6r 3               	pha
0000B6r 3               
0000B6r 3               	ldy #8
0000B6r 3               	lda (z80_ix),y 		; y coordinate.
0000B6r 3               	clc
0000B6r 3               vapou3:
0000B6r 3               	adc #(SPR_HGT/2-1)	; mid-point of sprite.
0000B6r 3               	sta z80_l
0000B6r 3               
0000B6r 3               	ldy #9
0000B6r 3               	lda (z80_ix),y 		; x coordinate.
0000B6r 3               	adc #7
0000B6r 3               	sta z80_h
0000B6r 3               
0000B6r 3               	jsr fpslot 		; find particle slot.
0000B6r 3               	bcc :+
0000B6r 3               	jmp vapou1		; no, we can use it.
0000B6r 3               :
0000B6r 3               vapou2:
0000B6r 3               	pla
0000B6r 3               	sta z80_x
0000B6r 3               	pla
0000B6r 3               	sta z80_i
0000B6r 3               	rts
0000B6r 3               vapou1:
0000B6r 3               	lda z80_l
0000B6r 3               	ldy #3
0000B6r 3               	sta (z80_ix),y		; set up y.
0000B6r 3               
0000B6r 3               	lda z80_h
0000B6r 3               	ldy #5
0000B6r 3               	sta (z80_ix),y 		; set up x coordinate.
0000B6r 3               
0000B6r 3               	jsr qrand		; get quick random number.
0000B6r 3               	and #15			; random time.
0000B6r 3               	clc
0000B6r 3               	adc #15			; minimum time on screen.
0000B6r 3               	ldy #1
0000B6r 3               	sta (z80_ix),y		; set time on screen.
0000B6r 3               
0000B6r 3               	lda #1
0000B6r 3               	ldy #0
0000B6r 3               	sta (z80_ix),y		; define particle as vapour trail.
0000B6r 3               vapou0:
0000B6r 3               	jsr chkxy		; plot first position.
0000B6r 3               	jmp vapou2
0000B6r 3               
0000B6r 3               ;----------------------------------------------------
0000B6r 3               ; Create a user particle.
0000B6r 3               ;----------------------------------------------------
0000B6r 3               
0000B6r 3               ptusr:
0000B6r 3               	sta z80_f		; store timer.
0000B6r 3               
0000B6r 3               	ldy #8
0000B6r 3               	lda (z80_ix),y 		; y coordinate.
0000B6r 3               	clc
0000B6r 3               	adc #7			; mid-point of sprite.
0000B6r 3               	sta z80_l
0000B6r 3               
0000B6r 3               	ldy #9
0000B6r 3               	lda (z80_ix),y 		; x coordinate.
0000B6r 3               	clc
0000B6r 3               	adc #7			; mid-point of sprite.
0000B6r 3               	sta z80_h
0000B6r 3               
0000B6r 3               	jsr fpslot 		; find particle slot.
0000B6r 3               	bcs ptusr1
0000B6r 3               	rts 			; out of slots, can't generate anything.
0000B6r 3               ptusr1:
0000B6r 3               	lda z80_l
0000B6r 3               	ldy #3
0000B6r 3               	sta (z80_ix),y 		; set up y.
0000B6r 3               
0000B6r 3               	lda z80_h
0000B6r 3               	ldy #5
0000B6r 3               	sta (z80_ix),y		; set up x coordinate.
0000B6r 3               
0000B6r 3               	lda z80_f 		; restore timer.
0000B6r 3               	ldy #1
0000B6r 3               	sta (z80_ix),y		; set time on screen.
0000B6r 3               
0000B6r 3               	lda #7
0000B6r 3               	ldy #0
0000B6r 3               	sta (z80_ix),y		; define particle as user particle.
0000B6r 3               
0000B6r 3               	jmp chkxy		; plot first position.
0000B6r 3               
0000B6r 3               ;----------------------------------------------------
0000B6r 3               ; Create a vertical or horizontal star.
0000B6r 3               ;----------------------------------------------------
0000B6r 3               
0000B6r 3               star:
0000B6r 3               	lda z80_i		; store pointer to sprite.
0000B6r 3               	pha
0000B6r 3               	lda z80_x
0000B6r 3               	pha
0000B6r 3               
0000B6r 3               	jsr fpslot 		; find particle slot.
0000B6r 3               	bcs star7		; found one we can use.
0000B6r 3               star0:
0000B6r 3               	pla 			; restore sprite pointer.
0000B6r 3               	sta z80_x
0000B6r 3               	pla
0000B6r 3               	sta z80_i
0000B6r 3               	rts 			; out of slots, can't generate anything.
0000B6r 3               star7:
0000B6r 3               	lda z80_c		; direction.
0000B6r 3               	and #3 			; is it left?
0000B6r 3               	bne :+
0000B6r 3               	jmp star1 		; yes, it's left.
0000B6r 3               :
0000B6r 3               	cmp #1 			; is it right?
0000B6r 3               	bne :+
0000B6r 3               	jmp star2 		; yes, it's right.
0000B6r 3               :
0000B6r 3               	cmp #2 			; is it up?
0000B6r 3               	bne :+
0000B6r 3               	jmp star3 		; yes, it's up.
0000B6r 3               :
0000B6r 3               	ldy wntopx 		; get edge of screen.
0000B6r 3               	iny			; down one pixel.
0000B6r 3               	tya
0000B6r 3               star8:
0000B6r 3               	ldy #3
0000B6r 3               	sta (z80_ix),y 		; set y coord.
0000B6r 3               	jsr qrand 		; get quick random number.
0000B6r 3               star9:
0000B6r 3               	ldy #5
0000B6r 3               	sta (z80_ix),y		; set x position.
0000B6r 3               
0000B6r 3               	lda z80_c		; direction.
0000B6r 3               	and #3			; zero to three.
0000B6r 3               	clc
0000B6r 3               	adc #3			; 3 to 6 for starfield.
0000B6r 3               	ldy #0
0000B6r 3               	sta (z80_ix),y		; define particle as star.
0000B6r 3               	jsr chkxy		; plot first position.
0000B6r 3               	jmp star0
0000B6r 3               star1:
0000B6r 3               	jsr qrand		; get quick random number.
0000B6r 3               	ldy #3
0000B6r 3               	sta (z80_ix),y 		; set y coord.
0000B6r 3               
0000B6r 3               	lda wnrgtx 		; get edge of screen.
0000B6r 3               	clc
0000B6r 3               	adc #15			; add width of sprite minus 1.
0000B6r 3               	jmp star9
0000B6r 3               star2:
0000B6r 3               	jsr qrand 		; get quick random number.
0000B6r 3               	ldy #3
0000B6r 3               	sta (z80_ix),y		; set y coord.
0000B6r 3               
0000B6r 3               	lda wnlftx		; get edge of screen.
0000B6r 3               	jmp star9
0000B6r 3               star3:
0000B6r 3               	lda wnbotx 		; get edge of screen.
0000B6r 3               	clc
0000B6r 3               	adc #15 		; height of sprite minus one pixel.
0000B6r 3               	jmp star8
0000B6r 3               
0000B6r 3               ;----------------------------------------------------
0000B6r 3               ; Find particle slot for lasers or vapour trail.
0000B6r 3               ; can't use alternate accumulator.
0000B6r 3               ;----------------------------------------------------
0000B6r 3               
0000B6r 3               fpslot:
0000B6r 3               	lda #<SHRAPN 		; shrapnel table.
0000B6r 3               	sta z80_x
0000B6r 3               	lda #>SHRAPN
0000B6r 3               	sta z80_i
0000B6r 3               
0000B6r 3               	lda #NUMSHR		; number of pieces in table.
0000B6r 3               	sta z80_b
0000B6r 3               fpslt0:
0000B6r 3               	ldy #0
0000B6r 3               	lda (z80_ix),y		; get type.
0000B6r 3               	asl a  			; is this slot in use?
0000B6r 3               	bcc :+
0000B6r 3               	rts			; no, we can use it.
0000B6r 3               :
0000B6r 3               	clc			; point to more shrapnel.
0000B6r 3               	lda z80_x
0000B6r 3               	adc #SHRSIZ
0000B6r 3               	sta z80_x
0000B6r 3               	bcc :+
0000B6r 3               	inc z80_i
0000B6r 3               :
0000B6r 3               	dec z80_b		; repeat for all shrapnel.
0000B6r 3               	bne fpslt0
0000B6r 3               
0000B6r 3               	clc
0000B6r 3               	rts 			; out of slots, can't generate anything.
0000B6r 3               
0000B6r 3               ;----------------------------------------------------
0000B6r 3               ; Create an explosion at sprite position.
0000B6r 3               ;----------------------------------------------------
0000B6r 3               
0000B6r 3               explod:
0000B6r 3               	sta z80_c 		; particles to create.
0000B6r 3               
0000B6r 3               	lda z80_i 		; store pointer to sprite.
0000B6r 3               	pha
0000B6r 3               	lda z80_x
0000B6r 3               	pha
0000B6r 3               
0000B6r 3               	ldy #8
0000B6r 3               	lda (z80_ix),y 		; y coordinate.
0000B6r 3               	sta z80_l
0000B6r 3               	ldy #9
0000B6r 3               	lda (z80_ix),y		; x coordinate.
0000B6r 3               	sta z80_h
0000B6r 3               
0000B6r 3               	lda #<SHRAPN		; shrapnel table.
0000B6r 3               	sta z80_x
0000B6r 3               	lda #>SHRAPN
0000B6r 3               	sta z80_i
0000B6r 3               
0000B6r 3               	lda #NUMSHR		; number of pieces in table.
0000B6r 3               	sta explcnt
0000B6r 3               expld0:
0000B6r 3               	ldy #0
0000B6r 3               	lda (z80_ix),y		; get type.
0000B6r 3               	asl a 			; is this slot in use?
0000B6r 3               	bcs expld1		; no, we can use it.
0000B6r 3               expld2:
0000B6r 3               	clc
0000B6r 3               	lda z80_x
0000B6r 3               	adc #SHRSIZ
0000B6r 3               	sta z80_x
0000B6r 3               	bcc :+
0000B6r 3               	inc z80_i
0000B6r 3               :
0000B6r 3               	dec explcnt		; repeat for all shrapnel.
0000B6r 3               	bne expld0
0000B6r 3               expld3:
0000B6r 3               	pla			; restore sprite pointer.
0000B6r 3               	sta z80_x
0000B6r 3               	pla
0000B6r 3               	sta z80_i
0000B6r 3               	rts 			; out of slots, can't generate any more.
0000B6r 3               
0000B6r 3               expld1:
0000B6r 3               	lda z80_c		; shrapnel counter.
0000B6r 3               	and #15			; 0 to 15.
0000B6r 3               	clc			; add to x.
0000B6r 3               	adc z80_l
0000B6r 3               	ldy #3
0000B6r 3               	sta (z80_ix),y		; y coord.
0000B6r 3               
0000B6r 3               	lda seed3 		; crap random number.
0000B6r 3               	and #15			; 0 to 15.
0000B6r 3               	clc 			; add to y.
0000B6r 3               	adc z80_h
0000B6r 3               	ldy #5
0000B6r 3               	sta (z80_ix),y		; x coord.
0000B6r 3               
0000B6r 3               	lda #2
0000B6r 3               	ldy #0
0000B6r 3               	sta (z80_ix),y		; switch it on.
0000B6r 3               
0000B6r 3               	jsr chkxy		; plot first position.
0000B6r 3               	jsr qrand		; quick random angle.
0000B6r 3               	and #60 		; keep within range.
0000B6r 3               	ldy #1
0000B6r 3               	sta (z80_ix),y		; angle.
0000B6r 3               
0000B6r 3               	dec z80_c		; one less piece of shrapnel to generate.
0000B6r 3               	bne expld2 		; back to main explosion loop.
0000B6r 3               	jmp expld3 		; restore sprite pointer and exit.
0000B6r 3               
0000B6r 3               ;----------------------------------------------------
0000B6r 3               ; Quick random
0000B6r 3               ;----------------------------------------------------
0000B6r 3               
0000B6r 3               qrand:
0000B6r 3               	jsr random		; r register.
0000B6r 3               	eor seed3		; combine with seed.
0000B6r 3               	sta seed3 		; new seed.
0000B6r 3               	rts
0000B6r 3               
0000B6r 3               ;----------------------------------------------------
0000B6r 3               ; Display all shrapnel.
0000B6r 3               ;----------------------------------------------------
0000B6r 3               
0000B6r 3               dshrp:
0000B6r 3               	lda #<plotde		; display routine.
0000B6r 3               	sta proshx+1
0000B6r 3               	lda #>plotde
0000B6r 3               	sta proshx+2
0000B6r 3               	jsr proshr		; process shrapnel.
0000B6r 3               
0000B6r 3               	lda #<prosh1		; processing routine.
0000B6r 3               	sta proshx+1
0000B6r 3               	lda #>prosh1
0000B6r 3               	sta proshx+2
0000B6r 3               	rts
0000B6r 3               
0000B6r 3               ;------------------------------------------------------
0000B6r 3               ; Particle engine.
0000B6r 3               ;
0000B6r 3               ; Init particle data for 55 particles in SHRAPN table.
0000B6r 3               ; Every particle has 6 bytes.
0000B6r 3               ;
0000B6r 3               ; global:	-
0000B6r 3               ; local:	x,y,hl
0000B6r 3               ; calls:	-
0000B6r 3               ;------------------------------------------------------
0000B6r 3               
0000B6r 3               inishr:
0000B6r 3               	lda #<SHRAPN 		; table.
0000B6r 3               	sta z80_l
0000B6r 3               	lda #>SHRAPN
0000B6r 3               	sta z80_h
0000B6r 3               
0000B6r 3               	ldy #0
0000B6r 3               	ldx #NUMSHR		; shrapnel pieces to process.
0000B6r 3               inish0:
0000B6r 3               	lda #255 		; kill the shrapnel.
0000B6r 3               	sta (z80_hl),y
0000B6r 3               
0000B6r 3               	clc 			; point there.
0000B6r 3               	lda z80_l
0000B6r 3               	adc #SHRSIZ		; distance to next.
0000B6r 3               	sta z80_l
0000B6r 3               	bcc :+
0000B6r 3               	inc z80_h
0000B6r 3               :
0000B6r 3               	dex
0000B6r 3               	bne inish0 		; round again.
0000B6r 3               	rts
0000B6r 3               
0000B6r 3               ;------------------------------------------------------
0000B6r 3               ; Check for collision between laser and sprite.
0000B6r 3               ;------------------------------------------------------
0000B6r 3               
0000B6r 3               lcol:
0000B6r 3               	lda #<SHRAPN		; shrapnel table.
0000B6r 3               	sta z80_l
0000B6r 3               	lda #>SHRAPN
0000B6r 3               	sta z80_h
0000B6r 3               
0000B6r 3               	lda #NUMSHR		; number of pieces in table.
0000B6r 3               	sta z80_b
0000B6r 3               lcol0:
0000B6r 3               	ldy #0
0000B6r 3               	lda (z80_hl),y 		; get type.
0000B6r 3               	beq lcol1		; yes, check collision.
0000B6r 3               lcol3:
0000B6r 3               	clc			; point to more shrapnel.
0000B6r 3               	lda z80_l
0000B6r 3               	adc #SHRSIZ
0000B6r 3               	sta z80_l
0000B6r 3               	bcc :+
0000B6r 3               	inc z80_h
0000B6r 3               :
0000B6r 3               	dec z80_b		; repeat for all shrapnel.
0000B6r 3               	bne lcol0
0000B6r 3               	clc
0000B6r 3               	rts 			; no collision, carry not set.
0000B6r 3               lcol1:
0000B6r 3               	ldy #3
0000B6r 3               	lda (z80_hl),y		; get y.
0000B6r 3               	sec
0000B6r 3               	ldy #8
0000B6r 3               	sbc (z80_ix),y		; subtract sprite y.
0000B6r 3               lcolh:
0000B6r 3               	cmp #SPR_HGT 		; within range?
0000B6r 3               	bcc :+
0000B6r 3               	jmp lcol2		; no, missed.
0000B6r 3               :
0000B6r 3               	ldy #5
0000B6r 3               	lda (z80_hl),y 		; get x.
0000B6r 3               	sec
0000B6r 3               	ldy #9
0000B6r 3               	sbc (z80_ix),y 		; subtract sprite y.
0000B6r 3               	cmp #16			; within range?
0000B6r 3               	bcs :+
0000B6r 3               	jmp lcol4 		; yes, collision occurred.
0000B6r 3               :
0000B6r 3               lcol2:
0000B6r 3               	jmp lcol3
0000B6r 3               lcol4:
0000B6r 3               	sec
0000B6r 3               	rts 			; return with carry set for collision.
0000B6r 3               .endif
0000B6r 3               
0000B6r 3               ;------------------------------------------------------
0000B6r 3               ; Main game engine code starts here.
0000B6r 3               ; After initialisation, mloop is the main loop
0000B6r 3               ;------------------------------------------------------
0000B6r 3               
0000B6r 3               game:
0000B6r 3               
0000B6r 3               ; Set up screen address table.
0000B6r 3               
0000B6r 3               setsat:
0000B6r 3  A9 00        	lda #<CharAddress	; start of screen.
0000B8r 3  85 rr        	sta scraddr
0000BAr 3  A9 10        	lda #>CharAddress
0000BCr 3  85 rr        	sta scraddr+1
0000BEr 3               
0000BEr 3  A0 00        	ldy #0			; vertical lines on screen.
0000C0r 3               setsa0:
0000C0r 3  A5 rr        	lda scraddr
0000C2r 3  99 00 07     	sta SCADTB_lb,y		; write low byte.
0000C5r 3  A5 rr        	lda scraddr+1
0000C7r 3  99 00 08     	sta SCADTB_hb,y		; write high byte.
0000CAr 3  20 rr rr     	jsr nline		; next line down.
0000CDr 3  C8           	iny			; next position in table.
0000CEr 3  D0 F0        	bne setsa0
0000D0r 3               
0000D0r 3               ; Set up colour address table
0000D0r 3               
0000D0r 3               setsof:
0000D0r 3  A9 00        	lda #<ColorAttr		; start of colour attributes
0000D2r 3  85 rr        	sta bufaddr
0000D4r 3  A9 96        	lda #>ColorAttr
0000D6r 3  85 rr        	sta bufaddr+1
0000D8r 3               
0000D8r 3  A0 00        	ldy #0			; vertical lines on screen.
0000DAr 3               setof0:
0000DAr 3  A5 rr        	lda bufaddr
0000DCr 3  99 4A 0A     	sta COLATTTB_lb,y	; write low byte.
0000DFr 3  A5 rr        	lda bufaddr+1
0000E1r 3  99 55 0A     	sta COLATTTB_hb,y	; write high byte.
0000E4r 3  18           	clc			; next line down.
0000E5r 3  A5 rr        	lda bufaddr
0000E7r 3  69 16        	adc #ScrWidth
0000E9r 3  85 rr        	sta bufaddr
0000EBr 3  90 02        	bcc :+
0000EDr 3  E6 rr        	inc bufaddr+1
0000EFr 3               :
0000EFr 3  C8           	iny			; next position in table.
0000F0r 3  C0 0B        	cpy #ScrHeight/2
0000F2r 3  D0 E6        	bne setof0
0000F4r 3               
0000F4r 3               ; Init graphics mode
0000F4r 3               
0000F4r 3  20 rr rr     	jsr init
0000F7r 3               
0000F7r 3               ; Init joysticks
0000F7r 3  20 rr rr     	jsr joyinit		; VIC20 joystick
0000FAr 3               
0000FAr 3               rpblc2:
0000FAr 3               .if pflag
0000FAr 3               	jsr inishr 		; initialise particle engine.
0000FAr 3               .endif
0000FAr 3               evintr:
0000FAr 3  20 rr rr     	jsr evnt12 		; call intro/menu event.
0000FDr 3               
0000FDr 3  A9 02        	lda #WALL 		; write default property.
0000FFr 3  A2 00        	ldx #0
000101r 3               clrmap:
000101r 3  9D 00 04     	sta MAP,x 		; block properties.
000104r 3  9D 00 05     	sta MAP+256,x
000107r 3  E8           	inx
000108r 3  D0 F7        	bne clrmap
00010Ar 3               
00010Ar 3               .if oflag
00010Ar 3  20 rr rr     	jsr iniob 		; initialise objects.
00010Dr 3               .endif
00010Dr 3  A9 00        	lda #0			; put zero in accumulator.
00010Fr 3  85 rr        	sta gamwon		; reset game won flag.
000111r 3               
000111r 3  20 rr rr     	jsr inisc 		; init the score.
000114r 3               mapst:
000114r 3  AD rr rr     	lda stmap 		; start position on map.
000117r 3  8D rr rr     	sta roomtb		; set up position in table, if there is one.
00011Ar 3               
00011Ar 3               inipbl:
00011Ar 3               .if aflag
00011Ar 3               	lda #<eop		; reset blockpointer
00011Ar 3               	sta pbptr
00011Ar 3               	lda #>eop
00011Ar 3               	sta pbptr+1
00011Ar 3               .endif
00011Ar 3  20 rr rr     	jsr initsc 		; set up first screen.
00011Dr 3               
00011Dr 3  A9 rr        	lda #<ssprit 		; default to spare sprite in table.
00011Fr 3  85 rr        	sta z80_x
000121r 3  A9 rr        	lda #>ssprit
000123r 3  85 rr        	sta z80_i
000125r 3               evini:
000125r 3  20 rr rr     	jsr evnt13 		; initialisation.
000128r 3               
000128r 3               ; Two restarts.
000128r 3               ; First restart - clear all sprites and initialise everything.
000128r 3               
000128r 3               rstrt:
000128r 3  20 rr rr     	jsr rsevt 		; restart events.
00012Br 3  20 rr rr     	jsr xspr 		; clear sprite table.
00012Er 3  20 rr rr     	jsr sprlst 		; fetch pointer to screen sprites.
000131r 3  20 rr rr     	jsr ispr 		; initialise sprite table.
000134r 3  4C rr rr     	jmp rstrt0
000137r 3               
000137r 3               ; Second restart - clear all but player, and don't initialise him.
000137r 3               
000137r 3               rstrtn:
000137r 3  20 rr rr     	jsr rsevt		; restart events.
00013Ar 3  20 rr rr     	jsr nspr 		; clear all non-player sprites.
00013Dr 3  20 rr rr     	jsr sprlst 		; fetch pointer to screen sprites.
000140r 3  20 rr rr     	jsr kspr 		; initialise sprite table, no more players.
000143r 3               
000143r 3               ; Set up the player and/or enemy sprites.
000143r 3               
000143r 3               rstrt0:
000143r 3  A9 00        	lda #0 			; zero in accumulator.
000145r 3  85 rr        	sta nexlev 		; reset next level flag.
000147r 3  85 rr        	sta restfl 		; reset restart flag.
000149r 3  85 rr        	sta deadf 		; reset dead flag.
00014Br 3               
00014Br 3  20 rr rr     	jsr droom 		; show screen layout.
00014Er 3               rpblc0:
00014Er 3               .if pflag
00014Er 3               	jsr inishr 		; initialise particle engine.
00014Er 3               .endif
00014Er 3               .if aflag
00014Er 3               	jsr rbloc		; draw blocks for this screen
00014Er 3               .endif
00014Er 3               .if oflag
00014Er 3  20 rr rr     	jsr shwob		; draw objects.
000151r 3               .endif
000151r 3               
000151r 3  A9 rr        	lda #<sprtab 		; address of sprite table, even sprites.
000153r 3  85 rr        	sta z80_x
000155r 3  A9 rr        	lda #>sprtab
000157r 3  85 rr        	sta z80_i
000159r 3  20 rr rr     	jsr dspr 		; display sprites.
00015Cr 3  A9 rr        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
00015Er 3  85 rr        	sta z80_x
000160r 3  A9 rr        	lda #>(sprtab+TABSIZ)
000162r 3  85 rr        	sta z80_i
000164r 3  20 rr rr     	jsr dspr 		; display sprites.
000167r 3               mloop:
000167r 3  20 rr rr     	jsr vsync 		; synchronise with display.
00016Ar 3               
00016Ar 3  A9 rr        	lda #<sprtab 		; address of sprite table, even sprites.
00016Cr 3  85 rr        	sta z80_x
00016Er 3  A9 rr        	lda #>sprtab
000170r 3  85 rr        	sta z80_i
000172r 3  20 rr rr     	jsr dspr 		; display even sprites.
000175r 3               
000175r 3               ;	jsr plsnd 		; play sounds.
000175r 3  20 rr rr     	jsr vsync 		; synchronise with display.
000178r 3  20 rr rr     	jsr proshr
00017Br 3               
00017Br 3  A9 rr        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
00017Dr 3  85 rr        	sta z80_x
00017Fr 3  A9 rr        	lda #>(sprtab+TABSIZ)
000181r 3  85 rr        	sta z80_i
000183r 3  20 rr rr     	jsr dspr 		; display odd sprites.
000186r 3               
000186r 3  A9 rr        	lda #<(ssprit) 		; point to spare sprite for spawning purposes.
000188r 3  85 rr        	sta z80_x
00018Ar 3  A9 rr        	lda #>(ssprit)
00018Cr 3  85 rr        	sta z80_i
00018Er 3               evlp1:
00018Er 3  20 rr rr     	jsr evnt10 		; called once per main loop.
000191r 3  20 rr rr     	jsr pspr 		; process sprites.
000194r 3               
000194r 3               ; Main loop events.
000194r 3               
000194r 3  A9 rr        	lda #<ssprit 		; point to spare sprite for spawning purposes.
000196r 3  85 rr        	sta z80_x
000198r 3  A9 rr        	lda #>ssprit
00019Ar 3  85 rr        	sta z80_i
00019Cr 3               evlp2:
00019Cr 3  20 rr rr     	jsr evnt11 		; called once per main loop.
00019Fr 3               bsortx:
00019Fr 3  20 rr rr     	jsr bsort 		; sort sprites.
0001A2r 3               
0001A2r 3  A5 rr        	lda nexlev		; finished level flag.
0001A4r 3  D0 1F        	bne newlev		; is set, go to next level.
0001A6r 3  A5 rr        	lda gamwon		; finished game flag.
0001A8r 3  D0 2A        	bne evwon		; is set, finish the game.
0001AAr 3  A5 rr        	lda restfl 		; finished level flag.
0001ACr 3  C9 01        	cmp #1			; has it been set?
0001AEr 3  D0 03        	bne :+
0001B0r 3  4C rr rr     	jmp rstrt		; yes, go to next level.
0001B3r 3               :
0001B3r 3  C9 02        	cmp #2			; has it been set?
0001B5r 3  D0 03        	bne :+
0001B7r 3  4C rr rr     	jmp rstrtn		; yes, go to next level.
0001BAr 3               :
0001BAr 3  A5 rr        	lda deadf 		; dead flag.
0001BCr 3  D0 1C        	bne pdead		; yes, player dead.
0001BEr 3               
0001BEr 3               ; back to start of main loop.
0001BEr 3               
0001BEr 3  E6 rr        	inc frmno
0001C0r 3  E6 rr        	inc clock
0001C2r 3  4C rr rr     	jmp mloop		; switched to a jmp mloop during test mode.
0001C5r 3               
0001C5r 3               ;----------------------------------------------------------
0001C5r 3               ; Read blocks from list and update screen accordingly.
0001C5r 3               ;----------------------------------------------------------
0001C5r 3               
0001C5r 3               .if aflag
0001C5r 3               rbloc:
0001C5r 3               	lda #<eop		; reset blockpointer
0001C5r 3               	sta pbbuf
0001C5r 3               	lda #>eop
0001C5r 3               	sta pbbuf+1
0001C5r 3               
0001C5r 3               rbloc2:
0001C5r 3               	lda pbbuf			; check for last block
0001C5r 3               	cmp pbptr
0001C5r 3               	bne rbloc1
0001C5r 3               	lda pbbuf+1
0001C5r 3               	cmp pbptr+1
0001C5r 3               	bne rbloc1
0001C5r 3               	rts
0001C5r 3               rbloc1:
0001C5r 3               	ldy #0
0001C5r 3               	lda (pbbuf),y		; check if block for this scno
0001C5r 3               	cmp scno
0001C5r 3               	bne rbloc0		; if not, skip
0001C5r 3               	iny
0001C5r 3               	lda (pbbuf),y		; get y
0001C5r 3               	sta dispy
0001C5r 3               	iny
0001C5r 3               	lda (pbbuf),y		; get x
0001C5r 3               	sta dispx
0001C5r 3               	iny
0001C5r 3               	lda (pbbuf),y		; get blocknr
0001C5r 3               	jsr pattr2		; draw block
0001C5r 3               rbloc0:
0001C5r 3               	clc			; point to next block
0001C5r 3               	lda pbbuf
0001C5r 3               	adc #4
0001C5r 3               	sta pbbuf
0001C5r 3               	bcc rbloc2
0001C5r 3               	inc pbbuf+1
0001C5r 3               	jmp rbloc2
0001C5r 3               .endif
0001C5r 3               
0001C5r 3               ;----------------------------------------------------------
0001C5r 3               ; New level
0001C5r 3               ;----------------------------------------------------------
0001C5r 3               
0001C5r 3               newlev:
0001C5r 3  A5 rr        	lda scno 			; current screen.
0001C7r 3  18           	clc
0001C8r 3  69 01        	adc #1				; next screen.
0001CAr 3  CD rr rr     	cmp numsc 			; total number of screens.
0001CDr 3  B0 05        	bcs evwon			; yes, game finished.
0001CFr 3  85 rr        	sta scno			; set new level number.
0001D1r 3  4C rr rr     	jmp rstrt			; restart, clearing all aliens.
0001D4r 3               
0001D4r 3               evwon:
0001D4r 3  20 rr rr     	jsr evnt18		 	; game completed.
0001D7r 3  4C rr rr     	jmp tidyup			; tidy up and return to BASIC/calling routine.
0001DAr 3               
0001DAr 3               ;----------------------------------------------------------
0001DAr 3               ; Player dead.
0001DAr 3               ;----------------------------------------------------------
0001DAr 3               
0001DAr 3               pdead:
0001DAr 3  A9 00        	lda #0				; zeroise accumulator.
0001DCr 3  85 rr        	sta deadf			; reset dead flag.
0001DEr 3               evdie:
0001DEr 3  20 rr rr     	jsr evnt16 			; death subroutine.
0001E1r 3  A5 rr        	lda numlif			; number of lives.
0001E3r 3  F0 03        	beq :+
0001E5r 3  4C rr rr     	jmp rstrt 			; restart game.
0001E8r 3               :
0001E8r 3               evfail:
0001E8r 3  20 rr rr     	jsr evnt17 			; failure event.
0001EBr 3  4C rr rr     	jmp game			; restart game
0001EEr 3               
0001EEr 3               ;----------------------------------------------------------
0001EEr 3               ; Tidy things up
0001EEr 3               ;----------------------------------------------------------
0001EEr 3               
0001EEr 3               tidyup:
0001EEr 3  A0 00        	ldy #0				; digits to check.
0001F0r 3               tidyu2:
0001F0r 3  B9 rr rr     	lda score,y 			; get score digit.
0001F3r 3  CD rr rr     	cmp hiscor 			; are we larger than high score digit?
0001F6r 3  90 07        	bcc tidyu0			; high score is bigger.
0001F8r 3  D0 0E        	bne tidyu1			; score is greater, record new high score.
0001FAr 3  C8           	iny				; next digit of high score.
0001FBr 3  C0 06        	cpy #6
0001FDr 3  D0 F1        	bne tidyu2			; repeat for all digits
0001FFr 3               tidyu0:
0001FFr 3  A9 rr        	lda #<score			; return pointing to score.
000201r 3  85 rr        	sta z80_c
000203r 3  A9 rr        	lda #>score
000205r 3  85 rr        	sta z80_b
000207r 3  60           	rts
000208r 3               tidyu1:
000208r 3  A0 05        	ldy #5
00020Ar 3               tidyu3:
00020Ar 3  B9 rr rr     	lda score,y			; score.
00020Dr 3  99 rr rr     	sta hiscor,y			; high score.
000210r 3  88           	dey
000211r 3  10 F7        	bpl tidyu3 			; copy score to high score.
000213r 3               evnewh:
000213r 3  20 rr rr     	jsr evnt19			; new high score event.
000216r 3  4C rr rr     	jmp tidyu0			; tidy up.
000219r 3               
000219r 3               ;--------------------------------------------------
000219r 3               ; Restart event.
000219r 3               ;--------------------------------------------------
000219r 3               
000219r 3               rsevt:
000219r 3  A9 rr        	lda #<ssprit 			; default to spare element in table.
00021Br 3  85 rr        	sta z80_x
00021Dr 3  A9 rr        	lda #>ssprit
00021Fr 3  85 rr        	sta z80_i
000221r 3               
000221r 3               evrs:
000221r 3  4C rr rr     	jmp evnt14	 		; call restart event.
000224r 3               
000224r 3               ;------------------------------------------------------------------
000224r 3               ; Copy number passed in a to string position bc, right-justified.
000224r 3               ;
000224r 3               ; Input:
000224r 3               ;  A  = number
000224r 3               ;  BC = string address
000224r 3               ;
000224r 3               ; Output:
000224r 3               ;  BC = string with number
000224r 3               ;-----------------------------------------------------------------
000224r 3               
000224r 3               num2ch:
000224r 3  85 rr        	sta z80_d		; Save number
000226r 3               
000226r 3  A9 00        	lda #0
000228r 3  85 rr        	sta flag
00022Ar 3               numdg3:
00022Ar 3  A2 64        	ldx #100		; hundreds column.
00022Cr 3  86 rr        	stx z80_e
00022Er 3  20 rr rr     	jsr numdg		; show digit.
000231r 3               numdg2:
000231r 3  A2 0A        	ldx #10			; tens column.
000233r 3  86 rr        	stx z80_e
000235r 3  20 rr rr     	jsr numdg		; show digit.
000238r 3               
000238r 3  E6 rr        	inc flag
00023Ar 3  A2 01        	ldx #1			; units column.
00023Cr 3  86 rr        	stx z80_e
00023Er 3               numdg:
00023Er 3  A9 30        	lda #48			; clear digit.
000240r 3  85 rr        	sta z80_a
000242r 3               numdg1:
000242r 3  A5 rr        	lda z80_d
000244r 3  C5 rr        	cmp z80_e
000246r 3  90 0E        	bcc numdg0		; nothing to show.
000248r 3  38           	sec
000249r 3  A5 rr        	lda z80_d
00024Br 3  E5 rr        	sbc z80_e		; subtract from column.
00024Dr 3  85 rr        	sta z80_d
00024Fr 3  E6 rr        	inc z80_a		; increment digit.
000251r 3  E6 rr        	inc flag
000253r 3  4C rr rr     	jmp numdg1		; repeat until column is zero.
000256r 3               numdg0:
000256r 3  A0 00        	ldy #0
000258r 3  A5 rr        	lda z80_a
00025Ar 3  91 rr        	sta (z80_bc),y		; write digit to buffer.
00025Cr 3  A5 rr        	lda flag
00025Er 3  F0 06        	beq :+
000260r 3  E6 rr        	inc z80_c		; next buffer position.
000262r 3  D0 02        	bne :+
000264r 3  E6 rr        	inc z80_b
000266r 3               :
000266r 3  60           	rts
000267r 3               num2dd:
000267r 3  85 rr        	sta z80_d		; Save number
000269r 3               
000269r 3  A9 01        	lda #1
00026Br 3  85 rr        	sta flag
00026Dr 3               
00026Dr 3  4C rr rr     	jmp numdg2
000270r 3               num2td:
000270r 3  85 rr        	sta z80_d		; Save number
000272r 3               
000272r 3  A9 01        	lda #1
000274r 3  85 rr        	sta flag
000276r 3  4C rr rr     	jmp numdg3
000279r 3               
000279r 3               ;---------------------------------------------------------
000279r 3               ; Reset score to "000000"
000279r 3               ;---------------------------------------------------------
000279r 3               
000279r 3               inisc:
000279r 3  A9 30        	lda #'0'
00027Br 3  A2 05        	ldx #5			; digits to initialise.
00027Dr 3               inisc0:
00027Dr 3  9D rr rr     	sta score,x 		; write zero digit.
000280r 3  CA           	dex			; next column.
000281r 3  10 FA        	bpl inisc0		; repeat for all digits.
000283r 3               
000283r 3  60           	rts
000284r 3               
000284r 3               ;-----------------------------------------------------
000284r 3               ; Multiply h by d and return in hl.
000284r 3               ;
000284r 3               ; Input:
000284r 3               ;  H = first number
000284r 3               ;  D = second number
000284r 3               ;
000284r 3               ; Output:
000284r 3               ;  HL = result H x D
000284r 3               ;-----------------------------------------------------
000284r 3               
000284r 3               imul:
000284r 3  A5 rr        	lda z80_d		; HL = H * D
000286r 3  85 rr        	sta z80_e
000288r 3  A5 rr        	lda z80_h
00028Ar 3  85 rr        	sta z80_c		; make c first multiplier.
00028Cr 3               imul0:
00028Cr 3  A9 00        	lda #0			; zeroise total.
00028Er 3  85 rr        	sta z80_l
000290r 3  85 rr        	sta z80_h
000292r 3               
000292r 3  A5 rr        	lda z80_h
000294r 3  85 rr        	sta z80_d		; zeroise high byte.
000296r 3               
000296r 3  A9 08        	lda #8			; repeat 8 times.
000298r 3  85 rr        	sta z80_b
00029Ar 3               imul1:
00029Ar 3  46 rr        	lsr z80_c		; rotate rightmost bit into carry.
00029Cr 3  90 0E        	bcc imul2		; wasn't set.
00029Er 3  18           	clc			; bit was set, so add de.
00029Fr 3  A5 rr        	lda z80_l
0002A1r 3  65 rr        	adc z80_e
0002A3r 3  85 rr        	sta z80_l
0002A5r 3  A5 rr        	lda z80_h
0002A7r 3  65 rr        	adc z80_d
0002A9r 3  85 rr        	sta z80_h
0002ABr 3  18           	clc 			; reset carry.
0002ACr 3               imul2:
0002ACr 3  06 rr        	asl z80_e 		; shift de 1 bit left.
0002AEr 3  26 rr        	rol z80_d
0002B0r 3  C6 rr        	dec z80_b
0002B2r 3  D0 E6        	bne imul1		; repeat 8 times.
0002B4r 3               
0002B4r 3  60           	rts
0002B5r 3               
0002B5r 3               ;-----------------------------------------------
0002B5r 3               ; Divide d by e and return in d, remainder in a.
0002B5r 3               ;
0002B5r 3               ; Input:
0002B5r 3               ;  D = first number
0002B5r 3               ;  E = second number
0002B5r 3               ;
0002B5r 3               ; Output:
0002B5r 3               ;  D = result D/E
0002B5r 3               ;  A = remainder
0002B5r 3               ;-----------------------------------------------
0002B5r 3               
0002B5r 3               idiv:
0002B5r 3  A9 00        	lda #0
0002B7r 3  A0 08        	ldy #8		 	; bits to shift.
0002B9r 3  06 rr        	asl z80_d
0002BBr 3               idiv0:
0002BBr 3  2A           	rol a 			; multiply d by 2.
0002BCr 3  C5 rr        	cmp z80_e 		; test if e is smaller.
0002BEr 3  90 02        	bcc idiv1		; e is greater, no division this time.
0002C0r 3  E5 rr        	sbc z80_e		; subtract it.
0002C2r 3               idiv1:
0002C2r 3  26 rr        	rol z80_d		; rotate into d.
0002C4r 3  88           	dey
0002C5r 3  D0 F4        	bne idiv0		; repeat
0002C7r 3  60           	rts
0002C8r 3               
0002C8r 3               ;---------------------------------------------------
0002C8r 3               ; Play AY sound effect
0002C8r 3               ;---------------------------------------------------
0002C8r 3               
0002C8r 3               plsnd:
0002C8r 3  60           	rts
0002C9r 3               
0002C9r 3               ;---------------------------------------------------
0002C9r 3               ; Objects handling.
0002C9r 3               ; 32 bytes for image
0002C9r 3               ; 1 for colour
0002C9r 3               ; 3 for room, y and x
0002C9r 3               ; 3 for starting room, y and x.
0002C9r 3               ; 254 = disabled.
0002C9r 3               ; 255 = object in player"s pockets.
0002C9r 3               ;---------------------------------------------------
0002C9r 3               
0002C9r 3               ;---------------------------------------------------
0002C9r 3               ; Show items present.
0002C9r 3               ;---------------------------------------------------
0002C9r 3               
0002C9r 3               .if oflag
0002C9r 3               shwob:
0002C9r 3  A9 rr        	lda #<objdta			; objects table.
0002CBr 3  85 rr        	sta z80_l
0002CDr 3  A9 rr        	lda #>objdta
0002CFr 3  85 rr        	sta z80_h
0002D1r 3  AD rr rr     	lda numob 			; number of objects in the game.
0002D4r 3  85 rr        	sta sprcnt
0002D6r 3               shwob0:
0002D6r 3  A0 21        	ldy #33 			; distance to room number.
0002D8r 3  B1 rr        	lda (z80_hl),y 			; same as an item?
0002DAr 3  C5 rr        	cmp scno 			; current location.
0002DCr 3  D0 03        	bne :+
0002DEr 3  20 rr rr     	jsr dobj 			; yes, display object.
0002E1r 3               :
0002E1r 3  18           	clc
0002E2r 3  A5 rr        	lda z80_l
0002E4r 3  69 27        	adc #39 			; distance to next item.
0002E6r 3  85 rr        	sta z80_l
0002E8r 3  A5 rr        	lda z80_h
0002EAr 3  69 00        	adc #0
0002ECr 3  85 rr        	sta z80_h	 		; point to it.
0002EEr 3  C6 rr        	dec sprcnt
0002F0r 3  D0 E4        	bne shwob0 			; repeat for others.
0002F2r 3  60           	rts
0002F3r 3               
0002F3r 3               ;---------------------------------------------------
0002F3r 3               ; Display object.
0002F3r 3               ; hl must point to object's start address.
0002F3r 3               ;
0002F3r 3               ; Input:
0002F3r 3               ;  HL = object address
0002F3r 3               ;---------------------------------------------------
0002F3r 3               
0002F3r 3               dobj:
0002F3r 3  A0 20        	ldy #32
0002F5r 3  B1 rr        	lda (z80_hl),y 			; point to y.
0002F7r 3  85 rr        	sta objcol
0002F9r 3  A0 22        	ldy #34
0002FBr 3  B1 rr        	lda (z80_hl),y 			; point to y.
0002FDr 3  85 rr        	sta dispy
0002FFr 3  C8           	iny
000300r 3  B1 rr        	lda (z80_hl),y 			; point to x.
000302r 3  85 rr        	sta dispx
000304r 3               dobj1:
000304r 3  4C rr rr     	jmp sprite 			; draw this sprite.
000307r 3               
000307r 3               ;--------------------------------------
000307r 3               ; Remove an object.
000307r 3               ;
000307r 3               ; Input:
000307r 3               ;  A = object number
000307r 3               ;--------------------------------------
000307r 3               
000307r 3               remob:
000307r 3  CD rr rr     	cmp numob			; number of objects in game.
00030Ar 3  90 01        	bcc :+				; are we checking past the end?
00030Cr 3  60           	rts				; yes, can't get non-existent item.
00030Dr 3               :
00030Dr 3  48           	pha				; remember object.
00030Er 3  20 rr rr     	jsr getob			; pick it up if we haven't already got it.
000311r 3  68           	pla				; retrieve object number.
000312r 3  20 rr rr     	jsr gotob			; get its address.
000315r 3  A9 FE        	lda #254
000317r 3  A0 21        	ldy #33
000319r 3  91 rr        	sta (z80_hl),y			; remove it.
00031Br 3  60           	rts
00031Cr 3               
00031Cr 3               ;---------------------------------------------------
00031Cr 3               ; Pick up object number held in the accumulator.
00031Cr 3               ;
00031Cr 3               ; Input:
00031Cr 3               ;  A = object number
00031Cr 3               ;---------------------------------------------------
00031Cr 3               
00031Cr 3               getob:
00031Cr 3  CD rr rr     	cmp numob 		; number of objects in game.
00031Fr 3  90 01        	bcc :+			; are we checking past the end?
000321r 3  60           	rts			; yes, can't get non-existent item.
000322r 3               :
000322r 3  20 rr rr     	jsr gotob 		; check if we already have it.
000325r 3  C9 FF        	cmp #255
000327r 3  D0 01        	bne :+
000329r 3  60           	rts			; we already do.
00032Ar 3               :
00032Ar 3  A0 21        	ldy #33
00032Cr 3  B1 rr        	lda (z80_hl),y		; is it on this screen?
00032Er 3  C5 rr        	cmp scno 		; current screen.
000330r 3  D0 14        	bne getob0		; not on screen, so nothing to delete.
000332r 3               
000332r 3  A9 FF        	lda #255
000334r 3  91 rr        	sta (z80_hl),y		; pick it up.
000336r 3  C8           	iny 			; point to y coord.
000337r 3               getob1:
000337r 3  A0 22        	ldy #34
000339r 3  B1 rr        	lda (z80_hl),y		; y coord.
00033Br 3  85 rr        	sta dispy
00033Dr 3  A0 23        	ldy #35
00033Fr 3  B1 rr        	lda (z80_hl),y 		; x coord.
000341r 3  85 rr        	sta dispx
000343r 3  4C rr rr     	jmp dobj1 		; delete object sprite.
000346r 3               getob0:
000346r 3  A9 FF        	lda #255
000348r 3  91 rr        	sta (z80_hl),y 		; pick it up.
00034Ar 3  60           	rts
00034Br 3               .endif
00034Br 3               
00034Br 3               ;-----------------------------------------------------------------
00034Br 3               ; Got object check.
00034Br 3               ; Call with object in accumulator, returns zero set if in pockets.
00034Br 3               ;
00034Br 3               ; Input:
00034Br 3               ;  A = object number
00034Br 3               ;-----------------------------------------------------------------
00034Br 3               .if oflag .or mflag
00034Br 3               gotob:
00034Br 3  CD rr rr     	cmp numob 		; number of objects in game.
00034Er 3  90 03        	bcc :+ 			; are we checking past the end?
000350r 3  4C rr rr     	jmp gotob0 		; yes, we can't have a non-existent object.
000353r 3               :
000353r 3  20 rr rr     	jsr findob		; find the object.
000356r 3               gotob1:
000356r 3  60           	rts
000357r 3               
000357r 3               gotob0:
000357r 3  A9 FE        	lda #254 		; missing.
000359r 3  4C rr rr     	jmp gotob1
00035Cr 3               
00035Cr 3               findob:
00035Cr 3  48           	pha			; save object number
00035Dr 3  A9 rr        	lda #<objdta 		; objects.
00035Fr 3  85 rr        	sta z80_l
000361r 3  A9 rr        	lda #>objdta
000363r 3  85 rr        	sta z80_h
000365r 3  68           	pla			; retreive object number
000366r 3  F0 0F        	beq fndob1 		; is it zero? yes, skip loop.
000368r 3  AA           	tax 			; loop counter
000369r 3               fndob2:
000369r 3  18           	clc
00036Ar 3  A5 rr        	lda z80_l
00036Cr 3  69 27        	adc #39 		; size of each object.
00036Er 3  85 rr        	sta z80_l
000370r 3  90 02        	bcc :+
000372r 3  E6 rr        	inc z80_h
000374r 3               :
000374r 3  CA           	dex 			; repeat until we find address.
000375r 3  D0 F2        	bne fndob2
000377r 3               fndob1:
000377r 3  A0 21        	ldy #33			; distance to room it's in.
000379r 3  B1 rr        	lda (z80_hl),y		; fetch status.
00037Br 3  60           	rts
00037Cr 3               .endif
00037Cr 3               
00037Cr 3               ;---------------------------------------------
00037Cr 3               ; Drop object number at (dispx, dispy).
00037Cr 3               ;
00037Cr 3               ; Input:
00037Cr 3               ;  A = object number
00037Cr 3               ;---------------------------------------------
00037Cr 3               
00037Cr 3               .if oflag
00037Cr 3               drpob:
00037Cr 3  CD rr rr     	cmp numob 		; are we checking past the end?
00037Fr 3  90 01        	bcc :+
000381r 3  60           	rts			; yes, can't drop non-existent item.
000382r 3               :
000382r 3  20 rr rr     	jsr gotob		; make sure object is in inventory.
000385r 3  C5 rr        	cmp scno		; already on this screen?
000387r 3  D0 01        	bne :+
000389r 3  60           	rts			; yes, nothing to do.
00038Ar 3               :
00038Ar 3  A0 21        	ldy #33
00038Cr 3  A5 rr        	lda scno
00038Er 3  91 rr        	sta (z80_hl),y		; bring onto screen.
000390r 3  A5 rr        	lda dispy		; sprite y coordinate.
000392r 3  C8           	iny
000393r 3  91 rr        	sta (z80_hl),y		; point to object y.
000395r 3  A5 rr        	lda dispx 		; sprite x coordinate.
000397r 3  C8           	iny
000398r 3  91 rr        	sta (z80_hl),y 		; point to object x
00039Ar 3  4C rr rr     	jmp dobj		; draw the object sprite.
00039Dr 3               
00039Dr 3               ;-----------------------------------------------
00039Dr 3               ; Seek objects at sprite position.
00039Dr 3               ;
00039Dr 3               ; Output:
00039Dr 3               ;  A = object number, if not found A=255
00039Dr 3               ;-----------------------------------------------
00039Dr 3               
00039Dr 3               skobj:
00039Dr 3  A9 rr        	lda #<objdta 		; pointer to objects.
00039Fr 3  85 rr        	sta z80_l
0003A1r 3  A9 rr        	lda #>objdta
0003A3r 3  85 rr        	sta z80_h
0003A5r 3               
0003A5r 3  AD rr rr     	lda numob 		; number of objects in game.
0003A8r 3  85 rr        	sta z80_b 		; set up the loop counter.
0003AAr 3               skobj0:
0003AAr 3  A5 rr        	lda scno		; current room number.
0003ACr 3  A0 21        	ldy #33
0003AEr 3  D1 rr        	cmp (z80_hl),y		; is object in here?
0003B0r 3  D0 03        	bne :+
0003B2r 3  20 rr rr     	jsr skobj1		; yes, check coordinates.
0003B5r 3               :
0003B5r 3  18           	clc			; point to next object in table.
0003B6r 3  A5 rr        	lda z80_l
0003B8r 3  69 27        	adc #39			; size of each object.
0003BAr 3  85 rr        	sta z80_l
0003BCr 3  90 02        	bcc :+
0003BEr 3  E6 rr        	inc z80_h
0003C0r 3               :
0003C0r 3  C6 rr        	dec z80_b
0003C2r 3  D0 E6        	bne skobj0		; repeat for all objects.
0003C4r 3               
0003C4r 3  A9 FF        	lda #255		; end of list and nothing found, return 255.
0003C6r 3  60           	rts
0003C7r 3               
0003C7r 3               skobj1:
0003C7r 3  A0 22        	ldy #34			; point to y coordinate.
0003C9r 3  B1 rr        	lda (z80_hl),y		; point to y coordinate.
0003CBr 3  38           	sec
0003CCr 3  A0 08        	ldy #var_newY
0003CEr 3  F1 rr        	sbc (z80_ix),y 		; subtract sprite y.
0003D0r 3  18           	clc
0003D1r 3  69 0F        	adc #15			; add sprite height minus one.
0003D3r 3  C9 1F        	cmp #31			; within range?
0003D5r 3  B0 18        	bcs skobj2		; no, ignore object.
0003D7r 3               
0003D7r 3  A0 23        	ldy #35			; point to x coordinate now.
0003D9r 3  B1 rr        	lda (z80_hl),y 		; get coordinate.
0003DBr 3  38           	sec
0003DCr 3  A0 09        	ldy #var_newX
0003DEr 3  F1 rr        	sbc (z80_ix),y 		; subtract the sprite x.
0003E0r 3  18           	clc			; add sprite width minus one.
0003E1r 3  69 0F        	adc #15
0003E3r 3  C9 1F        	cmp #31			; within range?
0003E5r 3  B0 08        	bcs skobj2		; no, ignore object.
0003E7r 3               
0003E7r 3  68           	pla			; remove return address from stack.
0003E8r 3  68           	pla
0003E9r 3               
0003E9r 3  AD rr rr     	lda numob 		; objects in game.
0003ECr 3  38           	sec
0003EDr 3  E5 rr        	sbc z80_b		; subtract loop counter.
0003EFr 3               skobj2:
0003EFr 3  60           	rts			; accumulator now points to object.
0003F0r 3               .endif
0003F0r 3               
0003F0r 3               ;---------------------------------------------------------------------
0003F0r 3               ; Spawn a new sprite.
0003F0r 3               ;---------------------------------------------------------------------
0003F0r 3               
0003F0r 3               spawn:
0003F0r 3  A9 rr        	lda #<sprtab		; sprite table.
0003F2r 3  85 rr        	sta z80_l
0003F4r 3  A9 rr        	lda #>sprtab
0003F6r 3  85 rr        	sta z80_h
0003F8r 3               numsp1:
0003F8r 3  A9 08        	lda #NUMSPR		; number of sprites.
0003FAr 3  85 rr        	sta spcnt
0003FCr 3               spaw0:
0003FCr 3  A0 00        	ldy #var_Type
0003FEr 3  B1 rr        	lda (z80_hl),y		; get sprite type.
000400r 3  C9 FF        	cmp #255		; is it an unused slot?
000402r 3  F0 0F        	beq spaw1 		; yes, we can use this one.
000404r 3               
000404r 3  18           	clc 			; point to next sprite in table.
000405r 3  A5 rr        	lda z80_l
000407r 3  69 11        	adc #TABSIZ		; size of each entry.
000409r 3  85 rr        	sta z80_l
00040Br 3  90 02        	bcc :+
00040Dr 3  E6 rr        	inc z80_h
00040Fr 3               :
00040Fr 3  C6 rr        	dec spcnt		; one less iteration.
000411r 3  D0 E9        	bne spaw0		; keep going until we find a slot.
000413r 3               
000413r 3               ; Didn't find one but drop through and set up a dummy sprite instead.
000413r 3               
000413r 3               spaw1:
000413r 3  A5 rr        	lda z80_i		; address of original sprite.
000415r 3  48           	pha
000416r 3  A5 rr        	lda z80_x
000418r 3  48           	pha
000419r 3               
000419r 3  A5 rr        	lda z80_l		; store spawned sprite address.
00041Br 3  85 rr        	sta spptr
00041Dr 3  A5 rr        	lda z80_h
00041Fr 3  85 rr        	sta spptr+1
000421r 3               
000421r 3  A5 rr        	lda z80_c
000423r 3  A0 00        	ldy #var_Type
000425r 3  91 rr        	sta (z80_hl),y 		; set the type.
000427r 3  A0 05        	ldy #var_newType
000429r 3  91 rr        	sta (z80_hl),y		; copy
00042Br 3               
00042Br 3  A5 rr        	lda z80_b
00042Dr 3  A0 01        	ldy #var_Image
00042Fr 3  91 rr        	sta (z80_hl),y		; set the image.
000431r 3  A0 06        	ldy #var_newImage
000433r 3  91 rr        	sta (z80_hl),y		; copy
000435r 3               
000435r 3  A9 00        	lda #0 				; frame zero.
000437r 3  A0 02        	ldy #var_Frame
000439r 3  91 rr        	sta (z80_hl),y		; set frame.
00043Br 3  A0 07        	ldy #var_newFrame
00043Dr 3  91 rr        	sta (z80_hl),y		; copy
00043Fr 3               
00043Fr 3  A0 08        	ldy #8
000441r 3  B1 rr        	lda (z80_ix),y 		; x coordinate.
000443r 3  A0 03        	ldy #3
000445r 3  91 rr        	sta (z80_hl),y		; set sprite coordinate.
000447r 3  A0 08        	ldy #8
000449r 3  91 rr        	sta (z80_hl),y		; copy
00044Br 3               
00044Br 3  A0 09        	ldy #9
00044Dr 3  B1 rr        	lda (z80_ix),y 		; y coordinate.
00044Fr 3  A0 04        	ldy #4
000451r 3  91 rr        	sta (z80_hl),y		; set sprite coordinate.
000453r 3  A0 09        	ldy #9
000455r 3  91 rr        	sta (z80_hl),y		; copy
000457r 3               
000457r 3  A0 0A        	ldy #10				; direction of original.
000459r 3  B1 rr        	lda (z80_ix),y
00045Br 3  91 rr        	sta (z80_hl),y		; direction
00045Dr 3               
00045Dr 3  A9 00        	lda #0
00045Fr 3  A0 0D        	ldy #var_jumpLo
000461r 3  91 rr        	sta (z80_hl),y		; reset parameter.
000463r 3  C8           	iny
000464r 3  91 rr        	sta (z80_hl),y		; reset parameter.
000466r 3  C8           	iny
000467r 3  91 rr        	sta (z80_hl),y		; reset parameter.
000469r 3  C8           	iny
00046Ar 3  91 rr        	sta (z80_hl),y		; reset parameter.
00046Cr 3               rtssp:
00046Cr 3  A5 rr        	lda spptr			; address of new sprite.
00046Er 3  85 rr        	sta z80_x
000470r 3  A5 rr        	lda spptr+1
000472r 3  85 rr        	sta z80_i
000474r 3               evis1:
000474r 3  20 rr rr     	jsr evnt09 			; call sprite initialisation event.
000477r 3               
000477r 3  A5 rr        	lda spptr 			; address of new sprite.
000479r 3  85 rr        	sta z80_x
00047Br 3  A5 rr        	lda spptr+1
00047Dr 3  85 rr        	sta z80_i
00047Fr 3               
00047Fr 3               	; _BEEB clipping code copied from CPC Engine - MISSING?!
00047Fr 3  A0 03        	ldy #var_Y
000481r 3  B1 rr        	lda (z80_hl), y		; old x coord
000483r 3  C9 A1        	cmp #SpriteMaxY     ; beyond maximum?
000485r 3  B0 03        	bcs :+				; yes, don't draw it.
000487r 3               
000487r 3  20 rr rr     	jsr sspria 			; display the new sprite.
00048Ar 3               :
00048Ar 3  68           	pla					; address of original sprite.
00048Br 3  85 rr        	sta z80_x
00048Dr 3  68           	pla
00048Er 3  85 rr        	sta z80_i
000490r 3               
000490r 3  60           	rts
000491r 3               
000491r 3  30 30 30 30  score:	.byte "000000"		; player"s score.
000495r 3  30 30        
000497r 3  30 30 30 30  hiscor:	.byte "000000"		; high score.
00049Br 3  30 30        
00049Dr 3  30 30 30 30  bonus:	.byte "000000"		; bonus.
0004A1r 3  30 30        
0004A3r 3  00 02        grbase:	.word ScreenAddr	; graphics base address.
0004A5r 3               
0004A5r 3               ;----------------------------------------------------
0004A5r 3               ; Check y-pos
0004A5r 3               ;----------------------------------------------------
0004A5r 3               
0004A5r 3               checkx:
0004A5r 3  A5 rr        	lda dispy		; y position.
0004A7r 3  C9 16        	cmp #22			; off screen?
0004A9r 3  B0 01        	bcs :+
0004ABr 3  60           	rts			; no, it's okay.
0004ACr 3               :
0004ACr 3  68           	pla			; remove return address from stack.
0004ADr 3  85 rr        	sta z80_l
0004AFr 3  68           	pla
0004B0r 3  85 rr        	sta z80_h
0004B2r 3  60           	rts
0004B3r 3               
0004B3r 3               ;-----------------------------------------------
0004B3r 3               ; Displays the current high score.
0004B3r 3               ;-----------------------------------------------
0004B3r 3               
0004B3r 3               dhisc:
0004B3r 3  A9 rr        	lda #<hiscor 		; high score text.
0004B5r 3  8D rr rr     	sta dscor3+1
0004B8r 3  8D rr rr     	sta bscor3+1
0004BBr 3  A9 rr        	lda #>hiscor
0004BDr 3  8D rr rr     	sta dscor3+2
0004C0r 3  8D rr rr     	sta bscor3+2
0004C3r 3  4C rr rr     	jmp dscor1		; check in printable range then show 6 digits.
0004C6r 3               
0004C6r 3               ;------------------------------------------------------
0004C6r 3               ; Displays the current score.
0004C6r 3               ;------------------------------------------------------
0004C6r 3               
0004C6r 3               dscor:
0004C6r 3  A9 rr        	lda #<score		; score text.
0004C8r 3  8D rr rr     	sta dscor3+1
0004CBr 3  8D rr rr     	sta bscor3+1
0004CEr 3  A9 rr        	lda #>score
0004D0r 3  8D rr rr     	sta dscor3+2
0004D3r 3  8D rr rr     	sta bscor3+2
0004D6r 3               dscor1:
0004D6r 3  8C rr rr     	sty tmpscr
0004D9r 3  20 rr rr     	jsr preprt		; set up font and print position.
0004DCr 3  20 rr rr     	jsr checkx		; make sure we're in a printable range.
0004DFr 3               
0004DFr 3               ;	lda #6			; digits to display.
0004DFr 3               ;	sta z80_b
0004DFr 3  A5 rr        	lda prtmod		; get print mode.
0004E1r 3  F0 03        	beq :+			; standard size text?
0004E3r 3  4C rr rr     	jmp bscor0		; no, show double-height.
0004E6r 3               :
0004E6r 3               dscor0:
0004E6r 3               ;	ldy #0
0004E6r 3               ;	lda (z80_hl),y 		; fetch character.
0004E6r 3  AC rr rr     	ldy tmpscr
0004E9r 3               dscor3:
0004E9r 3  B9 rr rr     	lda score,y
0004ECr 3  20 rr rr     	jsr pchar 		; display character.
0004EFr 3  E6 rr        	inc dispx		; move along x coordinate
0004F1r 3               
0004F1r 3               ;	inc z80_l		; next score column.
0004F1r 3               ;	bne :+
0004F1r 3               ;	inc z80_h
0004F1r 3               ;:
0004F1r 3  EE rr rr     	inc tmpscr
0004F4r 3  C6 rr        	dec z80_b
0004F6r 3  D0 EE        	bne dscor0 		; repeat for all digits.
0004F8r 3               dscor2:
0004F8r 3  A5 rr        	lda dispx 		; set up display coordinates.
0004FAr 3  85 rr        	sta charx
0004FCr 3  A5 rr        	lda dispy
0004FEr 3  85 rr        	sta chary
000500r 3  60           	rts
000501r 3               
000501r 3  00           tmpscr:	.byte 0
000502r 3               ;------------------------------------------------------
000502r 3               ; Displays the current score in double-height characters.
000502r 3               ;
000502r 3               ; Input:
000502r 3               ;  B  = digit number
000502r 3               ;  HL = score string
000502r 3               ;------------------------------------------------------
000502r 3               
000502r 3               bscor0:
000502r 3               ;	ldy #0
000502r 3               
000502r 3               ;	lda (z80_hl),y 		; fetch character.
000502r 3  A4 rr        	ldy tmp
000504r 3               bscor3:
000504r 3  B9 rr rr     	lda score,y
000507r 3  20 rr rr     	jsr bchar 		; display big char.
00050Ar 3               
00050Ar 3               ;	inc z80_l 		; next score column.
00050Ar 3               ;	bne :+
00050Ar 3               ;	inc z80_h
00050Ar 3               ;:
00050Ar 3  E6 rr        	inc tmp
00050Cr 3  C6 rr        	dec z80_b
00050Er 3  F0 03        	beq :+
000510r 3  4C rr rr     	jmp bscor0 		; repeat for all digits.
000513r 3               :
000513r 3  4C rr rr     	jmp dscor2 		; tidy up line and column variables.
000516r 3               
000516r 3               ;-----------------------------------------------------
000516r 3               ; Adds number in the hl pair to the score.
000516r 3               ;-----------------------------------------------------
000516r 3               
000516r 3               addsc:
000516r 3  A9 rr        	lda #<(score+1) 	; ten thousands column.
000518r 3  85 rr        	sta z80_e
00051Ar 3  A9 rr        	lda #>(score+1)
00051Cr 3  85 rr        	sta z80_d
00051Er 3  A9 10        	lda #<10000		; amount to add each time.
000520r 3  85 rr        	sta z80_c
000522r 3  A9 27        	lda #>10000
000524r 3  85 rr        	sta z80_b
000526r 3  20 rr rr     	jsr incsc		; add to score.
000529r 3               
000529r 3  E6 rr        	inc z80_e		; thousands column.
00052Br 3  D0 02        	bne :+
00052Dr 3  E6 rr        	inc z80_d
00052Fr 3               :
00052Fr 3  A9 E8        	lda #<1000		; amount to add each time.
000531r 3  85 rr        	sta z80_c
000533r 3  A9 03        	lda #>1000
000535r 3  85 rr        	sta z80_b
000537r 3  20 rr rr     	jsr incsc 		; add to score.
00053Ar 3               
00053Ar 3  E6 rr        	inc z80_e		; hundreds column.
00053Cr 3  D0 02        	bne :+
00053Er 3  E6 rr        	inc z80_d
000540r 3               :
000540r 3  A9 64        	lda #<100		; amount to add each time.
000542r 3  85 rr        	sta z80_c
000544r 3  A9 00        	lda #>100
000546r 3  85 rr        	sta z80_b
000548r 3  20 rr rr     	jsr incsc		; add to score.
00054Br 3               
00054Br 3  E6 rr        	inc z80_e 		; tens column.
00054Dr 3  D0 02        	bne :+
00054Fr 3  E6 rr        	inc z80_d
000551r 3               :
000551r 3  A9 0A        	lda #<10		; amount to add each time.
000553r 3  85 rr        	sta z80_c
000555r 3  A9 00        	lda #>10
000557r 3  85 rr        	sta z80_b
000559r 3  20 rr rr     	jsr incsc 		; add to score.
00055Cr 3               
00055Cr 3  E6 rr        	inc z80_e		; units column.
00055Er 3  D0 02        	bne :+
000560r 3  E6 rr        	inc z80_d
000562r 3               :
000562r 3  A9 01        	lda #<1			; units.
000564r 3  85 rr        	sta z80_c
000566r 3  A9 00        	lda #>1
000568r 3  85 rr        	sta z80_b
00056Ar 3               incsc:
00056Ar 3  A5 rr        	lda z80_h		; store amount to add.
00056Cr 3  48           	pha
00056Dr 3  A5 rr        	lda z80_l
00056Fr 3  48           	pha
000570r 3               
000570r 3  38           	sec			; subtract from amount to add.
000571r 3  A5 rr        	lda z80_l
000573r 3  E5 rr        	sbc z80_c
000575r 3  85 rr        	sta z80_l
000577r 3  A5 rr        	lda z80_h
000579r 3  E5 rr        	sbc z80_b
00057Br 3  85 rr        	sta z80_h
00057Dr 3  90 14        	bcc incsc0		; too much, restore value.
00057Fr 3               
00057Fr 3  68           	pla			; delete the previous amount from the stack.
000580r 3  68           	pla
000581r 3               
000581r 3  A5 rr        	lda z80_d 		; store column position.
000583r 3  48           	pha
000584r 3  A5 rr        	lda z80_e
000586r 3  48           	pha
000587r 3  20 rr rr     	jsr incsc2		; do the increment.
00058Ar 3               
00058Ar 3  68           	pla			; restore column.
00058Br 3  85 rr        	sta z80_e
00058Dr 3  68           	pla
00058Er 3  85 rr        	sta z80_d
000590r 3  4C rr rr     	jmp incsc		; repeat until all added.
000593r 3               
000593r 3               incsc0:
000593r 3  68           	pla			; restore previous value.
000594r 3  85 rr        	sta z80_l
000596r 3  68           	pla
000597r 3  85 rr        	sta z80_h
000599r 3  60           	rts
00059Ar 3               incsc2:
00059Ar 3  A0 00        	ldy #0
00059Cr 3  B1 rr        	lda (z80_de),y 		; get amount.
00059Er 3  18           	clc
00059Fr 3  69 01        	adc #1			; add one to column.
0005A1r 3  91 rr        	sta (z80_de),y		; write new column total.
0005A3r 3  C9 3A        	cmp #'9'+1		; gone beyond range of digits?
0005A5r 3  B0 01        	bcs :+
0005A7r 3  60           	rts			; no, carry on.
0005A8r 3               :
0005A8r 3  A9 30        	lda #'0'		; make it zero.
0005AAr 3  91 rr        	sta (z80_de),y		; write new column total.
0005ACr 3  C6 rr        	dec z80_e		; back one column.
0005AEr 3  D0 02        	bne :+
0005B0r 3  C6 rr        	dec z80_d
0005B2r 3               :
0005B2r 3  4C rr rr     	jmp incsc2
0005B5r 3               
0005B5r 3               ;------------------------------------
0005B5r 3               ; Add bonus to score and reset bonus
0005B5r 3               ;------------------------------------
0005B5r 3               
0005B5r 3               addbo:
0005B5r 3  A2 05        	ldx #5			; last digit.
0005B7r 3  18           	clc
0005B8r 3               addbo0:
0005B8r 3  BD rr rr     	lda score,x		; get score.
0005BBr 3  7D rr rr     	adc bonus,x		; add bonus.
0005BEr 3  38           	sec			; 0 to 18.
0005BFr 3  E9 30        	sbc #48
0005C1r 3  48           	pha
0005C2r 3  A9 30        	lda #'0'
0005C4r 3  9D rr rr     	sta bonus,x
0005C7r 3  68           	pla
0005C8r 3  C9 3A        	cmp #58
0005CAr 3  90 03        	bcc addbo1
0005CCr 3  38           	sec
0005CDr 3  E9 0A        	sbc #10
0005CFr 3               addbo1:
0005CFr 3  9D rr rr     	sta score,x		; zeroise bonus.
0005D2r 3  CA           	dex			; next digit.
0005D3r 3  10 E3        	bpl addbo0		; repeat for all 6 digits.
0005D5r 3  60           	rts
0005D6r 3               
0005D6r 3               ;------------------------------------
0005D6r 3               ; Swap score and bonus.
0005D6r 3               ;------------------------------------
0005D6r 3               
0005D6r 3               swpsb:
0005D6r 3  A2 05        	ldx #5			; digits to add.
0005D8r 3               swpsb0:
0005D8r 3  BD rr rr     	lda score,x 		; get score digits.
0005DBr 3  48           	pha			; save digit
0005DCr 3  BD rr rr     	lda bonus,x 		; get bonus digits.
0005DFr 3  9D rr rr     	sta score,x		; switch score-bonus
0005E2r 3  68           	pla
0005E3r 3  9D rr rr     	sta bonus,x
0005E6r 3  CA           	dex 			; repeat for all 6 digits.
0005E7r 3  10 EF        	bpl swpsb0
0005E9r 3  60           	rts
0005EAr 3               
0005EAr 3               ;----------------------------------------------------
0005EAr 3               ; Get print address.
0005EAr 3               ;----------------------------------------------------
0005EAr 3               
0005EAr 3               gprad:
0005EAr 3  98           	tya
0005EBr 3  48           	pha
0005ECr 3               
0005ECr 3  A5 rr        	lda dispx 		; x coordinate.
0005EEr 3  85 rr        	sta scraddr
0005F0r 3  A9 00        	lda #0
0005F2r 3  85 rr        	sta scraddr+1
0005F4r 3  06 rr        	asl scraddr  		; multiply char by 16
0005F6r 3  26 rr        	rol scraddr+1
0005F8r 3  06 rr        	asl scraddr
0005FAr 3  26 rr        	rol scraddr+1
0005FCr 3  06 rr        	asl scraddr
0005FEr 3  26 rr        	rol scraddr+1
000600r 3  06 rr        	asl scraddr
000602r 3  26 rr        	rol scraddr+1
000604r 3               
000604r 3  A5 rr        	lda dispy		; y coordinate.
000606r 3  0A           	asl a
000607r 3  0A           	asl a
000608r 3  0A           	asl a			; multiply char by 8
000609r 3               ;	asl a
000609r 3  A8           	tay
00060Ar 3               
00060Ar 3  18           	clc
00060Br 3  A5 rr        	lda scraddr
00060Dr 3  79 00 07     	adc SCADTB_lb,y
000610r 3  85 rr        	sta scraddr
000612r 3  A5 rr        	lda scraddr+1
000614r 3  79 00 08     	adc SCADTB_hb,y
000617r 3  85 rr        	sta scraddr+1
000619r 3               
000619r 3               
000619r 3               
000619r 3  A5 rr        	lda prtmod		; Double line if bigtxt
00061Br 3  F0 08        	beq noskip
00061Dr 3  A5 rr        	lda dispx
00061Fr 3  29 E0        	and #$e0
000621r 3  F0 02        	beq noskip
000623r 3  E6 rr        	inc scraddr+1
000625r 3               noskip:
000625r 3               
000625r 3  68           	pla
000626r 3  A8           	tay
000627r 3  60           	rts
000628r 3               ;--------------------------------------------------------------
000628r 3               ; Get property buffer address of char at (dispx, dispy) in hl.
000628r 3               ;
000628r 3               ; Output:
000628r 3               ;  buffaddr = bufaddr = MAP + dispy*22 + dispx
000628r 3               ;--------------------------------------------------------------
000628r 3               
000628r 3               pradd:
000628r 3  A5 rr        	lda dispy 		; y coordinate.
00062Ar 3  85 rr        	sta bufaddr
00062Cr 3  A9 00        	lda #0
00062Er 3  85 rr        	sta bufaddr+1
000630r 3  06 rr        	asl bufaddr  		; multiply char by 32
000632r 3  26 rr        	rol bufaddr+1
000634r 3  06 rr        	asl bufaddr
000636r 3  26 rr        	rol bufaddr+1
000638r 3  06 rr        	asl bufaddr
00063Ar 3  26 rr        	rol bufaddr+1
00063Cr 3  06 rr        	asl bufaddr
00063Er 3  26 rr        	rol bufaddr+1
000640r 3  06 rr        	asl bufaddr
000642r 3  26 rr        	rol bufaddr+1
000644r 3  18           	clc			; add address of MAP graphics.
000645r 3  A5 rr        	lda bufaddr
000647r 3  65 rr        	adc dispx
000649r 3  69 00        	adc #<MAP
00064Br 3  85 rr        	sta bufaddr
00064Dr 3  A5 rr        	lda bufaddr+1
00064Fr 3  69 04        	adc #>MAP
000651r 3  85 rr        	sta bufaddr+1
000653r 3  60           	rts
000654r 3               
000654r 3               ;--------------------------------------------------------------
000654r 3               ; Get attribute address at (dispx, dispy).
000654r 3               ;
000654r 3               ; Output:
000654r 3               ;  bufaddr = COLOR + dispy*22 + dispx
000654r 3               ;--------------------------------------------------------------
000654r 3               
000654r 3               gaadd:
000654r 3  A5 rr        	lda dispy
000656r 3  4A           	lsr a
000657r 3  A8           	tay
000658r 3  B9 55 0A     	lda COLATTTB_hb,y
00065Br 3  85 rr        	sta bufaddr+1
00065Dr 3  B9 4A 0A     	lda COLATTTB_lb,y
000660r 3  18           	clc
000661r 3  65 rr        	adc dispx
000663r 3  85 rr        	sta bufaddr
000665r 3  60           	rts
000666r 3               
000666r 3               ;----------------------------------------------
000666r 3               ; Print attributes, properties and pixels.
000666r 3               ;
000666r 3               ; Input:
000666r 3               ;  A	= tile number
000666r 3               ;----------------------------------------------
000666r 3               
000666r 3               pbpattr:			; entry PUTBLOCK command
000666r 3  A4 rr        	ldy charx
000668r 3  84 rr        	sty dispx
00066Ar 3  A4 rr        	ldy chary
00066Cr 3  84 rr        	sty dispy
00066Er 3               pattr:
00066Er 3               .if aflag
00066Er 3               	pha
00066Er 3               	jsr wbloc		; save blockinfo
00066Er 3               	pla
00066Er 3               .endif
00066Er 3               
00066Er 3               pattr2:
00066Er 3  85 rr        	sta z80_b		; store cell in b register for now.
000670r 3  AA           	tax
000671r 3  BD rr rr     	lda bprop,x 		; block properties.
000674r 3  85 rr        	sta z80_c
000676r 3  C9 08        	cmp #COLECT
000678r 3  D0 04        	bne :+
00067Ar 3  A5 rr        	lda z80_b
00067Cr 3  85 rr        	sta colpatt
00067Er 3               :
00067Er 3  20 rr rr     	jsr pradd 		; get property buffer address.
000681r 3  A5 rr        	lda z80_c
000683r 3  A0 00        	ldy #0
000685r 3  91 rr        	sta (bufaddr),y 	; write property.
000687r 3  A5 rr        	lda z80_b 		; restore cell.
000689r 3  4C rr rr     	jmp panp
00068Cr 3               ; Print attributes, no properties.
00068Cr 3               
00068Cr 3               ;colpatt:	.byte 0
00068Cr 3               
00068Cr 3               panp:
00068Cr 3  85 rr        	sta z80_e		; displacement in e.
00068Er 3  A9 00        	lda #0
000690r 3  85 rr        	sta z80_d		; no high byte.
000692r 3  06 rr        	asl z80_e  		; multiply char by 8.
000694r 3  26 rr        	rol z80_d
000696r 3  06 rr        	asl z80_e
000698r 3  26 rr        	rol z80_d
00069Ar 3  06 rr        	asl z80_e
00069Cr 3  26 rr        	rol z80_d
00069Er 3  18           	clc
00069Fr 3  A5 rr        	lda z80_e
0006A1r 3  69 rr        	adc #<chgfx 		; address of graphics.
0006A3r 3  85 rr        	sta tileaddr
0006A5r 3  A5 rr        	lda z80_d
0006A7r 3  69 rr        	adc #>chgfx
0006A9r 3  85 rr        	sta tileaddr+1
0006ABr 3               
0006ABr 3  A6 rr        	ldx z80_b		; set colour attribute
0006ADr 3  BD rr rr     	lda bCol,x
0006B0r 3  48           	pha
0006B1r 3  20 rr rr     	jsr gaadd
0006B4r 3  A0 00        	ldy #0
0006B6r 3  68           	pla
0006B7r 3  91 rr        	sta (bufaddr),y
0006B9r 3               
0006B9r 3  20 rr rr     	jsr gprad 		; get screen address.
0006BCr 3  A2 07        	ldx #7			; number of pixel rows to write.
0006BEr 3               panp0:
0006BEr 3  A0 00        	ldy #0
0006C0r 3  B1 rr        	lda (tileaddr),y 	; get image byte.
0006C2r 3               .if iflag
0006C2r 3               	eor #$ff		; Invert
0006C2r 3               .endif
0006C2r 3  BC rr rr     	ldy scrtab,x
0006C5r 3  91 rr        	sta (scraddr),y 	; copy to screen.
0006C7r 3  E6 rr        	inc tileaddr 		; next image byte.
0006C9r 3  D0 02        	bne :+
0006CBr 3  E6 rr        	inc tileaddr+1
0006CDr 3               :
0006CDr 3  CA           	dex	 		; repeat for 8 pixel rows.
0006CEr 3  10 EE        	bpl panp0
0006D0r 3  E6 rr        	inc dispx 		; move along one.
0006D2r 3  E6 rr        	inc charx
0006D4r 3  60           	rts
0006D5r 3               
0006D5r 3               ;----------------------------------------------
0006D5r 3               ; Write block
0006D5r 3               ;----------------------------------------------
0006D5r 3               
0006D5r 3               .if aflag
0006D5r 3               wbloc:
0006D5r 3               	ldy #3
0006D5r 3               	sta (pbptr),y		; store block number
0006D5r 3               	dey
0006D5r 3               	lda dispx
0006D5r 3               	sta (pbptr),y		; write x position of block.
0006D5r 3               	dey
0006D5r 3               	lda dispy
0006D5r 3               	sta (pbptr),y		; write y position of block.
0006D5r 3               	dey
0006D5r 3               	lda scno
0006D5r 3               	sta (pbptr),y		; write screen.
0006D5r 3               	clc			; point to next free location
0006D5r 3               	lda pbptr
0006D5r 3               	adc #4
0006D5r 3               	sta pbptr
0006D5r 3               	bcc :+
0006D5r 3               	inc pbptr+1
0006D5r 3               :
0006D5r 3               	rts
0006D5r 3               .endif
0006D5r 3               
0006D5r 3               ;.if kflag
0006D5r 3               ;panp:
0006D5r 3               ;.endif
0006D5r 3               
0006D5r 3               ;----------------------------------------------
0006D5r 3               ; Print character pixels, no more.
0006D5r 3               ;
0006D5r 3               ; Input:
0006D5r 3               ;  A	= character to print
0006D5r 3               ;----------------------------------------------
0006D5r 3               
0006D5r 3               pchr:
0006D5r 3  20 rr rr     	jsr pchar 		; show character in accumulator.
0006D8r 3  E6 rr        	inc dispx		; move along one.
0006DAr 3  60           	rts
0006DBr 3               
0006DBr 3               ;----------------------------------------------------
0006DBr 3               ; Shifter sprite routine for objects.
0006DBr 3               ;----------------------------------------------------
0006DBr 3               
0006DBr 3               .if oflag
0006DBr 3               sprit7:
0006DBr 3  A5 rr        	lda z80_b
0006DDr 3  F0 0C        	beq sprit0
0006DFr 3  85 rr        	sta z80_a
0006E1r 3               sprit3:
0006E1r 3  46 rr        	lsr spr			; shift into position.
0006E3r 3  66 rr        	ror spr+1
0006E5r 3  66 rr        	ror spr+2
0006E7r 3  C6 rr        	dec z80_a		; one less iteration.
0006E9r 3  D0 F6        	bne sprit3
0006EBr 3               sprit0:
0006EBr 3  60           	rts 			; now apply to screen.
0006ECr 3               .endif
0006ECr 3               
0006ECr 3               ;-----------------------------------------------------------
0006ECr 3               ; Get room address.
0006ECr 3               ;-----------------------------------------------------------
0006ECr 3               
0006ECr 3               groom:
0006ECr 3  A6 rr        	ldx scno 		; screen number.
0006EEr 3  A0 00        	ldy #0
0006F0r 3               groomx:
0006F0r 3  A9 rr        	lda #<scdat 		; pointer to screens.
0006F2r 3  85 rr        	sta z80_l
0006F4r 3  A9 rr        	lda #>scdat
0006F6r 3  85 rr        	sta z80_h
0006F8r 3               groom1:
0006F8r 3  E0 00        	cpx #0			; is it the first one?
0006FAr 3  F0 15        	beq groom0 		; no more screens to skip.
0006FCr 3               
0006FCr 3  18           	clc
0006FDr 3  A5 rr        	lda z80_l
0006FFr 3  79 rr rr     	adc scdat,y 		; low byte of screen size.
000702r 3  85 rr        	sta z80_l
000704r 3  C8           	iny			; point to high byte.
000705r 3  A5 rr        	lda z80_h
000707r 3  79 rr rr     	adc scdat,y 		; high byte of screen size.
00070Ar 3  85 rr        	sta z80_h
00070Cr 3  C8           	iny			; next address.
00070Dr 3               
00070Dr 3  CA           	dex 			; one less iteration.
00070Er 3  4C rr rr     	jmp groom1 		; loop until we reach the end.
000711r 3               groom0:
000711r 3  AD rr rr     	lda numsc		; add displacement.
000714r 3  0A           	asl a
000715r 3  18           	clc			; add double displacement to address.
000716r 3  65 rr        	adc z80_l
000718r 3  85 rr        	sta z80_l
00071Ar 3  A5 rr        	lda z80_h
00071Cr 3  69 00        	adc #0
00071Er 3  85 rr        	sta z80_h
000720r 3  60           	rts
000721r 3               
000721r 3               ;-----------------------------------------------------------
000721r 3               ; Draw present room.
000721r 3               ;-----------------------------------------------------------
000721r 3               
000721r 3               droom:
000721r 3  AD rr rr     	lda wintop 		; window top.
000724r 3  85 rr        	sta dispy		; set cursor y position.
000726r 3               droom2:
000726r 3  20 rr rr     	jsr groom 		; get address of current room.
000729r 3  A9 00        	lda #0	 		; zero in accumulator.
00072Br 3  85 rr        	sta comcnt 		; reset compression counter.
00072Dr 3  AD rr rr     	lda winhgt 		; height of window.
000730r 3  85 rr        	sta rrow		; set row counter
000732r 3               droom0:
000732r 3  AD rr rr     	lda winlft 		; window left edge.
000735r 3  85 rr        	sta dispx 		; set cursor x position.
000737r 3  AD rr rr     	lda winwid 		; width of window.
00073Ar 3  85 rr        	sta rcol		; set column counter
00073Cr 3               droom1:
00073Cr 3  20 rr rr     	jsr flbyt 		; decompress next byte on the fly.
00073Fr 3               .if xflag
00073Fr 3               	jsr drwmeta
00073Fr 3               .else
00073Fr 3  20 rr rr     	jsr pattr2 		; show attributes and block.
000742r 3               .endif
000742r 3  C6 rr        	dec rcol		; one less column.
000744r 3  D0 F6        	bne droom1 		; repeat for entire line.
000746r 3  E6 rr        	inc dispy		; move down one line.
000748r 3               .if xflag
000748r 3               	inc dispy		; move down one line.
000748r 3               .endif
000748r 3  C6 rr        	dec rrow 		; one less row.
00074Ar 3  D0 E6        	bne droom0 		; repeat for all rows.
00074Cr 3  60           	rts
00074Dr 3               
00074Dr 3               ;----------------------------------------------
00074Dr 3               ; Decompress bytes on-the-fly.
00074Dr 3               ;----------------------------------------------
00074Dr 3               
00074Dr 3               flbyt:
00074Dr 3  A5 rr        	lda comcnt 		; compression counter.
00074Fr 3  D0 21        	bne flbyt1		; any more to decompress?  yes.
000751r 3               
000751r 3  A0 00        	ldy #0
000753r 3  B1 rr        	lda (z80_hl),y 		; fetch next byte.
000755r 3  E6 rr        	inc z80_l 		; point to next cell.
000757r 3  D0 02        	bne :+
000759r 3  E6 rr        	inc z80_h
00075Br 3               :
00075Br 3  C9 FF        	cmp #255 		; is this byte a control code?
00075Dr 3  F0 01        	beq :+
00075Fr 3  60           	rts 			; no, this byte is uncompressed.
000760r 3               :
000760r 3  B1 rr        	lda (z80_hl),y 		; fetch byte type.
000762r 3  85 rr        	sta combyt 		; set up the type.
000764r 3  E6 rr        	inc z80_l 		; point to quantity.
000766r 3  D0 02        	bne :+
000768r 3  E6 rr        	inc z80_h
00076Ar 3               :
00076Ar 3  B1 rr        	lda (z80_hl),y 		; get quantity.
00076Cr 3  E6 rr        	inc z80_l 		; point to next byte.
00076Er 3  D0 02        	bne :+
000770r 3  E6 rr        	inc z80_h
000772r 3               :
000772r 3               flbyt1:
000772r 3  85 rr        	sta comcnt 		; store new quantity.
000774r 3  C6 rr        	dec comcnt		; one less.
000776r 3  A5 rr        	lda combyt 		; byte to expand.
000778r 3  60           	rts
000779r 3               
000779r 3               ; ------------------------------------------------------------------------------------------------------------------------------------------
000779r 3               ; Drawing a MetaBlock (4 tiles 8x8 => 16x16)
000779r 3               ; param in regA tells the block number to use, if 0 use 0,0,0,0  else use N,N+2 || N+1,N+3
000779r 3               ; ------------------------------------------------------------------------------------------------------------------------------------------
000779r 3               .if xflag
000779r 3               drwmeta:
000779r 3               	sta tmpblk
000779r 3               	jsr pattr2
000779r 3               
000779r 3               	inc dispy
000779r 3               	dec dispx
000779r 3               	ldx tmpblk
000779r 3               	beq :+
000779r 3               	inx
000779r 3               :
000779r 3               	txa
000779r 3               	jsr pattr2
000779r 3               
000779r 3               	ldx tmpblk
000779r 3               	beq :+
000779r 3               	inx
000779r 3               	inx
000779r 3               	inx
000779r 3               :
000779r 3               	txa
000779r 3               	jsr pattr2
000779r 3               
000779r 3               	dec dispy
000779r 3               	dec dispx
000779r 3               	ldx tmpblk
000779r 3               	beq :+
000779r 3               	inx
000779r 3               	inx
000779r 3               :
000779r 3               	txa
000779r 3               	jsr pattr2
000779r 3               	rts
000779r 3               
000779r 3               tmpblk:	.byte 0
000779r 3               
000779r 3               .endif
000779r 3               
000779r 3               ;------------------------------------------
000779r 3               ; Ladder down check.
000779r 3               ;
000779r 3               ; Input:
000779r 3               ;  IX = sprite pointer
000779r 3               ;------------------------------------------
000779r 3               
000779r 3               .if lflag
000779r 3               laddd:
000779r 3               	ldy #9
000779r 3               	lda (z80_ix),y		; x coordinate.
000779r 3               	sta dispx
000779r 3               
000779r 3               	ldy #8
000779r 3               	lda (z80_ix),y		; y coordinate.
000779r 3               	and #254		; make it even.
000779r 3               	sta (z80_ix),y 		; reset it.
000779r 3               	clc 			; look down 16 pixels.
000779r 3               numsp5:
000779r 3               	adc #SPR_HGT
000779r 3               	sta dispy		; coords in dispx,dispy.
000779r 3               	jmp laddv
000779r 3               
000779r 3               ;------------------------------------------
000779r 3               ; Ladder up check.
000779r 3               ;
000779r 3               ; Input:
000779r 3               ;  IX = sprite pointer
000779r 3               ;
000779r 3               ; Output:
000779r 3               ;  A  = 0 is ok, A <>0 is not ok
000779r 3               ;------------------------------------------
000779r 3               
000779r 3               laddu:
000779r 3               	ldy #9
000779r 3               	lda (z80_ix),y		; x coordinate.
000779r 3               	sta dispx
000779r 3               
000779r 3               	ldy #8
000779r 3               	lda (z80_ix),y		; y coordinate.
000779r 3               	and #254 		; make it even.
000779r 3               	sta (z80_ix),y		; reset it.
000779r 3               	clc 			; look 2 pixels above feet.
000779r 3               numsp6:
000779r 3               	adc #SPR_HGT-2
000779r 3               	sta dispy		; coords in dispx,dispy.
000779r 3               laddv:
000779r 3               	jsr tstbl 		; get map address.
000779r 3               	jsr ldchk 		; standard ladder check.
000779r 3               	beq :+
000779r 3               	rts 			; no way through.
000779r 3               :
000779r 3               	inc bufaddr 		; look right one cell.
000779r 3               	bne :+
000779r 3               	inc bufaddr+1
000779r 3               :
000779r 3               	jsr ldchk 		; do the check.
000779r 3               	beq :+
000779r 3               	rts 			; impassable.
000779r 3               :
000779r 3               	lda dispx 		; y coordinate.
000779r 3               	and #7 			; position straddling block cells.
000779r 3               	bne :+
000779r 3               	rts 			; no more checks needed.
000779r 3               :
000779r 3               	inc bufaddr 		; look to third cell.
000779r 3               	bne :+
000779r 3               	inc bufaddr+1
000779r 3               :
000779r 3               	jsr ldchk 		; do the check.
000779r 3               	rts  			; return with zero flag set accordingly.
000779r 3               .endif
000779r 3               
000779r 3               ;---------------------------------------------------------
000779r 3               ; Can go up check.
000779r 3               ;
000779r 3               ; Input:
000779r 3               ;  IX = sprite pointer
000779r 3               ;
000779r 3               ; Output:
000779r 3               ;  A  = 0 is ok, A <>0 is not ok
000779r 3               ;---------------------------------------------------------
000779r 3               
000779r 3               cangu:
000779r 3  A0 09        	ldy #9
00077Br 3  B1 rr        	lda (z80_ix),y		; x coordinate.
00077Dr 3  85 rr        	sta dispx
00077Fr 3  A0 08        	ldy #8
000781r 3  B1 rr        	lda (z80_ix),y 		; y coordinate.
000783r 3  38           	sec
000784r 3  E9 02        	sbc #2
000786r 3  85 rr        	sta dispy		; coords in dispx,dispy.
000788r 3  20 rr rr     	jsr tstbl 		; get map address.
00078Br 3  20 rr rr     	jsr lrchk 		; standard left/right check.
00078Er 3  F0 01        	beq :+
000790r 3  60           	rts			; no way through.
000791r 3               :
000791r 3  E6 rr        	inc bufaddr		; look right one cell.
000793r 3  D0 02        	bne :+
000795r 3  E6 rr        	inc bufaddr+1
000797r 3               :
000797r 3  20 rr rr     	jsr lrchk 		; do the check.
00079Ar 3  F0 01        	beq :+
00079Cr 3  60           	rts			; impassable.
00079Dr 3               :
00079Dr 3  A5 rr        	lda dispx		; x coordinate.
00079Fr 3  29 07        	and #7			; position straddling block cells.
0007A1r 3  D0 01        	bne :+
0007A3r 3  60           	rts			; no more checks needed.
0007A4r 3               :
0007A4r 3  E6 rr        	inc bufaddr		; look to third cell.
0007A6r 3  D0 02        	bne :+
0007A8r 3  E6 rr        	inc bufaddr+1
0007AAr 3               :
0007AAr 3  20 rr rr     	jsr lrchk		; do the check.
0007ADr 3  60           	rts 			; return with zero flag set accordingly.
0007AEr 3               
0007AEr 3               ;---------------------------------------------------------
0007AEr 3               ; Can go down check.
0007AEr 3               ;
0007AEr 3               ; Input:
0007AEr 3               ;  IX = sprite pointer
0007AEr 3               ;
0007AEr 3               ; Output:
0007AEr 3               ;  A  = 0 is ok, A <>0 is not ok
0007AEr 3               ;---------------------------------------------------------
0007AEr 3               
0007AEr 3               cangd:
0007AEr 3  A0 09        	ldy #9
0007B0r 3  B1 rr        	lda (z80_ix),y 		; x coordinate.
0007B2r 3  85 rr        	sta dispx
0007B4r 3  A0 08        	ldy #8
0007B6r 3  B1 rr        	lda (z80_ix),y		; y coordinate.
0007B8r 3  18           	clc
0007B9r 3               numsp3:
0007B9r 3  69 18        	adc #SPR_HGT 		; look down 16 pixels.
0007BBr 3  85 rr        	sta dispy		; coords in dispx,dispy.
0007BDr 3  20 rr rr     	jsr tstbl 		; get map address.
0007C0r 3  20 rr rr     	jsr plchk 		; block, platform check.
0007C3r 3  F0 01        	beq :+
0007C5r 3  60           	rts			; no way through.
0007C6r 3               :
0007C6r 3  E6 rr        	inc bufaddr		; look right one cell.
0007C8r 3  D0 02        	bne :+
0007CAr 3  E6 rr        	inc bufaddr+1
0007CCr 3               :
0007CCr 3  20 rr rr     	jsr plchk		; block, platform check.
0007CFr 3  F0 01        	beq :+
0007D1r 3  60           	rts			; impassable.
0007D2r 3               :
0007D2r 3  A5 rr        	lda dispx		; x coordinate.
0007D4r 3  29 07        	and #7			; position straddling block cells.
0007D6r 3  D0 01        	bne :+
0007D8r 3  60           	rts			; no more checks needed.
0007D9r 3               :
0007D9r 3  E6 rr        	inc bufaddr		; look to third cell.
0007DBr 3  D0 02        	bne :+
0007DDr 3  E6 rr        	inc bufaddr+1
0007DFr 3               :
0007DFr 3  20 rr rr     	jsr plchk		; block, platform check.
0007E2r 3  60           	rts			; return with zero flag set accordingly.
0007E3r 3               
0007E3r 3               ;---------------------------------------------------------
0007E3r 3               ; Can go left check.
0007E3r 3               ;
0007E3r 3               ; Input:
0007E3r 3               ;  IX = sprite pointer
0007E3r 3               ;
0007E3r 3               ; Output:
0007E3r 3               ;  A  = 0 is ok, A <>0 is not ok
0007E3r 3               ;---------------------------------------------------------
0007E3r 3               
0007E3r 3               cangl:
0007E3r 3  A0 08        	ldy #8
0007E5r 3  B1 rr        	lda (z80_ix),y 		; y coordinate.
0007E7r 3  85 rr        	sta dispy
0007E9r 3  A0 09        	ldy #9
0007EBr 3  B1 rr        	lda (z80_ix),y 		; x coordinate.
0007EDr 3  38           	sec
0007EEr 3  E9 02        	sbc #2			; look left 2 pixels.
0007F0r 3  85 rr        	sta dispx		; coords in dispx,dispy.
0007F2r 3  4C rr rr     	jmp cangh		; test if we can go there.
0007F5r 3               
0007F5r 3               ;---------------------------------------------------------
0007F5r 3               ; Can go right check.
0007F5r 3               ;
0007F5r 3               ; Input:
0007F5r 3               ;  IX = sprite pointer
0007F5r 3               ;
0007F5r 3               ; Output:
0007F5r 3               ;  A  = 0 is ok, A <>0 is not ok
0007F5r 3               ;---------------------------------------------------------
0007F5r 3               
0007F5r 3               cangr:
0007F5r 3  A0 08        	ldy #8
0007F7r 3  B1 rr        	lda (z80_ix),y		; y coordinate.
0007F9r 3  85 rr        	sta dispy
0007FBr 3  A0 09        	ldy #9
0007FDr 3  B1 rr        	lda (z80_ix),y		; x coordinate.
0007FFr 3  18           	clc
000800r 3  69 10        	adc #16			; look right 16 pixels.
000802r 3  85 rr        	sta dispx		; coords in dispx,dispy.
000804r 3               cangh:
000804r 3               cangh2:
000804r 3  A9 04        	lda #(SPR_HGT/8+1)	; default rows to write.
000806r 3  85 rr        	sta z80_b
000808r 3  A5 rr        	lda dispy		; y position.
00080Ar 3  29 07        	and #7			; does x straddle cells?
00080Cr 3  D0 02        	bne cangh0		; yes, loop counter is good.
00080Er 3  C6 rr        	dec z80_b		; one less row to write.
000810r 3               cangh0:
000810r 3  20 rr rr     	jsr tstbl		; get map address.
000813r 3               cangh1:
000813r 3  20 rr rr     	jsr lrchk		; standard left/right check.
000816r 3  F0 01        	beq :+
000818r 3  60           	rts			; no way through.
000819r 3               :
000819r 3  48           	pha
00081Ar 3  18           	clc
00081Br 3  A5 rr        	lda bufaddr
00081Dr 3  69 20        	adc #32		; look down.
00081Fr 3  85 rr        	sta bufaddr
000821r 3  90 02        	bcc :+
000823r 3  E6 rr        	inc bufaddr+1
000825r 3               :
000825r 3  68           	pla
000826r 3               
000826r 3  C6 rr        	dec z80_b
000828r 3  D0 E9        	bne cangh1
00082Ar 3  60           	rts
00082Br 3               
00082Br 3               ;-------------------------------------
00082Br 3               ; Check left/right movement is okay.
00082Br 3               ;
00082Br 3               ; Input:
00082Br 3               ;  bufaddr = MAP + x/8 + y/8*32
00082Br 3               ;
00082Br 3               ; Output:
00082Br 3               ;  A  = 0 is ok, A <>0 is not ok
00082Br 3               ;-------------------------------------
00082Br 3               
00082Br 3               lrchk:
00082Br 3  A0 00        	ldy #0
00082Dr 3  B1 rr        	lda (bufaddr),y		; fetch map cell.
00082Fr 3  C9 02        	cmp #WALL 		; is it passable?
000831r 3  F0 0A        	beq lrchkx		; no.
000833r 3               
000833r 3  C9 04        	cmp #FODDER		; fodder has to be dug.
000835r 3  F0 06        	beq lrchkx		; not passable.
000837r 3  A9 00        	lda #0
000839r 3  60           	rts
00083Ar 3               
00083Ar 3               ;--------------------------------------------------------------
00083Ar 3               ; Called by mmenu
00083Ar 3               ;--------------------------------------------------------------
00083Ar 3               
00083Ar 3               always:
00083Ar 3  A9 FF        	lda #255		; report it as okay.
00083Cr 3  60           	rts
00083Dr 3               
00083Dr 3               lrchkx:
00083Dr 3  A9 01        	lda #1 			; reset all bits.
00083Fr 3  60           	rts
000840r 3               
000840r 3               
000840r 3               ;--------------------------------------------------------------
000840r 3               ; Check platform or solid item is not in way.
000840r 3               ;
000840r 3               ; Input:
000840r 3               ;  bufaddr = MAP + x/8 + y/8*32
000840r 3               ;
000840r 3               ; Output:
000840r 3               ;  A  = 0 is ok, A <>0 is not ok
000840r 3               ;--------------------------------------------------------------
000840r 3               
000840r 3               plchk:
000840r 3  A0 00        	ldy #0
000842r 3  B1 rr        	lda (bufaddr),y 	; fetch map cell.
000844r 3  C9 02        	cmp #WALL 		; is it passable?
000846r 3  F0 F5        	beq lrchkx		; no.
000848r 3               .if pflag .or dflag
000848r 3               	cmp #FODDER		; fodder has to be dug.
000848r 3               	beq lrchkx		; not passable.
000848r 3               .endif
000848r 3  C9 01        	cmp #PLATFM		; platform is solid.
00084Ar 3  F0 03        	beq plchkx		; not passable.
00084Cr 3               .if lflag
00084Cr 3               	cmp #LADDER		; is it a ladder?
00084Cr 3               	beq lrchkx		; on ladder, deny movement.
00084Cr 3               .endif
00084Cr 3               plchk0:
00084Cr 3  A9 00        	lda #0			; report as ok
00084Er 3  60           	rts
00084Fr 3               plchkx:
00084Fr 3  A5 rr        	lda dispy		; x coordinate.
000851r 3  29 07        	and #7			; position straddling blocks.
000853r 3  F0 E8        	beq lrchkx		; on platform, deny movement.
000855r 3  4C rr rr     	jmp plchk0
000858r 3               
000858r 3               ;--------------------------------------------------------------
000858r 3               ; Check ladder is available.
000858r 3               ;
000858r 3               ; Input:
000858r 3               ;  bufaddr = MAP + x/8 + y/8*32
000858r 3               ;
000858r 3               ; Output:
000858r 3               ;  A  = 0 is ok, A <>0 is not ok
000858r 3               ;--------------------------------------------------------------
000858r 3               
000858r 3               .if lflag
000858r 3               ldchk:
000858r 3               	ldy #0
000858r 3               	lda (bufaddr),y 	; fetch cell.
000858r 3               	cmp #LADDER 		; is it a ladder?
000858r 3               	beq ldchk1
000858r 3               	lda #1
000858r 3               	rts  			; return with zero flag set accordingly.
000858r 3               ldchk1:
000858r 3               	lda #0
000858r 3               	rts
000858r 3               .endif
000858r 3               
000858r 3               ;--------------------------------------------------------------
000858r 3               ; Get collectables.
000858r 3               ;--------------------------------------------------------------
000858r 3               
000858r 3               .if cflag
000858r 3               getcol:
000858r 3                       lda #COLECT             ; collectable blocks.
000858r 3                       sta z80_b
000858r 3                       jsr tded                ; test for collectable blocks.
000858r 3                       cmp z80_b               ; did we find one?
000858r 3                       beq :+
000858r 3                       rts                     ; none were found, job done.
000858r 3               :
000858r 3                       jsr gtblk               ; get block.
000858r 3                       jsr evnt20              ; collected block event.
000858r 3                       jmp getcol              ; repeat until none left.
000858r 3               
000858r 3               ; Get collectable block.
000858r 3               
000858r 3               gtblk:
000858r 3               	ldy #0
000858r 3               	lda (bufaddr),y
000858r 3               	sta z80_a
000858r 3                       lda #0
000858r 3                       sta (bufaddr),y		; make it empty now.
000858r 3               
000858r 3               	lda bufaddr		; set dispx
000858r 3               	and #31
000858r 3               	sta dispx
000858r 3               
000858r 3               	lda bufaddr+1		; Set dispy
000858r 3               	sec
000858r 3               	sbc #>MAP
000858r 3               	sta bufaddr+1
000858r 3               	asl bufaddr
000858r 3               	rol bufaddr+1
000858r 3               	asl bufaddr
000858r 3               	rol bufaddr+1
000858r 3               	asl bufaddr
000858r 3               	rol bufaddr+1
000858r 3               	lda bufaddr+1
000858r 3               	sta dispy
000858r 3               
000858r 3               	lda colpatt		; get blocknr
000858r 3               	sta z80_e		; displacement in e.
000858r 3               	lda #0
000858r 3               	sta z80_d		; no high byte.
000858r 3               	asl z80_e  		; multiply char by 8.
000858r 3               	rol z80_d
000858r 3               	asl z80_e
000858r 3               	rol z80_d
000858r 3               	asl z80_e
000858r 3               	rol z80_d
000858r 3               	clc
000858r 3               	lda z80_e
000858r 3               	adc #<chgfx 		; address of graphics.
000858r 3               	sta tileaddr
000858r 3               	lda z80_d
000858r 3               	adc #>chgfx
000858r 3               	sta tileaddr+1
000858r 3               	jsr gprad 		; get screen address.
000858r 3               	ldx #7			; number of pixel rows to write.
000858r 3               gtblk0:
000858r 3               	ldy #0
000858r 3               	lda (tileaddr),y 	; get image byte.
000858r 3               	ldy scrtab,x
000858r 3               	eor (scraddr),y 	; XOR tile on screen
000858r 3               	sta (scraddr),y 	; copy to screen.
000858r 3               	inc tileaddr 		; next image byte.
000858r 3               	bne :+
000858r 3               	inc tileaddr+1
000858r 3               :
000858r 3               	dex	 		; repeat for 8 pixel rows.
000858r 3               	bpl gtblk0
000858r 3               	rts
000858r 3               .endif
000858r 3               
000858r 3               ;--------------------------------------------------------------
000858r 3               ; Touched deadly block check.
000858r 3               ; returns with DEADLY (must be non-zero) in accumulator if true.
000858r 3               ;
000858r 3               ; Input:
000858r 3               ;  IX = sprite address
000858r 3               ;
000858r 3               ; Output:
000858r 3               ;  A  = 0 is ok, A=5 is not ok
000858r 3               ;--------------------------------------------------------------
000858r 3               
000858r 3               tded:
000858r 3  A0 08        	ldy #8
00085Ar 3  B1 rr        	lda (z80_ix),y 		; y coordinate.
00085Cr 3  85 rr        	sta dispy
00085Er 3  C8           	iny
00085Fr 3  B1 rr        	lda (z80_ix),y 		; x coordinate.
000861r 3  85 rr        	sta dispx		; coords in dispx,dispy.
000863r 3  20 rr rr     	jsr tstbl		; get map address.
000866r 3  48           	pha
000867r 3  A9 1F        	lda #31			; default distance to next line down.
000869r 3  85 rr        	sta z80_e
00086Br 3  68           	pla
00086Cr 3  C5 rr        	cmp z80_b		; is this the required block?
00086Er 3  D0 01        	bne :+
000870r 3  60           	rts			; yes.
000871r 3               :
000871r 3  E6 rr        	inc bufaddr 		; next cell.
000873r 3  D0 02        	bne :+
000875r 3  E6 rr        	inc bufaddr+1
000877r 3               :
000877r 3  A0 00        	ldy #0
000879r 3  B1 rr        	lda (bufaddr),y		; fetch type.
00087Br 3  C5 rr        	cmp z80_b 		; is this deadly/custom?
00087Dr 3  D0 01        	bne :+
00087Fr 3  60           	rts			; yes.
000880r 3               :
000880r 3  A5 rr        	lda dispx		; horizontal position.
000882r 3  85 rr        	sta z80_c 		; store column in c register.
000884r 3  29 07        	and #7			; is it straddling cells?
000886r 3  D0 03        	bne :+
000888r 3  4C rr rr     	jmp tded0		; no.
00088Br 3               :
00088Br 3  E6 rr        	inc bufaddr 		; last cell.
00088Dr 3  D0 02        	bne :+
00088Fr 3  E6 rr        	inc bufaddr+1
000891r 3               :
000891r 3  A0 00        	ldy #0
000893r 3  B1 rr        	lda (bufaddr),y 	; fetch type.
000895r 3  C5 rr        	cmp z80_b		; is this the block?
000897r 3  D0 01        	bne :+
000899r 3  60           	rts			; yes.
00089Ar 3               :
00089Ar 3  C6 rr        	dec z80_e		; one less cell to next row down.
00089Cr 3               tded0:
00089Cr 3  18           	clc 			; point to next row.
00089Dr 3  A5 rr        	lda bufaddr
00089Fr 3  65 rr        	adc z80_e
0008A1r 3  85 rr        	sta bufaddr
0008A3r 3  90 02        	bcc :+
0008A5r 3  E6 rr        	inc bufaddr+1
0008A7r 3               :
0008A7r 3  A0 00        	ldy #0
0008A9r 3  B1 rr        	lda (bufaddr),y		; fetch left cell block.
0008ABr 3  C5 rr        	cmp z80_b		; is this fatal?
0008ADr 3  D0 01        	bne :+
0008AFr 3  60           	rts			; yes.
0008B0r 3               :
0008B0r 3  E6 rr        	inc bufaddr 		; next cell.
0008B2r 3  D0 02        	bne :+
0008B4r 3  E6 rr        	inc bufaddr+1
0008B6r 3               :
0008B6r 3  A0 00        	ldy #0
0008B8r 3  B1 rr        	lda (bufaddr),y 	; fetch type.
0008BAr 3  C5 rr        	cmp z80_b		; is this fatal?
0008BCr 3  D0 01        	bne :+
0008BEr 3  60           	rts			; yes.
0008BFr 3               :
0008BFr 3  A5 rr        	lda z80_c		; horizontal position.
0008C1r 3  29 07        	and #7			; is it straddling cells?
0008C3r 3  D0 03        	bne :+
0008C5r 3  4C rr rr     	jmp tded1 		; no.
0008C8r 3               :
0008C8r 3  E6 rr        	inc bufaddr		; last cell.
0008CAr 3  D0 02        	bne :+
0008CCr 3  E6 rr        	inc bufaddr+1
0008CEr 3               :
0008CEr 3  A0 00        	ldy #0
0008D0r 3  B1 rr        	lda (bufaddr),y		; fetch type.
0008D2r 3  C5 rr        	cmp z80_b		; is this fatal?
0008D4r 3  D0 01        	bne :+
0008D6r 3  60           	rts			; yes.
0008D7r 3               :
0008D7r 3               tded1:
0008D7r 3  A5 rr        	lda dispy		; vertical position.
0008D9r 3  29 07        	and #7 			; is it straddling cells?
0008DBr 3  D0 01        	bne :+
0008DDr 3  60           	rts			; no, job done.
0008DEr 3               :
0008DEr 3  18           	clc			; point to next row.
0008DFr 3  A5 rr        	lda bufaddr
0008E1r 3  65 rr        	adc z80_e
0008E3r 3  85 rr        	sta bufaddr
0008E5r 3  90 02        	bcc :+
0008E7r 3  E6 rr        	inc bufaddr+1
0008E9r 3               :
0008E9r 3  A0 00        	ldy #0
0008EBr 3  B1 rr        	lda (bufaddr),y 	; fetch left cell block.
0008EDr 3  C5 rr        	cmp z80_b		; is this fatal?
0008EFr 3  D0 01        	bne :+
0008F1r 3  60           	rts			; yes.
0008F2r 3               :
0008F2r 3  E6 rr        	inc bufaddr		; next cell.
0008F4r 3  D0 02        	bne :+
0008F6r 3  E6 rr        	inc bufaddr+1
0008F8r 3               :
0008F8r 3  A0 00        	ldy #0
0008FAr 3  B1 rr        	lda (bufaddr),y 	; fetch type.
0008FCr 3  C5 rr        	cmp z80_b		; is this fatal?
0008FEr 3  D0 01        	bne :+
000900r 3  60           	rts			; yes.
000901r 3               :
000901r 3  A5 rr        	lda z80_c		; horizontal position.
000903r 3  29 07        	and #7			; is it straddling cells?
000905r 3  D0 01        	bne :+
000907r 3  60           	rts			; no.
000908r 3               :
000908r 3  E6 rr        	inc bufaddr		; last cell.
00090Ar 3  D0 02        	bne :+
00090Cr 3  E6 rr        	inc bufaddr+1
00090Er 3               :
00090Er 3  A0 00        	ldy #0
000910r 3  B1 rr        	lda (bufaddr),y		; fetch final type.
000912r 3  60           	rts 			; return with final type in accumulator.
000913r 3               
000913r 3               ;---------------------------------------------------
000913r 3               ; Fetch block type at (dispx, dispy).
000913r 3               ;
000913r 3               ; Output:
000913r 3               ;  A = block type
000913r 3               ;---------------------------------------------------
000913r 3               
000913r 3               tstbl:
000913r 3  A5 rr        	lda dispy 		; fetch y coord.
000915r 3  4A           	lsr a			; bufaddr = y/8
000916r 3  4A           	lsr a
000917r 3  4A           	lsr a
000918r 3               ;	sta chary
000918r 3               
000918r 3  85 rr        	sta bufaddr
00091Ar 3  A9 00        	lda #0
00091Cr 3  85 rr        	sta bufaddr+1
00091Er 3               
00091Er 3  06 rr        	asl bufaddr  		; bufaddr = y/8 * 32
000920r 3  26 rr        	rol bufaddr+1
000922r 3  06 rr        	asl bufaddr
000924r 3  26 rr        	rol bufaddr+1
000926r 3  06 rr        	asl bufaddr
000928r 3  26 rr        	rol bufaddr+1
00092Ar 3  06 rr        	asl bufaddr
00092Cr 3  26 rr        	rol bufaddr+1
00092Er 3  06 rr        	asl bufaddr
000930r 3  26 rr        	rol bufaddr+1
000932r 3               
000932r 3  A5 rr        	lda dispx		; x/8
000934r 3  4A           	lsr a
000935r 3  4A           	lsr a
000936r 3  4A           	lsr a
000937r 3               ;	sta charx
000937r 3               
000937r 3  18           	clc			; bufaddr = MAP + x/8 + y/8*32
000938r 3  65 rr        	adc bufaddr
00093Ar 3  69 00        	adc #<MAP
00093Cr 3  85 rr        	sta bufaddr
00093Er 3  A5 rr        	lda bufaddr+1
000940r 3  69 04        	adc #>MAP
000942r 3  85 rr        	sta bufaddr+1
000944r 3               
000944r 3  A0 00        	ldy #0
000946r 3  B1 rr        	lda (bufaddr),y 	; fetch byte there.
000948r 3  60           	rts
000949r 3               
000949r 3               ;-------------------------------------------------------------------
000949r 3               ; Jump - if we can.
000949r 3               ; Requires initial speed to be set up in accumulator prior to call.
000949r 3               ;
000949r 3               ; Input:
000949r 3               ;  IX = sprite address
000949r 3               ;-------------------------------------------------------------------
000949r 3               
000949r 3               jump:
000949r 3  A0 0D        	ldy #var_jumpLo
00094Br 3  B1 rr        	lda (z80_ix),y		; jump table low.
00094Dr 3  A0 0E        	ldy #var_jumpHi
00094Fr 3  11 rr        	ora (z80_ix),y		; jump table high.
000951r 3  F0 01        	beq :+
000953r 3  60           	rts			; already in the air.
000954r 3               :
000954r 3  A9 rr        	lda #>jtab
000956r 3  A0 0E        	ldy #var_jumpHi
000958r 3  91 rr        	sta (z80_ix),y		; set jump high.
00095Ar 3  A9 rr        	lda #<jtab		; jump table start.
00095Cr 3  A0 0D        	ldy #var_jumpLo
00095Er 3  91 rr        	sta (z80_ix),y		; set jump low.
000960r 3  60           	rts
000961r 3               
000961r 3               ; Jump table.
000961r 3               ; _BEEB - jump table must reside entirely in a page otherwise grav fn breaks
000961r 3               ;.align 32
000961r 3               ;jtab:
000961r 3               ;	.byte 248,250,252
000961r 3               ;	.byte 254,254,255
000961r 3               ;	.byte 255,255,0,0
000961r 3               ;	.byte 0,1,1,1,2,2
000961r 3               ;	.byte 4,6,8,8,8,99
000961r 3               
000961r 3               ;------------------------------------------------
000961r 3               ; Random numbers code.
000961r 3               ; Pseudo-random number generator, 8-bit.
000961r 3               ;
000961r 3               ; Output:
000961r 3               ;  RND = random number
000961r 3               ;------------------------------------------------
000961r 3               
000961r 3               random:
000961r 3  A5 rr        	lda seed
000963r 3  F0 05        	beq doEor
000965r 3  0A           	asl a
000966r 3  F0 04        	beq noEor
000968r 3  90 02        	bcc noEor
00096Ar 3  49 1D        doEor:	eor #$1d
00096Cr 3  85 rr        noEor:	sta seed
00096Er 3  60           	rts
00096Fr 3               
00096Fr 3  A5 rr        	lda seed		; get last random number.
000971r 3  0A           	asl a
000972r 3  0A           	asl a
000973r 3  18           	clc
000974r 3  65 rr        	adc seed
000976r 3  18           	clc
000977r 3  69 45        	adc #$45
000979r 3  85 rr        	sta seed		; store new seed.
00097Br 3  85 rr        	sta varrnd		; return number in variable.
00097Dr 3  60           	rts
00097Er 3               
00097Er 3               ;-------------------------------------------------------
00097Er 3               ; Joystick and keyboard reading routines.
00097Er 3               ;
00097Er 3               ; contrl = 0, Keyboard
00097Er 3               ;          1, JoyKeyb
00097Er 3               ;          2, JoyMMC
00097Er 3               ;
00097Er 3               ;      joyval=x65FUDLR (bit cleared if key pressed)
00097Er 3               ;             ||||||||
00097Er 3               ;             |||||||+> Right    KEY 0  - X
00097Er 3               ;             ||||||+-> Left     KEY 1  - Z
00097Er 3               ;             |||||+--> Down     KEY 2  - .
00097Er 3               ;             ||||+---> Up       KEY 3  - ;
00097Er 3               ;             |||+----> Fire1    KEY 4  - SPC
00097Er 3               ;             ||+-----> Fire2    KEY 5  - Q
00097Er 3               ;             |+------> Fire3    KEY 6  - P
00097Er 3               ;             +-------> Not used
00097Er 3               ;
00097Er 3               ;                       Option1  KEY 7  - 1
00097Er 3               ;                       Option2  KEY 8  - 2
00097Er 3               ;                       Option3  KEY 9  - 3
00097Er 3               ;                       Option4  KEY 10 - 4
00097Er 3               ;-------------------------------------------------------
00097Er 3               
00097Er 3               joykey:
00097Er 3  A5 rr        	lda contrl 		; control flag.
000980r 3  C9 01        	cmp #1
000982r 3  F0 1A        	beq joy1 		; scan joystick1
000984r 3  C9 02        	cmp #2
000986r 3  F0 1C        	beq joy2 		; scan joystick2
000988r 3               
000988r 3               ; Scan keyboard
000988r 3               
000988r 3  A9 00        	lda #0		 	; zero reading.
00098Ar 3  85 rr        	sta z80_e
00098Cr 3               
00098Cr 3  A0 06        	ldy #6	 		; address of last key.
00098Er 3               joyke0:
00098Er 3  B9 rr rr     	lda keys,y 		; get key from table.
000991r 3  20 rr rr     	jsr ktest		; being pressed?
000994r 3  26 rr        	rol z80_e 		; rotate into reading.
000996r 3               
000996r 3  88           	dey		 	; next key.
000997r 3  10 F5        	bpl joyke0 		; repeat for all keys.
000999r 3               joyret:
000999r 3  A5 rr        	lda z80_e
00099Br 3  85 rr        	sta joyval
00099Dr 3  60           	rts
00099Er 3               
00099Er 3               ; Scan joystick 1
00099Er 3               
00099Er 3               joy1:
00099Er 3  20 rr rr     	jsr joy1scan
0009A1r 3  4C rr rr     	jmp joyret 		; store the value.
0009A4r 3               
0009A4r 3               ; Scan joystick 2
0009A4r 3               
0009A4r 3               joy2:
0009A4r 3  20 rr rr     	jsr joy2scan
0009A7r 3  4C rr rr     	jmp joyret 		; store the value.
0009AAr 3               
0009AAr 3               ;---------------------------------------------------------------
0009AAr 3               ; Display message.
0009AAr 3               ;
0009AAr 3               ; Input:
0009AAr 3               ;  A = message number
0009AAr 3               ;---------------------------------------------------------------
0009AAr 3               
0009AAr 3               dmsg:
0009AAr 3  AA           	tax
0009ABr 3  A9 rr        	lda #<msgdat		; pointer to messages.
0009ADr 3  85 rr        	sta z80_l
0009AFr 3  A9 rr        	lda #>msgdat
0009B1r 3  85 rr        	sta z80_h
0009B3r 3  20 rr rr     	jsr getwrd		; get message number.
0009B6r 3               dmsg3:
0009B6r 3  20 rr rr     	jsr preprt		; pre-printing stuff.
0009B9r 3  20 rr rr     	jsr checkx		; make sure we"re in a printable range.
0009BCr 3  A5 rr        	lda prtmod		; print mode.
0009BEr 3  D0 47        	bne bmsg1		; no, double-height text.
0009C0r 3               dmsg0:
0009C0r 3  A5 rr        	lda z80_h		; store string pointer.
0009C2r 3  48           	pha
0009C3r 3  A5 rr        	lda z80_l
0009C5r 3  48           	pha
0009C6r 3               
0009C6r 3  A0 00        	ldy #0
0009C8r 3  B1 rr        	lda (z80_hl),y		; fetch byte to display.
0009CAr 3  29 7F        	and #127		; remove any end marker.
0009CCr 3  C9 0D        	cmp #ASCII_NEWLINE
0009CEr 3  F0 24        	beq dmsg1
0009D0r 3  20 rr rr     	jsr pchar		; display character.
0009D3r 3  20 rr rr     	jsr nexpos 		; display position.
0009D6r 3  D0 03        	bne dmsg2		; not on a new line.
0009D8r 3  20 rr rr     	jsr nexlin		; next line down.
0009DBr 3               dmsg2:
0009DBr 3  68           	pla			; retrieve string pointer
0009DCr 3  85 rr        	sta z80_l
0009DEr 3  68           	pla
0009DFr 3  85 rr        	sta z80_h
0009E1r 3               
0009E1r 3  A0 00        	ldy #0
0009E3r 3  B1 rr        	lda (z80_hl),y		; fetch last character.
0009E5r 3  0A           	asl a  			; was it the end?
0009E6r 3  90 03        	bcc :+
0009E8r 3  4C rr rr     	jmp dscor2		; yes, job done.
0009EBr 3               :
0009EBr 3  E6 rr        	inc z80_l		; next character to display.
0009EDr 3  D0 02        	bne :+
0009EFr 3  E6 rr        	inc z80_h
0009F1r 3               :
0009F1r 3  4C rr rr     	jmp dmsg0
0009F4r 3               dmsg1:
0009F4r 3  E6 rr        	inc dispy
0009F6r 3  A5 rr        	lda dispy
0009F8r 3  C9 18        	cmp #24
0009FAr 3  90 04        	bcc dmsg4
0009FCr 3  A9 00        	lda #0
0009FEr 3  85 rr        	sta dispy
000A00r 3               dmsg4:
000A00r 3  A9 00        	lda #0
000A02r 3  85 rr        	sta dispx
000A04r 3  4C rr rr     	jmp dmsg2
000A07r 3               
000A07r 3               
000A07r 3               ;----------------------------------------------------------
000A07r 3               ; Display message in big text.
000A07r 3               ;
000A07r 3               ; Input:
000A07r 3               ;  HL = string pointer
000A07r 3               ;----------------------------------------------------------
000A07r 3               
000A07r 3               bmsg1:
000A07r 3  A0 00        	ldy #0
000A09r 3  B1 rr        	lda (z80_hl),y 		; get character to display.
000A0Br 3  29 7F        	and #127		; only want 7 bits.
000A0Dr 3  C9 0D        	cmp #ASCII_NEWLINE
000A0Fr 3  F0 13        	beq bmsg2
000A11r 3  20 rr rr     	jsr bchar 		; display big char.
000A14r 3               bmsg3:
000A14r 3  A0 00        	ldy #0
000A16r 3  B1 rr        	lda (z80_hl),y 		; look at last character.
000A18r 3  48           	pha
000A19r 3  E6 rr        	inc z80_l 		; next character in list.
000A1Br 3  D0 02        	bne :+
000A1Dr 3  E6 rr        	inc z80_h
000A1Fr 3               :
000A1Fr 3  68           	pla
000A20r 3  0A           	asl a  			; was terminator flag set?
000A21r 3  90 E4        	bcc bmsg1		; no, keep going.
000A23r 3               
000A23r 3  60           	rts
000A24r 3               bmsg2:
000A24r 3  A9 00        	lda #0
000A26r 3  85 rr        	sta dispx
000A28r 3  E6 rr        	inc dispy
000A2Ar 3  E6 rr        	inc dispy
000A2Cr 3  A5 rr        	lda dispy
000A2Er 3  C9 17        	cmp #23
000A30r 3  90 E2        	bcc bmsg3
000A32r 3  A9 00        	lda #0
000A34r 3  85 rr        	sta dispy
000A36r 3  4C rr rr     	jmp bmsg3
000A39r 3               
000A39r 3               ;----------------------------------------------------------
000A39r 3               ; Big character display.
000A39r 3               ;
000A39r 3               ; Input:
000A39r 3               ;  A = character
000A39r 3               ;----------------------------------------------------------
000A39r 3               
000A39r 3               bchar:
000A39r 3  85 rr        	sta z80_e		; save char in lb
000A3Br 3  A9 00        	lda #0
000A3Dr 3  85 rr        	sta z80_d		; reset hb
000A3Fr 3               
000A3Fr 3  06 rr        	asl z80_e 		; multiply char by 8.
000A41r 3  26 rr        	rol z80_d
000A43r 3  06 rr        	asl z80_e
000A45r 3  26 rr        	rol z80_d
000A47r 3  06 rr        	asl z80_e
000A49r 3  26 rr        	rol z80_d		; de = a*8
000A4Br 3               
000A4Br 3  18           	clc			; de = #<(FONT-256) + a*8
000A4Cr 3  A5 rr        	lda z80_e
000A4Er 3  69 rr        	adc #<(FONT-256) 		; address of font.
000A50r 3  85 rr        	sta z80_e
000A52r 3  A5 rr        	lda z80_d
000A54r 3  69 rr        	adc #>(FONT-256)
000A56r 3  85 rr        	sta z80_d
000A58r 3               
000A58r 3  20 rr rr     	jsr gaadd		; set colour attribute
000A5Br 3  AD rr rr     	lda fontcol
000A5Er 3  A0 00        	ldy #0
000A60r 3  91 rr        	sta (bufaddr),y
000A62r 3               
000A62r 3  20 rr rr     	jsr gprad 		; get screen address.
000A65r 3               
000A65r 3  A2 00        	ldx #0			; height of character in font.
000A67r 3               bchar0:
000A67r 3  A0 00        	ldy #0
000A69r 3  B1 rr        	lda (z80_de),y 		; get a bit of the font.
000A6Br 3               
000A6Br 3               .if iflag
000A6Br 3               	eor #$ff
000A6Br 3               .endif
000A6Br 3               
000A6Br 3  91 rr        	sta (scraddr),y
000A6Dr 3  48           	pha
000A6Er 3  20 rr rr     	jsr nline 		; next line down.
000A71r 3  68           	pla
000A72r 3  91 rr        	sta (scraddr),y
000A74r 3  20 rr rr     	jsr nline 		; next line down.
000A77r 3               
000A77r 3  18           	clc
000A78r 3  E6 rr        	inc z80_e 		; next line of font.
000A7Ar 3  D0 02        	bne :+
000A7Cr 3  E6 rr        	inc z80_d
000A7Er 3               :
000A7Er 3  E8           	inx
000A7Fr 3  E0 08        	cpx #8
000A81r 3  D0 E4        	bne bchar0
000A83r 3               
000A83r 3  20 rr rr     	jsr nexpos		; display position.
000A86r 3  D0 05        	bne bchar2 		; not on a new line.
000A88r 3               bchar3:
000A88r 3  E6 rr        	inc dispy
000A8Ar 3  20 rr rr     	jsr nexlin 		; next line check.
000A8Dr 3               bchar2:
000A8Dr 3  4C rr rr     	jmp dscor2		; tidy up line and column variables.
000A90r 3               
000A90r 3               
000A90r 3               ;-------------------------------------------------
000A90r 3               ; Display a character.
000A90r 3               ;
000A90r 3               ; Input:
000A90r 3               ;  A = character
000A90r 3               ;-------------------------------------------------
000A90r 3               
000A90r 3               achar:
000A90r 3  85 rr        	sta z80_b 		; copy to b.
000A92r 3  20 rr rr     	jsr preprt 		; get ready to print.
000A95r 3  A5 rr        	lda z80_b		; character in accumulator.
000A97r 3  A6 rr        	ldx prtmod 		; print mode.
000A99r 3  F0 03        	beq :+
000A9Br 3  4C rr rr     	jmp bchar 		; no, double-height text.
000A9Er 3               :
000A9Er 3  20 rr rr     	jsr pchar 		; display character.
000AA1r 3  20 rr rr     	jsr nexpos 		; display position.
000AA4r 3  F0 E2        	beq bchar3		; next line down.
000AA6r 3  4C rr rr     	jmp bchar2 		; tidy up.
000AA9r 3               
000AA9r 3               
000AA9r 3               ;-------------------------------------------------
000AA9r 3               ; Get next print column position.
000AA9r 3               ;-------------------------------------------------
000AA9r 3               
000AA9r 3               nexpos:
000AA9r 3  E6 rr        	inc dispx		; move along one position.
000AABr 3  A5 rr        	lda dispx 		; get coordinate.
000AADr 3  C9 16        	cmp #22
000AAFr 3  D0 0E        	bne :+
000AB1r 3  A9 00        	lda #0
000AB3r 3  85 rr        	sta dispx
000AB5r 3  A5 rr        	lda prtmod
000AB7r 3  F0 06        	beq :+
000AB9r 3  20 rr rr     	jsr nexlin
000ABCr 3  4C rr rr     	jmp nexlin
000ABFr 3               :
000ABFr 3  60           	rts
000AC0r 3               
000AC0r 3               ;-------------------------------------------------
000AC0r 3               ; Get next print line position.
000AC0r 3               ;-------------------------------------------------
000AC0r 3               
000AC0r 3               nexlin:
000AC0r 3  E6 rr        	inc dispy 		; newline.
000AC2r 3  A5 rr        	lda dispy		; vertical position.
000AC4r 3  C9 16        	cmp #22			; past screen edge?
000AC6r 3  B0 01        	bcs :+
000AC8r 3  60           	rts			; no, still okay.
000AC9r 3               :
000AC9r 3  A9 00        	lda #0			; restart at top.
000ACBr 3  85 rr        	sta dispy
000ACDr 3  60           	rts
000ACEr 3               
000ACEr 3               ;--------------------------------------------------------
000ACEr 3               ; Pre-print preliminaries.
000ACEr 3               ;--------------------------------------------------------
000ACEr 3               
000ACEr 3               preprt:
000ACEr 3  A9 rr        	lda #<(FONT-256)		; font pointer.
000AD0r 3  8D rr rr     	sta grbase		; set up graphics base.
000AD3r 3  A9 rr        	lda #>(FONT-256)
000AD5r 3  8D rr rr     	sta grbase+1
000AD8r 3               prescr:
000AD8r 3  A5 rr        	lda charx 		; display coordinates.
000ADAr 3  85 rr        	sta dispx		; set up general coordinates.
000ADCr 3  A5 rr        	lda chary
000ADEr 3  85 rr        	sta dispy
000AE0r 3  60           	rts
000AE1r 3               
000AE1r 3               ;--------------------------------------------------------------
000AE1r 3               ; Get messagenr x in hl
000AE1r 3               ;
000AE1r 3               ; Input:
000AE1r 3               ;  HL = pointer to message list
000AE1r 3               ;  X  = message number.
000AE1r 3               ;--------------------------------------------------------------
000AE1r 3               
000AE1r 3               getwrd:
000AE1r 3  E0 00        	cpx #0
000AE3r 3  D0 01        	bne:+ 			; first word in list?
000AE5r 3  60           	rts 			; yep, don't search.
000AE6r 3               :
000AE6r 3  A0 00        	ldy #0
000AE8r 3               getwd0:
000AE8r 3  B1 rr        	lda (z80_hl),y
000AEAr 3  48           	pha
000AEBr 3  E6 rr        	inc z80_l
000AEDr 3  D0 02        	bne :+
000AEFr 3  E6 rr        	inc z80_h
000AF1r 3               :
000AF1r 3  68           	pla
000AF2r 3  C9 80        	cmp #128		; found end?
000AF4r 3  30 F2        	bmi getwd0		; no, carry on.
000AF6r 3  CA           	dex			; until we have right number.
000AF7r 3  D0 EF        	bne getwd0
000AF9r 3  60           	rts
000AFAr 3               
000AFAr 3               ;-----------------------------------------------------------
000AFAr 3               ; Bubble sort.
000AFAr 3               ;-----------------------------------------------------------
000AFAr 3               
000AFAr 3               bsort:
000AFAr 3  A9 07        	lda #NUMSPR - 1		; sprites to swap.
000AFCr 3  85 rr        	sta qscnt
000AFEr 3               
000AFEr 3  A9 rr        	lda #<sprtab 		; sprite table.
000B00r 3  85 rr        	sta z80_x
000B02r 3  A9 rr        	lda #>sprtab
000B04r 3  85 rr        	sta z80_i
000B06r 3               bsort0:
000B06r 3  A0 00        	ldy #0
000B08r 3  B1 rr        	lda (z80_ix),y 		; first sprite type.
000B0Ar 3  C9 FF        	cmp #255 		; is it switched off?
000B0Cr 3  F0 30        	beq swemp		; yes, may need to switch another in here.
000B0Er 3               
000B0Er 3  A0 11        	ldy #TABSIZ
000B10r 3  B1 rr        	lda (z80_ix),y 		; check next slot exists.
000B12r 3  C9 FF        	cmp #255 		; is it enabled?
000B14r 3  F0 0A        	beq bsort2 		; no, nothing to swap.
000B16r 3               
000B16r 3  A0 14        	ldy #TABSIZ+3
000B18r 3  B1 rr        	lda (z80_ix),y 		; fetch next sprite's coordinate.
000B1Ar 3  A0 03        	ldy #3
000B1Cr 3  D1 rr        	cmp (z80_ix),y 		; compare with this x coordinate.
000B1Er 3  90 10        	bcc bsort1		; next sprite is higher - may need to switch.
000B20r 3               bsort2:
000B20r 3  18           	clc
000B21r 3  A5 rr        	lda z80_x
000B23r 3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
000B25r 3  85 rr        	sta z80_x
000B27r 3  90 02        	bcc :+
000B29r 3  E6 rr        	inc z80_i
000B2Br 3               :
000B2Br 3  C6 rr        	dec qscnt
000B2Dr 3  D0 D7        	bne bsort0		; repeat for remaining sprites.
000B2Fr 3  60           	rts
000B30r 3               
000B30r 3               bsort1:
000B30r 3  A0 11        	ldy #TABSIZ
000B32r 3  B1 rr        	lda (z80_ix),y		; sprite on/off flag.
000B34r 3  C9 FF        	cmp #255		; is it enabled?
000B36r 3  F0 E8        	beq bsort2		; no, nothing to swap.
000B38r 3  20 rr rr     	jsr swspr		; swap positions.
000B3Br 3  4C rr rr     	jmp bsort2
000B3Er 3               swemp:
000B3Er 3  A0 11        	ldy #TABSIZ
000B40r 3  B1 rr        	lda (z80_ix),y		; next table entry.
000B42r 3  C9 FF        	cmp #255		; is that one on?
000B44r 3  F0 DA        	beq bsort2		; no, nothing to swap.
000B46r 3  20 rr rr     	jsr swspr		; swap positions.
000B49r 3  4C rr rr     	jmp bsort2
000B4Cr 3               
000B4Cr 3               ; Swap sprites.
000B4Cr 3               
000B4Cr 3               swspr:
000B4Cr 3  A5 rr        	lda z80_x		; table address
000B4Er 3  85 rr        	sta z80_e		; copy to de pair.
000B50r 3  85 rr        	sta z80_l		; copy to hl pair.
000B52r 3  A5 rr        	lda z80_i
000B54r 3  85 rr        	sta z80_h
000B56r 3  85 rr        	sta z80_d
000B58r 3               
000B58r 3  18           	clc
000B59r 3  A5 rr        	lda z80_l
000B5Br 3  69 11        	adc #TABSIZ		; distance to second entry.
000B5Dr 3  85 rr        	sta z80_l
000B5Fr 3  90 02        	bcc :+
000B61r 3  E6 rr        	inc z80_h
000B63r 3               :
000B63r 3  A9 11        	lda #TABSIZ		; bytes to swap.
000B65r 3  85 rr        	sta z80_b
000B67r 3  A0 00        	ldy #0
000B69r 3               swspr0:
000B69r 3  B1 rr        	lda (z80_hl),y		; fetch second byte.
000B6Br 3  48           	pha
000B6Cr 3  B1 rr        	lda (z80_de),y 		; fetch first byte.
000B6Er 3  91 rr        	sta (z80_hl),y 		; copy to second.
000B70r 3  68           	pla
000B71r 3  91 rr        	sta (z80_de),y 		; copy to first sprite entry.
000B73r 3               
000B73r 3  E6 rr        	inc z80_e 		; next byte.
000B75r 3  D0 02        	bne :+
000B77r 3  E6 rr        	inc z80_d
000B79r 3               :
000B79r 3  E6 rr        	inc z80_l 		; next byte.
000B7Br 3  D0 02        	bne :+
000B7Dr 3  E6 rr        	inc z80_h
000B7Fr 3               :
000B7Fr 3  C6 rr        	dec z80_b
000B81r 3  D0 E6        	bne swspr0 		; swap all bytes in table entry.
000B83r 3  60           	rts
000B84r 3               
000B84r 3               ;----------------------------------------------------
000B84r 3               ; Process sprites.
000B84r 3               ;----------------------------------------------------
000B84r 3               
000B84r 3               pspr:
000B84r 3  A9 08        	lda #NUMSPR		; sprites to process.
000B86r 3  85 rr        	sta sprptr
000B88r 3               
000B88r 3  A9 rr        	lda #<sprtab 		; sprite table.
000B8Ar 3  85 rr        	sta z80_x
000B8Cr 3  A9 rr        	lda #>sprtab
000B8Er 3  85 rr        	sta z80_i
000B90r 3               pspr1:
000B90r 3  A0 00        	ldy #0
000B92r 3  B1 rr        	lda (z80_ix),y		; fetch sprite type.
000B94r 3  C9 09        	cmp #9 			; within range of sprite types?
000B96r 3  B0 03        	bcs :+
000B98r 3  20 rr rr     	jsr pspr2 		; yes, process this one.
000B9Br 3               :
000B9Br 3  18           	clc
000B9Cr 3  A5 rr        	lda z80_x
000B9Er 3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
000BA0r 3  85 rr        	sta z80_x
000BA2r 3  90 02        	bcc :+
000BA4r 3  E6 rr        	inc z80_i		; next sprite.
000BA6r 3               :
000BA6r 3  C6 rr        	dec sprptr 		; repeat for remaining sprites.
000BA8r 3  D0 E6        	bne pspr1
000BAAr 3  60           	rts
000BABr 3               
000BABr 3               pspr2:
000BABr 3  A5 rr        	lda z80_x 		; store original sprite pointer.
000BADr 3  85 rr        	sta ogptr
000BAFr 3  A5 rr        	lda z80_i
000BB1r 3  85 rr        	sta ogptr+1
000BB3r 3  20 rr rr     	jsr pspr3		; do the routine.
000BB6r 3               rtorg:
000BB6r 3  A5 rr        	lda ogptr 		; restore original pointer to sprite.
000BB8r 3  85 rr        	sta z80_x
000BBAr 3  A5 rr        	lda ogptr+1
000BBCr 3  85 rr        	sta z80_i
000BBEr 3               rtorg0:
000BBEr 3  60           	rts
000BBFr 3               
000BBFr 3               pspr3:
000BBFr 3  A9 rr        	lda #<evtyp0		; sprite type events list.
000BC1r 3  85 rr        	sta z80_l
000BC3r 3  A9 rr        	lda #>evtyp0
000BC5r 3  85 rr        	sta z80_h
000BC7r 3               pspr4:
000BC7r 3  B1 rr        	lda (z80_ix),y
000BC9r 3  0A           	asl a			; double accumulator.
000BCAr 3  18           	clc
000BCBr 3  65 rr        	adc z80_l
000BCDr 3  85 rr        	sta z80_l
000BCFr 3  90 02        	bcc :+
000BD1r 3  E6 rr        	inc z80_h
000BD3r 3               :
000BD3r 3  B1 rr        	lda (z80_hl),y
000BD5r 3  85 rr        	sta z80_e 		; copy to de.
000BD7r 3  48           	pha
000BD8r 3               
000BD8r 3  E6 rr        	inc z80_l 		; next byte of address.
000BDAr 3  D0 02        	bne :+
000BDCr 3  E6 rr        	inc z80_h
000BDEr 3               :
000BDEr 3  B1 rr        	lda (z80_hl),y 		; address high.
000BE0r 3  85 rr        	sta z80_d
000BE2r 3               
000BE2r 3  48           	pha	 		; swap address into hl.
000BE3r 3  A5 rr        	lda z80_h
000BE5r 3  85 rr        	sta z80_d
000BE7r 3  68           	pla
000BE8r 3  85 rr        	sta z80_h
000BEAr 3  68           	pla
000BEBr 3  85 rr        	sta z80_l
000BEDr 3  A5 rr        	lda z80_l
000BEFr 3  85 rr        	sta z80_e
000BF1r 3               
000BF1r 3  6C rr rr     	jmp (z80_hl) 		; go there.
000BF4r 3               
000BF4r 3               ; Address of each sprite type's routine.
000BF4r 3               
000BF4r 3  rr rr        evtyp0:	.word evnt00
000BF6r 3  rr rr        evtyp1:	.word evnt01
000BF8r 3  rr rr        evtyp2:	.word evnt02
000BFAr 3  rr rr        evtyp3:	.word evnt03
000BFCr 3  rr rr        evtyp4:	.word evnt04
000BFEr 3  rr rr        evtyp5:	.word evnt05
000C00r 3  rr rr        evtyp6:	.word evnt06
000C02r 3  rr rr        evtyp7:	.word evnt07
000C04r 3  rr rr        evtyp8:	.word evnt08
000C06r 3               
000C06r 3               ;--------------------------------------------------------------
000C06r 3               ; Display sprites.
000C06r 3               ;
000C06r 3               ; Input:
000C06r 3               ;  IX = sprite table
000C06r 3               ;--------------------------------------------------------------
000C06r 3               
000C06r 3               dspr:
000C06r 3  A9 04        	lda #(NUMSPR/2)		; number of sprites to display.
000C08r 3  85 rr        	sta sprcnt
000C0Ar 3               
000C0Ar 3               dspr0:
000C0Ar 3  A0 00        	ldy #var_Type
000C0Cr 3  B1 rr        	lda (z80_ix),y 		; get sprite type.
000C0Er 3  C9 FF        	cmp #255 		; is it enabled?
000C10r 3  D0 45        	bne dspr1 		; yes, it needs deleting.
000C12r 3               dspr5:
000C12r 3  A0 05        	ldy #var_newType
000C14r 3  B1 rr        	lda (z80_ix),y 		; new type.
000C16r 3  C9 FF        	cmp #255		; is it enabled?
000C18r 3  F0 03        	beq dspr2
000C1Ar 3  4C rr rr     	jmp dspr3 		; yes, it needs drawing.
000C1Dr 3               dspr2:
000C1Dr 3  A0 05        	ldy #var_newType
000C1Fr 3  B1 rr        	lda (z80_ix),y 		; copy new type.
000C21r 3  A0 00        	ldy #var_Type
000C23r 3  91 rr        	sta (z80_ix),y
000C25r 3  A0 06        	ldy #var_newImage
000C27r 3  B1 rr        	lda (z80_ix),y 		; copy new image number.
000C29r 3  A0 01        	ldy #var_Image
000C2Br 3  91 rr        	sta (z80_ix),y
000C2Dr 3  A0 07        	ldy #var_newFrame
000C2Fr 3  B1 rr        	lda (z80_ix),y 		; copy new frame.
000C31r 3  A0 02        	ldy #var_Frame
000C33r 3  91 rr        	sta (z80_ix),y
000C35r 3  A0 08        	ldy #var_newY
000C37r 3  B1 rr        	lda (z80_ix),y 		; copy new y.
000C39r 3  A0 03        	ldy #var_Y
000C3Br 3  91 rr        	sta (z80_ix),y
000C3Dr 3  A0 09        	ldy #var_newX
000C3Fr 3  B1 rr        	lda (z80_ix),y 		; copy new x.
000C41r 3  A0 04        	ldy #var_X
000C43r 3  91 rr        	sta (z80_ix),y
000C45r 3               
000C45r 3  18           	clc
000C46r 3  A5 rr        	lda z80_x
000C48r 3  69 22        	adc #(TABSIZ*2)		; distance to next odd/even entry.
000C4Ar 3  85 rr        	sta z80_x
000C4Cr 3  A5 rr        	lda z80_i
000C4Er 3  69 00        	adc #0
000C50r 3  85 rr        	sta z80_i 		; next sprite.
000C52r 3  C6 rr        	dec sprcnt
000C54r 3  D0 B4        	bne dspr0		; repeat for remaining sprites.
000C56r 3  60           	rts
000C57r 3               
000C57r 3               dspr1:
000C57r 3               	; _BEEB clipping code copied from CPC Engine
000C57r 3  A0 03        	ldy #var_Y
000C59r 3  B1 rr        	lda (z80_ix), y		; old x coord
000C5Br 3  C9 A1        	cmp #SpriteMaxY     	; beyond maximum?
000C5Dr 3  B0 B3        	bcs dspr5		; yes, don't delete it.
000C5Fr 3               
000C5Fr 3  A0 05        	ldy #var_newType
000C61r 3  B1 rr        	lda (z80_ix),y 		; type of new sprite.
000C63r 3  C9 FF        	cmp #255		; is this enabled?
000C65r 3  D0 06        	bne dspr4 		; yes, display both.
000C67r 3               
000C67r 3               dspr6:
000C67r 3  20 rr rr     	jsr sspria 		; show single sprite.
000C6Ar 3  4C rr rr     	jmp dspr2
000C6Dr 3               
000C6Dr 3               ; Displaying two sprites.  Don't bother redrawing if nothing has changed.
000C6Dr 3               
000C6Dr 3               dspr4:
000C6Dr 3               	; _BEEB clipping code copied from CPC Engine
000C6Dr 3  A0 08        	ldy #var_newY
000C6Fr 3  B1 rr        	lda (z80_ix), y		; old x coord
000C71r 3  C9 A1        	cmp #SpriteMaxY     	; beyond maximum?
000C73r 3  B0 F2        	bcs dspr6		; yes, don't display it.
000C75r 3               
000C75r 3  A0 04        	ldy #var_X
000C77r 3  B1 rr        	lda (z80_ix),y		; old x.
000C79r 3  A0 09        	ldy #var_newX
000C7Br 3  D1 rr        	cmp (z80_ix),y 		; compare with new value.
000C7Dr 3  D0 21        	bne dspr7 		; they differ, need to redraw.
000C7Fr 3               
000C7Fr 3  A0 03        	ldy #var_Y
000C81r 3  B1 rr        	lda (z80_ix),y		; old y.
000C83r 3  A0 08        	ldy #var_newY
000C85r 3  D1 rr        	cmp (z80_ix),y 		; compare against new value.
000C87r 3  D0 17        	bne dspr7		; they differ, need to redraw.
000C89r 3               
000C89r 3  A0 02        	ldy #var_Frame
000C8Br 3  B1 rr        	lda (z80_ix),y 		; old frame.
000C8Dr 3  A0 07        	ldy #var_newFrame
000C8Fr 3  D1 rr        	cmp (z80_ix),y 		; compare against new value.
000C91r 3  D0 0D        	bne dspr7 		; they differ, need to redraw.
000C93r 3               
000C93r 3  A0 01        	ldy #var_Image
000C95r 3  B1 rr        	lda (z80_ix),y 		; old image.
000C97r 3  A0 06        	ldy #var_newImage
000C99r 3  D1 rr        	cmp (z80_ix),y 		; compare against new value.
000C9Br 3  D0 03        	bne dspr7 		; they differ, need to redraw.
000C9Dr 3  4C rr rr     	jmp dspr2		; everything is the same, don't redraw.
000CA0r 3               dspr7:
000CA0r 3  20 rr rr     	jsr sspric 		; delete old sprite, draw new one simultaneously.
000CA3r 3  4C rr rr     	jmp dspr2
000CA6r 3               dspr3:
000CA6r 3               	; _BEEB clipping code copied from CPC Engine
000CA6r 3  A0 08        	ldy #var_newY
000CA8r 3  B1 rr        	lda (z80_ix), y		; old x coord
000CAAr 3  C9 A1        	cmp #SpriteMaxY     	; beyond maximum?
000CACr 3  90 03        	bcc :+			; no, continue
000CAEr 3  4C rr rr     	jmp dspr2		; yes, don't display it.
000CB1r 3               :
000CB1r 3  20 rr rr     	jsr ssprib 		; show single sprite.
000CB4r 3  4C rr rr     	jmp dspr2
000CB7r 3               
000CB7r 3               ;-----------------------------------------
000CB7r 3               ; Get sprite address calculations.
000CB7r 3               ; gspran = new sprite, gsprad = old sprite.
000CB7r 3               ;
000CB7r 3               ; Input:
000CB7r 3               ;  IX = sprite address
000CB7r 3               ;-----------------------------------------
000CB7r 3               
000CB7r 3               gspran:
000CB7r 3  A0 08        	ldy #var_newY
000CB9r 3  B1 rr        	lda (z80_ix),y 		; new y coordinate.
000CBBr 3  85 rr        	sta dispy
000CBDr 3  A0 09        	ldy #var_newX
000CBFr 3  B1 rr        	lda (z80_ix),y 		; new x coordinate.
000CC1r 3  85 rr        	sta dispx
000CC3r 3  A0 06        	ldy #var_newImage
000CC5r 3  B1 rr        	lda (z80_ix),y 		; new sprite image.
000CC7r 3  20 rr rr     	jsr gfrm		; fetch start frame for this sprite.
000CCAr 3               
000CCAr 3  A0 00        	ldy #0
000CCCr 3  B1 rr        	lda (z80_hl),y 		; frame in accumulator.
000CCEr 3  A0 07        	ldy #var_newFrame
000CD0r 3  18           	clc
000CD1r 3  71 rr        	adc (z80_ix),y 		; new add frame number.
000CD3r 3  4C rr rr     	jmp gspra0
000CD6r 3               
000CD6r 3               ;-----------------------------------------
000CD6r 3               ; Calculate old sprite address
000CD6r 3               ;
000CD6r 3               ; Input:
000CD6r 3               ;  IX = sprite address
000CD6r 3               ;
000CD6r 3               ; Output:
000CD6r 3               ;  B  = right byte mask
000CD6r 3               ;  C  = left byte mask
000CD6r 3               ;  DE = spriteframe address
000CD6r 3               ;  scraddr = screenaddress(dispx,dispy)
000CD6r 3               ;-----------------------------------------
000CD6r 3               
000CD6r 3               gsprad:
000CD6r 3  A0 03        	ldy #var_Y
000CD8r 3  B1 rr        	lda (z80_ix),y		; y coordinate.
000CDAr 3  85 rr        	sta dispy
000CDCr 3  A0 04        	ldy #var_X
000CDEr 3  B1 rr        	lda (z80_ix),y		; x coordinate.
000CE0r 3  85 rr        	sta dispx
000CE2r 3  A0 01        	ldy #var_Image
000CE4r 3  B1 rr        	lda (z80_ix),y 		; sprite image.
000CE6r 3  20 rr rr     	jsr gfrm 		; fetch start frame for this sprite.
000CE9r 3               
000CE9r 3  A0 00        	ldy #0
000CEBr 3  B1 rr        	lda (z80_hl),y 		; frame in accumulator.
000CEDr 3  A0 02        	ldy #var_Frame
000CEFr 3  18           	clc
000CF0r 3  71 rr        	adc (z80_ix),y 		; add frame number.
000CF2r 3               
000CF2r 3               gspra0:
000CF2r 3               .if rflag
000CF2r 3               	sta z80_e		; multiply by 32.
000CF2r 3               	lda #0
000CF2r 3               	sta z80_d
000CF2r 3               
000CF2r 3               	asl z80_e
000CF2r 3               	rol z80_d
000CF2r 3               	asl z80_e
000CF2r 3               	rol z80_d
000CF2r 3               	asl z80_e
000CF2r 3               	rol z80_d
000CF2r 3               	asl z80_e
000CF2r 3               	rol z80_d
000CF2r 3               .if bflag
000CF2r 3               	lda z80_e		; multiply by 48
000CF2r 3               	sta tmp1
000CF2r 3               	lda z80_d
000CF2r 3               	sta tmp2
000CF2r 3               .endif
000CF2r 3               	asl z80_e
000CF2r 3               	rol z80_d
000CF2r 3               .if bflag
000CF2r 3               	clc
000CF2r 3               	lda z80_e
000CF2r 3               	adc tmp1
000CF2r 3               	sta z80_e
000CF2r 3               	lda z80_d
000CF2r 3               	adc tmp2
000CF2r 3               	sta z80_d
000CF2r 3               .endif
000CF2r 3               .else
000CF2r 3  4A           	lsr a	  		; multiply by 128.
000CF3r 3  85 rr        	sta z80_d 		; store in d.
000CF5r 3  85 rr        	sta tmp1
000CF7r 3  A9 00        	lda #0
000CF9r 3  6A           	ror a
000CFAr 3  85 rr        	sta z80_e 		; got low byte.
000CFCr 3  85 rr        	sta tmp2
000CFEr 3               .if bflag
000CFEr 3  46 rr        	lsr tmp1		; multiply by 192
000D00r 3  66 rr        	ror tmp2
000D02r 3  18           	clc
000D03r 3  A5 rr        	lda tmp2
000D05r 3  65 rr        	adc z80_e
000D07r 3  85 rr        	sta z80_e
000D09r 3  A5 rr        	lda tmp1
000D0Br 3  65 rr        	adc z80_d
000D0Dr 3  85 rr        	sta z80_d
000D0Fr 3               .endif
000D0Fr 3               .endif
000D0Fr 3  18           	clc 			; address of play sprites.
000D10r 3  A5 rr        	lda z80_e
000D12r 3  69 rr        	adc #<sprgfx
000D14r 3  85 rr        	sta z80_e
000D16r 3  A5 rr        	lda z80_d
000D18r 3  69 rr        	adc #>sprgfx
000D1Ar 3  85 rr        	sta z80_d
000D1Cr 3               
000D1Cr 3  A5 rr        	lda dispx 		; y coordinate.
000D1Er 3  29 06        	and #6 			; position within byte boundary.
000D20r 3  AA           	tax	 		; low byte of table displacement.
000D21r 3               .if rflag
000D21r 3               	stx sprshft
000D21r 3               .else
000D21r 3  0A           	asl a	  		; multiply by 32.
000D22r 3  0A           	asl a  			; already a multiple
000D23r 3  0A           	asl a  			; of 2, so just 4
000D24r 3               .if bflag
000D24r 3  85 rr        	sta tmp1
000D26r 3  0A           	asl a  			; shifts needed.
000D27r 3  18           	clc
000D28r 3  65 rr        	adc tmp1
000D2Ar 3               .else
000D2Ar 3               	asl a  			; shifts needed.
000D2Ar 3               .endif
000D2Ar 3  18           	clc 			; add to sprite address.
000D2Br 3  65 rr        	adc z80_e
000D2Dr 3  85 rr        	sta z80_e
000D2Fr 3  90 02        	bcc :+
000D31r 3  E6 rr        	inc z80_d
000D33r 3               :
000D33r 3               .endif
000D33r 3  BD rr rr     	lda spmask,x		 ; pointer to mask table.
000D36r 3  85 rr        	sta z80_c 		; left mask.
000D38r 3  BD rr rr     	lda spmask+1,x
000D3Br 3  85 rr        	sta z80_b 		; right mask.
000D3Dr 3               ; Drop into screen address routine.
000D3Dr 3  4C rr rr     	jmp scadd
000D40r 3               
000D40r 3  FF 00 3F C0  spmask:	.byte 255,0,63,192,15,240,3,252
000D44r 3  0F F0 03 FC  
000D48r 3               
000D48r 3               
000D48r 3               ;-----------------------------------------------------------
000D48r 3               ; Animates a sprite.
000D48r 3               ;
000D48r 3               ; Input:
000D48r 3               ;  IX = sprite address
000D48r 3               ;  HL = last sprite address
000D48r 3               ;-----------------------------------------------------------
000D48r 3               
000D48r 3               animsp:
000D48r 3  25 rr        	and frmno
000D4Ar 3  F0 01        	beq :+
000D4Cr 3  60           	rts
000D4Dr 3               :
000D4Dr 3  A0 06        	ldy #var_newImage
000D4Fr 3  B1 rr        	lda (z80_ix),y		; sprite image
000D51r 3  20 rr rr     	jsr gfrm		; get frame data.
000D54r 3               
000D54r 3  E6 rr        	inc z80_l		; point to frames.
000D56r 3  D0 02        	bne :+
000D58r 3  E6 rr        	inc z80_h
000D5Ar 3               :
000D5Ar 3  A0 07        	ldy #var_newFrame
000D5Cr 3  B1 rr        	lda (z80_ix),y		; sprite frame.
000D5Er 3  18           	clc
000D5Fr 3  69 01        	adc #1			; next one along.
000D61r 3  A0 00        	ldy #0
000D63r 3  D1 rr        	cmp (z80_hl),y		; reached the last frame?
000D65r 3  90 02        	bcc anims0		; no, not yet.
000D67r 3  A9 00        	lda #0			; start at first frame.
000D69r 3               anims0:
000D69r 3  A0 07        	ldy #var_newFrame
000D6Br 3  91 rr        	sta (z80_ix),y		; new frame.
000D6Dr 3  60           	rts
000D6Er 3               
000D6Er 3               ;--------------------------------------------------------------
000D6Er 3               ; Animate back
000D6Er 3               ;
000D6Er 3               ; Input:
000D6Er 3               ;  IX = sprite address
000D6Er 3               ;  HL = last sprite address
000D6Er 3               ;--------------------------------------------------------------
000D6Er 3               
000D6Er 3               animbk:
000D6Er 3  25 rr        	and frmno
000D70r 3  F0 01        	beq :+
000D72r 3  60           	rts
000D73r 3               :
000D73r 3  A0 06        	ldy #var_newImage
000D75r 3  B1 rr        	lda (z80_ix),y		; sprite image.
000D77r 3  20 rr rr     	jsr gfrm		; get frame data.
000D7Ar 3               
000D7Ar 3  E6 rr        	inc z80_l 		; point to frames.
000D7Cr 3  D0 02        	bne :+
000D7Er 3  E6 rr        	inc z80_h
000D80r 3               :
000D80r 3  A0 07        	ldy #var_newFrame
000D82r 3  B1 rr        	lda (z80_ix),y 		; sprite frame.
000D84r 3  F0 03        	beq :+
000D86r 3  4C rr rr     	jmp rtanb0 		; yes, start at end.
000D89r 3               :
000D89r 3  A0 00        	ldy #0
000D8Br 3  B1 rr        	lda (z80_hl),y 		; last sprite.
000D8Dr 3               rtanb0:
000D8Dr 3  38           	sec
000D8Er 3  E9 01        	sbc #1			; next one along.
000D90r 3  4C rr rr     	jmp anims0		; set new frame.
000D93r 3               
000D93r 3               ;--------------------------------------------------------------
000D93r 3               ; Check for collision with other sprite, strict enforcement.
000D93r 3               ;
000D93r 3               ; Input:
000D93r 3               ;  b		= sprite to test for
000D93r 3               ;  ix		= current sprite pointer
000D93r 3               ;
000D93r 3               ; global:	b
000D93r 3               ; local:	x,y,hl,de,skptr
000D93r 3               ; calls:	-
000D93r 3               ;--------------------------------------------------------------
000D93r 3               
000D93r 3               sktyp:
000D93r 3  A9 rr        	lda #<sprtab				; sprite table.
000D95r 3  85 rr        	sta z80_l
000D97r 3  A9 rr        	lda #>sprtab
000D99r 3  85 rr        	sta z80_h
000D9Br 3               numsp2:
000D9Br 3  A9 08        	lda #NUMSPR				; number of sprites.
000D9Dr 3  85 rr        	sta sktptr
000D9Fr 3               sktyp0:
000D9Fr 3  A5 rr        	lda z80_l 				; store pointer to sprite.
000DA1r 3  85 rr        	sta skptr
000DA3r 3  A5 rr        	lda z80_h
000DA5r 3  85 rr        	sta skptr+1
000DA7r 3               
000DA7r 3  A0 00        	ldy #0
000DA9r 3  B1 rr        	lda (z80_hl),y 				; get sprite type.
000DABr 3  C5 rr        	cmp z80_b				; is it the type we seek?
000DADr 3  F0 1D        	beq coltyp				; yes, we can use this one.
000DAFr 3               sktyp1:
000DAFr 3  18           	clc
000DB0r 3  A5 rr        	lda skptr				; retrieve sprite pointer.
000DB2r 3  69 11        	adc #TABSIZ				; size of each entry.
000DB4r 3  85 rr        	sta z80_l
000DB6r 3  A5 rr        	lda skptr+1
000DB8r 3  69 00        	adc #0
000DBAr 3  85 rr        	sta z80_h
000DBCr 3  C6 rr        	dec sktptr					; one less iteration.
000DBEr 3  D0 DF        	bne sktyp0				; keep going until we find a slot.
000DC0r 3  A9 00        	lda #0					; default to ROM address - no sprite.
000DC2r 3  85 rr        	sta z80_l
000DC4r 3  85 rr        	sta z80_h
000DC6r 3  85 rr        	sta skptr				; store pointer to sprite.
000DC8r 3  85 rr        	sta skptr+1
000DCAr 3               
000DCAr 3  18           	clc					; don't return with zero flag set.
000DCBr 3  60           	rts 					; didn't find one.
000DCCr 3               
000DCCr 3               coltyp:
000DCCr 3  A0 00        	ldy #0
000DCEr 3  B1 rr        	lda (z80_ix),y				; current sprite type.
000DD0r 3  C5 rr        	cmp z80_b				; seeking sprite of same type?
000DD2r 3  F0 3D        	beq colty1				; yes, need to check we're not detecting ourselves.
000DD4r 3               colty0:
000DD4r 3  A0 09        	ldy #9					; distance to x position in table.
000DD6r 3  B1 rr        	lda (z80_hl),y				; fetch x coordinate.
000DD8r 3  85 rr        	sta z80_e
000DDAr 3  88           	dey
000DDBr 3  B1 rr        	lda (z80_hl),y				; fetch y coordinate.
000DDDr 3  85 rr        	sta z80_d
000DDFr 3               
000DDFr 3               ; Drop into collision detection.
000DDFr 3               
000DDFr 3               colc16:
000DDFr 3  A0 09        	ldy #9
000DE1r 3  B1 rr        	lda (z80_ix),y			 	; x coord.
000DE3r 3  38           	sec					; subtract x.
000DE4r 3  E5 rr        	sbc z80_e
000DE6r 3  B0 05        	bcs  colc1a 				; result is positive.
000DE8r 3  49 FF        	eor #$ff				; make negative positive.
000DEAr 3  18           	clc
000DEBr 3  69 01        	adc #1
000DEDr 3               colc1a:
000DEDr 3  C9 10        	cmp #16 				; within x range?
000DEFr 3  B0 BE        	bcs sktyp1				; no - they"ve missed.
000DF1r 3  85 rr        	sta z80_c				; store difference.
000DF3r 3               
000DF3r 3  A0 08        	ldy #8
000DF5r 3  B1 rr        	lda (z80_ix),y				; y coord.
000DF7r 3  38           	sec
000DF8r 3  E5 rr        	sbc z80_d				; subtract y.
000DFAr 3  B0 05        	bcs colc1b				; result is positive.
000DFCr 3  49 FF        	eor #$ff				; make negative positive.
000DFEr 3  18           	clc
000DFFr 3  69 01        	adc #1
000E01r 3               colc1b:
000E01r 3  C9 10        	cmp #16					; within y range?
000E03r 3  B0 AA        	bcs sktyp1 				; no - they've missed.
000E05r 3  18           	clc					; add x difference.
000E06r 3  65 rr        	adc z80_c
000E08r 3  C9 1A        	cmp #26					; only 5 corner pixels touching?
000E0Ar 3  B0 02        	bcs :+
000E0Cr 3  38           	sec
000E0Dr 3  60           	rts 					; carry set if there's a collision.
000E0Er 3               :
000E0Er 3  4C rr rr     	jmp sktyp1				; try next sprite in table.
000E11r 3               colty1:
000E11r 3  A5 rr        	lda z80_x  				; compare the two.
000E13r 3  C5 rr        	cmp z80_l
000E15r 3  D0 09        	bne end_col
000E17r 3  A5 rr        	lda z80_i
000E19r 3  C5 rr        	cmp z80_h
000E1Br 3  D0 03        	bne end_col
000E1Dr 3  4C rr rr     	jmp sktyp1 				; addresses are identical.
000E20r 3               end_col:
000E20r 3  4C rr rr     	jmp colty0
000E23r 3               
000E23r 3               ;-----------------------------------------------------------
000E23r 3               ; Display number, left aligned
000E23r 3               ;
000E23r 3               ; Input:
000E23r 3               ;  a		= number
000E23r 3               ;
000E23r 3               ; global:	-
000E23r 3               ; local:	a,y,bc,hl,displ0
000E23r 3               ; calls:	num2ch,dmsg3
000E23r 3               ;-----------------------------------------------------------
000E23r 3               
000E23r 3               disply:
000E23r 3  85 rr        	sta z80_a
000E25r 3  A9 rr        	lda #<displ0				; display workspace.
000E27r 3  85 rr        	sta z80_c
000E29r 3  A9 rr        	lda #>displ0
000E2Br 3  85 rr        	sta z80_b
000E2Dr 3  A5 rr        	lda z80_a
000E2Fr 3  20 rr rr     	jsr num2ch				; convert accumulator to string.
000E32r 3               displ1:
000E32r 3  C6 rr        	dec z80_c				; back one character.
000E34r 3  D0 02        	bne :+
000E36r 3  C6 rr        	dec z80_b
000E38r 3               :
000E38r 3  A0 00        	ldy #0
000E3Ar 3  B1 rr        	lda (z80_bc),y				; fetch digit.
000E3Cr 3  09 80        	ora #128				; insert end marker.
000E3Er 3  91 rr        	sta (z80_bc),y				; new value.
000E40r 3               
000E40r 3  A9 rr        	lda #<displ0				; display space.
000E42r 3  85 rr        	sta z80_l
000E44r 3  A9 rr        	lda #>displ0
000E46r 3  85 rr        	sta z80_h
000E48r 3  4C rr rr     	jmp dmsg3				; display the string.
000E4Br 3               
000E4Br 3  00 00 00 8D  displ0:	.byte 0,0,0,13+128
000E4Fr 3               
000E4Fr 3               ;----------------------------------------------------------------
000E4Fr 3               ; Initialise screen.
000E4Fr 3               ;
000E4Fr 3               ; global:	roomtb,scno
000E4Fr 3               ; local:	-
000E4Fr 3               ; calls:	tstcs
000E4Fr 3               ;----------------------------------------------------------------
000E4Fr 3               
000E4Fr 3               initsc:
000E4Fr 3  AD rr rr     	lda roomtb 			; whereabouts in the map are we?
000E52r 3  20 rr rr     	jsr tstsc 			; find displacement.
000E55r 3  C9 FF        	cmp #255 			; is it valid?
000E57r 3  F0 02        	beq init_end 			; no, it's rubbish.
000E59r 3  85 rr        	sta scno			; store new room number.
000E5Br 3               init_end:
000E5Br 3  60           	rts
000E5Cr 3               
000E5Cr 3               ;----------------------------------------------------------------
000E5Cr 3               ; Test screen.
000E5Cr 3               ;
000E5Cr 3               ; global:	-
000E5Cr 3               ; local:	x
000E5Cr 3               ; calls:	-
000E5Cr 3               ;----------------------------------------------------------------
000E5Cr 3               
000E5Cr 3               tstsc:
000E5Cr 3  85 rr        	sta tmproom
000E5Er 3  18           	clc
000E5Fr 3  69 03        	adc #MAPWID 			; add width in case we"re negative.
000E61r 3  AA           	tax 				; add displacement to map data.
000E62r 3  BD rr rr     	lda mapdat-MAPWID,x 		; find room number there.
000E65r 3  60           	rts
000E66r 3               
000E66r 3               ;--------------------------
000E66r 3               ; Screen left.
000E66r 3               ;--------------------------
000E66r 3               
000E66r 3               scrl:
000E66r 3  AD rr rr     	lda roomtb 			; present room table pointer.
000E69r 3  38           	sec
000E6Ar 3  E9 01        	sbc #1				; room left.
000E6Cr 3               scrl0:
000E6Cr 3  20 rr rr     	jsr tstsc			; test screen.
000E6Fr 3  C9 FF        	cmp #255			; is there a screen this way?
000E71r 3  D0 01        	bne :+
000E73r 3  60           	rts				; no, return to loop.
000E74r 3               :
000E74r 3  A5 rr        	lda tmproom			; restore room displacement.
000E76r 3  8D rr rr     	sta roomtb			; new room table position.
000E79r 3               scrl1:
000E79r 3  20 rr rr     	jsr initsc 			; set new screen.
000E7Cr 3  A9 02        	lda #2
000E7Er 3  85 rr        	sta restfl 			; set it.
000E80r 3  60           	rts
000E81r 3               scrr:
000E81r 3  AD rr rr     	lda roomtb 			; room table pointer.
000E84r 3  18           	clc
000E85r 3  69 01        	adc #1				; room right.
000E87r 3  4C rr rr     	jmp scrl0
000E8Ar 3               scru:
000E8Ar 3  AD rr rr     	lda roomtb 			; room table pointer.
000E8Dr 3  38           	sec
000E8Er 3  E9 03        	sbc #MAPWID 			; room up.
000E90r 3  4C rr rr     	jmp scrl0
000E93r 3               scrd:
000E93r 3  AD rr rr     	lda roomtb 			; room table pointer.
000E96r 3  18           	clc
000E97r 3  69 03        	adc #MAPWID 			; room down.
000E99r 3  4C rr rr     	jmp scrl0
000E9Cr 3               
000E9Cr 3               ;-----------------------------------------
000E9Cr 3               ; Jump to new screen.
000E9Cr 3               ;-----------------------------------------
000E9Cr 3               
000E9Cr 3               nwscr:
000E9Cr 3  A2 00        	ldx #0				; start of map data.
000E9Er 3               nwscr0:
000E9Er 3  DD rr rr     	cmp mapdat,x
000EA1r 3  F0 06        	beq nwscr1			; have we found a match for screen?
000EA3r 3  E8           	inx 				; next room.
000EA4r 3  E0 50        	cpx #80				; zero room count, 80 to search.
000EA6r 3  D0 F6        	bne nwscr0			; keep looking.
000EA8r 3  60           	rts
000EA9r 3               nwscr1:
000EA9r 3  8E rr rr     	stx roomtb			; set the map position.
000EACr 3  4C rr rr     	jmp scrl1			; draw new room.
000EAFr 3               
000EAFr 3               
000EAFr 3               ;----------------------------------------------------------
000EAFr 3               ; Gravity processing.
000EAFr 3               ;----------------------------------------------------------
000EAFr 3               
000EAFr 3               grav:
000EAFr 3  A0 0D        	ldy #13
000EB1r 3  B1 rr        	lda (z80_ix),y			; jump pointer low.
000EB3r 3  85 rr        	sta z80_l
000EB5r 3  A0 0E        	ldy #14
000EB7r 3  B1 rr        	lda (z80_ix),y			; jump pointer high.
000EB9r 3  85 rr        	sta z80_h
000EBBr 3  05 rr        	ora z80_l			; merge in low byte.
000EBDr 3  D0 01        	bne :+
000EBFr 3  60           	rts				; if neither is set, we're not in the air.
000EC0r 3               :
000EC0r 3  A0 00        	ldy #0
000EC2r 3  B1 rr        	lda (z80_hl),y			; pixels to move.
000EC4r 3  85 rr        	sta z80_a
000EC6r 3  C9 63        	cmp #99				; reached the end?
000EC8r 3  D0 0C        	bne grav0			; no, continue.
000ECAr 3               grav2:
000ECAr 3  C6 rr        	dec z80_l			; go back to previous value.
000ECCr 3  C9 FF        	cmp #$ff
000ECEr 3  D0 02        	bne :+
000ED0r 3  C6 rr        	dec z80_h
000ED2r 3               :
000ED2r 3  B1 rr        	lda (z80_hl),y			; fetch that from table.
000ED4r 3  85 rr        	sta z80_a
000ED6r 3               grav0:
000ED6r 3  E6 rr        	inc z80_l			; point to next table entry.
000ED8r 3  D0 02        	bne :+
000EDAr 3  E6 rr        	inc z80_h
000EDCr 3               :
000EDCr 3  A5 rr        	lda z80_l
000EDEr 3  A0 0D        	ldy #13
000EE0r 3  91 rr        	sta (z80_ix),y			; store new pointer low.
000EE2r 3  A5 rr        	lda z80_h
000EE4r 3  A0 0E        	ldy #14
000EE6r 3  91 rr        	sta (z80_ix),y			; store new pointer high.
000EE8r 3               grav1:
000EE8r 3  A5 rr        	lda z80_a
000EEAr 3  D0 01        	bne :+				; any movement required?
000EECr 3  60           	rts				; no, not this time.
000EEDr 3               :
000EEDr 3  A5 rr        	lda z80_a
000EEFr 3  C9 80        	cmp #128			; is it up or down?
000EF1r 3  B0 15        	bcs gravu			; it's up.
000EF3r 3               gravd:
000EF3r 3  85 rr        	sta z80_b			; set pixels to move.
000EF5r 3               gravd0:
000EF5r 3  20 rr rr     	jsr cangd			; can we go down?
000EF8r 3  D0 28        	bne gravst			; can't move down, so stop.
000EFAr 3  A0 08        	ldy #8
000EFCr 3  B1 rr        	lda (z80_ix),y			; adjust new x coord.
000EFEr 3  18           	clc
000EFFr 3  69 01        	adc #1
000F01r 3  91 rr        	sta (z80_ix),y
000F03r 3  C6 rr        	dec z80_b
000F05r 3  D0 EE        	bne gravd0
000F07r 3  60           	rts
000F08r 3               gravu:
000F08r 3  49 FF        	eor #$ff			; flip the sign so it's positive.
000F0Ar 3  18           	clc
000F0Br 3  69 01        	adc #1
000F0Dr 3  85 rr        	sta z80_b			; set pixels to move.
000F0Fr 3               gravu0:
000F0Fr 3  20 rr rr     	jsr cangu			; can we go up?
000F12r 3  D0 6E        	bne ifalls			; can't move up, go down next.
000F14r 3  A0 08        	ldy #8
000F16r 3  B1 rr        	lda (z80_ix),y
000F18r 3  38           	sec
000F19r 3  E9 01        	sbc #1
000F1Br 3  91 rr        	sta (z80_ix),y			; adjust new x coord.
000F1Dr 3  C6 rr        	dec z80_b
000F1Fr 3  D0 EE        	bne gravu0
000F21r 3  60           	rts
000F22r 3               gravst:
000F22r 3  A0 0D        	ldy #var_jumpLo
000F24r 3  B1 rr        	lda (z80_ix),y			; jump pointer low.
000F26r 3  85 rr        	sta z80_l
000F28r 3  A0 0E        	ldy #var_jumpHi
000F2Ar 3  B1 rr        	lda (z80_ix),y			; jump pointer high.
000F2Cr 3  85 rr        	sta z80_h
000F2Er 3               
000F2Er 3  A9 00        	lda #0				; null value in pointer.
000F30r 3  A0 0D        	ldy #var_jumpLo
000F32r 3  91 rr        	sta (z80_ix),y			; store new pointer low.
000F34r 3  C8           	iny
000F35r 3  91 rr        	sta (z80_ix),y			; store new pointer high.
000F37r 3               
000F37r 3  A0 00        	ldy #0
000F39r 3  B1 rr        	lda (z80_hl),y			; fetch byte from table.
000F3Br 3  C9 63        	cmp #99				; is it the end marker?
000F3Dr 3               evftf:
000F3Dr 3  F0 01        	beq :+				; yes, fallen too far.
000F3Fr 3  60           	rts
000F40r 3               :
000F40r 3  4C rr rr     	jmp evnt15			; EVENT FELLTOOFAR
000F43r 3               
000F43r 3               ;------------------------------------------------
000F43r 3               ; Initiate fall check.
000F43r 3               ;------------------------------------------------
000F43r 3               
000F43r 3               ifall:
000F43r 3  A0 0D        	ldy #var_jumpLo
000F45r 3  B1 rr        	lda (z80_ix),y 			; jump pointer low.
000F47r 3  85 rr        	sta z80_l
000F49r 3  A0 0E        	ldy #var_jumpHi
000F4Br 3  B1 rr        	lda (z80_ix),y 			; jump pointer high.
000F4Dr 3  85 rr        	sta z80_h			; high byte in accumulator.
000F4Fr 3  05 rr        	ora z80_l			; merge in low byte.
000F51r 3  F0 01        	beq :+
000F53r 3  60           	rts				; if either is set, we're already in the air.
000F54r 3               :
000F54r 3  A0 09        	ldy #9
000F56r 3  B1 rr        	lda (z80_ix),y			; y coordinate.
000F58r 3  85 rr        	sta dispx
000F5Ar 3  A0 08        	ldy #8
000F5Cr 3  B1 rr        	lda (z80_ix),y			; look x coordinate.
000F5Er 3  18           	clc
000F5Fr 3               numsp7:
000F5Fr 3  69 18        	adc #SPR_HGT			; add 16 pixels.
000F61r 3  85 rr        	sta dispy			; set up test coordinates.
000F63r 3  20 rr rr     	jsr tstbl			; get map address.
000F66r 3  20 rr rr     	jsr plchk			; block, platform check.
000F69r 3  F0 01        	beq :+
000F6Br 3  60           	rts				; it's solid, don't fall.
000F6Cr 3               :
000F6Cr 3  E6 rr        	inc bufaddr			; look right one cell.
000F6Er 3  20 rr rr     	jsr plchk			; block, platform check.
000F71r 3  F0 01        	beq :+
000F73r 3  60           	rts				; it's solid, don't fall.
000F74r 3               :
000F74r 3  A5 rr        	lda dispx			; y coordinate.
000F76r 3  29 07        	and #7				; position straddling block cells.
000F78r 3  F0 08        	beq ifalls			; no more checks needed.
000F7Ar 3  E6 rr        	inc bufaddr			; look to third cell.
000F7Cr 3  20 rr rr     	jsr plchk			; block, platform check.
000F7Fr 3  F0 01        	beq :+
000F81r 3  60           	rts				; it's solid, don't fall.
000F82r 3               :
000F82r 3               ifalls:
000F82r 3  A9 rr        	lda #<jtab			; jump table start.
000F84r 3  85 rr        	sta z80_l
000F86r 3  A9 rr        	lda #>jtab
000F88r 3  85 rr        	sta z80_h
000F8Ar 3               ifal0:
000F8Ar 3  E6 rr        	inc z80_l			; point to next value.
000F8Cr 3  D0 02        	bne :+
000F8Er 3  E6 rr        	inc z80_h
000F90r 3               :
000F90r 3  A0 00        	ldy #0
000F92r 3  B1 rr        	lda (z80_hl),y			; fetch value.
000F94r 3  F0 F4        	beq ifal0			; no, get next value.
000F96r 3  C9 63        	cmp #99				; reached end of table?
000F98r 3  D0 01        	bne :+
000F9Ar 3  60           	rts				; yes, don't fall.
000F9Br 3               :
000F9Br 3  C9 80        	cmp #128			; is it going up?
000F9Dr 3  B0 EB        	bcs ifal0			; yes, looking for first movement down.
000F9Fr 3               
000F9Fr 3  A0 0D        	ldy #13
000FA1r 3  A5 rr        	lda z80_l
000FA3r 3  91 rr        	sta (z80_ix),y 			; set jump low.
000FA5r 3  A0 0E        	ldy #14
000FA7r 3  A5 rr        	lda z80_h
000FA9r 3  91 rr        	sta (z80_ix),y 			; set jump high.
000FABr 3  60           	rts
000FACr 3               
000FACr 3               
000FACr 3               ;----------------------------------------------------
000FACr 3               ; Get frame data for a particular sprite.
000FACr 3               ; Input:
000FACr 3               ;  a		= framenumer
000FACr 3               ; Output:
000FACr 3               ;  hl		= frame address
000FACr 3               ;
000FACr 3               ; global:	hl,frmptr
000FACr 3               ; local:	-
000FACr 3               ; calls:	-
000FACr 3               ;----------------------------------------------------
000FACr 3               
000FACr 3               gfrm:
000FACr 3  0A           	asl a	 		 	; multiple of 2.
000FADr 3  18           	clc
000FAEr 3  6D rr rr     	adc frmptr 			; frames used by game.
000FB1r 3  85 rr        	sta z80_l
000FB3r 3  AD rr rr     	lda frmptr+1
000FB6r 3  69 00        	adc #0
000FB8r 3  85 rr        	sta z80_h 			; point to frame start.
000FBAr 3  60           	rts
000FBBr 3               
000FBBr 3               ;----------------------------------------------------
000FBBr 3               ; Find sprite list for current room.
000FBBr 3               ;
000FBBr 3               ; global:	hl
000FBBr 3               ; local:	x,y
000FBBr 3               ; calls:	-
000FBBr 3               ;----------------------------------------------------
000FBBr 3               
000FBBr 3               sprlst:
000FBBr 3  A9 rr        	lda #<nmedat 			; list of enemy sprites.
000FBDr 3  85 rr        	sta z80_l
000FBFr 3  A9 rr        	lda #>nmedat
000FC1r 3  85 rr        	sta z80_h
000FC3r 3  A6 rr        	ldx scno 			; screen number.
000FC5r 3  D0 01        	bne sprls2 			; is it the first screen?
000FC7r 3  60           	rts 				; yes, don't need to search data.
000FC8r 3               sprls2:
000FC8r 3  A0 00        	ldy #0
000FCAr 3               sprls1:
000FCAr 3  B1 rr        	lda (z80_hl),y 			; fetch type of sprite.
000FCCr 3  C9 FF        	cmp #255			; is it an end marker?
000FCEr 3  F0 0E        	beq sprls0 			; yes, end of this room.
000FD0r 3               
000FD0r 3  18           	clc 				; point to next sprite in list.
000FD1r 3  A5 rr        	lda z80_l
000FD3r 3  69 04        	adc #NMESIZ
000FD5r 3  85 rr        	sta z80_l
000FD7r 3  90 02        	bcc :+
000FD9r 3  E6 rr        	inc z80_h
000FDBr 3               :
000FDBr 3  4C rr rr     	jmp sprls1 			; continue until end of room.
000FDEr 3               sprls0:
000FDEr 3  E6 rr        	inc z80_l 			; point to start of next screen.s
000FE0r 3  D0 02        	bne :+
000FE2r 3  E6 rr        	inc z80_h
000FE4r 3               :
000FE4r 3  CA           	dex
000FE5r 3  D0 E3        	bne sprls1 			; continue until room found.
000FE7r 3  60           	rts
000FE8r 3               
000FE8r 3               
000FE8r 3               ;----------------------------------------------------
000FE8r 3               ; Clear all but a single player sprite.
000FE8r 3               ;
000FE8r 3               ; global:	-
000FE8r 3               ; local:	x,y,ix
000FE8r 3               ; calls:	-
000FE8r 3               ;----------------------------------------------------
000FE8r 3               
000FE8r 3               nspr:
000FE8r 3  A9 08        	lda #NUMSPR			; sprite slots in table.
000FEAr 3  85 rr        	sta sprcnt
000FECr 3  A9 rr        	lda #<sprtab 			; sprite table.
000FEEr 3  85 rr        	sta z80_x
000FF0r 3  A9 rr        	lda #>sprtab
000FF2r 3  85 rr        	sta z80_i
000FF4r 3               nspr0:
000FF4r 3  A0 00        	ldy #0 				; fetch sprite type.
000FF6r 3  B1 rr        	lda (z80_ix),y 			; is it a player?
000FF8r 3  F0 1A        	beq nspr1 			; yes, keep this one.
000FFAr 3               
000FFAr 3  A9 FF        	lda #255
000FFCr 3  A0 00        	ldy #0 				; fetch sprite type.
000FFEr 3  91 rr        	sta (z80_ix),y 			; delete sprite.
001000r 3  A0 05        	ldy #5
001002r 3  91 rr        	sta (z80_ix),y 			; remove next type.
001004r 3               
001004r 3  18           	clc	 			; next sprite.
001005r 3  A5 rr        	lda z80_x
001007r 3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
001009r 3  85 rr        	sta z80_x
00100Br 3  90 02        	bcc :+
00100Dr 3  E6 rr        	inc z80_i
00100Fr 3               :
00100Fr 3  C6 rr        	dec sprcnt	 			; one less space in the table.
001011r 3  D0 E1        	bne nspr0
001013r 3  60           	rts
001014r 3               nspr1:
001014r 3  A9 FF        	lda #255
001016r 3  A0 00        	ldy #0
001018r 3  91 rr        	sta (z80_ix),y 			; delete sprite.
00101Ar 3               
00101Ar 3  18           	clc	 			; point to next sprite.
00101Br 3  A5 rr        	lda z80_x
00101Dr 3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
00101Fr 3  85 rr        	sta z80_x
001021r 3  90 02        	bcc :+
001023r 3  E6 rr        	inc z80_i
001025r 3               :
001025r 3  C6 rr        	dec sprcnt	 			; one less to do.
001027r 3  D0 01        	bne nspr2
001029r 3  60           	rts
00102Ar 3               nspr2:
00102Ar 3  A9 FF        	lda #255
00102Cr 3  A0 00        	ldy #0
00102Er 3  91 rr        	sta (z80_ix),y 			; delete sprite.
001030r 3  A0 05        	ldy #5
001032r 3  91 rr        	sta (z80_ix),y 			; remove next type.
001034r 3               
001034r 3  18           	clc	 			; next sprite.
001035r 3  A5 rr        	lda z80_x
001037r 3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
001039r 3  85 rr        	sta z80_x
00103Br 3  90 02        	bcc :+
00103Dr 3  E6 rr        	inc z80_i
00103Fr 3               :
00103Fr 3  C6 rr        	dec sprcnt	 			; one less space in table.
001041r 3  D0 E7        	bne nspr2
001043r 3  60           	rts
001044r 3               
001044r 3               ;----------------------------------------------------------
001044r 3               ; Two initialisation routines.
001044r 3               ; Initialise sprites - copy everything from list to table.
001044r 3               ;
001044r 3               ; global:	-
001044r 3               ; local:	x,y,ix
001044r 3               ; calls:	cpsp
001044r 3               ;----------------------------------------------------------
001044r 3               
001044r 3               ispr:
001044r 3  A9 08        	lda #NUMSPR			; sprite slots in table.
001046r 3  85 rr        	sta sprcnt
001048r 3  A9 rr        	lda #<sprtab			; sprite table.
00104Ar 3  85 rr        	sta z80_x
00104Cr 3  A9 rr        	lda #>sprtab
00104Er 3  85 rr        	sta z80_i
001050r 3               ispr2:
001050r 3  A0 00        	ldy #0
001052r 3  B1 rr        	lda (z80_hl),y 			; fetch byte.
001054r 3  C9 FF        	cmp #255 			; is it an end marker?
001056r 3  D0 01        	bne :+
001058r 3  60           	rts 				; yes, no more to do.
001059r 3               :
001059r 3               ispr1:
001059r 3  A0 00        	ldy #0
00105Br 3  B1 rr        	lda (z80_ix),y 			; fetch sprite type.
00105Dr 3  C9 FF        	cmp #255 			; is it enabled yet?
00105Fr 3  D0 08        	bne ispr4			; yes, try another slot.
001061r 3               
001061r 3  A0 05        	ldy #5
001063r 3  B1 rr        	lda (z80_ix),y		 	; next type.
001065r 3  C9 FF        	cmp #255 			; is it enabled yet?
001067r 3  F0 10        	beq ispr3 			; no, process this one.
001069r 3               ispr4:
001069r 3  18           	clc 				; next sprite.
00106Ar 3  A5 rr        	lda z80_x
00106Cr 3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
00106Er 3  85 rr        	sta z80_x
001070r 3  90 02        	bcc :+
001072r 3  E6 rr        	inc z80_i
001074r 3               :
001074r 3  C6 rr        	dec sprcnt
001076r 3  D0 E1        	bne ispr1 			; repeat for remaining sprites.
001078r 3  60           	rts  				; no more room in table.
001079r 3               ispr3:
001079r 3  20 rr rr     	jsr cpsp			; initialise a sprite.
00107Cr 3  C6 rr        	dec sprcnt			; one less space in the table.
00107Er 3  D0 D0        	bne ispr2
001080r 3  60           	rts
001081r 3               
001081r 3               
001081r 3               ;-----------------------------------------------------------------------
001081r 3               ; Initialise sprites - but not player, we're keeping the old one.
001081r 3               ;
001081r 3               ; global:	-
001081r 3               ; local:	x,y,ix
001081r 3               ; calls:	cpsp
001081r 3               ;-----------------------------------------------------------------------
001081r 3               
001081r 3               kspr:
001081r 3  A2 08        	ldx #NUMSPR			; sprite slots in table.
001083r 3  A9 rr        	lda #<sprtab 			; sprite table.
001085r 3  85 rr        	sta z80_x
001087r 3  A9 rr        	lda #>sprtab
001089r 3  85 rr        	sta z80_i
00108Br 3               kspr2:
00108Br 3  A0 00        	ldy #0
00108Dr 3  B1 rr        	lda (z80_hl),y 			; fetch byte.
00108Fr 3  C9 FF        	cmp #255 			; is it an end marker?
001091r 3  D0 01        	bne :+
001093r 3  60           	rts 				; yes, no more to do.
001094r 3               :
001094r 3  C9 00        	cmp #0
001096r 3  D0 0E        	bne kspr1 			; no, add to table as normal.
001098r 3               
001098r 3  18           	clc 				; next sprite.
001099r 3  A5 rr        	lda z80_l
00109Br 3  69 04        	adc #NMESIZ		 	; distance to next odd/even entry.
00109Dr 3  85 rr        	sta z80_l
00109Fr 3  90 02        	bcc :+
0010A1r 3  E6 rr        	inc z80_h
0010A3r 3               :
0010A3r 3  4C rr rr     	jmp kspr2
0010A6r 3               kspr1:
0010A6r 3  A0 00        	ldy #0 				; fetch sprite type.
0010A8r 3  B1 rr        	lda (z80_ix),y
0010AAr 3  C9 FF        	cmp #255 			; is it enabled yet?
0010ACr 3  D0 08        	bne kspr4 			; yes, try another slot.
0010AEr 3               
0010AEr 3  A0 05        	ldy #5 				; next type.
0010B0r 3  B1 rr        	lda (z80_ix),y
0010B2r 3  C9 FF        	cmp #255 			; is it enabled yet?
0010B4r 3  F0 0F        	beq kspr3 			; no, process this one.
0010B6r 3               kspr4:
0010B6r 3  18           	clc 				; next sprite.
0010B7r 3  A5 rr        	lda z80_x
0010B9r 3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
0010BBr 3  85 rr        	sta z80_x
0010BDr 3  90 02        	bcc :+
0010BFr 3  E6 rr        	inc z80_i
0010C1r 3               :
0010C1r 3  CA           	dex	 			; repeat for remaining sprites.
0010C2r 3  D0 E2        	bne kspr1
0010C4r 3  60           	rts  				; no more room in table.
0010C5r 3               kspr3:
0010C5r 3  20 rr rr     	jsr cpsp 			; copy sprite to table.
0010C8r 3  CA           	dex	 			; one less space in the table.
0010C9r 3  D0 C0        	bne kspr2
0010CBr 3  60           	rts
0010CCr 3               
0010CCr 3               ;----------------------------------------------
0010CCr 3               ; Copy sprite from list to table.
0010CCr 3               ;
0010CCr 3               ; global:	hl,ix
0010CCr 3               ; local:	y
0010CCr 3               ; calls:	evnt09
0010CCr 3               ;----------------------------------------------
0010CCr 3               
0010CCr 3               cpsp:
0010CCr 3  A0 00        	ldy #0					; fetch byte from table.
0010CEr 3  B1 rr        	lda (z80_hl),y
0010D0r 3               	; y=var_Type
0010D0r 3  91 rr        	sta (z80_ix),y			; set up type.
0010D2r 3  A0 05        	ldy #var_newType
0010D4r 3  91 rr        	sta (z80_ix),y 			; set up type.
0010D6r 3               
0010D6r 3  E6 rr        	inc z80_l 				; move to next byte.
0010D8r 3  D0 02        	bne :+
0010DAr 3  E6 rr        	inc z80_h
0010DCr 3               :
0010DCr 3  A0 00        	ldy #0 					; fetch byte from table.
0010DEr 3  B1 rr        	lda (z80_hl),y
0010E0r 3  A0 06        	ldy #var_newImage
0010E2r 3  91 rr        	sta (z80_ix),y			; set up image.
0010E4r 3               
0010E4r 3  E6 rr        	inc z80_l 				; move to next byte.
0010E6r 3  D0 02        	bne :+
0010E8r 3  E6 rr        	inc z80_h
0010EAr 3               :
0010EAr 3  A0 00        	ldy #0
0010ECr 3  B1 rr        	lda (z80_hl),y 			; fetch byte from table.
0010EEr 3  A0 08        	ldy #var_newY
0010F0r 3  91 rr        	sta (z80_ix),y 			; set up coordinate.
0010F2r 3               
0010F2r 3  A9 C8        	lda #200 				; set initial coordinate off screen.
0010F4r 3  A0 03        	ldy #var_Y
0010F6r 3  91 rr        	sta (z80_ix),y
0010F8r 3               
0010F8r 3  E6 rr        	inc z80_l 				; move to next byte.
0010FAr 3  D0 02        	bne :+
0010FCr 3  E6 rr        	inc z80_h
0010FEr 3               :
0010FEr 3  A0 00        	ldy #0 					; fetch byte from table.
001100r 3  B1 rr        	lda (z80_hl),y
001102r 3  A0 09        	ldy #var_newX
001104r 3  91 rr        	sta (z80_ix),y 			; set up coordinate.
001106r 3               
001106r 3  E6 rr        	inc z80_l 				; move to next byte.
001108r 3  D0 02        	bne :+
00110Ar 3  E6 rr        	inc z80_h
00110Cr 3               :
00110Cr 3  A9 00        	lda #0					; zeroes in accumulator.
00110Er 3  A0 07        	ldy #var_newFrame 		; reset frame number.
001110r 3  91 rr        	sta (z80_ix),y
001112r 3  A0 0A        	ldy #var_Direction 		; reset direction.
001114r 3  91 rr        	sta (z80_ix),y
001116r 3  A0 0D        	ldy #var_jumpLo			; reset jump pointer low.
001118r 3  91 rr        	sta (z80_ix),y
00111Ar 3  A0 0E        	ldy #var_jumpHi	 		; reset jump pointer high.
00111Cr 3  91 rr        	sta (z80_ix),y
00111Er 3               
00111Er 3  A9 FF        	lda #255 				; reset data pointer to auto-restore.
001120r 3  A0 10        	ldy #var_dataHi
001122r 3  91 rr        	sta (z80_ix),y
001124r 3               evis0:
001124r 3  A5 rr        	lda z80_i
001126r 3  48           	pha
001127r 3  A5 rr        	lda z80_x
001129r 3  48           	pha
00112Ar 3  A5 rr        	lda z80_h
00112Cr 3  48           	pha
00112Dr 3  A5 rr        	lda z80_l
00112Fr 3  48           	pha
001130r 3               
001130r 3  20 rr rr     	jsr evnt09 				; perform event.
001133r 3               
001133r 3  68           	pla
001134r 3  85 rr        	sta z80_l
001136r 3  68           	pla
001137r 3  85 rr        	sta z80_h
001139r 3  68           	pla
00113Ar 3  85 rr        	sta z80_x
00113Cr 3  68           	pla
00113Dr 3  85 rr        	sta z80_i
00113Fr 3               
00113Fr 3  18           	clc
001140r 3  A5 rr        	lda z80_x 			; distance to next odd/even entry.
001142r 3  69 11        	adc #TABSIZ		 	; next sprite.
001144r 3  85 rr        	sta z80_x
001146r 3  90 02        	bcc :+
001148r 3  E6 rr        	inc z80_i
00114Ar 3               :
00114Ar 3  60           	rts
00114Br 3               
00114Br 3               
00114Br 3               ;-------------------------------------
00114Br 3               ; Clear the play area window.
00114Br 3               ;-------------------------------------
00114Br 3               
00114Br 3               clw:
00114Br 3  AD rr rr     	lda wintop			; get coordinates of window.
00114Er 3  85 rr        	sta dispy			; put into dispx for calculation.
001150r 3  AD rr rr     	lda winlft
001153r 3  85 rr        	sta dispx
001155r 3               
001155r 3  AD rr rr     	lda winhgt			; height of window.
001158r 3  85 rr        	sta rrow			; copy to b register.
00115Ar 3               clw3:
00115Ar 3  AD rr rr     	lda winwid 			; width of window.
00115Dr 3  85 rr        	sta rcol
00115Fr 3               clw2:
00115Fr 3  20 rr rr     	jsr gprad 			; get print address.
001162r 3  A9 00        	lda #0				; zero byte to write.
001164r 3  A2 07        	ldx #7				; pixel height of each cell.
001166r 3               clw1:
001166r 3  BC rr rr     	ldy scrtab,x
001169r 3  91 rr        	sta (scraddr),y 			; copy to screen.
00116Br 3  CA           	dex				; next screen row down.
00116Cr 3  10 F8        	bpl clw1
00116Er 3               
00116Er 3  E6 rr        	inc dispx			; next column.
001170r 3  C6 rr        	dec rcol			; one less to do.
001172r 3  D0 EB        	bne clw2			; repeat for remaining columns.
001174r 3               
001174r 3  AD rr rr     	lda winlft			; get left edge.
001177r 3  85 rr        	sta dispx 			; reset x.
001179r 3  E6 rr        	inc dispy 			; next line down.
00117Br 3               
00117Br 3  C6 rr        	dec rrow
00117Dr 3  D0 DB        	bne clw3			; repeat down the screen.
00117Fr 3               
00117Fr 3  AD rr rr     	lda wintop			; get coordinates of window.
001182r 3  85 rr        	sta chary			; put into display position.
001184r 3  AD rr rr     	lda winlft
001187r 3  85 rr        	sta charx
001189r 3  60           	rts
00118Ar 3               
00118Ar 3               
00118Ar 3               ;----------------------------------------------------------
00118Ar 3               ; Effects code.
00118Ar 3               ; Ticker routine is called 25 times per second.
00118Ar 3               ;
00118Ar 3               ; txtini = text scroller address
00118Ar 3               ; txtscr = left text screen address
00118Ar 3               ; txtwid = scroller width
00118Ar 3               ; txtbit = 128
00118Ar 3               ; X      = message nr
00118Ar 3               ;----------------------------------------------------------
00118Ar 3               
00118Ar 3  00 08 10 18  scrollpos:	.byte   0,  8, 16, 24, 32, 40, 48, 56
00118Er 3  20 28 30 38  
001192r 3  40 48 50 58  		.byte  64, 72, 80, 88, 96,104,112,120
001196r 3  60 68 70 78  
00119Ar 3  80 88 90 98  		.byte 128,136,144,152,160,168,176,184
00119Er 3  A0 A8 B0 B8  
0011A2r 3  C0 C8 D0 D8  		.byte 192,200,208,216,224,232,240,248
0011A6r 3  E0 E8 F0 F8  
0011AAr 3               .if sflag
0011AAr 3               scrly:
0011AAr 3               	rts
0011AAr 3               	.word txtscr         	; set scr_l = left screen address.
0011AAr 3               	sta scr_l
0011AAr 3               	sta tmp_byte		; tmp_byte = lb left screen address
0011AAr 3               	lda txtscr+1
0011AAr 3               	sta scr_l+1
0011AAr 3               	sta scr_r+1		; set hb scr_r = hb left screen address
0011AAr 3               
0011AAr 3               	stx xtmp		; save x
0011AAr 3               
0011AAr 3               	ldx txtwid
0011AAr 3               	dex
0011AAr 3               	ldy scrollpos,x
0011AAr 3               	tya
0011AAr 3               	clc
0011AAr 3               	adc scr_l
0011AAr 3               	sta scr_r		; set lb scr_r = scr_l + (txtwid - 1) * 8
0011AAr 3               
0011AAr 3               	lda #8
0011AAr 3               	sta line_cnt
0011AAr 3               scrly1:
0011AAr 3               	ldx txtwid		; set txtwide
0011AAr 3               	dex
0011AAr 3               	clc
0011AAr 3               scrly0:
0011AAr 3               	ldy scrollpos,x
0011AAr 3               	lda (scr_l),y		; scroll 1 line
0011AAr 3               	rol a
0011AAr 3               	sta (scr_l),y
0011AAr 3               	dex
0011AAr 3               	bpl scrly0
0011AAr 3               
0011AAr 3               	inc scr_l
0011AAr 3               	dec line_cnt
0011AAr 3               	bne scrly1		; repeat 8 times
0011AAr 3               
0011AAr 3               	lda txtpos 		; get text pointer.
0011AAr 3               	sta scr_txt
0011AAr 3               	lda txtpos+1
0011AAr 3               	sta scr_txt+1
0011AAr 3               
0011AAr 3               	ldy #0
0011AAr 3               	lda (scr_txt),y 	; find character we're displaying.
0011AAr 3               	and #127 		; remove end marker bit if applicable.
0011AAr 3               	cmp #13			; is it newline?
0011AAr 3               	bne scrly5 		; no, it's okay.
0011AAr 3               	lda #32			; convert to a space instead.
0011AAr 3               scrly5:
0011AAr 3               	sta fntaddr		; calculate char address
0011AAr 3               	lda #0
0011AAr 3               	sta fntaddr+1
0011AAr 3               	asl fntaddr  		; multiply char by 8.
0011AAr 3               	rol fntaddr+1
0011AAr 3               	asl fntaddr
0011AAr 3               	rol fntaddr+1
0011AAr 3               	asl fntaddr
0011AAr 3               	rol fntaddr+1
0011AAr 3               	lda fntaddr
0011AAr 3               	clc
0011AAr 3               	adc #<(FONT-256)
0011AAr 3               	sta scrly3+1		; that's the low byte.
0011AAr 3               	lda fntaddr+1
0011AAr 3               	adc #>(FONT-256)
0011AAr 3               	sta scrly3+2		; add displacement.
0011AAr 3               
0011AAr 3               	ldy #0
0011AAr 3               scrly3:
0011AAr 3               	lda $3333,y		; get image of char line.
0011AAr 3               	and txtbit
0011AAr 3               	beq scrly2		; don't plot pixel
0011AAr 3               	lda (scr_r),y
0011AAr 3               	clc
0011AAr 3               	ora #1
0011AAr 3               	sta (scr_r),y		; plot pixel
0011AAr 3               scrly2:
0011AAr 3               	iny			; next line of char.
0011AAr 3               	cpy #8
0011AAr 3               	bne scrly3
0011AAr 3               
0011AAr 3               	lsr txtbit		; bit of text to display.
0011AAr 3               	bcs :+
0011AAr 3               	rts
0011AAr 3               :
0011AAr 3               	ldy #0
0011AAr 3               	lda (scr_txt),y 	; what was the character?
0011AAr 3               	asl a	  		; end of message?
0011AAr 3               	bcs scrly4
0011AAr 3               	inc txtpos
0011AAr 3               	bne :+
0011AAr 3               	inc txtpos+1
0011AAr 3               :
0011AAr 3               	jmp scrly6 		; not yet - continue.
0011AAr 3               scrly4:
0011AAr 3               	lda txtini 		; start of scrolling message.
0011AAr 3               	sta txtpos
0011AAr 3               	lda txtini+1
0011AAr 3               	sta txtpos+1
0011AAr 3               scrly6:
0011AAr 3               	lda #128
0011AAr 3               	sta txtbit
0011AAr 3               	ldx xtmp
0011AAr 3               	rts
0011AAr 3               
0011AAr 3               ;scrline:	.byte $00,$20,$40,$60,$80,$a0,$c0,$e0
0011AAr 3               tmp_byte:	.byte 0
0011AAr 3               line_cnt:	.byte 0
0011AAr 3               
0011AAr 3               ;-------------------------------------------------------
0011AAr 3               ; Entry TICKER command
0011AAr 3               ;
0011AAr 3               ; Entry:
0011AAr 3               ;  z80_b = message nr
0011AAr 3               ;  z80_c = width
0011AAr 3               ;-------------------------------------------------------
0011AAr 3               
0011AAr 3               iscrly:
0011AAr 3               	jsr prescr 		; set up display position.
0011AAr 3               	lda #<msgdat 		; text messages.
0011AAr 3               	sta z80_l
0011AAr 3               	lda #>msgdat
0011AAr 3               	sta z80_h
0011AAr 3               	lda z80_c 		; width.
0011AAr 3               	sec
0011AAr 3               	sbc #1			; subtract one.
0011AAr 3               	cmp #32 		; is it between 1 and 32?
0011AAr 3               	bcc :+
0011AAr 3               	lda #$60
0011AAr 3               	jmp iscrl0		; no, disable messages.
0011AAr 3               :
0011AAr 3               	ldx z80_b		; message number.
0011AAr 3               	jsr getwrd 		; find message start.
0011AAr 3               
0011AAr 3               	lda z80_l		; set initial text position.
0011AAr 3               	sta txtini
0011AAr 3               	lda z80_h
0011AAr 3               	sta txtini+1
0011AAr 3               
0011AAr 3               	lda #$ad		; code for lda adrr
0011AAr 3               iscrl0:
0011AAr 3               	sta scrly		; enable/disable scrolling routine.
0011AAr 3               
0011AAr 3               	jsr prescr 		; set up display position.
0011AAr 3               	jsr gprad 		; get print address.
0011AAr 3               
0011AAr 3               	lda scraddr 		; set text screen address.
0011AAr 3               	sta txtscr
0011AAr 3               	lda scraddr+1
0011AAr 3               	sta txtscr+1
0011AAr 3               
0011AAr 3               	lda z80_c		; width.
0011AAr 3               	sta txtwid		; set width in working storage.
0011AAr 3               
0011AAr 3               	lda #128 		; start with leftmost bit.
0011AAr 3               	sta txtbit
0011AAr 3               
0011AAr 3               	jmp scrly4
0011AAr 3               .endif
0011AAr 3               
0011AAr 3               ;------------------------------------------------------------------
0011AAr 3               ; Dig routine, conditional assembly depending on dflag
0011AAr 3               ;------------------------------------------------------------------
0011AAr 3               .if dflag
0011AAr 3               dig:
0011AAr 3               	and #3
0011AAr 3               	beq digr		; dig right
0011AAr 3               	cmp #1
0011AAr 3               	beq digl		; dig left
0011AAr 3               	cmp #2
0011AAr 3               	beq digd		; dig down
0011AAr 3               
0011AAr 3               ; Dig up.
0011AAr 3               
0011AAr 3               digu:				; dig up
0011AAr 3               	ldy #8
0011AAr 3               	lda (z80_ix),y
0011AAr 3               	sec
0011AAr 3               	sbc #2
0011AAr 3               	sta dispy		; set y
0011AAr 3               
0011AAr 3               	iny
0011AAr 3               	lda (z80_ix),y
0011AAr 3               	sta dispx		; set x
0011AAr 3               	jmp digv
0011AAr 3               
0011AAr 3               ; Dig down.
0011AAr 3               
0011AAr 3               digd:
0011AAr 3               	ldy #9
0011AAr 3               	lda (z80_ix),y
0011AAr 3               	sta dispx		; set y
0011AAr 3               
0011AAr 3               	dey
0011AAr 3               	clc
0011AAr 3               	lda (z80_ix),y
0011AAr 3               	adc #16
0011AAr 3               	sta dispy		; set y
0011AAr 3               	jmp digv
0011AAr 3               
0011AAr 3               ; Dig left.
0011AAr 3               
0011AAr 3               digl:
0011AAr 3               	ldy #8
0011AAr 3               	lda (z80_ix),y
0011AAr 3               	sta dispy		; set y
0011AAr 3               
0011AAr 3               	iny
0011AAr 3               	lda (z80_ix),y
0011AAr 3               	sec
0011AAr 3               	sbc #2			; x=x-2
0011AAr 3               	sta dispx		; set x
0011AAr 3               	jmp digh
0011AAr 3               
0011AAr 3               ; Dig right.
0011AAr 3               
0011AAr 3               digr:
0011AAr 3               	ldy #8
0011AAr 3               	lda (z80_ix),y
0011AAr 3               	sta dispy		; set y
0011AAr 3               
0011AAr 3               	iny
0011AAr 3               	lda (z80_ix),y
0011AAr 3               	clc
0011AAr 3               	adc #16
0011AAr 3               	sta dispx		; set x+16
0011AAr 3               	jmp digh
0011AAr 3               
0011AAr 3               ; Vertical digging
0011AAr 3               
0011AAr 3               digv:
0011AAr 3               	jsr tstbl		; check blocktype in MAP
0011AAr 3               	jsr fdchk		; test if FODDER
0011AAr 3               
0011AAr 3               	clc
0011AAr 3               	lda dispx		; look 1 cell down
0011AAr 3               	adc #8
0011AAr 3               	sta dispx
0011AAr 3               	jsr tstbl		; check blocktype in MAP
0011AAr 3               	jsr fdchk
0011AAr 3               	lda dispx
0011AAr 3               	and #7
0011AAr 3               	bne :+
0011AAr 3               	rts
0011AAr 3               :
0011AAr 3               	clc
0011AAr 3               	lda dispx		; look 1 cell down
0011AAr 3               	adc #8
0011AAr 3               	sta dispx
0011AAr 3               	jsr tstbl		; check blocktype in MAP
0011AAr 3               	jmp fdchk
0011AAr 3               
0011AAr 3               ; Horizontal digging
0011AAr 3               
0011AAr 3               digh:
0011AAr 3               	jsr tstbl		; check blocktype in MAP
0011AAr 3               	jsr fdchk		; test if FODDER
0011AAr 3               
0011AAr 3               	clc
0011AAr 3               	lda dispy		; look 1 cell down
0011AAr 3               	adc #8
0011AAr 3               	sta dispy
0011AAr 3               	jsr tstbl		; check blocktype in MAP
0011AAr 3               	jsr fdchk
0011AAr 3               	lda dispy
0011AAr 3               	and #7
0011AAr 3               	bne :+
0011AAr 3               	rts
0011AAr 3               :
0011AAr 3               	clc
0011AAr 3               	lda dispy		; look 1 cell down
0011AAr 3               	adc #8
0011AAr 3               	sta dispy
0011AAr 3               	jsr tstbl		; check blocktype in MAP
0011AAr 3               	jmp fdchk
0011AAr 3               
0011AAr 3               digcnt:	.byte 0
0011AAr 3               
0011AAr 3               .endif
0011AAr 3               
0011AAr 3               ;------------------------------------------------------------------
0011AAr 3               ; Sprite table
0011AAr 3               ;------------------------------------------------------------------
0011AAr 3               
0011AAr 3               
0011AAr 3               ; ix+0  = type.
0011AAr 3               ; ix+1  = sprite image number.
0011AAr 3               ; ix+2  = frame.
0011AAr 3               ; ix+3  = y coord.
0011AAr 3               ; ix+4  = x coord.
0011AAr 3               
0011AAr 3               ; ix+5  = new type.
0011AAr 3               ; ix+6  = new image number.
0011AAr 3               ; ix+7  = new frame.
0011AAr 3               ; ix+8  = new y coord.
0011AAr 3               ; ix+9  = new x coord.
0011AAr 3               
0011AAr 3               ; ix+10 = direction.
0011AAr 3               ; ix+11 = parameter 1.
0011AAr 3               ; ix+12 = parameter 2.
0011AAr 3               ; ix+13 = jump pointer low.
0011AAr 3               ; ix+14 = jump pointer high.
0011AAr 3               ; ix+15 = data pointer low.
0011AAr 3               ; ix+16 = data pointer high.
0011AAr 3               
0011AAr 3               ; block NUMSPR * TABSIZ,255
0011AAr 3               
0011AAr 3  FF FF FF FF  sprtab:	.res NUMSPR*TABSIZ,255
0011AEr 3  FF FF FF FF  
0011B2r 3  FF FF FF FF  
001232r 3  FF FF FF FF  ssprit:	.byte 255,255,255,255,255,255,255,0,192,120,0,0,0,255,255,255,255
001236r 3  FF FF FF 00  
00123Ar 3  C0 78 00 00  
001243r 3  07           roomtb:	.byte 7                      ; start room map offset.
001244r 3               
001244r 3               setfgcol:
001244r 3               setbgcol:
001244r 3  60           	rts
001245r 3               
001245r 3               ; User routine.  Put your own code in here to be called with USER instruction.
001245r 3               ; if USER has an argument it will be passed in the accumulator.
001245r 3               
001245r 3               user:
001245r 3               	.include "user.inc"
001245r 4               ;---------------------------------------------------------------
001245r 4               ; Zeropage variables
001245r 4               ;---------------------------------------------------------------
001245r 4               
001245r 4               ;	SONG_POS          = $90
001245r 4               ;	PATTERN_POS       = $91
001245r 4               ;	FRAME_COUNT       = $92
001245r 4               ;	FRAME_LENGTH      = $93
001245r 4               ;	SONG_NEXT_TRUE    = $94
001245r 4               ;	SONG_END_TRUE     = $95
001245r 4               ;
001245r 4               ;	; 2 byte address of pattern data
001245r 4               ;	CH1_PATTERN_POS   = $96
001245r 4               ;	CH2_PATTERN_POS   = $98
001245r 4               ;	CH3_PATTERN_POS   = $9a
001245r 4               ;	CH4_PATTERN_POS   = $9c
001245r 4               ;	; #$00 == inactive mode
001245r 4               ;	CH1_ACTIVE        = $a0
001245r 4               ;	CH2_ACTIVE        = $a1
001245r 4               ;	CH3_ACTIVE        = $a2
001245r 4               ;	CH4_ACTIVE        = $a3
001245r 4               ;
001245r 4               ;	TEMP_GUY          = $a4
001245r 4               ;	CHAN_NOTE_DATA    = $a5
001245r 4               ;	CHANS_INACTIVE    = $a6
001245r 4               ;	FAST_COUNTER      = $a7
001245r 4               ;	MEGA_COUNTER      = $a8
001245r 4               
001245r 4               
001245r 4               ;---------------------------------------------------------------
001245r 4               ; Constants
001245r 4               ;---------------------------------------------------------------
001245r 4               
001245r 4               	TEXT_TITLE        = songpos
001245r 4               	TEXT_ARTIST       = songpos+$10
001245r 4               	TEXT_COPY         = songpos+$20
001245r 4               	TABLE_SPEED       = songpos+$30
001245r 4               	TABLE_VOLUME      = songpos+$40
001245r 4               	PATTERNS          = songpos+$50
001245r 4               	SONG_PAGE_1       = songpos+$850
001245r 4               	SONG_PAGE_2       = songpos+$950
001245r 4               
001245r 4               ; VIC-I chip audio registers
001245r 4               	VIC_CHAN_1        = $900a
001245r 4               	VIC_CHAN_2        = $900b
001245r 4               	VIC_CHAN_3        = $900c
001245r 4               	VIC_CHAN_4        = $900d
001245r 4               	VIC_VOLUME        = $900e
001245r 4               
001245r 4               
001245r 4               ; bit masks for pattern data / effects
001245r 4               	NOTE_IS           = %10000000
001245r 4               	NOTE_OFF          = %00000001
001245r 4               	NOTE_NEXT         = %00000010
001245r 4               	NOTE_END          = %00000011
001245r 4               	NOTE_NOTHING      = %00000000
001245r 4               
001245r 4               ;---------------------------------------------------------------
001245r 4               ; API calls, entry with A = API call
001245r 4               ;---------------------------------------------------------------
001245r 4               
001245r 4               api:
001245r 4  C9 00        	cmp #0
001247r 4  D0 03        	bne api1
001249r 4  4C rr rr     	jmp int_init
00124Cr 4               api1:
00124Cr 4  C9 01        	cmp #1
00124Er 4  D0 03        	bne api2
001250r 4  4C rr rr     	jmp music_on
001253r 4               api2:
001253r 4  C9 02        	cmp #2
001255r 4  D0 03        	bne api3
001257r 4  4C rr rr     	jmp music_off
00125Ar 4               api3:
00125Ar 4  C9 03        	cmp #3
00125Cr 4  D0 03        	bne api4
00125Er 4  4C rr rr     	jmp musicinit
001261r 4               api4:
001261r 4  C9 04        	cmp #4
001263r 4  D0 03        	bne api_end
001265r 4  4C rr rr     	jmp musicplay
001268r 4               api_end:
001268r 4  60           	rts
001269r 4               
001269r 4               ;---------------------------------------------------------------
001269r 4               ; Init VIA2 timer21 for IRQ 1/50 sec
001269r 4               ;---------------------------------------------------------------
001269r 4               
001269r 4               int_init:
001269r 4  78           	sei			; disable interrupt
00126Ar 4  A9 C0        	lda #$c0		; T1 continuous
00126Cr 4  8D 2B 91     	sta AUX2
00126Fr 4  A9 C0        	lda #$c0		; int timer1
001271r 4  8D 2E 91     	sta IER2
001274r 4  A9 20        	lda #<timerint		; timer 1/50 sec
001276r 4  8D 24 91     	sta Timer21_Low
001279r 4  A9 4E        	lda #>timerint
00127Br 4  8D 25 91     	sta Timer21_High
00127Er 4  A9 rr        	lda #<int_service	; set new IRQ vector
001280r 4  8D 14 03     	sta $0314
001283r 4  A9 rr        	lda #>int_service
001285r 4  8D 15 03     	sta $0315
001288r 4  60           	rts
001289r 4               
001289r 4               ;---------------------------------------------------------------
001289r 4               ; INTERRUPT SERVICE ROUTINE
001289r 4               ;---------------------------------------------------------------
001289r 4               
001289r 4               int_service:
001289r 4  AD 24 91     	lda Timer21_Low		; Clear timer1 flag
00128Cr 4               
00128Cr 4               ; Insert interrupt code here
00128Cr 4               
00128Cr 4  20 rr rr     	jsr musicplay		; Cycle color topleft char
00128Fr 4               
00128Fr 4               ; End of interrupt code
00128Fr 4               
00128Fr 4  68           	pla			; Restore resgisters
001290r 4  A8           	tay
001291r 4  68           	pla
001292r 4  AA           	tax
001293r 4  68           	pla
001294r 4               
001294r 4  40           	rti			; Return from interrupt
001295r 4               
001295r 4               ;---------------------------------------------------------------
001295r 4               ; Music_on, enable interrupt and play music
001295r 4               ;---------------------------------------------------------------
001295r 4               
001295r 4               music_on:
001295r 4  A9 C0        	lda #$c0		; int timer1
001297r 4  8D 2E 91     	sta IER2
00129Ar 4  A9 0F        	lda #$0f
00129Cr 4  8D 0E 90     	sta $900e
00129Fr 4  58           	cli			; enable interrupts
0012A0r 4  60           	rts
0012A1r 4               
0012A1r 4               ;---------------------------------------------------------------
0012A1r 4               ; Music_off, disable interrrupt and stop music
0012A1r 4               ;---------------------------------------------------------------
0012A1r 4               
0012A1r 4               music_off:
0012A1r 4  78           	sei			; enable interrupts
0012A2r 4  A9 7F        	lda #$7f		; int timer1
0012A4r 4  8D 2D 91     	sta IFR2
0012A7r 4  8D 2E 91     	sta IER2
0012AAr 4  A9 00        	lda #$00
0012ACr 4  8D 0E 90     	sta $900e
0012AFr 4  60           	rts
0012B0r 4               
0012B0r 4               ;---------------------------------------------------------------
0012B0r 4               ; Initialisation routine
0012B0r 4               ;---------------------------------------------------------------
0012B0r 4               
0012B0r 4               musicinit:
0012B0r 4  A9 00        	lda #$00
0012B2r 4  85 rr        	sta SONG_POS
0012B4r 4  85 rr        	sta PATTERN_POS
0012B6r 4  85 rr        	sta SONG_NEXT_TRUE
0012B8r 4  85 rr        	sta SONG_END_TRUE
0012BAr 4  85 rr        	sta FRAME_COUNT
0012BCr 4  85 rr        	sta MEGA_COUNTER
0012BEr 4               
0012BEr 4               ; load first frame length
0012BEr 4  A9 01        	lda #$01
0012C0r 4  85 rr        	sta FRAME_LENGTH
0012C2r 4  60           	rts
0012C3r 4               
0012C3r 4               ;---------------------------------------------------------------
0012C3r 4               ; Mainloop
0012C3r 4               ;---------------------------------------------------------------
0012C3r 4               
0012C3r 4               musicplay:
0012C3r 4               main_loop_skip_raster:
0012C3r 4               
0012C3r 4               ; load them patterns
0012C3r 4               ; resets song position if 4 empty patterns
0012C3r 4  20 rr rr     	jsr SONG_POS_UPDATE
0012C6r 4               
0012C6r 4               ; update song stuff
0012C6r 4  20 rr rr     	jsr AUDIO_UPDATE
0012C9r 4               
0012C9r 4               ; check if NeXT was called
0012C9r 4  A5 rr        	lda SONG_NEXT_TRUE
0012CBr 4  C9 00        	cmp #$00
0012CDr 4  F0 11        	beq not_next_effect_called
0012CFr 4  A9 00        	lda #$00
0012D1r 4  85 rr        	sta PATTERN_POS
0012D3r 4  85 rr        	sta SONG_NEXT_TRUE
0012D5r 4  E6 rr        	inc SONG_POS
0012D7r 4  20 rr rr     	jsr SONG_POS_UPDATE
0012DAr 4  20 rr rr     	jsr AUDIO_PROCESS_CHANNEL
0012DDr 4  4C rr rr     	jmp main_loop_skip_raster
0012E0r 4               
0012E0r 4               ; ready for next music frame?
0012E0r 4               not_next_effect_called:
0012E0r 4  E6 rr        	inc FRAME_COUNT
0012E2r 4  A5 rr        	lda FRAME_COUNT
0012E4r 4  C5 rr        	cmp FRAME_LENGTH
0012E6r 4  D0 18        	bne endmusicplayfunc
0012E8r 4               
0012E8r 4               ; reset frame counter
0012E8r 4  A9 00        	lda #$00
0012EAr 4  85 rr        	sta FRAME_COUNT
0012ECr 4               
0012ECr 4               ; increase pattern position
0012ECr 4  E6 rr        	inc PATTERN_POS
0012EEr 4  A5 rr        	lda PATTERN_POS
0012F0r 4  C9 10        	cmp #$10
0012F2r 4  D0 08        	bne not_next_pattern
0012F4r 4               
0012F4r 4               next_pattern:
0012F4r 4  A9 00        	lda #$00
0012F6r 4  85 rr        	sta PATTERN_POS
0012F8r 4  E6 rr        	inc SONG_POS
0012FAr 4  A5 rr        	lda SONG_POS
0012FCr 4               
0012FCr 4               not_next_pattern:
0012FCr 4               
0012FCr 4               ; done
0012FCr 4  E6 rr        	inc MEGA_COUNTER
0012FEr 4  A5 rr        	lda MEGA_COUNTER
001300r 4               
001300r 4               endmusicplayfunc:
001300r 4  60           	rts
001301r 4               
001301r 4               ;---------------------------------------------------------------
001301r 4               ;---------------------------------------------------------------
001301r 4               
001301r 4               ; grab current playback data and push to VIC
001301r 4               
001301r 4               AUDIO_UPDATE:
001301r 4               
001301r 4               ; y = pattern position
001301r 4  A4 rr        	ldy PATTERN_POS
001303r 4  B9 rr rr     	lda TABLE_SPEED,y
001306r 4  85 rr        	sta FRAME_LENGTH
001308r 4  B9 rr rr     	lda TABLE_VOLUME,y
00130Br 4  8D 0E 90     	sta VIC_VOLUME
00130Er 4               
00130Er 4               ; x = channel counter
00130Er 4  A2 00        	ldx #$00
001310r 4               
001310r 4               ; CHANNEL 1
001310r 4  A5 rr        	lda CH1_ACTIVE
001312r 4  C9 00        	cmp #$00
001314r 4  D0 05        	bne channel1_active
001316r 4               
001316r 4  A9 20        	lda #$20
001318r 4  4C rr rr     	jmp channel1_done
00131Br 4               
00131Br 4               channel1_active:
00131Br 4  B1 rr        	lda (CH1_PATTERN_POS),y
00131Dr 4  20 rr rr     	jsr AUDIO_PROCESS_CHANNEL
001320r 4  69 20        	adc #$20
001322r 4               
001322r 4               channel1_done:
001322r 4               
001322r 4               ; CHANNEL 2
001322r 4  E8           	inx
001323r 4  A5 rr        	lda CH2_ACTIVE
001325r 4  C9 00        	cmp #$00
001327r 4  D0 05        	bne channel2_active
001329r 4               
001329r 4  A9 20        	lda #$20
00132Br 4  4C rr rr     	jmp channel2_done
00132Er 4               
00132Er 4               channel2_active:
00132Er 4  B1 rr        	lda (CH2_PATTERN_POS),y
001330r 4  20 rr rr     	jsr AUDIO_PROCESS_CHANNEL
001333r 4  69 20        	adc #$20
001335r 4               
001335r 4               channel2_done:
001335r 4               
001335r 4               ; CHANNEL 3
001335r 4  E8           	inx
001336r 4  A5 rr        	lda CH3_ACTIVE
001338r 4  C9 00        	cmp #$00
00133Ar 4  D0 05        	bne channel3_active
00133Cr 4  A9 20        	lda #$20
00133Er 4  4C rr rr     	jmp channel3_done
001341r 4               
001341r 4               channel3_active:
001341r 4  B1 rr        	lda (CH3_PATTERN_POS),y
001343r 4  20 rr rr     	jsr AUDIO_PROCESS_CHANNEL
001346r 4  69 20        	adc #$20
001348r 4               
001348r 4               channel3_done:
001348r 4               
001348r 4               ; CHANNEL 4
001348r 4  E8           	inx
001349r 4  A5 rr        	lda CH4_ACTIVE
00134Br 4  C9 00        	cmp #$00
00134Dr 4  D0 05        	bne channel4_active
00134Fr 4               
00134Fr 4  A9 20        	lda #$20
001351r 4  4C rr rr     	jmp channel4_done
001354r 4               
001354r 4               channel4_active:
001354r 4  B1 rr        	lda (CH4_PATTERN_POS),y
001356r 4  20 rr rr     	jsr AUDIO_PROCESS_CHANNEL
001359r 4  69 20        	adc #$20
00135Br 4               
00135Br 4               channel4_done:
00135Br 4  60           	rts
00135Cr 4               
00135Cr 4               ;---------------------------------------------------------------
00135Cr 4               ;---------------------------------------------------------------
00135Cr 4               
00135Cr 4               AUDIO_PROCESS_CHANNEL:
00135Cr 4  85 rr        	sta CHAN_NOTE_DATA
00135Er 4  29 80        	and #%10000000
001360r 4  C9 80        	cmp #%10000000
001362r 4  D0 06        	bne not_note
001364r 4               
001364r 4               is_note:
001364r 4  A5 rr        	lda CHAN_NOTE_DATA
001366r 4  9D 0A 90     	sta VIC_CHAN_1,x
001369r 4  60           	rts
00136Ar 4               
00136Ar 4               not_note:
00136Ar 4  A5 rr        	lda CHAN_NOTE_DATA
00136Cr 4  C9 01        	cmp #%00000001
00136Er 4  D0 06        	bne not_note_off
001370r 4               
001370r 4  A9 00        	lda #$00
001372r 4  9D 0A 90     	sta VIC_CHAN_1,x
001375r 4  60           	rts
001376r 4               
001376r 4               not_note_off:
001376r 4  A5 rr        	lda CHAN_NOTE_DATA
001378r 4  C9 02        	cmp #%00000010
00137Ar 4  D0 03        	bne not_note_next
00137Cr 4               
00137Cr 4               ; move song to next song row
00137Cr 4  E6 rr        	inc SONG_NEXT_TRUE
00137Er 4               
00137Er 4               ; XXX do what here?
00137Er 4               ; will update correctly on next frame
00137Er 4               ; if we move where this subroutine gets called
00137Er 4               
00137Er 4               ;	lda #$00
00137Er 4  60           	rts
00137Fr 4               
00137Fr 4               not_note_next:
00137Fr 4  A5 rr        	lda CHAN_NOTE_DATA
001381r 4  C9 03        	cmp #NOTE_END
001383r 4  D0 05        	bne not_end_of_song
001385r 4               
001385r 4               ; turn the sound off cheaply :D/
001385r 4  A9 00        	lda #$00
001387r 4  8D 0E 90     	sta VIC_VOLUME
00138Ar 4               
00138Ar 4               ;-----BUG----------
00138Ar 4               ; soft reset the machine!
00138Ar 4               ; solution from https://www.c64-wiki.com/wiki/Reset_(Process)
00138Ar 4               ;	jmp $fd22
00138Ar 4               ;-----BUG----------
00138Ar 4               
00138Ar 4               not_end_of_song:
00138Ar 4  60           	rts
00138Br 4               
00138Br 4               ;---------------------------------------------------------------
00138Br 4               ;---------------------------------------------------------------
00138Br 4               
00138Br 4               ; put pattern addresses in zero page
00138Br 4               ; SONG_POS should be set before calling
00138Br 4               
00138Br 4               SONG_POS_UPDATE:
00138Br 4               
00138Br 4               ; x = channel pattern position offset
00138Br 4  A2 00        	ldx #$00
00138Dr 4  86 rr        	stx CHANS_INACTIVE
00138Fr 4  A9 FF        	lda #$ff
001391r 4  85 rr        	sta CH1_ACTIVE
001393r 4  85 rr        	sta CH2_ACTIVE
001395r 4  85 rr        	sta CH3_ACTIVE
001397r 4  85 rr        	sta CH4_ACTIVE
001399r 4               
001399r 4               song_pos_loop:
001399r 4  A5 rr        	lda SONG_POS
00139Br 4  38           	sec
00139Cr 4  E9 40        	sbc #$40
00139Er 4  10 10        	bpl song_page_2
0013A0r 4               
0013A0r 4               song_page_1:
0013A0r 4  0A           	asl
0013A1r 4  0A           	asl
0013A2r 4  85 rr        	sta TEMP_GUY
0013A4r 4  8A           	txa
0013A5r 4  4A           	lsr
0013A6r 4  18           	clc
0013A7r 4  65 rr        	adc TEMP_GUY
0013A9r 4  A8           	tay
0013AAr 4  B9 rr rr     	lda SONG_PAGE_1,y
0013ADr 4  4C rr rr     	jmp pattern_found
0013B0r 4               
0013B0r 4               song_page_2:
0013B0r 4  0A           	asl
0013B1r 4  0A           	asl
0013B2r 4  85 rr        	sta TEMP_GUY
0013B4r 4  8A           	txa
0013B5r 4  4A           	lsr
0013B6r 4  18           	clc
0013B7r 4  65 rr        	adc TEMP_GUY
0013B9r 4  A8           	tay
0013BAr 4  B9 rr rr     	lda SONG_PAGE_2,y
0013BDr 4               
0013BDr 4               pattern_found:
0013BDr 4  85 rr        	sta TEMP_GUY
0013BFr 4               
0013BFr 4               ; lets make sure its not an empty pattern
0013BFr 4  C9 FF        	cmp #$ff
0013C1r 4  D0 17        	bne dont_reset
0013C3r 4               
0013C3r 4               ; set channel to inactive mode
0013C3r 4  8A           	txa
0013C4r 4  4A           	lsr
0013C5r 4  A8           	tay
0013C6r 4  A9 00        	lda #$00
0013C8r 4  99 rr rr     	sta CH1_ACTIVE,y
0013CBr 4               
0013CBr 4               ; reset song if there are 4 empty patterns
0013CBr 4  E6 rr        	inc CHANS_INACTIVE
0013CDr 4  A5 rr        	lda CHANS_INACTIVE
0013CFr 4  C9 04        	cmp #$04
0013D1r 4  D0 07        	bne dont_reset
0013D3r 4               
0013D3r 4               song_reset:
0013D3r 4  A9 00        	lda #$00
0013D5r 4  85 rr        	sta SONG_POS
0013D7r 4  4C rr rr     	jmp SONG_POS_UPDATE
0013DAr 4               
0013DAr 4               dont_reset:
0013DAr 4  A5 rr        	lda TEMP_GUY
0013DCr 4               
0013DCr 4               ; LSB
0013DCr 4  0A           	asl
0013DDr 4  0A           	asl
0013DEr 4  0A           	asl
0013DFr 4  0A           	asl
0013E0r 4  18           	clc
0013E1r 4  69 50        	adc #$50
0013E3r 4  95 rr        	sta CH1_PATTERN_POS,x
0013E5r 4  E8           	inx
0013E6r 4               
0013E6r 4               ; MSB
0013E6r 4  A5 rr        	lda TEMP_GUY
0013E8r 4  4A           	lsr
0013E9r 4  4A           	lsr
0013EAr 4  4A           	lsr
0013EBr 4  4A           	lsr
0013ECr 4  69 rr        	adc #>PATTERNS
0013EEr 4  95 rr        	sta CH1_PATTERN_POS,x
0013F0r 4  E8           	inx
0013F1r 4  E0 08        	cpx #$08
0013F3r 4  D0 A4        	bne song_pos_loop
0013F5r 4  60           	rts
0013F6r 4               
0013F6r 4  xx xx xx xx  	.align $100
0013FAr 4  xx xx xx xx  
0013FEr 4  xx xx        
001400r 4               songpos:
001400r 4  34 4B 2D 49  	.incbin "songdata_jonah.bin"
001404r 4  0E 14 12 0F  
001408r 4  20 20 20 20  
001E50r 4               
001E50r 3               
001E50r 3               ; Everything below here will be generated by the editors.
001E50r 3               
001E50r 3               
001E50r 3  60                   rts
001E51r 3               WINDOWTOP = 1
001E51r 3               WINDOWLFT = 0
001E51r 3               WINDOWHGT = 20
001E51r 3               WINDOWWID = 22 ;a
001E51r 3               MAPWID = 3
001E51r 3  FF FF FF             .byte 255,255,255
001E54r 3               mapdat:
001E54r 3  FF 00 FF             .byte 255,0,255
001E57r 3  FF FF FF             .byte 255,255,255
001E5Ar 3  01           stmap:  .byte 1
001E5Br 3               
001E5Br 3               evnt00:
001E5Br 3  20 rr rr             jsr ifall	; FALL
001E5Er 3  A9 00                lda #0
001E60r 3  85 rr                sta vari
001E62r 3  A5 rr                lda joyval	; KEY
001E64r 3  29 02                and #2
001E66r 3  F0 03                beq :+
001E68r 3  4C rr rr             jmp a00112
001E6Br 3               :
001E6Br 3  A9 03                lda #3
001E6Dr 3  A0 06                ldy #6
001E6Fr 3  91 rr                sta (z80_ix),y
001E71r 3  A9 01                lda #1
001E73r 3  A0 0A                ldy #10
001E75r 3  91 rr                sta (z80_ix),y
001E77r 3  A9 01                lda #1
001E79r 3  85 rr                sta vari
001E7Br 3  20 rr rr             jsr cangl	; CANGOLEFT
001E7Er 3  F0 03                beq :+
001E80r 3  4C rr rr             jmp a00112
001E83r 3               :
001E83r 3  A0 09                ldy #9 		; SPRITELEFT
001E85r 3  B1 rr                lda (z80_ix),y
001E87r 3  38                   sec
001E88r 3  E9 02                sbc #2
001E8Ar 3  91 rr                sta (z80_ix),y
001E8Cr 3  A5 rr        a00112: lda joyval	; KEY
001E8Er 3  29 01                and #1
001E90r 3  F0 03                beq :+
001E92r 3  4C rr rr             jmp a00208
001E95r 3               :
001E95r 3  A9 02                lda #2
001E97r 3  A0 06                ldy #6
001E99r 3  91 rr                sta (z80_ix),y
001E9Br 3  A9 00                lda #0
001E9Dr 3  A0 0A                ldy #10
001E9Fr 3  91 rr                sta (z80_ix),y
001EA1r 3  A9 01                lda #1
001EA3r 3  85 rr                sta vari
001EA5r 3  20 rr rr             jsr cangr	; CANGORIGHT
001EA8r 3  F0 03                beq :+
001EAAr 3  4C rr rr             jmp a00208
001EADr 3               :
001EADr 3  A0 09                ldy #9 		; SPRITERIGHT
001EAFr 3  B1 rr                lda (z80_ix),y
001EB1r 3  18                   clc
001EB2r 3  69 02                adc #2
001EB4r 3  91 rr                sta (z80_ix),y
001EB6r 3  A9 00        a00208: lda #0
001EB8r 3  C5 rr                cmp vari
001EBAr 3  F0 03                beq *+5
001EBCr 3  4C rr rr             jmp a00244
001EBFr 3  A0 0A                ldy #10
001EC1r 3  B1 rr                lda (z80_ix),y
001EC3r 3  A0 06                ldy #6
001EC5r 3  91 rr                sta (z80_ix),y
001EC7r 3  A5 rr        a00244: lda joyval	; KEY
001EC9r 3  29 10                and #16
001ECBr 3  F0 03                beq :+
001ECDr 3  4C rr rr             jmp a00271
001ED0r 3               :
001ED0r 3  20 rr rr             jsr jump	; TABLEJUMP
001ED3r 3  A9 00        a00271: lda #0		; ANIMATE
001ED5r 3  20 rr rr             jsr animsp
001ED8r 3  4C rr rr             jmp grav
001EDBr 3               evnt01:
001EDBr 3  60                   rts
001EDCr 3               evnt02:
001EDCr 3  60                   rts
001EDDr 3               evnt03:
001EDDr 3  60                   rts
001EDEr 3               evnt04:
001EDEr 3  60                   rts
001EDFr 3               evnt05:
001EDFr 3  60                   rts
001EE0r 3               evnt06:
001EE0r 3  60                   rts
001EE1r 3               evnt07:
001EE1r 3  60                   rts
001EE2r 3               evnt08:
001EE2r 3  60                   rts
001EE3r 3               evnt09:
001EE3r 3  60                   rts
001EE4r 3               evnt10:
001EE4r 3  A0 07                ldy #7 	; KEY
001EE6r 3                       .if swrflag
001EE6r 3                       lda keys + data_address - data_start,y
001EE6r 3                       .else
001EE6r 3  B9 rr rr             lda keys,y
001EE9r 3                       .endif
001EE9r 3  20 rr rr             jsr ktest
001EECr 3  90 03                bcc :+
001EEEr 3  4C rr rr             jmp k00061
001EF1r 3               :
001EF1r 3  A9 01                lda #1	; NEXTLEVEL
001EF3r 3  85 rr                sta nexlev
001EF5r 3  60           k00061: rts
001EF6r 3               evnt11:
001EF6r 3  A9 17                lda #23		; AT
001EF8r 3  85 rr                sta chary
001EFAr 3  A9 14                lda #20
001EFCr 3  85 rr                sta charx
001EFEr 3  A9 rr                lda #<displ0	; DISPLAYTRIPLE
001F00r 3  85 rr                sta z80_c
001F02r 3  A9 rr                lda #>displ0
001F04r 3  85 rr                sta z80_b
001F06r 3  A5 rr                lda clock
001F08r 3  20 rr rr             jsr num2td
001F0Br 3  20 rr rr             jsr displ1
001F0Er 3  60                   rts
001F0Fr 3               evnt12:
001F0Fr 3  20 rr rr             jsr cls		; CLS
001F12r 3  60                   rts
001F13r 3               evnt13:
001F13r 3  60                   rts
001F14r 3               evnt14:
001F14r 3  A9 00                lda #0 	; PAPER
001F16r 3  0A                   asl a
001F17r 3  0A                   asl a
001F18r 3  0A                   asl a
001F19r 3  0A                   asl a
001F1Ar 3  85 rr                sta tmp
001F1Cr 3  AD 0F 90             lda RegF
001F1Fr 3  29 8F                and #%10001111
001F21r 3  05 rr                ora tmp
001F23r 3  8D 0F 90             sta RegF
001F26r 3  A9 00                lda #0		; AT
001F28r 3  85 rr                sta chary
001F2Ar 3  A9 04                lda #4
001F2Cr 3  85 rr                sta charx
001F2Er 3  A9 01                lda #1 	; INK
001F30r 3  8D rr rr             sta fontcol
001F33r 3  A9 00                lda #0		; PRINT
001F35r 3  20 rr rr             jsr dmsg
001F38r 3  60                   rts
001F39r 3               evnt15:
001F39r 3  60                   rts
001F3Ar 3               evnt16:
001F3Ar 3  60                   rts
001F3Br 3               evnt17:
001F3Br 3  60                   rts
001F3Cr 3               evnt18:
001F3Cr 3  60                   rts
001F3Dr 3               evnt19:
001F3Dr 3  60                   rts
001F3Er 3               evnt20:
001F3Er 3  A9 00                lda #0	; GET
001F40r 3  20 rr rr             jsr getob
001F43r 3  60                   rts
001F44r 3  60           ptcusr: rts
001F45r 3               data_start:
001F45r 3               msgdat:
001F45r 3  42 49 47 20          .byte "BIG SPRITE DEM",207
001F49r 3  53 50 52 49  
001F4Dr 3  54 45 20 44  
001F54r 3               nummsg:
001F54r 3  01                   .byte 1
001F55r 3               chgfx:
001F55r 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
001F59r 3  00 00 00 00  
001F5Dr 3  01 01 01 FF          .byte 1,1,1,255,16,16,16,255
001F61r 3  10 10 10 FF  
001F65r 3               bCol:
001F65r 3  01                   .byte 1
001F66r 3  01                   .byte 1
001F67r 3               bprop:
001F67r 3  00                   .byte 0
001F68r 3  02                   .byte 2
001F69r 3               sprgfx:
001F69r 3  00 00 03 E0          .byte 0,0,3,224,7,248,15,0,14,200,5,252,0,248,3,96,13,120,30,128,31,160,61,160,59,168,61,172,26,206,7,5,6,227,9,240,30,240,60,88,120,56,96,48,88,14,60,31
001F6Dr 3  07 F8 0F 00  
001F71r 3  0E C8 05 FC  
001F99r 3  00 00 00 F8          .byte 0,0,0,248,1,254,3,192,3,178,1,127,0,62,0,216,3,94,7,160,7,232,15,104,14,234,15,107,134,179,65,193,193,184,2,124,7,188,15,22,30,14,24,12,150,3,207,7
001F9Dr 3  01 FE 03 C0  
001FA1r 3  03 B2 01 7F  
001FC9r 3  00 00 00 3E          .byte 0,0,0,62,128,127,0,240,128,236,192,95,128,15,0,54,128,215,1,232,1,250,3,218,131,186,195,218,225,172,80,112,48,110,0,159,1,239,131,197,135,131,6,3,229,128,243,193
001FCDr 3  80 7F 00 F0  
001FD1r 3  80 EC C0 5F  
001FF9r 3  00 00 80 0F          .byte 0,0,128,15,224,31,0,60,32,59,240,23,224,3,128,13,224,53,0,122,128,126,128,246,160,238,176,246,56,107,20,28,140,27,192,39,192,123,96,241,225,224,193,128,57,96,124,240
001FFDr 3  E0 1F 00 3C  
002001r 3  20 3B F0 17  
002029r 3  00 00 07 C0          .byte 0,0,7,192,15,240,31,0,30,144,13,248,3,240,1,192,26,240,61,0,63,176,123,176,119,180,123,182,53,165,30,2,12,224,3,240,30,240,60,88,120,56,96,48,88,14,60,31
00202Dr 3  0F F0 1F 00  
002031r 3  1E 90 0D F8  
002059r 3  00 00 01 F0          .byte 0,0,1,240,3,252,7,192,7,164,3,126,0,252,0,112,6,188,15,64,15,236,30,236,29,237,158,237,77,105,135,128,3,56,0,252,7,188,15,22,30,14,24,12,150,3,207,7
00205Dr 3  03 FC 07 C0  
002061r 3  07 A4 03 7E  
002089r 3  00 00 00 7C          .byte 0,0,0,124,0,255,1,240,1,233,128,223,0,63,0,28,1,175,3,208,3,251,7,187,71,123,103,187,83,90,33,224,0,206,0,63,1,239,131,197,135,131,6,3,229,128,243,193
00208Dr 3  00 FF 01 F0  
002091r 3  01 E9 80 DF  
0020B9r 3  00 00 00 1F          .byte 0,0,0,31,192,63,0,124,64,122,224,55,192,15,0,7,192,107,0,244,192,254,193,238,209,222,217,238,148,214,8,120,128,51,192,15,192,123,96,241,225,224,193,128,57,96,124,240
0020BDr 3  C0 3F 00 7C  
0020C1r 3  40 7A E0 37  
0020E9r 3  00 00 07 C0          .byte 0,0,7,192,15,240,31,0,30,144,13,248,3,240,1,192,26,240,61,0,63,176,123,176,119,180,123,182,53,165,30,2,12,224,3,240,30,240,60,88,120,56,96,48,88,14,60,31
0020EDr 3  0F F0 1F 00  
0020F1r 3  1E 90 0D F8  
002119r 3  00 00 01 F0          .byte 0,0,1,240,3,252,7,192,7,164,3,126,0,252,0,112,6,188,15,64,15,236,30,236,29,237,158,237,77,105,135,128,3,56,0,252,7,188,15,22,30,14,24,12,150,3,207,7
00211Dr 3  03 FC 07 C0  
002121r 3  07 A4 03 7E  
002149r 3  00 00 00 7C          .byte 0,0,0,124,0,255,1,240,1,233,128,223,0,63,0,28,1,175,3,208,3,251,7,187,71,123,103,187,83,90,33,224,0,206,0,63,1,239,131,197,135,131,6,3,229,128,243,193
00214Dr 3  00 FF 01 F0  
002151r 3  01 E9 80 DF  
002179r 3  00 00 00 1F          .byte 0,0,0,31,192,63,0,124,64,122,224,55,192,15,0,7,192,107,0,244,192,254,193,238,209,222,217,238,148,214,8,120,128,51,192,15,192,123,96,241,225,224,193,128,57,96,124,240
00217Dr 3  C0 3F 00 7C  
002181r 3  40 7A E0 37  
0021A9r 3  00 00 03 E0          .byte 0,0,3,224,7,248,15,0,14,200,5,252,0,248,3,96,13,120,30,128,31,160,61,160,59,168,61,172,26,206,7,5,6,227,9,240,30,240,60,88,120,56,96,48,88,14,60,31
0021ADr 3  07 F8 0F 00  
0021B1r 3  0E C8 05 FC  
0021D9r 3  00 00 00 F8          .byte 0,0,0,248,1,254,3,192,3,178,1,127,0,62,0,216,3,94,7,160,7,232,15,104,14,234,15,107,134,179,65,193,193,184,2,124,7,188,15,22,30,14,24,12,150,3,207,7
0021DDr 3  01 FE 03 C0  
0021E1r 3  03 B2 01 7F  
002209r 3  00 00 00 3E          .byte 0,0,0,62,128,127,0,240,128,236,192,95,128,15,0,54,128,215,1,232,1,250,3,218,131,186,195,218,225,172,80,112,48,110,0,159,1,239,131,197,135,131,6,3,229,128,243,193
00220Dr 3  80 7F 00 F0  
002211r 3  80 EC C0 5F  
002239r 3  00 00 80 0F          .byte 0,0,128,15,224,31,0,60,32,59,240,23,224,3,128,13,224,53,0,122,128,126,128,246,160,238,176,246,56,107,20,28,140,27,192,39,192,123,96,241,225,224,193,128,57,96,124,240
00223Dr 3  E0 1F 00 3C  
002241r 3  20 3B F0 17  
002269r 3  00 00 03 E0          .byte 0,0,3,224,7,248,15,0,14,200,5,252,0,248,3,96,13,120,30,128,31,160,61,160,59,168,61,172,26,206,7,5,6,227,9,240,30,240,60,88,120,56,96,48,88,14,60,31
00226Dr 3  07 F8 0F 00  
002271r 3  0E C8 05 FC  
002299r 3  00 00 00 F8          .byte 0,0,0,248,1,254,3,192,3,178,1,127,0,62,0,216,3,94,7,160,7,232,15,104,14,234,15,107,134,179,65,193,193,184,2,124,7,188,15,22,30,14,24,12,150,3,207,7
00229Dr 3  01 FE 03 C0  
0022A1r 3  03 B2 01 7F  
0022C9r 3  00 00 00 3E          .byte 0,0,0,62,128,127,0,240,128,236,192,95,128,15,0,54,128,215,1,232,1,250,3,218,131,186,195,218,225,172,80,112,48,110,0,159,1,239,131,197,135,131,6,3,229,128,243,193
0022CDr 3  80 7F 00 F0  
0022D1r 3  80 EC C0 5F  
0022F9r 3  00 00 80 0F          .byte 0,0,128,15,224,31,0,60,32,59,240,23,224,3,128,13,224,53,0,122,128,126,128,246,160,238,176,246,56,107,20,28,140,27,192,39,192,123,96,241,225,224,193,128,57,96,124,240
0022FDr 3  E0 1F 00 3C  
002301r 3  20 3B F0 17  
002329r 3  00 00 03 E0          .byte 0,0,3,224,7,248,15,0,14,200,5,252,0,248,3,96,13,120,30,128,31,160,61,160,59,168,61,172,26,206,7,5,6,227,9,240,30,240,60,88,120,56,96,48,88,14,60,31
00232Dr 3  07 F8 0F 00  
002331r 3  0E C8 05 FC  
002359r 3  00 00 00 F8          .byte 0,0,0,248,1,254,3,192,3,178,1,127,0,62,0,216,3,94,7,160,7,232,15,104,14,234,15,107,134,179,65,193,193,184,2,124,7,188,15,22,30,14,24,12,150,3,207,7
00235Dr 3  01 FE 03 C0  
002361r 3  03 B2 01 7F  
002389r 3  00 00 00 3E          .byte 0,0,0,62,128,127,0,240,128,236,192,95,128,15,0,54,128,215,1,232,1,250,3,218,131,186,195,218,225,172,80,112,48,110,0,159,1,239,131,197,135,131,6,3,229,128,243,193
00238Dr 3  80 7F 00 F0  
002391r 3  80 EC C0 5F  
0023B9r 3  00 00 80 0F          .byte 0,0,128,15,224,31,0,60,32,59,240,23,224,3,128,13,224,53,0,122,128,126,128,246,160,238,176,246,56,107,20,28,140,27,192,39,192,123,96,241,225,224,193,128,57,96,124,240
0023BDr 3  E0 1F 00 3C  
0023C1r 3  20 3B F0 17  
0023E9r 3  00 00 07 C0          .byte 0,0,7,192,31,224,0,240,19,112,63,160,31,0,6,192,30,176,1,120,5,248,5,188,21,220,53,188,115,88,160,224,199,96,15,144,15,120,26,60,28,30,12,6,112,26,248,60
0023EDr 3  1F E0 00 F0  
0023F1r 3  13 70 3F A0  
002419r 3  00 00 01 F0          .byte 0,0,1,240,7,248,0,60,4,220,15,232,7,192,1,176,7,172,0,94,1,126,1,111,5,119,13,111,28,214,40,56,49,216,3,228,3,222,6,143,135,7,131,1,156,6,62,15
00241Dr 3  07 F8 00 3C  
002421r 3  04 DC 0F E8  
002449r 3  00 00 00 7C          .byte 0,0,0,124,1,254,0,15,1,55,3,250,1,240,0,108,1,235,128,23,128,95,192,91,193,93,195,91,135,53,10,14,12,118,0,249,128,247,193,163,225,193,96,192,167,1,207,131
00244Dr 3  01 FE 00 0F  
002451r 3  01 37 03 FA  
002479r 3  00 00 00 1F          .byte 0,0,0,31,128,127,192,3,192,77,128,254,0,124,0,27,192,122,224,5,224,23,240,22,112,87,240,214,97,205,130,131,131,29,64,62,224,61,240,104,120,112,24,48,105,192,243,224
00247Dr 3  80 7F C0 03  
002481r 3  C0 4D 80 FE  
0024A9r 3  00 00 03 E0          .byte 0,0,3,224,15,240,0,248,9,120,31,176,15,192,3,128,15,88,0,188,13,252,13,222,45,238,109,222,165,172,64,120,7,48,15,192,15,120,26,60,28,30,12,6,112,26,248,60
0024ADr 3  0F F0 00 F8  
0024B1r 3  09 78 1F B0  
0024D9r 3  00 00 00 F8          .byte 0,0,0,248,3,252,0,62,2,94,7,236,3,240,0,224,3,214,0,47,3,127,131,119,139,123,155,119,41,107,16,30,1,204,3,240,3,222,6,143,135,7,131,1,156,6,62,15
0024DDr 3  03 FC 00 3E  
0024E1r 3  02 5E 07 EC  
002509r 3  00 00 00 3E          .byte 0,0,0,62,0,255,128,15,128,151,1,251,0,252,0,56,128,245,192,11,192,223,224,221,226,222,230,221,202,90,132,7,0,115,0,252,128,247,193,163,225,193,96,192,167,1,207,131
00250Dr 3  00 FF 80 0F  
002511r 3  80 97 01 FB  
002539r 3  00 00 80 0F          .byte 0,0,128,15,192,63,224,3,224,37,192,126,0,63,0,14,96,61,240,2,240,55,120,55,184,183,121,183,178,150,225,1,192,28,0,63,224,61,240,104,120,112,24,48,105,192,243,224
00253Dr 3  C0 3F E0 03  
002541r 3  E0 25 C0 7E  
002569r 3  00 00 03 E0          .byte 0,0,3,224,15,240,0,248,9,120,31,176,15,192,3,128,15,88,0,188,13,252,13,222,45,238,109,222,165,172,64,120,7,48,15,192,15,120,26,60,28,30,12,6,112,26,248,60
00256Dr 3  0F F0 00 F8  
002571r 3  09 78 1F B0  
002599r 3  00 00 00 F8          .byte 0,0,0,248,3,252,0,62,2,94,7,236,3,240,0,224,3,214,0,47,3,127,131,119,139,123,155,119,41,107,16,30,1,204,3,240,3,222,6,143,135,7,131,1,156,6,62,15
00259Dr 3  03 FC 00 3E  
0025A1r 3  02 5E 07 EC  
0025C9r 3  00 00 00 3E          .byte 0,0,0,62,0,255,128,15,128,151,1,251,0,252,0,56,128,245,192,11,192,223,224,221,226,222,230,221,202,90,132,7,0,115,0,252,128,247,193,163,225,193,96,192,167,1,207,131
0025CDr 3  00 FF 80 0F  
0025D1r 3  80 97 01 FB  
0025F9r 3  00 00 80 0F          .byte 0,0,128,15,192,63,224,3,224,37,192,126,0,63,0,14,96,61,240,2,240,55,120,55,184,183,121,183,178,150,225,1,192,28,0,63,224,61,240,104,120,112,24,48,105,192,243,224
0025FDr 3  C0 3F E0 03  
002601r 3  E0 25 C0 7E  
002629r 3  00 00 07 C0          .byte 0,0,7,192,31,224,0,240,19,112,63,160,31,0,6,192,30,176,1,120,5,248,5,188,21,220,53,188,115,88,160,224,199,96,15,144,15,120,26,60,28,30,12,6,112,26,248,60
00262Dr 3  1F E0 00 F0  
002631r 3  13 70 3F A0  
002659r 3  00 00 01 F0          .byte 0,0,1,240,7,248,0,60,4,220,15,232,7,192,1,176,7,172,0,94,1,126,1,111,5,119,13,111,28,214,40,56,49,216,3,228,3,222,6,143,135,7,131,1,156,6,62,15
00265Dr 3  07 F8 00 3C  
002661r 3  04 DC 0F E8  
002689r 3  00 00 00 7C          .byte 0,0,0,124,1,254,0,15,1,55,3,250,1,240,0,108,1,235,128,23,128,95,192,91,193,93,195,91,135,53,10,14,12,118,0,249,128,247,193,163,225,193,96,192,167,1,207,131
00268Dr 3  01 FE 00 0F  
002691r 3  01 37 03 FA  
0026B9r 3  00 00 00 1F          .byte 0,0,0,31,128,127,192,3,192,77,128,254,0,124,0,27,192,122,224,5,224,23,240,22,112,87,240,214,97,205,130,131,131,29,64,62,224,61,240,104,120,112,24,48,105,192,243,224
0026BDr 3  80 7F C0 03  
0026C1r 3  C0 4D 80 FE  
0026E9r 3  00 00 07 C0          .byte 0,0,7,192,31,224,0,240,19,112,63,160,31,0,6,192,30,176,1,120,5,248,5,188,21,220,53,188,115,88,160,224,199,96,15,144,15,120,26,60,28,30,12,6,112,26,248,60
0026EDr 3  1F E0 00 F0  
0026F1r 3  13 70 3F A0  
002719r 3  00 00 01 F0          .byte 0,0,1,240,7,248,0,60,4,220,15,232,7,192,1,176,7,172,0,94,1,126,1,111,5,119,13,111,28,214,40,56,49,216,3,228,3,222,6,143,135,7,131,1,156,6,62,15
00271Dr 3  07 F8 00 3C  
002721r 3  04 DC 0F E8  
002749r 3  00 00 00 7C          .byte 0,0,0,124,1,254,0,15,1,55,3,250,1,240,0,108,1,235,128,23,128,95,192,91,193,93,195,91,135,53,10,14,12,118,0,249,128,247,193,163,225,193,96,192,167,1,207,131
00274Dr 3  01 FE 00 0F  
002751r 3  01 37 03 FA  
002779r 3  00 00 00 1F          .byte 0,0,0,31,128,127,192,3,192,77,128,254,0,124,0,27,192,122,224,5,224,23,240,22,112,87,240,214,97,205,130,131,131,29,64,62,224,61,240,104,120,112,24,48,105,192,243,224
00277Dr 3  80 7F C0 03  
002781r 3  C0 4D 80 FE  
0027A9r 3  00 00 07 C0          .byte 0,0,7,192,31,224,0,240,19,112,63,160,31,0,6,192,30,176,1,120,5,248,5,188,21,220,53,188,115,88,160,224,199,96,15,144,15,120,26,60,28,30,12,6,112,26,248,60
0027ADr 3  1F E0 00 F0  
0027B1r 3  13 70 3F A0  
0027D9r 3  00 00 01 F0          .byte 0,0,1,240,7,248,0,60,4,220,15,232,7,192,1,176,7,172,0,94,1,126,1,111,5,119,13,111,28,214,40,56,49,216,3,228,3,222,6,143,135,7,131,1,156,6,62,15
0027DDr 3  07 F8 00 3C  
0027E1r 3  04 DC 0F E8  
002809r 3  00 00 00 7C          .byte 0,0,0,124,1,254,0,15,1,55,3,250,1,240,0,108,1,235,128,23,128,95,192,91,193,93,195,91,135,53,10,14,12,118,0,249,128,247,193,163,225,193,96,192,167,1,207,131
00280Dr 3  01 FE 00 0F  
002811r 3  01 37 03 FA  
002839r 3  00 00 00 1F          .byte 0,0,0,31,128,127,192,3,192,77,128,254,0,124,0,27,192,122,224,5,224,23,240,22,112,87,240,214,97,205,130,131,131,29,64,62,224,61,240,104,120,112,24,48,105,192,243,224
00283Dr 3  80 7F C0 03  
002841r 3  C0 4D 80 FE  
002869r 3  00 00 00 00          .byte 0,0,0,0,3,224,7,248,15,0,14,200,5,252,2,248,13,96,30,120,31,128,61,160,59,168,61,172,26,204,7,10,6,230,9,240,30,240,60,88,120,58,96,54,88,14,60,28
00286Dr 3  03 E0 07 F8  
002871r 3  0F 00 0E C8  
002899r 3  00 00 00 00          .byte 0,0,0,0,0,248,1,254,3,192,3,178,1,127,0,190,3,88,7,158,7,224,15,104,14,234,15,107,6,179,129,194,129,185,2,124,7,188,15,22,158,14,152,13,150,3,15,7
00289Dr 3  00 F8 01 FE  
0028A1r 3  03 C0 03 B2  
0028C9r 3  00 00 00 00          .byte 0,0,0,0,0,62,128,127,0,240,128,236,192,95,128,47,0,214,129,231,1,248,3,218,131,186,195,218,193,172,160,112,96,110,0,159,1,239,131,197,167,131,102,3,229,128,195,193
0028CDr 3  00 3E 80 7F  
0028D1r 3  00 F0 80 EC  
0028F9r 3  00 00 00 00          .byte 0,0,0,0,128,15,224,31,0,60,32,59,240,23,224,11,128,53,224,121,0,126,128,246,160,238,176,246,48,107,40,28,152,27,192,39,192,123,96,241,233,224,217,128,57,96,112,240
0028FDr 3  80 0F E0 1F  
002901r 3  00 3C 20 3B  
002929r 3  00 00 03 E0          .byte 0,0,3,224,7,248,15,0,14,200,5,252,0,248,3,96,5,120,6,128,15,160,15,32,14,160,14,40,13,140,5,212,1,152,8,64,30,224,61,224,217,112,224,192,96,176,48,120
00292Dr 3  07 F8 0F 00  
002931r 3  0E C8 05 FC  
002959r 3  00 00 00 F8          .byte 0,0,0,248,1,254,3,192,3,178,1,127,0,62,0,216,1,94,1,160,3,232,3,200,3,168,3,138,3,99,1,117,0,102,2,16,7,184,15,120,54,92,56,48,24,44,12,30
00295Dr 3  01 FE 03 C0  
002961r 3  03 B2 01 7F  
002989r 3  00 00 00 3E          .byte 0,0,0,62,128,127,0,240,128,236,192,95,128,15,0,54,128,87,0,104,0,250,0,242,0,234,128,226,192,216,64,93,128,25,0,132,1,238,3,222,13,151,14,12,6,11,131,7
00298Dr 3  80 7F 00 F0  
002991r 3  80 EC C0 5F  
0029B9r 3  00 00 80 0F          .byte 0,0,128,15,224,31,0,60,32,59,240,23,224,3,128,13,224,21,0,26,128,62,128,60,128,58,160,56,48,54,80,23,96,6,0,33,128,123,128,247,195,101,3,131,193,130,224,193
0029BDr 3  E0 1F 00 3C  
0029C1r 3  20 3B F0 17  
0029E9r 3  00 00 03 E0          .byte 0,0,3,224,7,248,15,0,14,200,5,252,0,248,3,96,5,120,14,128,15,160,15,32,6,160,7,0,3,160,5,112,6,96,41,128,55,160,55,96,40,192,3,0,2,192,1,224
0029EDr 3  07 F8 0F 00  
0029F1r 3  0E C8 05 FC  
002A19r 3  00 00 00 F8          .byte 0,0,0,248,1,254,3,192,3,178,1,127,0,62,0,216,1,94,3,160,3,232,3,200,1,168,1,192,0,232,1,92,1,152,10,96,13,232,13,216,10,48,0,192,0,176,0,120
002A1Dr 3  01 FE 03 C0  
002A21r 3  03 B2 01 7F  
002A49r 3  00 00 00 3E          .byte 0,0,0,62,128,127,0,240,128,236,192,95,128,15,0,54,128,87,0,232,0,250,0,242,0,106,0,112,0,58,0,87,0,102,2,152,3,122,3,118,2,140,0,48,0,44,0,30
002A4Dr 3  80 7F 00 F0  
002A51r 3  80 EC C0 5F  
002A79r 3  00 00 80 0F          .byte 0,0,128,15,224,31,0,60,32,59,240,23,224,3,128,13,224,21,0,58,128,62,128,60,128,26,0,28,128,14,192,21,128,25,0,166,128,222,128,221,0,163,0,12,0,11,128,7
002A7Dr 3  E0 1F 00 3C  
002A81r 3  20 3B F0 17  
002AA9r 3  00 00 03 E0          .byte 0,0,3,224,7,248,15,0,14,200,5,252,0,248,3,96,1,120,2,128,3,160,11,160,27,32,51,192,53,232,38,220,48,24,6,96,7,176,7,144,1,96,4,240,11,0,7,128
002AADr 3  07 F8 0F 00  
002AB1r 3  0E C8 05 FC  
002AD9r 3  00 00 00 F8          .byte 0,0,0,248,1,254,3,192,3,178,1,127,0,62,0,216,0,94,0,160,0,232,2,232,6,200,12,240,13,122,9,183,12,6,1,152,1,236,1,228,0,88,1,60,2,192,1,224
002ADDr 3  01 FE 03 C0  
002AE1r 3  03 B2 01 7F  
002B09r 3  00 00 00 3E          .byte 0,0,0,62,128,127,0,240,128,236,192,95,128,15,0,54,128,23,0,40,0,58,0,186,1,178,3,60,131,94,194,109,131,1,0,102,0,123,0,121,0,22,0,79,0,176,0,120
002B0Dr 3  80 7F 00 F0  
002B11r 3  80 EC C0 5F  
002B39r 3  00 00 80 0F          .byte 0,0,128,15,224,31,0,60,32,59,240,23,224,3,128,13,224,5,0,10,128,14,128,46,128,108,0,207,160,215,112,155,96,192,128,25,192,30,64,30,128,5,192,19,0,44,0,30
002B3Dr 3  E0 1F 00 3C  
002B41r 3  20 3B F0 17  
002B69r 3  00 00 00 00          .byte 0,0,0,0,3,224,7,248,15,0,14,200,5,252,2,248,1,96,6,120,15,128,14,160,14,160,15,0,3,160,5,112,6,96,1,128,5,248,14,216,31,54,48,44,44,24,30,0
002B6Dr 3  03 E0 07 F8  
002B71r 3  0F 00 0E C8  
002B99r 3  00 00 00 00          .byte 0,0,0,0,0,248,1,254,3,192,3,178,1,127,0,190,0,88,1,158,3,224,3,168,3,168,3,192,0,232,1,92,1,152,0,96,1,126,3,182,135,205,12,11,11,6,7,128
002B9Dr 3  00 F8 01 FE  
002BA1r 3  03 C0 03 B2  
002BC9r 3  00 00 00 00          .byte 0,0,0,0,0,62,128,127,0,240,128,236,192,95,128,47,0,22,128,103,0,248,0,234,0,234,0,240,0,58,0,87,0,102,0,24,128,95,128,237,97,243,195,2,130,193,1,224
002BCDr 3  00 3E 80 7F  
002BD1r 3  00 F0 80 EC  
002BF9r 3  00 00 00 00          .byte 0,0,0,0,128,15,224,31,0,60,32,59,240,23,224,11,128,5,224,25,0,62,128,58,128,58,0,60,128,14,192,21,128,25,0,6,224,23,96,59,216,124,176,192,96,176,0,120
002BFDr 3  80 0F E0 1F  
002C01r 3  00 3C 20 3B  
002C29r 3  00 00 00 00          .byte 0,0,0,0,3,224,7,248,15,0,14,200,5,252,2,248,1,96,14,120,15,128,30,160,29,160,30,160,15,64,2,200,0,200,1,48,13,248,30,253,62,27,36,7,24,2,60,0
002C2Dr 3  03 E0 07 F8  
002C31r 3  0F 00 0E C8  
002C59r 3  00 00 00 00          .byte 0,0,0,0,0,248,1,254,3,192,3,178,1,127,0,190,0,88,3,158,3,224,7,168,7,104,7,168,3,208,0,178,0,50,0,76,3,126,71,191,207,134,201,1,134,0,15,0
002C5Dr 3  00 F8 01 FE  
002C61r 3  03 C0 03 B2  
002C89r 3  00 00 00 00          .byte 0,0,0,0,0,62,128,127,0,240,128,236,192,95,128,47,0,22,128,231,0,248,1,234,1,218,1,234,0,244,128,44,128,12,0,19,128,223,209,239,179,225,114,64,33,128,3,192
002C8Dr 3  00 3E 80 7F  
002C91r 3  00 F0 80 EC  
002CB9r 3  00 00 00 00          .byte 0,0,0,0,128,15,224,31,0,60,32,59,240,23,224,11,128,5,224,57,0,62,128,122,128,118,128,122,0,61,32,11,32,3,192,4,224,55,244,123,108,248,28,144,8,96,0,240
002CBDr 3  80 0F E0 1F  
002CC1r 3  00 3C 20 3B  
002CE9r 3  00 00 00 00          .byte 0,0,0,0,7,192,31,224,0,240,19,112,63,160,31,64,6,176,30,120,1,248,5,188,21,220,53,188,51,88,80,224,103,96,15,144,15,120,26,60,92,30,108,6,112,26,56,60
002CEDr 3  07 C0 1F E0  
002CF1r 3  00 F0 13 70  
002D19r 3  00 00 00 00          .byte 0,0,0,0,1,240,7,248,0,60,4,220,15,232,7,208,1,172,7,158,0,126,1,111,5,119,13,111,12,214,20,56,25,216,3,228,3,222,6,143,151,7,155,1,156,6,14,15
002D1Dr 3  01 F0 07 F8  
002D21r 3  00 3C 04 DC  
002D49r 3  00 00 00 00          .byte 0,0,0,0,0,124,1,254,0,15,1,55,3,250,1,244,0,107,129,231,128,31,192,91,193,93,195,91,131,53,5,14,6,118,0,249,128,247,193,163,229,193,102,192,167,1,195,131
002D4Dr 3  00 7C 01 FE  
002D51r 3  00 0F 01 37  
002D79r 3  00 00 00 00          .byte 0,0,0,0,0,31,128,127,192,3,192,77,128,254,0,125,192,26,224,121,224,7,240,22,112,87,240,214,96,205,129,67,129,157,64,62,224,61,240,104,121,112,25,176,105,192,240,224
002D7Dr 3  00 1F 80 7F  
002D81r 3  C0 03 C0 4D  
002DA9r 3  00 00 07 C0          .byte 0,0,7,192,31,224,0,240,19,112,63,160,31,0,6,192,30,160,1,96,5,240,4,240,5,112,20,112,49,176,43,160,25,128,2,16,7,120,7,188,14,155,3,7,13,6,30,12
002DADr 3  1F E0 00 F0  
002DB1r 3  13 70 3F A0  
002DD9r 3  00 00 01 F0          .byte 0,0,1,240,7,248,0,60,4,220,15,232,7,192,1,176,7,168,0,88,1,124,1,60,1,92,5,28,12,108,10,232,6,96,0,132,1,222,1,239,195,166,192,193,131,65,7,131
002DDDr 3  07 F8 00 3C  
002DE1r 3  04 DC 0F E8  
002E09r 3  00 00 00 7C          .byte 0,0,0,124,1,254,0,15,1,55,3,250,1,240,0,108,1,234,0,22,0,95,0,79,0,87,1,71,3,27,2,186,1,152,0,33,128,119,192,123,176,233,112,48,96,208,193,224
002E0Dr 3  01 FE 00 0F  
002E11r 3  01 37 03 FA  
002E39r 3  00 00 00 1F          .byte 0,0,0,31,128,127,192,3,192,77,128,254,0,124,0,27,128,122,128,5,192,23,192,19,192,21,192,81,192,198,128,174,0,102,64,8,224,29,240,30,108,58,28,12,24,52,48,120
002E3Dr 3  80 7F C0 03  
002E41r 3  C0 4D 80 FE  
002E69r 3  00 00 07 C0          .byte 0,0,7,192,31,224,0,240,19,112,63,160,31,0,6,192,30,160,1,112,5,240,4,240,5,96,0,224,5,192,14,160,6,96,1,148,5,236,6,236,3,20,0,192,3,64,7,128
002E6Dr 3  1F E0 00 F0  
002E71r 3  13 70 3F A0  
002E99r 3  00 00 01 F0          .byte 0,0,1,240,7,248,0,60,4,220,15,232,7,192,1,176,7,168,0,92,1,124,1,60,1,88,0,56,1,112,3,168,1,152,0,101,1,123,1,187,0,197,0,48,0,208,1,224
002E9Dr 3  07 F8 00 3C  
002EA1r 3  04 DC 0F E8  
002EC9r 3  00 00 00 7C          .byte 0,0,0,124,1,254,0,15,1,55,3,250,1,240,0,108,1,234,0,23,0,95,0,79,0,86,0,14,0,92,0,234,0,102,64,25,192,94,192,110,64,49,0,12,0,52,0,120
002ECDr 3  01 FE 00 0F  
002ED1r 3  01 37 03 FA  
002EF9r 3  00 00 00 1F          .byte 0,0,0,31,128,127,192,3,192,77,128,254,0,124,0,27,128,122,192,5,192,23,192,19,128,21,128,3,0,23,128,58,128,25,80,6,176,23,176,27,80,12,0,3,0,13,0,30
002EFDr 3  80 7F C0 03  
002F01r 3  C0 4D 80 FE  
002F29r 3  00 00 07 C0          .byte 0,0,7,192,31,224,0,240,19,112,63,160,31,0,6,192,30,128,1,64,5,192,5,208,4,216,3,204,23,172,59,100,24,12,6,96,13,224,9,224,6,128,15,32,0,208,1,224
002F2Dr 3  1F E0 00 F0  
002F31r 3  13 70 3F A0  
002F59r 3  00 00 01 F0          .byte 0,0,1,240,7,248,0,60,4,220,15,232,7,192,1,176,7,160,0,80,1,112,1,116,1,54,0,243,5,235,14,217,6,3,1,152,3,120,2,120,1,160,3,200,0,52,0,120
002F5Dr 3  07 F8 00 3C  
002F61r 3  04 DC 0F E8  
002F89r 3  00 00 00 7C          .byte 0,0,0,124,1,254,0,15,1,55,3,250,1,240,0,108,1,232,0,20,0,92,0,93,128,77,192,60,193,122,67,182,193,128,0,102,0,222,0,158,0,104,0,242,0,13,0,30
002F8Dr 3  01 FE 00 0F  
002F91r 3  01 37 03 FA  
002FB9r 3  00 00 00 1F          .byte 0,0,0,31,128,127,192,3,192,77,128,254,0,124,0,27,0,122,0,5,0,23,64,23,96,19,48,15,176,94,144,237,48,96,128,25,128,55,128,39,0,26,128,60,64,3,128,7
002FBDr 3  80 7F C0 03  
002FC1r 3  C0 4D 80 FE  
002FE9r 3  00 00 00 00          .byte 0,0,0,0,7,192,31,224,0,240,19,112,63,160,31,64,6,128,30,96,1,240,5,112,5,112,0,240,5,192,14,160,6,96,1,128,31,160,27,112,108,248,52,12,24,52,0,120
002FEDr 3  07 C0 1F E0  
002FF1r 3  00 F0 13 70  
003019r 3  00 00 00 00          .byte 0,0,0,0,1,240,7,248,0,60,4,220,15,232,7,208,1,160,7,152,0,124,1,92,1,92,0,60,1,112,3,168,1,152,0,96,7,232,6,220,27,62,13,3,6,13,0,30
00301Dr 3  01 F0 07 F8  
003021r 3  00 3C 04 DC  
003049r 3  00 00 00 00          .byte 0,0,0,0,0,124,1,254,0,15,1,55,3,250,1,244,0,104,1,230,0,31,0,87,0,87,0,15,0,92,0,234,0,102,0,24,1,250,1,183,134,207,195,64,65,131,128,7
00304Dr 3  00 7C 01 FE  
003051r 3  00 0F 01 37  
003079r 3  00 00 00 00          .byte 0,0,0,0,0,31,128,127,192,3,192,77,128,254,0,125,0,26,128,121,192,7,192,21,192,21,192,3,0,23,128,58,128,25,0,6,128,126,192,109,225,179,48,208,208,96,224,1
00307Dr 3  00 1F 80 7F  
003081r 3  C0 03 C0 4D  
0030A9r 3  00 00 00 00          .byte 0,0,0,0,7,192,31,224,0,240,19,112,63,160,31,64,6,128,30,112,1,240,5,120,5,184,5,120,2,240,19,64,19,0,12,128,31,176,191,120,216,124,224,36,64,24,0,60
0030ADr 3  07 C0 1F E0  
0030B1r 3  00 F0 13 70  
0030D9r 3  00 00 00 00          .byte 0,0,0,0,1,240,7,248,0,60,4,220,15,232,7,208,1,160,7,156,0,124,1,94,1,110,1,94,0,188,4,208,4,192,3,32,7,236,47,222,54,31,56,9,16,6,0,15
0030DDr 3  01 F0 07 F8  
0030E1r 3  00 3C 04 DC  
003109r 3  00 00 00 00          .byte 0,0,0,0,0,124,1,254,0,15,1,55,3,250,1,244,0,104,1,231,0,31,128,87,128,91,128,87,0,47,1,52,1,48,0,200,1,251,139,247,205,135,78,2,132,1,192,3
00310Dr 3  00 7C 01 FE  
003111r 3  00 0F 01 37  
003139r 3  00 00 00 00          .byte 0,0,0,0,0,31,128,127,192,3,192,77,128,254,0,125,0,26,192,121,192,7,224,21,224,22,224,21,192,11,0,77,0,76,0,50,192,126,226,253,243,97,147,128,97,0,240,0
00313Dr 3  00 1F 80 7F  
003141r 3  C0 03 C0 4D  
003169r 3               frmlst:
003169r 3  00 06                .byte 0,6
00316Br 3  06 06                .byte 6,6
00316Dr 3  0C 06                .byte 12,6
00316Fr 3  12 06 18 00          .byte 18,6,24,0
003173r 3               scdat:
003173r 3  65 00                .word 101
003175r 3  FF 01 17 FF          .byte 255,1,23,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1
003179r 3  00 14 01 01  
00317Dr 3  FF 00 14 01  
003196r 3  FF 00 14 01          .byte 255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,16
00319Ar 3  01 FF 00 14  
00319Er 3  01 01 FF 00  
0031B7r 3  FF 01 06 FF          .byte 255,1,6,255,0,20,1,1,255,0,20,1,1,255,0,9,255,1,6,255,0,5,1,1,255,0,20,1,1,255,0,20,255,1,23
0031BBr 3  00 14 01 01  
0031BFr 3  FF 00 14 01  
0031DAr 3               numsc:
0031DAr 3  01                   .byte 1
0031DBr 3               nmedat:
0031DBr 3  00 00 50 28          .byte 0,0,80,40,255
0031DFr 3  FF           
0031E0r 3               NUMOBJ = 3
0031E0r 3               objdta:
0031E0r 3  FF FF 80 01          .byte 255,255,128,1,128,1,128,1,129,1,129,1,129,1,129,1,129,1,129,1,129,1,129,1,128,1,128,1,128,1,255,255,0,255,5,6,255,5,6
0031E4r 3  80 01 80 01  
0031E8r 3  81 01 81 01  
003207r 3  FF FF 80 01          .byte 255,255,128,1,128,1,128,1,131,129,128,129,128,129,131,129,130,1,130,1,130,1,131,129,128,1,128,1,128,1,255,255,0,255,11,11,255,11,11
00320Br 3  80 01 80 01  
00320Fr 3  83 81 80 81  
00322Er 3  FF FF 80 01          .byte 255,255,128,1,128,1,128,1,131,129,128,129,128,129,131,129,128,129,128,129,128,129,131,129,128,1,128,1,128,1,255,255,0,255,19,18,255,19,18
003232r 3  80 01 80 01  
003236r 3  83 81 80 81  
003255r 3               font:
003255r 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
003259r 3  00 00 00 00  
00325Dr 3  00 30 30 30          .byte 0,48,48,48,48,0,48,0
003261r 3  30 00 30 00  
003265r 3  00 6C 6C 00          .byte 0,108,108,0,0,0,0,0
003269r 3  00 00 00 00  
00326Dr 3  00 6C FE 6C          .byte 0,108,254,108,108,254,108,0
003271r 3  6C FE 6C 00  
003275r 3  00 18 7E 78          .byte 0,24,126,120,126,30,126,24
003279r 3  7E 1E 7E 18  
00327Dr 3  00 E6 EC 18          .byte 0,230,236,24,48,110,206,0
003281r 3  30 6E CE 00  
003285r 3  00 30 78 30          .byte 0,48,120,48,126,204,126,0
003289r 3  7E CC 7E 00  
00328Dr 3  00 18 30 00          .byte 0,24,48,0,0,0,0,0
003291r 3  00 00 00 00  
003295r 3  00 0C 18 18          .byte 0,12,24,24,24,24,12,0
003299r 3  18 18 0C 00  
00329Dr 3  00 60 30 30          .byte 0,96,48,48,48,48,96,0
0032A1r 3  30 30 60 00  
0032A5r 3  00 00 3C 18          .byte 0,0,60,24,126,24,60,0
0032A9r 3  7E 18 3C 00  
0032ADr 3  00 00 18 18          .byte 0,0,24,24,126,24,24,0
0032B1r 3  7E 18 18 00  
0032B5r 3  00 00 00 00          .byte 0,0,0,0,0,24,24,48
0032B9r 3  00 18 18 30  
0032BDr 3  00 00 00 18          .byte 0,0,0,24,36,24,0,0
0032C1r 3  24 18 00 00  
0032C5r 3  00 00 00 00          .byte 0,0,0,0,0,56,56,0
0032C9r 3  00 38 38 00  
0032CDr 3  00 00 06 0C          .byte 0,0,6,12,24,48,96,0
0032D1r 3  18 30 60 00  
0032D5r 3  00 7C EE EE          .byte 0,124,238,238,238,238,124,0
0032D9r 3  EE EE 7C 00  
0032DDr 3  00 38 3C 1C          .byte 0,56,60,28,28,126,126,0
0032E1r 3  1C 7E 7E 00  
0032E5r 3  00 7C FE 1E          .byte 0,124,254,30,248,246,254,0
0032E9r 3  F8 F6 FE 00  
0032EDr 3  00 7C DE 3C          .byte 0,124,222,60,30,254,124,0
0032F1r 3  1E FE 7C 00  
0032F5r 3  00 1C 3C 7C          .byte 0,28,60,124,220,254,60,0
0032F9r 3  DC FE 3C 00  
0032FDr 3  00 FE F6 F8          .byte 0,254,246,248,62,222,124,0
003301r 3  3E DE 7C 00  
003305r 3  00 7C EC F2          .byte 0,124,236,242,254,238,124,0
003309r 3  FE EE 7C 00  
00330Dr 3  00 FE FE 0E          .byte 0,254,254,14,60,120,120,0
003311r 3  3C 78 78 00  
003315r 3  00 7C EE 7C          .byte 0,124,238,124,238,238,124,0
003319r 3  EE EE 7C 00  
00331Dr 3  00 7C FE F6          .byte 0,124,254,246,222,62,124,0
003321r 3  DE 3E 7C 00  
003325r 3  00 00 30 30          .byte 0,0,48,48,0,48,48,0
003329r 3  00 30 30 00  
00332Dr 3  00 7C 82 BA          .byte 0,124,130,186,162,186,130,124
003331r 3  A2 BA 82 7C  
003335r 3  00 00 0C 18          .byte 0,0,12,24,48,24,12,0
003339r 3  30 18 0C 00  
00333Dr 3  00 00 00 7E          .byte 0,0,0,126,0,126,0,0
003341r 3  00 7E 00 00  
003345r 3  00 00 30 18          .byte 0,0,48,24,12,24,48,0
003349r 3  0C 18 30 00  
00334Dr 3  00 7C C6 0C          .byte 0,124,198,12,24,0,24,0
003351r 3  18 00 18 00  
003355r 3  00 7C DE FE          .byte 0,124,222,254,254,192,124,0
003359r 3  FE C0 7C 00  
00335Dr 3  00 7C EE FE          .byte 0,124,238,254,238,238,108,0
003361r 3  EE EE 6C 00  
003365r 3  00 7C EE FC          .byte 0,124,238,252,238,254,124,0
003369r 3  EE FE 7C 00  
00336Dr 3  00 7C FE E0          .byte 0,124,254,224,254,254,124,0
003371r 3  FE FE 7C 00  
003375r 3  00 FC EE EE          .byte 0,252,238,238,254,254,252,0
003379r 3  FE FE FC 00  
00337Dr 3  00 7E F0 FC          .byte 0,126,240,252,240,254,126,0
003381r 3  F0 FE 7E 00  
003385r 3  00 7E F0 FC          .byte 0,126,240,252,240,240,240,0
003389r 3  F0 F0 F0 00  
00338Dr 3  00 7C FE F0          .byte 0,124,254,240,238,246,124,0
003391r 3  EE F6 7C 00  
003395r 3  00 EE EE FE          .byte 0,238,238,254,254,238,238,0
003399r 3  FE EE EE 00  
00339Dr 3  00 7E 7E 3C          .byte 0,126,126,60,60,126,126,0
0033A1r 3  3C 7E 7E 00  
0033A5r 3  00 1E 1E 1E          .byte 0,30,30,30,222,254,124,0
0033A9r 3  DE FE 7C 00  
0033ADr 3  00 EE FC F8          .byte 0,238,252,248,248,252,238,0
0033B1r 3  F8 FC EE 00  
0033B5r 3  00 70 F0 F0          .byte 0,112,240,240,252,254,126,0
0033B9r 3  FC FE 7E 00  
0033BDr 3  00 D6 FE FE          .byte 0,214,254,254,238,238,238,0
0033C1r 3  EE EE EE 00  
0033C5r 3  00 CE EE FE          .byte 0,206,238,254,254,238,230,0
0033C9r 3  FE EE E6 00  
0033CDr 3  00 7C FE EE          .byte 0,124,254,238,238,254,124,0
0033D1r 3  EE FE 7C 00  
0033D5r 3  00 FC EE EE          .byte 0,252,238,238,252,240,240,0
0033D9r 3  FC F0 F0 00  
0033DDr 3  00 7C FE FE          .byte 0,124,254,254,238,242,124,0
0033E1r 3  EE F2 7C 00  
0033E5r 3  00 FC FE EE          .byte 0,252,254,238,252,238,238,0
0033E9r 3  FC EE EE 00  
0033EDr 3  00 7C F0 FC          .byte 0,124,240,252,30,254,124,0
0033F1r 3  1E FE 7C 00  
0033F5r 3  00 FE FE 38          .byte 0,254,254,56,124,124,124,0
0033F9r 3  7C 7C 7C 00  
0033FDr 3  00 EE EE EE          .byte 0,238,238,238,238,254,124,0
003401r 3  EE FE 7C 00  
003405r 3  00 EE EE EE          .byte 0,238,238,238,238,124,56,0
003409r 3  EE 7C 38 00  
00340Dr 3  00 EE EE EE          .byte 0,238,238,238,254,254,108,0
003411r 3  FE FE 6C 00  
003415r 3  00 EE FE 7C          .byte 0,238,254,124,254,254,238,0
003419r 3  FE FE EE 00  
00341Dr 3  00 EE EE FE          .byte 0,238,238,254,62,254,252,0
003421r 3  3E FE FC 00  
003425r 3  00 FE FE B8          .byte 0,254,254,184,118,254,254,0
003429r 3  76 FE FE 00  
00342Dr 3  00 1E 18 18          .byte 0,30,24,24,24,24,30,0
003431r 3  18 18 1E 00  
003435r 3  00 00 C0 60          .byte 0,0,192,96,48,24,12,0
003439r 3  30 18 0C 00  
00343Dr 3  00 F0 30 30          .byte 0,240,48,48,48,48,240,0
003441r 3  30 30 F0 00  
003445r 3  00 30 78 FC          .byte 0,48,120,252,48,48,48,0
003449r 3  30 30 30 00  
00344Dr 3  00 00 00 00          .byte 0,0,0,0,0,0,0,255
003451r 3  00 00 00 FF  
003455r 3  00 3C 66 F8          .byte 0,60,102,248,96,96,254,0
003459r 3  60 60 FE 00  
00345Dr 3  00 00 78 0C          .byte 0,0,120,12,124,204,124,0
003461r 3  7C CC 7C 00  
003465r 3  00 60 60 7C          .byte 0,96,96,124,102,102,124,0
003469r 3  66 66 7C 00  
00346Dr 3  00 00 3C 60          .byte 0,0,60,96,96,96,60,0
003471r 3  60 60 3C 00  
003475r 3  00 0C 0C 7C          .byte 0,12,12,124,204,204,124,0
003479r 3  CC CC 7C 00  
00347Dr 3  00 00 78 CC          .byte 0,0,120,204,248,192,124,0
003481r 3  F8 C0 7C 00  
003485r 3  00 1C 30 38          .byte 0,28,48,56,48,48,48,0
003489r 3  30 30 30 00  
00348Dr 3  00 00 7C CC          .byte 0,0,124,204,204,124,12,120
003491r 3  CC 7C 0C 78  
003495r 3  00 C0 C0 F8          .byte 0,192,192,248,204,204,204,0
003499r 3  CC CC CC 00  
00349Dr 3  00 30 00 70          .byte 0,48,0,112,48,48,120,0
0034A1r 3  30 30 78 00  
0034A5r 3  00 0C 00 0C          .byte 0,12,0,12,12,12,108,56
0034A9r 3  0C 0C 6C 38  
0034ADr 3  00 60 78 70          .byte 0,96,120,112,112,120,108,0
0034B1r 3  70 78 6C 00  
0034B5r 3  00 30 30 30          .byte 0,48,48,48,48,48,28,0
0034B9r 3  30 30 1C 00  
0034BDr 3  00 00 F8 FC          .byte 0,0,248,252,252,252,252,0
0034C1r 3  FC FC FC 00  
0034C5r 3  00 00 F8 CC          .byte 0,0,248,204,204,204,204,0
0034C9r 3  CC CC CC 00  
0034CDr 3  00 00 78 CC          .byte 0,0,120,204,204,204,120,0
0034D1r 3  CC CC 78 00  
0034D5r 3  00 00 F8 CC          .byte 0,0,248,204,204,248,192,192
0034D9r 3  CC F8 C0 C0  
0034DDr 3  00 00 7C CC          .byte 0,0,124,204,204,124,12,14
0034E1r 3  CC 7C 0C 0E  
0034E5r 3  00 00 3C 60          .byte 0,0,60,96,96,96,96,0
0034E9r 3  60 60 60 00  
0034EDr 3  00 00 78 C0          .byte 0,0,120,192,120,12,248,0
0034F1r 3  78 0C F8 00  
0034F5r 3  00 30 78 30          .byte 0,48,120,48,48,48,28,0
0034F9r 3  30 30 1C 00  
0034FDr 3  00 00 CC CC          .byte 0,0,204,204,204,204,120,0
003501r 3  CC CC 78 00  
003505r 3  00 00 CC CC          .byte 0,0,204,204,120,120,48,0
003509r 3  78 78 30 00  
00350Dr 3  00 00 CC FC          .byte 0,0,204,252,252,252,120,0
003511r 3  FC FC 78 00  
003515r 3  00 00 CC 78          .byte 0,0,204,120,48,120,204,0
003519r 3  30 78 CC 00  
00351Dr 3  00 00 CC CC          .byte 0,0,204,204,204,124,12,120
003521r 3  CC 7C 0C 78  
003525r 3  00 00 FC 18          .byte 0,0,252,24,48,96,252,0
003529r 3  30 60 FC 00  
00352Dr 3  00 1E 18 70          .byte 0,30,24,112,24,24,30,0
003531r 3  18 18 1E 00  
003535r 3  00 18 18 18          .byte 0,24,24,24,24,24,24,0
003539r 3  18 18 18 00  
00353Dr 3  00 F0 30 1C          .byte 0,240,48,28,48,48,240,0
003541r 3  30 30 F0 00  
003545r 3  00 3C 78 00          .byte 0,60,120,0,0,0,0,0
003549r 3  00 00 00 00  
00354Dr 3  7C C6 BB E3          .byte 124,198,187,227,227,187,198,124
003551r 3  E3 BB C6 7C  
003555r 3               jtab:
003555r 3  F8 FA FC FE          .byte 248,250,252,254,254,255,255,255,0,0,0,1,1,1,2,2,4,6,8,8,8,99
003559r 3  FE FF FF FF  
00355Dr 3  00 00 00 01  
00356Br 3  65 14 51 10  keys:   .byte 101,20,81,16,48,68,52,112,0,113,1
00356Fr 3  30 44 34 70  
003573r 3  00 71 01     
003576r 3               
003576r 2               
003576r 1               	.include "lib.inc"
003576r 2               ;----------------------------------------------------------------------
003576r 2               ; VIC20 Platform Specific functions
003576r 2               ;----------------------------------------------------------------------
003576r 2               
003576r 2               ;============================================================
003576r 2               ; PLATFORM VARIABLES
003576r 2               ;============================================================
003576r 2               ;
003576r 2               ; Memory map:
003576r 2               ;
003576r 2               ;	$0000-$01ff	 0.5kB	CPU WS
003576r 2               ;	$0200-$03ff	 0.5kB	VIDEO RAM
003576r 2               ;	$0400-$0fff	 3,0kB	RAM
003576r 2               ;	$1000-$1fff	 4,0kB	CHAR RAM
003576r 2               ;	$2000-$7fff	24,0kB	RAM
003576r 2               ;	$8000-$8fff	 4,0kB	CHAR ROM
003576r 2               ;	$9000-$93ff	 1,0kB	VIC VIA's
003576r 2               ;	$9600-$97ff	 1,0kB	COLOUR RAM
003576r 2               ;	$9800-$9fff	 2,0kB	I/O
003576r 2               ;	$a000-$bfff	 8,0kB	RAM
003576r 2               ;	$c000-$dfff	 8,0kB	BASIC ROM
003576r 2               ;	$e000-$ffff	 8,0kB	KERNAL ROM
003576r 2               ;
003576r 2               ; Keyboard matrix:
003576r 2               ;                          	  $9121
003576r 2               ;          $9120	b7  b6  b5  b4  b3  b2  b1  b0
003576r 2               ; 	127-0111 1111 	F7  Hom  -   0   8   6   4   2
003576r 2               ;               ASCII   ??  ??  45  48  56  54  52  50
003576r 2               ;                 VIC   07  06  05  04  03  02  01  00
003576r 2               ;
003576r 2               ; 	191-1011 1111 	F5       @   O   U   T   E   Q
003576r 2               ;               ASCII   ??  ??  64  79  85  84  69  81
003576r 2               ;                 VIC   17  16  15  14  13  12  11  10
003576r 2               ;
003576r 2               ; 	223-1101 1111 	F3   =   :   K   H   F   S  Com
003576r 2               ;               ASCII   ??  61  58  75  72  70  83  ??
003576r 2               ;                 VIC   27  26  25  24  23  22  21  20
003576r 2               ;
003576r 2               ; 	239-1110 1111 	F1  RSh  .   M   B   C   Z  Spc
003576r 2               ;               ASCII   ??  ??  46  77  66  67  90  32
003576r 2               ;                 VIC   37  36  35  34  33  32  31  30
003576r 2               ;
003576r 2               ; 	247-1111 0111	Cur  /   ,   N   V   X  LSh Run
003576r 2               ;               ASCII   ??  47  44  78  86  88  ??  ??
003576r 2               ;                 VIC   47  46  45  44  43  42  41  40
003576r 2               ;
003576r 2               ; 	251-1111 1011	Cur  ;   L   J   G   D   A  Ctr
003576r 2               ;               ASCII   ??  59  76  74  71  68  65  ??
003576r 2               ;                 VIC   57  56  55  54  53  52  51  50
003576r 2               ;
003576r 2               ; 	253-1111 1101	Ret  *   P   I   Y   R   W
003576r 2               ;               ASCII   13  42  80  73  89  82  87
003576r 2               ;                 VIC   67  66  65  64  63  62  61  60
003576r 2               ;
003576r 2               ; 	254-1111 1110	Del Pnd  +   9   7   5   3   1
003576r 2               ;               ASCII   08  ??  43  57  55  53  51  49
003576r 2               ;                 VIC   77  76  75  74  73  72  71  70
003576r 2               ;
003576r 2               ;	 P =$65,O=$14,A=$51,Q=$10
003576r 2               ;	SPC=$30,N=$44,M=$34
003576r 2               ;	 1 =$70,2=$00,3=$71,4=$01
003576r 2               ;
003576r 2               ; Joysticks:
003576r 2               ;
003576r 2               ;               b7    b6    b5    b4    b3    b2    b1    b0
003576r 2               ;	$9111	-     -     Fire  Left  Down  Up    -     -
003576r 2               ;	$9120	Right -     -     -     -     -     -     -
003576r 2               ;
003576r 2               ;	$9122	DDRB = Data Direction Register port $9120
003576r 2               ;               0 = input, 1 = output
003576r 2               ;		Bit7 should be 0 to read joystick $9120
003576r 2               ;
003576r 2               ; Video registers:
003576r 2               ;
003576r 2               ;	$9000	horizontal centering
003576r 2               ;		bits 0-6 horizontal centering
003576r 2               ;		bit  7 sets interlace scan
003576r 2               ;	$9001	vertical centering
003576r 2               ;	$9002	set # of columns
003576r 2               ;		bits 0-6 set # of columns
003576r 2               ;		bit 7 is part of video matrix address
003576r 2               ;	$9003	set # of rows
003576r 2               ;		bit 0 sets 8x8 or 16x8 chars
003576r 2               ;		bits 1-6 set # of rows
003576r 2               ;	$9005	start of character memory
003576r 2               ;		bits 0-3 start of character memory (default = 0)
003576r 2               ;		bits 4-7 is rest of video address (default= F)
003576r 2               ;		BITS 3,2,1,0 CM startinq address
003576r 2               ;			     HEX   DEC
003576r 2               ;		0000   ROM   8000  32768
003576r 2               ;		0001	     8400  33792
003576r 2               ;		0010	     8800  34816
003576r 2               ;		0011	     8C00  35840
003576r 2               ;		1000   RAM   0000  0000
003576r 2               ;		1001  xxxx
003576r 2               ;		1010  xxxx   unavail.
003576r 2               ;		1011  xxxx
003576r 2               ;		1100	     1000  4096
003576r 2               ;		1101	     1400  5120
003576r 2               ;		1110	     1800  6144
003576r 2               ;		1111	     1C00  7168
003576r 2               ;	$900f	Screen and border color register
003576r 2               ;		bits 4-7 select background color
003576r 2               ;		bits 0-2 select border color
003576r 2               ;		bit 3 selects inverted or normal mode
003576r 2               ;
003576r 2               ; $9110-$911F 6522 VIA#1
003576r 2               ; $9120-$912F 6522 VIA#2
003576r 2               ;
003576r 2               ;	$9110,$9120 	Port B output register
003576r 2               ;	$9111,$9121 	Port A output register
003576r 2               ;			(PA0) Bit 0=Serial CLK IN
003576r 2               ;			(PA1) Bit 1=Serial DATA IN
003576r 2               ;			(PA2) Bit 2=Joy 0
003576r 2               ;			(PA3) Bit 3=Joy 1
003576r 2               ;			(PA4) Bit 4=Joy 2
003576r 2               ;			(PA5) Bit 5 = Lightpen/Fire button
003576r 2               ;			(PA6) Bit 6=Cassette switch sense
003576r 2               ;			(PA7) Bit 7=Serial ATN out
003576r 2               ;	$9112,$9122	Data direction register B
003576r 2               ;	$9113,$9123	Data direction register A
003576r 2               ;	$9114,$9124	Timer 1 low byte
003576r 2               ;	$9115,$9125	Timer 1 high byte & counter
003576r 2               ;	$9116,$9126	Timer 1 low byte
003576r 2               ;	$9117,$9127	Timer 1 high byte
003576r 2               ;	$9118,$9128	Timer 2 low byte
003576r 2               ;	$9119,$9129	Timer 2 high byte
003576r 2               ;	$911A,$912A	Shift register
003576r 2               ;	$911B,$912B	Auxiliary control register
003576r 2               ;	$911C,$912C	Peripheral control register
003576r 2               ;			(CA1, CA2, CB1, CB2)
003576r 2               ;			CA1 = restore key (Bit 0)
003576r 2               ;			CA2 = cassette motor control (Bits 1-3)
003576r 2               ;			CB1 = interrupt signal for received
003576r 2               ;			RS-232 data (Bit 4)
003576r 2               ;			CB2=transmitted RS-232 data (Bits 5-7)
003576r 2               ;	$911D,$912D	Interrupt flag register
003576r 2               ;	$911E,$912E	Interrupt enable register
003576r 2               ;	$911F,$912F	Port A (Sense cassette switch)
003576r 2               
003576r 2               ; VIC constants
003576r 2               
003576r 2               ;	scrchar 	= 22				; char/line
003576r 2               ;	scrline		= 22				; lines/screen
003576r 2               	ScreenSize	= ScrWidth * ScrHeight * 8	; Screen size bytes
003576r 2               	ScreenRowBytes	= ScrWidth * 16			; bytes/line
003576r 2               	SpriteMaxY	= 161				; maxlines - 16 + 1
003576r 2               
003576r 2               ; VIC variables:
003576r 2               
003576r 2  00           	fontcol:	.byte 0		; Frontcolour text
003577r 2               
003577r 2               ; Addresses
003577r 2               
003577r 2               	MapAddr		= $400		; RAM
003577r 2               	ScreenAddr	= $0200		; VIDEO RAM
003577r 2               	CharAddress	= $1000		; CHAR RAM
003577r 2               	Reg0		= $9000		; Horizontal centering
003577r 2               	Reg1		= $9001		; Vertical centering
003577r 2               	Reg2		= $9002		; Set # of columns
003577r 2               	Reg3		= $9003		; Set # of rows
003577r 2               	Reg4		= $9004		; Vsync signal
003577r 2               	Reg5		= $9005		; Start of character memory
003577r 2               	RegE		= $900e		; Colour and auxcolour register
003577r 2               	RegF		= $900f		; Screen and border color register
003577r 2               
003577r 2               	JoyAddr1	= $9111		; Joystick address 1
003577r 2               	Timer11_Low  	= $9114		; Timer 1 low byte
003577r 2               	Timer11_High 	= $9115		; Timer 1 high byte
003577r 2               	Timer12_Low  	= $9118		; Timer 2 low byte
003577r 2               	Timer12_High 	= $9119		; Timer 2 high byte
003577r 2               	AUX1		= $911b		; Auxiliary control register
003577r 2               	IFR1		= $911d		; Interrupt Flag Register
003577r 2               	IER1		= $911e		; Interrupt Enable Register
003577r 2               
003577r 2               	KeyColAddr	= $9120		; Keyboard column (write)
003577r 2               	JoyAddr2	= $9120		; Joystick address 2
003577r 2               	KeyRowAddr	= $9121		; Keyboard row (read)
003577r 2               	DDRB		= $9122		; Bit7 must be 0 for joystick read
003577r 2               	Timer21_Low  	= $9124		; Timer 1 low byte
003577r 2               	Timer21_High 	= $9125		; Timer 1 high byte
003577r 2               	AUX2		= $912b		; Auxiliary control register
003577r 2               	IFR2		= $912d		; Interrupt Flag Register
003577r 2               	IER2		= $912e		; Interrupt Enable Register
003577r 2               
003577r 2               	ColorAttr	= $9600		; Color attributes
003577r 2               	HiRAM		= $a000		; Hi RAM 8kB
003577r 2               
003577r 2               ;----------------------------------------------------------------------
003577r 2               ; VIC20 video hardware fns
003577r 2               ;----------------------------------------------------------------------
003577r 2               
003577r 2               init:
003577r 2               
003577r 2               ; Disable interrupts
003577r 2               
003577r 2  A9 7F        	lda #$7f
003579r 2  8D 1E 91     	sta $911e
00357Cr 2  8D 2D 91     	sta $912d
00357Fr 2  8D 2E 91     	sta $912e
003582r 2               
003582r 2               ; Set audio volume to max
003582r 2  A9 0F        	lda #$0f
003584r 2  8D 0E 90     	sta $900e
003587r 2               
003587r 2               ; Init screen for NTSC
003587r 2               ; this sets the background and border color of the screen
003587r 2               ; in this case border black and background black
003587r 2               
003587r 2  A9 18        	lda #%00011000
003589r 2  8D 0F 90     	sta RegF
00358Cr 2               
00358Cr 2               ; Reset fontcolor
00358Cr 2  A9 00        	lda #0		; Black
00358Er 2  8D rr rr     	sta fontcol
003591r 2               
003591r 2               
003591r 2               ; max num of columns 24
003591r 2               
003591r 2  AD 02 90     	lda Reg2
003594r 2  29 80        	and #%10000000
003596r 2  09 16        	ora #ScrWidth
003598r 2  8D 02 90     	sta Reg2
00359Br 2               
00359Br 2               ; max num of lines (mult by 2 - 24) for 8x8 chars
00359Br 2               ; no multiply for 8x16 chars
00359Br 2               
00359Br 2  AD 03 90     	lda Reg3
00359Er 2  29 81        	and #%10000001
0035A0r 2  09 16        	ora #ScrWidth		; number of rows multipled by two
0035A2r 2  8D 03 90     	sta Reg3
0035A5r 2               
0035A5r 2               ; horizontal and vertical position must be set for
0035A5r 2               ; non standard screen resolution (standard 22x23)
0035A5r 2               ; same games even allow the user to change them
0035A5r 2               ; these values are for PAL for NTSC should be different
0035A5r 2               ; move horizontal position in the screen
0035A5r 2               
0035A5r 2  AD 00 90     	lda Reg0
0035A8r 2  29 80        	and #%10000000
0035AAr 2  09 04        	ora #CentreX
0035ACr 2  8D 00 90     	sta Reg0
0035AFr 2               
0035AFr 2               ; move vertical position in the screen
0035AFr 2               
0035AFr 2  A9 1B        	lda #CentreY
0035B1r 2  8D 01 90     	sta Reg1
0035B4r 2               
0035B4r 2               ; Set screem memory to $200
0035B4r 2               ; bit 7 on $9002 has to be set
0035B4r 2               
0035B4r 2  AD 02 90     	lda Reg2
0035B7r 2  09 80        	ora #%10000000
0035B9r 2  8D 02 90     	sta Reg2
0035BCr 2               
0035BCr 2               ; Set character data pointer to CHAR RAM at $1000
0035BCr 2               ; bit 7 on $9005 has always to be set
0035BCr 2               ; (based on compute - mapping the vic book)
0035BCr 2               ; color ram goes to 9600
0035BCr 2               
0035BCr 2  AD 05 90     	lda Reg5
0035BFr 2  29 0C        	and #%00001100
0035C1r 2  09 8C        	ora #%10001100
0035C3r 2  8D 05 90     	sta Reg5
0035C6r 2               
0035C6r 2               ; This set the char size to 8x16
0035C6r 2               
0035C6r 2  AD 03 90     	lda Reg3
0035C9r 2  09 01        	ora #%00000001
0035CBr 2  8D 03 90     	sta Reg3
0035CEr 2               
0035CEr 2               ; Init screencharacters
0035CEr 2               ; Fill screen with characters from left to right, up to down
0035CEr 2               
0035CEr 2  A2 00        	ldx #0
0035D0r 2  A0 00        	ldy #0
0035D2r 2               scrinit:
0035D2r 2  8A           	txa
0035D3r 2  9D 00 02     	sta ScreenAddr,x
0035D6r 2  98           	tya
0035D7r 2  9D 00 96     	sta ColorAttr,x
0035DAr 2  E8           	inx
0035DBr 2  E0 F2        	cpx#242
0035DDr 2  D0 F3        	bne scrinit
0035DFr 2               
0035DFr 2               ; Reset fontcolor
0035DFr 2               
0035DFr 2  A9 00        	lda #0			; Black
0035E1r 2  8D rr rr     	sta fontcol
0035E4r 2               
0035E4r 2               ; Init music
0035E4r 2               
0035E4r 2               ;	jsr initmusic
0035E4r 2               
0035E4r 2               ; Init VIA1 timer11 for timeout 1/25 sec
0035E4r 2               
0035E4r 2  A9 E0        	lda #$e0		; T1 continuous
0035E6r 2  8D 1B 91     	sta AUX1
0035E9r 2  A9 7F        	lda #$7f		; No int
0035EBr 2  8D 1E 91     	sta IER1
0035EEr 2  A9 00        	lda #0
0035F0r 2  8D 1D 91     	sta IFR1		; Clear interrupt flags
0035F3r 2  A9 20        	lda #<timervalue	; Timer 1/25 sec
0035F5r 2  8D 14 91     	sta Timer11_Low
0035F8r 2  A9 4E        	lda #>timervalue
0035FAr 2  8D 15 91     	sta Timer11_High
0035FDr 2               
0035FDr 2               ; Pre-shifted byte tables if parameter 'r' given
0035FDr 2               ; 4 tables are created which 0,2,4 ad 6 bits pre-shifted
0035FDr 2               ; The bits are shifted to the right and overflow bits are
0035FDr 2               ; inserted to the left. So 1 byte contains a left and right part
0035FDr 2               
0035FDr 2               .if rflag
0035FDr 2               shift0 = HiRAM
0035FDr 2               shift2 = HiRAM+256
0035FDr 2               shift4 = HiRAM+512
0035FDr 2               shift6 = HiRAM+768
0035FDr 2               
0035FDr 2               ; Pre-shifted table 0 pixels
0035FDr 2               
0035FDr 2               	ldx #0
0035FDr 2               shf0:
0035FDr 2               	txa
0035FDr 2               	sta shift0,x
0035FDr 2               	inx
0035FDr 2               	bne shf0
0035FDr 2               
0035FDr 2               ; Pre-shifted table 2 pixels
0035FDr 2               
0035FDr 2               	ldx #0
0035FDr 2               shf2:
0035FDr 2               	ldy #2
0035FDr 2               	txa
0035FDr 2               shf2loop:
0035FDr 2               	lsr a
0035FDr 2               	bcc :+
0035FDr 2               	ora #$80
0035FDr 2               :
0035FDr 2               	dey
0035FDr 2               	bne shf2loop
0035FDr 2               	sta shift2,x
0035FDr 2               	inx
0035FDr 2               	bne shf2
0035FDr 2               
0035FDr 2               ; Pre-shifted table 4 pixels
0035FDr 2               
0035FDr 2               	ldx #0
0035FDr 2               shf4:
0035FDr 2               	ldy #4
0035FDr 2               	txa
0035FDr 2               shf4loop:
0035FDr 2               	lsr a
0035FDr 2               	bcc :+
0035FDr 2               	ora #$80
0035FDr 2               :
0035FDr 2               	dey
0035FDr 2               	bne shf4loop
0035FDr 2               	sta shift4,x
0035FDr 2               	inx
0035FDr 2               	bne shf4
0035FDr 2               
0035FDr 2               ; Pre-shifted table 6 pixels
0035FDr 2               
0035FDr 2               	ldx #0
0035FDr 2               shf6:
0035FDr 2               	ldy #6
0035FDr 2               	txa
0035FDr 2               shf6loop:
0035FDr 2               	lsr a
0035FDr 2               	bcc :+
0035FDr 2               	ora #$80
0035FDr 2               :
0035FDr 2               	dey
0035FDr 2               	bne shf6loop
0035FDr 2               	sta shift6,x
0035FDr 2               	inx
0035FDr 2               	bne shf6
0035FDr 2               .endif
0035FDr 2               
0035FDr 2  60           	rts
0035FEr 2               
0035FEr 2               ;========================================================
0035FEr 2               ; KEY AND JOYSTICK ROUTINES
0035FEr 2               ;--------------------------------------------------------
0035FEr 2               ; Keys
0035FEr 2               ;
0035FEr 2               ; Out: joyval=x65FUDLR (bit cleared if key pressed)
0035FEr 2               ;             ||||||||
0035FEr 2               ;             |||||||+> Right    KEY 0  - X
0035FEr 2               ;             ||||||+-> Left     KEY 1  - Z
0035FEr 2               ;             |||||+--> Down     KEY 2  - .
0035FEr 2               ;             ||||+---> Up       KEY 3  - ;
0035FEr 2               ;             |||+----> Fire1    KEY 4  - SPC
0035FEr 2               ;             ||+-----> Fire2    KEY 5  - Q
0035FEr 2               ;             |+------> Fire3    KEY 6  - P
0035FEr 2               ;             +-------> Not used
0035FEr 2               ;
0035FEr 2               ;                       Option1  KEY 7  - 1
0035FEr 2               ;                       Option2  KEY 8  - 2
0035FEr 2               ;                       Option3  KEY 9  - 3
0035FEr 2               ;                       Option4  KEY 10 - 4
0035FEr 2               ;--------------------------------------------------------
0035FEr 2               
0035FEr 2               ;----------------------------------------------------
0035FEr 2               ; Interrupt service
0035FEr 2               ;----------------------------------------------------
0035FEr 2               
0035FEr 2               intserv:
0035FEr 2  EE 01 96     	inc $9601	; scroll colour char topleft
003601r 2  68           	pla
003602r 2  A8           	tay
003603r 2  68           	pla
003604r 2  AA           	tax
003605r 2  68           	pla
003606r 2  40           	rti
003607r 2               
003607r 2               ;--------------------------------------------------------
003607r 2               ; PRSKEY
003607r 2               ;
003607r 2               ; Wait for keypress.
003607r 2               ;--------------------------------------------------------
003607r 2               
003607r 2               prskey:
003607r 2  98           	tya
003608r 2  48           	pha
003609r 2               prsloop:
003609r 2  20 rr rr     	jsr vsync
00360Cr 2  20 rr rr     	jsr readkey
00360Fr 2  C0 FF        	cpy #255
003611r 2  F0 F6        	beq prsloop		; wait until key pressed
003613r 2               
003613r 2               prsrelease:
003613r 2  20 rr rr     	jsr vsync
003616r 2  20 rr rr     	jsr readkey
003619r 2  C0 FF        	cpy #255
00361Br 2  D0 F6        	bne prsrelease		; wait until key released
00361Dr 2               
00361Dr 2  20 rr rr     	jsr joykey
003620r 2               
003620r 2  68           	pla
003621r 2  A8           	tay
003622r 2  60           	rts
003623r 2               
003623r 2               ;--------------------------------------------------------
003623r 2               ; KTEST
003623r 2               ;
003623r 2               ; Keyboard test routine with key in A.
003623r 2               ; Scan key and clear carry if key pressed
003623r 2               ;--------------------------------------------------------
003623r 2               
003623r 2               ktest:
003623r 2  85 rr        	sta z80_a		; save key
003625r 2               
003625r 2  4A           	lsr a
003626r 2  4A           	lsr a
003627r 2  4A           	lsr a
003628r 2  4A           	lsr a
003629r 2  AA           	tax
00362Ar 2  BD rr rr     	lda colmask,x
00362Dr 2  8D 20 91     	sta KeyColAddr		; set row
003630r 2               
003630r 2  A5 rr        	lda z80_a
003632r 2  29 0F        	and #$0f
003634r 2  AA           	tax			; get column
003635r 2               
003635r 2  AD 21 91     	lda KeyRowAddr		; read column
003638r 2  3D rr rr     	and keymask,x		; check if key pressed
00363Br 2  F0 02        	beq pressed		; Skip if pressed
00363Dr 2  38           	sec			; key not pressed
00363Er 2  60           	rts
00363Fr 2               pressed:
00363Fr 2  18           	clc			; key pressed
003640r 2  60           	rts
003641r 2               
003641r 2  7F BF DF EF  colmask:	.byte 127,191,223,239,247,251,253,254
003645r 2  F7 FB FD FE  
003649r 2  01 02 04 08  keymask:	.byte $01,$02,$04,$08,$10,$20,$40,$80
00364Dr 2  10 20 40 80  
003651r 2               
003651r 2               ;---------------------------------------------------------------
003651r 2               ; KGET
003651r 2               ;
003651r 2               ; Read keyboard matrix if a key is pressed.
003651r 2               ; Return A = high nibble=row and low nibble=col
003651r 2               ;---------------------------------------------------------------
003651r 2               
003651r 2               kget:
003651r 2  86 rr        	stx xtmp		; Save x-reg
003653r 2               kget0:
003653r 2  A2 00        	ldx #0			; reset row
003655r 2               kget1:
003655r 2  BD rr rr     	lda colmask,x		; Get mask
003658r 2  8D 20 91     	sta KeyColAddr		; Set row
00365Br 2  AD 21 91     	lda KeyRowAddr		; Read columns
00365Er 2  85 rr        	sta tmp			; Save colums
003660r 2  C9 FF        	cmp #$ff		; Key pressed?
003662r 2  D0 08        	bne kget2		; Yes, skip
003664r 2  E8           	inx			; Next row
003665r 2  E0 08        	cpx #8			; All rows scanned?
003667r 2  D0 EC        	bne kget1		; No, repeat
003669r 2  4C rr rr     	jmp kget0		; No key pressed, a=$ff
00366Cr 2               kget2:
00366Cr 2  A0 00        	ldy #0			; Reset column
00366Er 2               kget3:
00366Er 2  46 rr        	lsr tmp			; Test bit
003670r 2  90 04        	bcc kget4		; If clear, key pressed
003672r 2  C8           	iny			; Next column
003673r 2  4C rr rr     	jmp kget3		; Repeat
003676r 2               kget4:
003676r 2  86 rr        	stx tmp			; Get row
003678r 2  06 rr        	asl tmp			; Make high nibble
00367Ar 2  06 rr        	asl tmp
00367Cr 2  06 rr        	asl tmp
00367Er 2  06 rr        	asl tmp
003680r 2  98           	tya			; Get column
003681r 2  18           	clc
003682r 2  65 rr        	adc tmp			; Add row as low nibble
003684r 2  85 rr        	sta tmp
003686r 2               kget5:
003686r 2  AD 21 91     	lda KeyRowAddr		; Read columns
003689r 2  C9 FF        	cmp #$ff
00368Br 2  D0 F9        	bne kget5
00368Dr 2               
00368Dr 2  A5 rr        	lda tmp			; Return keycode
00368Fr 2  A6 rr        	ldx xtmp		; Restore X-reg
003691r 2  60           	rts			; Return
003692r 2               
003692r 2               ;-------------------------------------------------------------
003692r 2               ; READKEY
003692r 2               ;
003692r 2               ; Check keyboard matrix if a key is pressed
003692r 2               ; Return keymask in Y
003692r 2               ;-------------------------------------------------------------
003692r 2               
003692r 2               readkey:
003692r 2  A9 FF        	lda #$ff		; Keymask
003694r 2  85 rr        	sta tmp
003696r 2  A2 07        	ldx #7
003698r 2               scanrow:
003698r 2  BD rr rr     	lda colmask,x
00369Br 2  8D 20 91     	sta KeyColAddr		; set row
00369Er 2  AD 21 91     	lda KeyRowAddr		; read column
0036A1r 2  25 rr        	and tmp			; Reset bit is key pressed
0036A3r 2  85 rr        	sta tmp
0036A5r 2  CA           	dex
0036A6r 2  10 F0        	bpl scanrow
0036A8r 2  A5 rr        	lda tmp
0036AAr 2  A8           	tay
0036ABr 2  60           	rts
0036ACr 2               
0036ACr 2               ;-------------------------------------------------------------
0036ACr 2               ; JOY1SCAN
0036ACr 2               ;
0036ACr 2               ; Initializes joystick
0036ACr 2               ;-------------------------------------------------------------
0036ACr 2               
0036ACr 2               joyinit:
0036ACr 2  60           	rts
0036ADr 2               
0036ADr 2               ;-------------------------------------------------------------
0036ADr 2               ; JOY1SCAN
0036ADr 2               ;
0036ADr 2               ; Scan joystick1 and return key in z80_e
0036ADr 2               ; Up, down, left, right and fire are read from the joystick
0036ADr 2               ; Fire2 and fire3 are read from the keyboard
0036ADr 2               ;-------------------------------------------------------------
0036ADr 2               
0036ADr 2               joy1scan:
0036ADr 2  A9 FF        	lda #$ff
0036AFr 2  85 rr        	sta z80_e
0036B1r 2               
0036B1r 2  AD 11 91     	lda JoyAddr1		; Read joystick input
0036B4r 2  4A           	lsr a
0036B5r 2  4A           	lsr a
0036B6r 2               
0036B6r 2  4A           	lsr a
0036B7r 2  26 rr        	rol z80_e		; Up
0036B9r 2  4A           	lsr a
0036BAr 2  26 rr        	rol z80_e		; Down
0036BCr 2  4A           	lsr a
0036BDr 2  26 rr        	rol z80_e		; Left
0036BFr 2               
0036BFr 2  A9 7F        	lda #%01111111
0036C1r 2  8D 22 91     	sta DDRB		; Bit7 = input joystick b7
0036C4r 2  AD 20 91     	lda JoyAddr2
0036C7r 2  0A           	asl a
0036C8r 2  26 rr        	rol z80_e		; Right
0036CAr 2  A9 FF        	lda #%11111111
0036CCr 2  8D 22 91     	sta DDRB		; Reset
0036CFr 2               
0036CFr 2  AD 11 91     	lda JoyAddr1
0036D2r 2  29 20        	and #%00100000
0036D4r 2  D0 06        	bne :+
0036D6r 2  A5 rr        	lda z80_e
0036D8r 2  29 EF        	and #%11101111		; Fire
0036DAr 2  85 rr        	sta z80_e
0036DCr 2               :
0036DCr 2  AD rr rr     	lda keys+6		; Scan keys for Fire3
0036DFr 2  20 rr rr     	jsr ktest
0036E2r 2  B0 06        	bcs :+
0036E4r 2  A5 rr        	lda z80_e
0036E6r 2  29 BF        	and #%10111111
0036E8r 2  85 rr        	sta z80_e
0036EAr 2               :
0036EAr 2  AD rr rr     	lda keys+5		; Scan keys for Fire2
0036EDr 2  20 rr rr     	jsr ktest
0036F0r 2  B0 06        	bcs :+
0036F2r 2  A5 rr        	lda z80_e
0036F4r 2  29 DF        	and #%11011111
0036F6r 2  85 rr        	sta z80_e
0036F8r 2               :
0036F8r 2  60           	rts
0036F9r 2               
0036F9r 2               ;-------------------------------------------------------------
0036F9r 2               ; JOY2SCAN
0036F9r 2               ;
0036F9r 2               ; TODO, Scan joystick2 and return key in z80_e
0036F9r 2               ;-------------------------------------------------------------
0036F9r 2               
0036F9r 2               joy2scan:
0036F9r 2  60           	rts
0036FAr 2               
0036FAr 2               
0036FAr 2               
0036FAr 2               ;========================================================
0036FAr 2               ; HARDWARE DEPENDING ROUTINES
0036FAr 2               ;========================================================
0036FAr 2               
0036FAr 2               ;----------------------------------------------------
0036FAr 2               ; DELAY
0036FAr 2               ;
0036FAr 2               ; Delay routine A * 1/50 sec
0036FAr 2               ;----------------------------------------------------
0036FAr 2               
0036FAr 2               delay:
0036FAr 2  85 rr        	sta xtmp		; set delaycounter
0036FCr 2               del_loop:
0036FCr 2  AD 04 90     	lda Reg4
0036FFr 2  D0 FB        	bne del_loop		; wait for flyback (1/60 sec)
003701r 2               
003701r 2  A0 D0        	ldy #208		; wait 208 x 16 = 3328 usec
003703r 2               delay1:
003703r 2  61 80        	adc ($80,x)		;	 6 usec
003705r 2  61 80        	adc ($80,x)		;	 6 usec
003707r 2  88           	dey			;	 2 usec
003708r 2  D0 F9        	bne delay1		;	 2 usec
00370Ar 2  EA           	nop			; 2 usec
00370Br 2  EA           	nop			; 2 usec
00370Cr 2               				; tot: 20000 usec
00370Cr 2  C6 rr        	dec xtmp		; Next 1/50 sec delay
00370Er 2  D0 EC        	bne del_loop
003710r 2  60           	rts
003711r 2               
003711r 2               ;-------------------------------------------------------------
003711r 2               ; VSYNC
003711r 2               ;
003711r 2               ; - read joystick/keyboard
003711r 2               ; - sync framerate with timer 25Hz
003711r 2               ; - handle shrapnel every even frame
003711r 2               ; - handle sound
003711r 2               ;-------------------------------------------------------------
003711r 2               
003711r 2               vsync:
003711r 2  48           	pha			; save registers
003712r 2  98           	tya
003713r 2  48           	pha
003714r 2  8A           	txa
003715r 2  48           	pha
003716r 2               
003716r 2               ; Read joystick/keyboard.
003716r 2               
003716r 2  20 rr rr     	jsr joykey
003719r 2               
003719r 2               ; Sync framerate with timer 25Hz
003719r 2               
003719r 2  A9 40        	lda #$40		; set Timer1 expired bit
00371Br 2               vsync1:
00371Br 2  2C 1D 91     	bit IFR1		; check Interrupt Flag Register
00371Er 2  F0 FB        	beq vsync1		; wait if timer not expired
003720r 2  AD 14 91     	lda Timer11_Low		; clear Timer interrupt
003723r 2               
003723r 2               ; Handle shrapnel every even frame
003723r 2               
003723r 2  A5 rr        	lda clock		; get clock
003725r 2  29 01        	and #1			; 2 frames expired
003727r 2  D0 03        	bne:+
003729r 2  20 rr rr     	jsr proshr		; process shrapnel
00372Cr 2               :
00372Cr 2               
00372Cr 2               ; Handle sound
00372Cr 2               
00372Cr 2  AD rr rr         lda sndtyp
00372Fr 2  F0 33            beq sndskip
003731r 2               
003731r 2               sndloop:
003731r 2  AC rr rr         ldy sndtyp
003734r 2               sndwait:
003734r 2  88               dey
003735r 2  D0 FD            bne sndwait
003737r 2               
003737r 2  AD rr rr         lda sndtyp
00373Ar 2  30 11            bmi crashaudio
00373Cr 2               
00373Cr 2               
00373Cr 2               beepaudio:
00373Cr 2                   ; enable sound on channel 2
00373Cr 2                   ; add 128 because sound is in range 128-255
00373Cr 2  4A               lsr
00373Dr 2  A9 FF            lda #$ff
00373Fr 2  38               sec
003740r 2  ED rr rr         sbc sndtyp
003743r 2  4A               lsr
003744r 2  4A               lsr
003745r 2  09 C0            ora #%11000000
003747r 2  8D 0C 90         sta $900c
00374Ar 2               
00374Ar 2  4C rr rr         jmp endaudiotype
00374Dr 2               crashaudio:
00374Dr 2  A9 FF            lda #$ff
00374Fr 2  38               sec
003750r 2  ED rr rr         sbc sndtyp
003753r 2  09 80            ora #%10000000
003755r 2  8D 0D 90         sta $900d
003758r 2               
003758r 2               endaudiotype:
003758r 2               
003758r 2  CE rr rr         dec sndtyp
00375Br 2  F0 07            beq sndskip
00375Dr 2  C9 80            cmp #128
00375Fr 2  F0 03            beq sndskip
003761r 2  4C rr rr         jmp sndloop
003764r 2               sndskip:
003764r 2                   ; disable sound
003764r 2  A9 00            lda #$00
003766r 2  8D 0C 90         sta $900c
003769r 2  8D 0D 90         sta $900d
00376Cr 2               
00376Cr 2  68               pla
00376Dr 2  AA               tax
00376Er 2  68               pla
00376Fr 2  A8               tay
003770r 2  68               pla
003771r 2  60               rts
003772r 2  00           sndtyp:		.byte 0		; Beep sound parameter
003773r 2               
003773r 2               
003773r 2               
003773r 2               
003773r 2               
003773r 2               
003773r 2               ;========================================================
003773r 2               ; SPRITE HANDLING ROUTINES
003773r 2               ;========================================================
003773r 2               
003773r 2               ;----------------------------------------------------
003773r 2               ; SPRITE
003773r 2               ;
003773r 2               ; Draw object sprite
003773r 2               ;----------------------------------------------------
003773r 2               
003773r 2               .if oflag
003773r 2               sprite:
003773r 2  86 rr        	stx xtmp		; Save X-reg
003775r 2  20 rr rr     	jsr scadd 		; get screen address in scraddr.
003778r 2               
003778r 2  A5 rr        	lda dispx 		; x position.
00377Ar 2  29 07        	and #7 			; position straddling cells.
00377Cr 2  85 rr        	sta z80_b		; store in b register.
00377Er 2               
00377Er 2  A5 rr        	lda z80_l		; store sprite graphic address.
003780r 2  8D rr rr     	sta sprit1+1
003783r 2  8D rr rr     	sta sprit2+1
003786r 2  A5 rr        	lda z80_h
003788r 2  8D rr rr     	sta sprit1+2
00378Br 2  8D rr rr     	sta sprit2+2
00378Er 2               
00378Er 2  A2 00        	ldx #0			; pixel height.
003790r 2  A0 00        	ldy #0
003792r 2               sprit1:
003792r 2  BD rr rr     	lda objdta,x		; fetch first byte.
003795r 2  85 rr        	sta spr
003797r 2  E8           	inx
003798r 2               sprit2:
003798r 2  BD rr rr     	lda objdta,x
00379Br 2  85 rr        	sta spr+1
00379Dr 2               
00379Dr 2  A9 00        	lda #0
00379Fr 2  85 rr        	sta spr+2
0037A1r 2  20 rr rr     	jsr sprit7		; shift sprite
0037A4r 2               
0037A4r 2  A5 rr        	lda spr			; fetch graphic.
0037A6r 2  A0 00        	ldy #0			; _BEEB
0037A8r 2  51 rr        	eor (scraddr),y		; merge with screen image.
0037AAr 2  91 rr        	sta (scraddr),y		; write to screen.
0037ACr 2               
0037ACr 2  A5 rr        	lda spr+1		; fetch graphic.
0037AEr 2  A0 10        	ldy #16			; _BEEB
0037B0r 2  51 rr        	eor (scraddr),y		; merge with screen image.
0037B2r 2  91 rr        	sta (scraddr),y		; write to screen.
0037B4r 2               
0037B4r 2  A5 rr        	lda spr+2		; fetch graphic.
0037B6r 2  A0 20        	ldy #32			; _BEEB
0037B8r 2  51 rr        	eor (scraddr),y		; merge with screen image.
0037BAr 2  91 rr        	sta (scraddr),y		; write to screen.
0037BCr 2               
0037BCr 2  20 rr rr     	jsr nline
0037BFr 2               
0037BFr 2  E8           	inx			; next source byte.
0037C0r 2  E0 20        	cpx #32
0037C2r 2  D0 CE        	bne sprit1		; repeat
0037C4r 2               
0037C4r 2  A6 rr        	ldx xtmp		; retreive X-reg
0037C6r 2  60           	rts
0037C7r 2               
0037C7r 2               .endif
0037C7r 2               
0037C7r 2               ;------------------------------------------------------------------
0037C7r 2               ; SCADD
0037C7r 2               ;
0037C7r 2               ; This routine returns a screen address for X,Y in scraddr.
0037C7r 2               ;------------------------------------------------------------------
0037C7r 2               
0037C7r 2               scadd:
0037C7r 2  A5 rr        	lda dispx		; get x
0037C9r 2  29 F8        	and #$f8		; reset bit 0-2 for get block pos
0037CBr 2  85 rr        	sta scraddr		; set lb scraddr
0037CDr 2  A9 00        	lda #0
0037CFr 2  85 rr        	sta scraddr+1		; set hb scraddr
0037D1r 2  06 rr        	asl scraddr		; multiply X by 2
0037D3r 2  26 rr        	rol scraddr+1
0037D5r 2               
0037D5r 2               ; Add line address Y pos to X
0037D5r 2               
0037D5r 2  A6 rr        	ldx dispy		; get row address Y pos
0037D7r 2  18           	clc
0037D8r 2  A5 rr        	lda scraddr
0037DAr 2  7D 00 07     	adc SCADTB_lb,x
0037DDr 2  85 rr        	sta scraddr
0037DFr 2  A5 rr        	lda scraddr+1
0037E1r 2  7D 00 08     	adc SCADTB_hb,x
0037E4r 2  85 rr        	sta scraddr+1
0037E6r 2               
0037E6r 2  60           	rts
0037E7r 2               
0037E7r 2               ;------------------------------------------------------------------
0037E7r 2               ; SSPRIA
0037E7r 2               ;
0037E7r 2               ; Erase single sprite, old (ix+0).
0037E7r 2               ;------------------------------------------------------------------
0037E7r 2               
0037E7r 2               sspria:
0037E7r 2  20 rr rr     	jsr gsprad		; get old sprite address.
0037EAr 2               sspri2:
0037EAr 2               .if rflag
0037EAr 2               	lda z80_e		; 3c
0037EAr 2               	sta dline_spraddr1+1	; 4c
0037EAr 2               	sta dline_spraddr2+1	; 4c
0037EAr 2               	lda z80_d		; 3c
0037EAr 2               	sta dline_spraddr1+2	; 4c
0037EAr 2               	sta dline_spraddr2+2	; 4c
0037EAr 2               
0037EAr 2               	ldx sprshft
0037EAr 2               	lda shift_table,x
0037EAr 2               	sta dline_shift1+1
0037EAr 2               	sta dline_shift2+1
0037EAr 2               	lda shift_table+1,x
0037EAr 2               	sta dline_shift1+2
0037EAr 2               	sta dline_shift2+2
0037EAr 2               
0037EAr 2               	ldx #0			; byte counter.
0037EAr 2               sspri0:
0037EAr 2               	jsr dline		; draw a line.
0037EAr 2                 .if bflag
0037EAr 2               	cpx #48			; big sprites have 24 bytes
0037EAr 2                 .else
0037EAr 2               	cpx #32			; normal sprites have 32 bytes
0037EAr 2                 .endif
0037EAr 2               	bne sspri0		; repeat 16 times x 2 bytes
0037EAr 2               	rts
0037EAr 2               .else
0037EAr 2                 .if bflag
0037EAr 2  A9 18        	lda #24			; big sprites have 24 lines
0037ECr 2                 .else
0037ECr 2               	lda #16			; normal sprites have 16 lines.
0037ECr 2                 .endif
0037ECr 2  8D rr rr     	sta acnt
0037EFr 2               sspri0:
0037EFr 2  20 rr rr     	jsr dline		; draw a line.
0037F2r 2  CE rr rr     	dec acnt
0037F5r 2  D0 F8        	bne sspri0		; repeat 16 times
0037F7r 2  60           	rts
0037F8r 2               
0037F8r 2  00           acnt:	.byte 0			; line counter
0037F9r 2               
0037F9r 2               .endif
0037F9r 2               
0037F9r 2               ;------------------------------------------------------------------
0037F9r 2               ; SSPRIB
0037F9r 2               ;
0037F9r 2               ; Display single sprite, new (ix+5).
0037F9r 2               ;------------------------------------------------------------------
0037F9r 2               
0037F9r 2               ssprib:
0037F9r 2  20 rr rr     	jsr gspran 		; get new sprite address.
0037FCr 2  4C rr rr     	jmp sspri2		; Display sprite
0037FFr 2               
0037FFr 2               ;------------------------------------------------------------------
0037FFr 2               ; SSPRIC
0037FFr 2               ;
0037FFr 2               ; Erase old (ix+0) and display new (ix+5) sprite line by line.
0037FFr 2               ;------------------------------------------------------------------
0037FFr 2               
0037FFr 2               sspric:
0037FFr 2               .if rflag
0037FFr 2               	jsr gsprad 		; get old sprite address.
0037FFr 2               
0037FFr 2               	lda z80_e		; 3c
0037FFr 2               	sta ddline_spraddr3+1	; 4c
0037FFr 2               	sta ddline_spraddr4+1	; 4c
0037FFr 2               
0037FFr 2               	lda z80_d		; 3c
0037FFr 2               	sta ddline_spraddr3+2	; 4c
0037FFr 2               	sta ddline_spraddr4+2	; 4c
0037FFr 2               
0037FFr 2               	ldx sprshft		; set spriteshift table addresses
0037FFr 2               	lda shift_table,x
0037FFr 2               	sta ddline_shift3+1
0037FFr 2               	sta ddline_shift4+1
0037FFr 2               	lda shift_table+1,x
0037FFr 2               	sta ddline_shift3+2
0037FFr 2               	sta ddline_shift4+2
0037FFr 2               
0037FFr 2               	jsr exx  		; store addresses.
0037FFr 2               	jsr gspran 		; get new sprite addresses.
0037FFr 2               
0037FFr 2               	lda z80_e		; 3c
0037FFr 2               	sta ddline_spraddr1+1	; 4c
0037FFr 2               	sta ddline_spraddr2+1	; 4c
0037FFr 2               
0037FFr 2               	lda z80_d		; 3c
0037FFr 2               	sta ddline_spraddr1+2	; 4c
0037FFr 2               	sta ddline_spraddr2+2	; 4c
0037FFr 2               
0037FFr 2               	ldx sprshft
0037FFr 2               	lda shift_table,x
0037FFr 2               	sta ddline_shift1+1
0037FFr 2               	sta ddline_shift2+1
0037FFr 2               	lda shift_table+1,x
0037FFr 2               	sta ddline_shift1+2
0037FFr 2               	sta ddline_shift2+2
0037FFr 2               
0037FFr 2               	ldx #0
0037FFr 2               lloop:
0037FFr 2               	jsr ddline 		; draw a line.
0037FFr 2                 .if bflag
0037FFr 2               	cpx #48
0037FFr 2                 .else
0037FFr 2               	cpx #32
0037FFr 2                 .endif
0037FFr 2               	bne lloop
0037FFr 2               	rts
0037FFr 2               
0037FFr 2               shift_table:
0037FFr 2               	.word shift0
0037FFr 2               	.word shift2
0037FFr 2               	.word shift4
0037FFr 2               	.word shift6
0037FFr 2               
0037FFr 2               ;------------------------------------------------------------------
0037FFr 2               ; DLINE
0037FFr 2               ;
0037FFr 2               ; Draw a sprite line, now work out next target address.
0037FFr 2               ;
0037FFr 2               ; Input:
0037FFr 2               ;  B  = right mask
0037FFr 2               ;  C  = left mask
0037FFr 2               ;  DE = spriteaddress
0037FFr 2               ;  scraddr = screen address
0037FFr 2               ;------------------------------------------------------------------
0037FFr 2               
0037FFr 2               dline:
0037FFr 2               
0037FFr 2               dline_spraddr1:
0037FFr 2               	ldy $ffff,x 		; get graphic data as pointer.
0037FFr 2               dline_shift1:
0037FFr 2               	lda $ffff,y		; get pre-shifted data
0037FFr 2               	sta sprtmp		; save byte
0037FFr 2               	and z80_c 		; mask right for left byte
0037FFr 2               
0037FFr 2               	ldy #0
0037FFr 2               	eor (scraddr),y 	; XOR with what's there.
0037FFr 2               	sta (scraddr),y 	; display left byte
0037FFr 2               
0037FFr 2               ; carry to next screen byte
0037FFr 2               
0037FFr 2               	lda sprtmp		; fetch data.
0037FFr 2               	and z80_b 		; mask for left part
0037FFr 2               	sta sprtmp
0037FFr 2               
0037FFr 2               ; middle screen byte
0037FFr 2               
0037FFr 2               	inx
0037FFr 2               dline_spraddr2:
0037FFr 2               	ldy $ffff,x 		; second bit of data.
0037FFr 2               dline_shift2:
0037FFr 2               	lda $ffff,y
0037FFr 2               	sta sprtmp2
0037FFr 2               	and z80_c 		; mask away what's not needed.
0037FFr 2               	ora sprtmp
0037FFr 2               	ldy #16
0037FFr 2               	eor (scraddr),y 	; XOR with what's there.
0037FFr 2               	sta (scraddr),y 	; display middle bye.
0037FFr 2               
0037FFr 2               ; carry to last screen byte
0037FFr 2               
0037FFr 2               	lda sprtmp2
0037FFr 2               	and z80_b 		; mask away unwanted
0037FFr 2               
0037FFr 2               	ldy #32
0037FFr 2               	eor (scraddr),y 	; XOR with what's there.
0037FFr 2               	sta (scraddr),y 	; display right byte.
0037FFr 2               
0037FFr 2               	inx
0037FFr 2               .else
0037FFr 2               
0037FFr 2  20 rr rr     	jsr gsprad 		; get old sprite address.
003802r 2  20 rr rr     	jsr exx  		; store addresses.
003805r 2  20 rr rr     	jsr gspran 		; get new sprite addresses.
003808r 2               
003808r 2               .if bflag
003808r 2  A9 17        	lda #23
00380Ar 2               .else
00380Ar 2               	lda #15
00380Ar 2               .endif
00380Ar 2  85 rr        	sta ccnt
00380Cr 2               lloop:
00380Cr 2  20 rr rr     	jsr dline 		; draw a line.
00380Fr 2  20 rr rr     	jsr exx  		; restore old addresses.
003812r 2  20 rr rr     	jsr dline 		; delete a line.
003815r 2  20 rr rr     	jsr exx  		; flip to new sprite addresses.
003818r 2  C6 rr        	dec ccnt
00381Ar 2  D0 F0        	bne lloop
00381Cr 2               
00381Cr 2  20 rr rr     	jsr dline		; draw a line.
00381Fr 2  20 rr rr     	jsr exx 		; restore old addresses.
003822r 2               
003822r 2               ;-------------------------------------------------------------
003822r 2               ; Drop through.
003822r 2               ; Line drawn, now work out next target address.
003822r 2               ;
003822r 2               ; Input:
003822r 2               ;  B  = right mask
003822r 2               ;  C  = left mask
003822r 2               ;  DE = spriteaddress
003822r 2               ;  scraddr = screen address
003822r 2               ;-------------------------------------------------------------
003822r 2               
003822r 2               dline:
003822r 2  A0 00        	ldy #0
003824r 2  B1 rr        	lda (z80_de),y 		; graphic data.
003826r 2  48           	pha
003827r 2  25 rr        	and z80_c 		; mask away what's not needed.
003829r 2  51 rr        	eor (scraddr),y 	; XOR with what's there.
00382Br 2  91 rr        	sta (scraddr),y 	; left byte on screen.
00382Dr 2               
00382Dr 2  68           	pla
00382Er 2  25 rr        	and z80_b 		; mask away unwanted bits.
003830r 2  A0 20        	ldy #32
003832r 2  51 rr        	eor (scraddr),y 	; XOR with what's there.
003834r 2  91 rr        	sta (scraddr),y 	; right byte on screen
003836r 2               
003836r 2  E6 rr        	inc z80_e 		; next graphic.
003838r 2  D0 02        	bne :+
00383Ar 2  E6 rr        	inc z80_d
00383Cr 2               :
00383Cr 2               ; _BEEB screen arrangement
00383Cr 2               ;	sec
00383Cr 2               ;	lda scraddr 		; one character cell to the left.
00383Cr 2               ;	sbc #8
00383Cr 2               ;	sta scraddr
00383Cr 2               ;	lda scraddr+1
00383Cr 2               ;	sbc #0
00383Cr 2               ;	sta scraddr+1
00383Cr 2  A0 00        	ldy #0
00383Er 2  B1 rr        	lda (z80_de),y 		; second bit of data.
003840r 2  A0 10        	ldy #16
003842r 2  51 rr        	eor (scraddr),y 	; XOR with what's there.
003844r 2  91 rr        	sta (scraddr),y 	; middle byte on screen.
003846r 2               
003846r 2  E6 rr        	inc z80_e 		; point to next line of data.
003848r 2  D0 02        	bne :+
00384Ar 2  E6 rr        	inc z80_d
00384Cr 2               :
00384Cr 2               ; _BEEB screen arrangement
00384Cr 2               ;	sec
00384Cr 2               ;	lda scraddr 		; another char left.
00384Cr 2               ;	sbc #8
00384Cr 2               ;	sta scraddr
00384Cr 2               ;	lda scraddr+1
00384Cr 2               ;	sbc #0
00384Cr 2               ;	sta scraddr+1
00384Cr 2               .endif
00384Cr 2               
00384Cr 2               ;----------------------------------------------------------------------
00384Cr 2               ; Line drawn, now work out next target address.
00384Cr 2               ;----------------------------------------------------------------------
00384Cr 2               
00384Cr 2               ; _BEEB screen arrangement
00384Cr 2               
00384Cr 2               nline:
00384Cr 2  A5 rr        	lda scraddr 			; get low byte of address.
00384Er 2  29 0F        	and #15
003850r 2  C9 0F        	cmp #15				; is this last line of row?
003852r 2  F0 03        	beq beeb_next_row
003854r 2               
003854r 2               	; within same row
003854r 2  E6 rr        	inc scraddr			; new low byte of address.
003856r 2  60           	rts
003857r 2               
003857r 2               beeb_next_row:
003857r 2  18           	clc
003858r 2  A5 rr        	lda scraddr
00385Ar 2  69 51        	adc #<(ScreenRowBytes-15)
00385Cr 2  85 rr        	sta scraddr			; new low byte of address.
00385Er 2  A5 rr        	lda scraddr+1
003860r 2  69 01        	adc #>(ScreenRowBytes-15)
003862r 2  85 rr        	sta scraddr+1			; new high byte of address.
003864r 2  60           	rts
003865r 2               
003865r 2               .if rflag
003865r 2               ;-------------------------------------------------------------
003865r 2               ; Drop through.
003865r 2               ; Line drawn, now work out next target address.
003865r 2               ;
003865r 2               ; Input:
003865r 2               ;  B  = right mask
003865r 2               ;  C  = left mask
003865r 2               ;  DE = spriteaddress
003865r 2               ;  scraddr = screen address
003865r 2               ;-------------------------------------------------------------
003865r 2               
003865r 2               ddline:
003865r 2               
003865r 2               ; NEW SPRITE
003865r 2               
003865r 2               ; first screen byte
003865r 2               
003865r 2               ddline_spraddr1:
003865r 2               	ldy $ffff,x 		; graphic data.
003865r 2               ddline_shift1:
003865r 2               	lda $ffff,y
003865r 2               	sta sprtmp
003865r 2               	and z80_c 			; mask away what's not needed.
003865r 2               
003865r 2               	ldy #0
003865r 2               	eor (scraddr),y 	; XOR with what's there.
003865r 2               	sta (scraddr),y 	; bung it in.
003865r 2               
003865r 2               ; carry to next screen byte
003865r 2               
003865r 2               	lda sprtmp			; fetch data.
003865r 2               	and z80_b 			; mask away unwanted
003865r 2               	sta sprtmp
003865r 2               
003865r 2               ; middle screen byte
003865r 2               
003865r 2               	inx
003865r 2               ddline_spraddr2:
003865r 2               	ldy $ffff,x 		; second bit of data.
003865r 2               ddline_shift2:
003865r 2               	lda $ffff,y
003865r 2               	sta sprtmp2
003865r 2               	and z80_c 			; mask away what's not needed.
003865r 2               	ora sprtmp
003865r 2               
003865r 2               	ldy #16
003865r 2               	eor (scraddr),y 	; XOR with what's there.
003865r 2               	sta (scraddr),y 	; bung it in.
003865r 2               
003865r 2               ; carry to last screen byte
003865r 2               
003865r 2               	lda sprtmp2
003865r 2               	and z80_b 			; mask away unwanted
003865r 2               
003865r 2               	ldy #32
003865r 2               	eor (scraddr),y 	; XOR with what's there.
003865r 2               	sta (scraddr),y 	; bung it in.
003865r 2               
003865r 2               ; _BEEB next row
003865r 2               
003865r 2               	lda scraddr 		; get low byte of address.
003865r 2               	and #15
003865r 2               	cmp #15				; is this last line of row?
003865r 2               	beq :+
003865r 2               
003865r 2               	; within same row can't increment page
003865r 2               	inc scraddr			; new low byte of address.
003865r 2               	bne ddline2
003865r 2               
003865r 2               :
003865r 2               	clc
003865r 2               	lda scraddr
003865r 2               	adc #<(ScreenRowBytes-15)
003865r 2               	sta scraddr			; new low byte of address.
003865r 2               	lda scraddr+1
003865r 2               	adc #>(ScreenRowBytes-15)
003865r 2               	sta scraddr+1		; new high byte of address.
003865r 2               
003865r 2               ; OLD SPRITE
003865r 2               
003865r 2               ddline2:
003865r 2               
003865r 2               ; still first row but different data!
003865r 2               
003865r 2               	dex
003865r 2               
003865r 2               ; first screen byte
003865r 2               
003865r 2               ddline_spraddr3:
003865r 2               	ldy $ffff,x			; graphic data.
003865r 2               ddline_shift3:
003865r 2               	lda $ffff,y
003865r 2               	sta sprtmp
003865r 2               	and z80_cp 			; mask away what's not needed.
003865r 2               
003865r 2               	ldy #0
003865r 2               	eor (z80_hlp),y 	; XOR with what's there.
003865r 2               	sta (z80_hlp),y 	; bung it in.
003865r 2               
003865r 2               ; carry to next screen byte
003865r 2               
003865r 2               	lda sprtmp			; fetch data.
003865r 2               	and z80_bp 			; mask away unwanted
003865r 2               	sta sprtmp
003865r 2               
003865r 2               ; middle screen byte
003865r 2               
003865r 2               	inx
003865r 2               ddline_spraddr4:
003865r 2               	ldy $ffff,x 		; second bit of data.
003865r 2               ddline_shift4:
003865r 2               	lda $ffff,y
003865r 2               	sta sprtmp2
003865r 2               	and z80_cp 			; mask away what's not needed.
003865r 2               	ora sprtmp
003865r 2               
003865r 2               	ldy #16
003865r 2               	eor (z80_hlp),y 	; XOR with what's there.
003865r 2               	sta (z80_hlp),y 	; bung it in.
003865r 2               
003865r 2               ; last screen byte
003865r 2               
003865r 2               	lda sprtmp2			; fetch data.
003865r 2               	and z80_bp 			; mask away unwanted
003865r 2               
003865r 2               	ldy #32
003865r 2               	eor (z80_hlp),y 	; XOR with what's there.
003865r 2               	sta (z80_hlp),y 	; bung it in.
003865r 2               
003865r 2               ; next row of sprite data
003865r 2               
003865r 2               	inx
003865r 2               
003865r 2               ; _BEEB screen arrangement
003865r 2               
003865r 2               	lda z80_lp 			; get low byte of address.
003865r 2               	and #15
003865r 2               	cmp #15				; is this last line of row?
003865r 2               	beq :+
003865r 2               
003865r 2               	; within same row can't increment page
003865r 2               	inc z80_lp			; new low byte of address.
003865r 2               	rts
003865r 2               
003865r 2               :
003865r 2               	clc
003865r 2               	lda z80_lp
003865r 2               	adc #<(ScreenRowBytes-15)
003865r 2               	sta z80_lp			; new low byte of address.
003865r 2               	lda z80_lp+1
003865r 2               	adc #>(ScreenRowBytes-15)
003865r 2               	sta z80_lp+1		; new high byte of address.
003865r 2               	rts
003865r 2               .endif
003865r 2               
003865r 2               ;----------------------------------------------------
003865r 2               ; Display character in A at dispx,dispy.
003865r 2               ;
003865r 2               ; Input:
003865r 2               ;  A 	   = character to print
003865r 2               ;----------------------------------------------------
003865r 2               
003865r 2               pchar:
003865r 2  85 rr        	sta fntaddr
003867r 2  A9 00        	lda #0
003869r 2  85 rr        	sta fntaddr+1
00386Br 2  06 rr        	asl fntaddr  		; multiply char by 8.
00386Dr 2  26 rr        	rol fntaddr+1
00386Fr 2  06 rr        	asl fntaddr
003871r 2  26 rr        	rol fntaddr+1
003873r 2  06 rr        	asl fntaddr
003875r 2  26 rr        	rol fntaddr+1
003877r 2               
003877r 2  A5 rr        	lda fntaddr
003879r 2  18           	clc
00387Ar 2  69 rr        	adc #<(FONT-256)
00387Cr 2  85 rr        	sta fntaddr		; that's the low byte.
00387Er 2  A5 rr        	lda fntaddr+1
003880r 2  69 rr        	adc #>(FONT-256)
003882r 2  85 rr        	sta fntaddr+1		; add displacement.
003884r 2               
003884r 2               pchark:
003884r 2  20 rr rr     	jsr gaadd		; set colour attribute
003887r 2  AD rr rr     	lda fontcol
00388Ar 2  A0 00        	ldy #0
00388Cr 2  91 rr        	sta (bufaddr),y
00388Er 2               
00388Er 2  20 rr rr     	jsr gprad		; get screen address.
003891r 2  A2 07        	ldx #7			; lines to write.
003893r 2               pchar0:
003893r 2  A0 00        	ldy #0
003895r 2  B1 rr        	lda (fntaddr),y 	; get image byte.
003897r 2  BC rr rr     	ldy scrtab,x		; Get rowoffset
00389Ar 2               .if iflag
00389Ar 2               	eor #TxtInvert		; Invert
00389Ar 2               .endif
00389Ar 2  91 rr        	sta (scraddr),y 	; copy to screen.
00389Cr 2  E6 rr        	inc fntaddr		; next image byte.
00389Er 2  D0 02        	bne :+
0038A0r 2  E6 rr        	inc fntaddr+1
0038A2r 2               :
0038A2r 2  CA           	dex			; next screen row down.
0038A3r 2  10 EE        	bpl pchar0		; repeat.
0038A5r 2               
0038A5r 2  60           	rts
0038A6r 2               
0038A6r 2  07 06 05 04  scrtab:		.byte $07,$06,$05,$04,$03,$02,$01,$00
0038AAr 2  03 02 01 00  
0038AEr 2               
0038AEr 2               
0038AEr 1               ;	.include "music.inc"
0038AEr 1               	.include "z80.asm"
0038AEr 2               ;------------------------------------------------------
0038AEr 2               ; z80.asm
0038AEr 2               ; spectrum stuff
0038AEr 2               ; adresses
0038AEr 2               
0038AEr 2               ;ws	 = $60
0038AEr 2               
0038AEr 2               ;z80_f	 = ws+$00
0038AEr 2               ;z80_a	 = ws+$01
0038AEr 2               ;z80_af	 = z80_f
0038AEr 2               
0038AEr 2               ;z80_c	 = ws+$02
0038AEr 2               ;z80_b	 = ws+$03
0038AEr 2               ;z80_bc	 = z80_c
0038AEr 2               
0038AEr 2               ;z80_e	 = ws+$04
0038AEr 2               ;z80_d	 = ws+$05
0038AEr 2               ;z80_de	 = z80_e
0038AEr 2               
0038AEr 2               ;z80_l	 = ws+$06
0038AEr 2               ;z80_h	 = ws+$07
0038AEr 2               ;z80_hl	 = z80_l
0038AEr 2               
0038AEr 2               ;z80_x    = ws+$08
0038AEr 2               ;z80_i    = ws+$09
0038AEr 2               ;z80_ix	 = z80_x
0038AEr 2               
0038AEr 2               ;z80_iy	 = ws+$0a
0038AEr 2               
0038AEr 2               ;z80_fp	 = ws+$0c
0038AEr 2               ;z80_ap	 = ws+$0d
0038AEr 2               
0038AEr 2               ;z80_cp	 = ws+$0e
0038AEr 2               ;z80_bp	 = ws+$0f
0038AEr 2               ;z80_bcp = z80_cp
0038AEr 2               
0038AEr 2               ;z80_ep	 = ws+$10
0038AEr 2               ;z80_dp	 = ws+$11
0038AEr 2               ;z80_dep = z80_ep
0038AEr 2               
0038AEr 2               ;z80_lp	 = ws+$12
0038AEr 2               ;z80_hp	 = ws+$13
0038AEr 2               ;z80_hlp = z80_lp
0038AEr 2               
0038AEr 2               ;z80_sp   = ws+$14
0038AEr 2               
0038AEr 2               ;z80_reg0 = ws+$16
0038AEr 2               ;z80_reg1 = ws+$17
0038AEr 2               ;z80_reg2 = ws+$18
0038AEr 2               ;z80_reg3 = ws+$19
0038AEr 2               
0038AEr 2               ;z80_r	 = ws+$1a
0038AEr 2               
0038AEr 2               ; Contains seperatly 1 bit set
0038AEr 2               ; _BEEB this is not safe memory to use as required by MOS
0038AEr 2               
0038AEr 2               _bitmem0	= $f8
0038AEr 2               _bitmem1	= $f9
0038AEr 2               _bitmem2	= $fa
0038AEr 2               _bitmem3	= $fb
0038AEr 2               _bitmem4	= $fc
0038AEr 2               _bitmem5	= $fd
0038AEr 2               _bitmem6	= $fe
0038AEr 2               _bitmem7	= $ff
0038AEr 2               
0038AEr 2               ; constants
0038AEr 2               _bitvalue0	= $01
0038AEr 2               _bitvalue1	= $02
0038AEr 2               _bitvalue2	= $04
0038AEr 2               _bitvalue3	= $08
0038AEr 2               _bitvalue4	= $10
0038AEr 2               _bitvalue5	= $20
0038AEr 2               _bitvalue6	= $40
0038AEr 2               _bitvalue7	= $80
0038AEr 2               
0038AEr 2               _notbitvalue0	= $fe
0038AEr 2               _notbitvalue1	= $fd
0038AEr 2               _notbitvalue2	= $fb
0038AEr 2               _notbitvalue3	= $f7
0038AEr 2               _notbitvalue4	= $ef
0038AEr 2               _notbitvalue5	= $df
0038AEr 2               _notbitvalue6	= $bf
0038AEr 2               _notbitvalue7	= $7f
0038AEr 2               
0038AEr 2               
0038AEr 2               ;add_hl_bc:
0038AEr 2               ;		lda z80_l
0038AEr 2               ;		clc
0038AEr 2               ;		adc z80_c
0038AEr 2               ;		sta z80_l
0038AEr 2               ;		lda z80_h
0038AEr 2               ;		adc z80_b
0038AEr 2               ;		sta z80_h
0038AEr 2               ;		rts
0038AEr 2               ;
0038AEr 2               ;add_ix_de:
0038AEr 2               ;		lda z80_ix
0038AEr 2               ;		clc
0038AEr 2               ;		adc z80_e
0038AEr 2               ;		sta z80_ix
0038AEr 2               ;		lda z80_ix+1
0038AEr 2               ;		adc z80_d
0038AEr 2               ;		sta z80_ix+1
0038AEr 2               ;		rts
0038AEr 2               ;
0038AEr 2               ;add_iy_de:
0038AEr 2               ;		lda z80_iy
0038AEr 2               ;		clc
0038AEr 2               ;		adc z80_e
0038AEr 2               ;		sta z80_iy
0038AEr 2               ;		lda z80_iy+1
0038AEr 2               ;		adc z80_d
0038AEr 2               ;		sta z80_iy+1
0038AEr 2               ;		rts
0038AEr 2               ;
0038AEr 2               ;add_hl_de:
0038AEr 2               ;		lda z80_l
0038AEr 2               ;		clc
0038AEr 2               ;		adc z80_e
0038AEr 2               ;		sta z80_l
0038AEr 2               ;		lda z80_h
0038AEr 2               ;		adc z80_d
0038AEr 2               ;		sta z80_h
0038AEr 2               ;		rts
0038AEr 2               ;
0038AEr 2               ;add_ix_bc:
0038AEr 2               ;		lda z80_ix
0038AEr 2               ;		clc
0038AEr 2               ;		adc z80_c
0038AEr 2               ;		sta z80_ix
0038AEr 2               ;		lda z80_ix+1
0038AEr 2               ;		adc z80_b
0038AEr 2               ;		sta z80_ix+1
0038AEr 2               ;		rts
0038AEr 2               ;
0038AEr 2               ;add_iy_bc:
0038AEr 2               ;		lda z80_iy
0038AEr 2               ;		clc
0038AEr 2               ;		adc z80_c
0038AEr 2               ;		sta z80_iy
0038AEr 2               ;		lda z80_iy+1
0038AEr 2               ;		adc z80_b
0038AEr 2               ;		sta z80_iy+1
0038AEr 2               ;		rts
0038AEr 2               ;
0038AEr 2               ;sbc_hl_de:
0038AEr 2               ;		lda z80_l
0038AEr 2               ;		sbc z80_e
0038AEr 2               ;		sta z80_l
0038AEr 2               ;		lda z80_h
0038AEr 2               ;		sbc z80_d
0038AEr 2               ;		sta z80_h
0038AEr 2               ;		rts
0038AEr 2               ;
0038AEr 2               ;sbc_hl_bc:
0038AEr 2               ;		lda z80_l
0038AEr 2               ;		sbc z80_c
0038AEr 2               ;		sta z80_l
0038AEr 2               ;		lda z80_h
0038AEr 2               ;		sbc z80_b
0038AEr 2               ;		sta z80_h
0038AEr 2               ;		rts
0038AEr 2               ;
0038AEr 2               ;cmp_hl_bc:
0038AEr 2               ;		lda z80_l
0038AEr 2               ;		cmp z80_c
0038AEr 2               ;		bne cmp_hl_bc_end
0038AEr 2               ;		lda z80_h
0038AEr 2               ;		cmp z80_b
0038AEr 2               ;cmp_hl_bc_end:
0038AEr 2               ;		rts
0038AEr 2               ;
0038AEr 2               ;cmp_iy_ix:
0038AEr 2               ;		lda z80_iy
0038AEr 2               ;		cmp z80_ix
0038AEr 2               ;		bne cmp_iy_ix_end
0038AEr 2               ;		lda z80_iy+1
0038AEr 2               ;		cmp z80_ix+1
0038AEr 2               ;cmp_iy_ix_end:
0038AEr 2               ;		rts
0038AEr 2               ;
0038AEr 2               ;dec_hl:
0038AEr 2               ;		lda z80_l
0038AEr 2               ;		bne dec_hl_no_dec_h
0038AEr 2               ;		dec z80_h
0038AEr 2               ;dec_hl_no_dec_h:
0038AEr 2               ;		dec z80_l
0038AEr 2               ;		rts
0038AEr 2               ;
0038AEr 2               ;dec_ix:
0038AEr 2               ;		lda z80_ix
0038AEr 2               ;		bne dec_ix_no_dec_h
0038AEr 2               ;		dec z80_ix+1
0038AEr 2               ;dec_ix_no_dec_h:
0038AEr 2               ;		dec z80_ix
0038AEr 2               ;		rts
0038AEr 2               ;
0038AEr 2               ;dec_bc:
0038AEr 2               ;		lda z80_c
0038AEr 2               ;		bne dec_bc_no_dec_b
0038AEr 2               ;		dec z80_b
0038AEr 2               ;dec_bc_no_dec_b:
0038AEr 2               ;		dec z80_c
0038AEr 2               ;		rts
0038AEr 2               ;
0038AEr 2               ;dec_de:
0038AEr 2               ;		lda z80_e
0038AEr 2               ;		bne dec_de_no_dec_d
0038AEr 2               ;		dec z80_d
0038AEr 2               ;dec_de_no_dec_d:
0038AEr 2               ;		dec z80_e
0038AEr 2               ;		rts
0038AEr 2               ;
0038AEr 2               ;ex_af_afs:
0038AEr 2               ;	rts
0038AEr 2               ;ex_de_hl:
0038AEr 2               ;		lda z80_e
0038AEr 2               ;		ldx z80_l
0038AEr 2               ;		stx z80_e
0038AEr 2               ;		sta z80_l
0038AEr 2               ;		lda z80_d
0038AEr 2               ;		ldx z80_h
0038AEr 2               ;		stx z80_d
0038AEr 2               ;		sta z80_h
0038AEr 2               ;		rts
0038AEr 2               ;
0038AEr 2               exx:
0038AEr 2  A5 rr        		lda z80_c
0038B0r 2  A4 rr        		ldy z80_cp
0038B2r 2  84 rr        		sty z80_c
0038B4r 2  85 rr        		sta z80_cp
0038B6r 2  A5 rr        		lda z80_b
0038B8r 2  A4 rr        		ldy z80_bp
0038BAr 2  84 rr        		sty z80_b
0038BCr 2  85 rr        		sta z80_bp
0038BEr 2  A5 rr        		lda z80_e
0038C0r 2  A4 rr        		ldy z80_ep
0038C2r 2  84 rr        		sty z80_e
0038C4r 2  85 rr        		sta z80_ep
0038C6r 2  A5 rr        		lda z80_d
0038C8r 2  A4 rr        		ldy z80_dp
0038CAr 2  84 rr        		sty z80_d
0038CCr 2  85 rr        		sta z80_dp
0038CEr 2  A5 rr        		lda scraddr
0038D0r 2  A4 rr        		ldy z80_lp
0038D2r 2  84 rr        		sty scraddr
0038D4r 2  85 rr        		sta z80_lp
0038D6r 2  A5 rr        		lda scraddr+1
0038D8r 2  A4 rr        		ldy z80_hp
0038DAr 2  84 rr        		sty scraddr+1
0038DCr 2  85 rr        		sta z80_hp
0038DEr 2  60           		rts
0038DFr 2               
0038DFr 2               ;ex_sp_hl:
0038DFr 2               ;		tsx
0038DFr 2               ;		lda $0103,x
0038DFr 2               ;		ldy z80_h
0038DFr 2               ;		sta z80_h
0038DFr 2               ;		tya
0038DFr 2               ;		sta $0103,x
0038DFr 2               ;		lda $0104,x
0038DFr 2               ;		ldy z80_l
0038DFr 2               ;		sta z80_l
0038DFr 2               ;		tya
0038DFr 2               ;		sta $104,x
0038DFr 2               ;		rts
0038DFr 2               ;
0038DFr 2               ;ldi:
0038DFr 2               ;	rts
0038DFr 2               ;ldir:
0038DFr 2               ;		ldy #$00
0038DFr 2               ;		ldx z80_b
0038DFr 2               ;		beq ldir_last_page
0038DFr 2               ;ldir_loop:
0038DFr 2               ;		lda (z80_hl),y
0038DFr 2               ;		sta (z80_de),y
0038DFr 2               ;		iny
0038DFr 2               ;		bne ldir_loop
0038DFr 2               ;		inc z80_h
0038DFr 2               ;		inc z80_d
0038DFr 2               ;		dex
0038DFr 2               ;		bne ldir_loop
0038DFr 2               ;ldir_last_page:
0038DFr 2               ;		lda z80_c
0038DFr 2               ;		beq ldir_end
0038DFr 2               ;ldir_last_page_loop:
0038DFr 2               ;		lda (z80_hl),y
0038DFr 2               ;		sta (z80_de),y
0038DFr 2               ;		iny
0038DFr 2               ;		cpy z80_c
0038DFr 2               ;		bne ldir_last_page_loop
0038DFr 2               ;ldir_end:
0038DFr 2               ;		stx z80_c
0038DFr 2               ;		stx z80_b
0038DFr 2               ;		tya
0038DFr 2               ;		clc
0038DFr 2               ;		adc z80_l
0038DFr 2               ;		sta z80_l
0038DFr 2               ;		bcc *+4
0038DFr 2               ;		inc z80_h
0038DFr 2               ;		tya
0038DFr 2               ;		clc
0038DFr 2               ;		adc z80_e
0038DFr 2               ;		sta z80_e
0038DFr 2               ;		bcc *+4
0038DFr 2               ;		inc z80_d
0038DFr 2               ;		rts
0038DFr 2               ;
0038DFr 2               ;lddr:		ldy #$00
0038DFr 2               ;lddr_loop:
0038DFr 2               ;		lda (z80_hl),y
0038DFr 2               ;		sta (z80_de),y
0038DFr 2               ;		jsr dec_hl
0038DFr 2               ;		jsr dec_de
0038DFr 2               ;		jsr dec_bc
0038DFr 2               ;		lda z80_b
0038DFr 2               ;		ora z80_c
0038DFr 2               ;		bne lddr_loop
0038DFr 2               ;		rts
0038DFr 2               ;ei:
0038DFr 2               ;		rts
0038DFr 2               ;di:
0038DFr 2               ;		rts
0038DFr 2               
0038DFr 2               ;-------------------------------------------------------------
0038DFr 2               ; Set bits in bitmem
0038DFr 2               ;-------------------------------------------------------------
0038DFr 2               
0038DFr 2               .if 0
0038DFr 2               z80_init:
0038DFr 2               	ldx #$00
0038DFr 2               	lda #$01
0038DFr 2               z80_init_loop:
0038DFr 2               	sta _bitmem0,x
0038DFr 2               	inx
0038DFr 2               	asl a
0038DFr 2               	bne z80_init_loop
0038DFr 2               	rts
0038DFr 2               .endif
0038DFr 2               
0038DFr 2               push_af:
0038DFr 2               push_bc:
0038DFr 2               push_de:
0038DFr 2               push_hl:
0038DFr 2               
0038DFr 2               pop_af:
0038DFr 2               pop_bc:
0038DFr 2               pop_de:
0038DFr 2               pop_ix:
0038DFr 2               pop_hl:
0038DFr 2               
0038DFr 2               add_hl_hl:
0038DFr 2               
0038DFr 2               inc_bc:
0038DFr 2               inc_de:
0038DFr 2               inc_hl:
0038DFr 2               inc_ix:
0038DFr 2               inc_sp:
0038DFr 2               
0038DFr 2               cpir:
0038DFr 2               
0038DFr 2               ex_af_af:
0038DFr 2               ;	rts
0038DFr 2               
0038DFr 1               
0038DFr 1               eind_asm:
0038DFr 1               eop:					; End Of Program
0038DFr 1               
0038DFr 1               .out .sprintf("Gamecode size = %d bytes, free space = %d bytes", (eind_asm - main),(24576-eind_asm + main))
0038DFr 1               
