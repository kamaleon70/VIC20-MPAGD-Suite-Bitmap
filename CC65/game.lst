ca65 V2.13.3 - (C) Copyright 1998-2012 Ullrich von Bassewitz
Main file   : game.asm
Current file: game.asm

000000r 1               ;----------------------------------------------
000000r 1               ; Common AGD engine
000000r 1               ; VIC20 conversion by Kees van Oss 2024
000000r 1               ;----------------------------------------------
000000r 1               
000000r 1               .segment "ZEROPAGE"
000000r 1               	.include "game.cfg"
000000r 2               ; Flags saved by AGD Compiler
000000r 2               
000000r 2               mflag = 0 ;
000000r 2               pflag = 0 ;
000000r 2               sflag = 0 ;
000000r 2               dflag = 0 ;
000000r 2               cflag = 0 ;
000000r 2               oflag = 0 ;
000000r 2               lflag = 0 ;
000000r 2               bflag = 0 ;
000000r 2               rflag = 0 ;
000000r 2               
000000r 1               	.include "engine-zp.inc"
000000r 2               ;----------------------------------------------------------------------
000000r 2               ; AGD 6502 Engine Zero Page Variables
000000r 2               ;----------------------------------------------------------------------
000000r 2               
000000r 2               ; Variables start here.
000000r 2               
000000r 2  xx           scno:	.res 1			; present screen number.
000001r 2  xx           numlif:	.res 1			; number of lives.
000002r 2               
000002r 2  xx           vara:	.res 1			; general-purpose variable.
000003r 2  xx           varb:	.res 1			; general-purpose variable.
000004r 2  xx           varc:	.res 1			; general-purpose variable.
000005r 2  xx           vard:	.res 1			; general-purpose variable.
000006r 2  xx           vare:	.res 1			; general-purpose variable.
000007r 2  xx           varf:	.res 1			; general-purpose variable.
000008r 2  xx           varg:	.res 1			; general-purpose variable.
000009r 2  xx           varh:	.res 1			; general-purpose variable.
00000Ar 2  xx           vari:	.res 1			; general-purpose variable.
00000Br 2  xx           varj:	.res 1			; general-purpose variable.
00000Cr 2  xx           vark:	.res 1			; general-purpose variable.
00000Dr 2  xx           varl:	.res 1			; general-purpose variable.
00000Er 2  xx           varm:	.res 1			; general-purpose variable.
00000Fr 2  xx           varn:	.res 1			; general-purpose variable.
000010r 2  xx           varo:	.res 1			; general-purpose variable.
000011r 2  xx           varp:	.res 1			; general-purpose variable.
000012r 2  xx           varq:	.res 1			; general-purpose variable.
000013r 2  xx           varr:	.res 1			; general-purpose variable.
000014r 2  xx           vars:	.res 1			; general-purpose variable.
000015r 2  xx           vart:	.res 1			; general-purpose variable.
000016r 2  xx           varu:	.res 1			; general-purpose variable.
000017r 2  xx           varv:	.res 1			; general-purpose variable.
000018r 2  xx           varw:	.res 1			; general-purpose variable.
000019r 2  xx           varz:	.res 1			; general-purpose variable.
00001Ar 2               
00001Ar 2  xx           charx:	.res 1			; cursor x position.
00001Br 2  xx           chary:	.res 1			; cursor y position.
00001Cr 2               
00001Cr 2  xx           clock:	.res 1			; last clock reading.
00001Dr 2  xx           varrnd:	.res 1	        ; last random number.
00001Er 2  xx           varobj:	.res 1  	    ; last object number.
00001Fr 2  xx           varopt:	.res 1     		; last option chosen from menu.
000020r 2  xx           varblk:	.res 1  		; block type.
000021r 2  xx           nexlev:	.res 1			; next level flag.
000022r 2  xx           restfl:	.res 1			; restart screen flag.
000023r 2  xx           deadf:	.res 1			; dead flag.
000024r 2  xx           gamwon:	.res 1			; game won flag.
000025r 2  xx           dispx:	.res 1			; cursor x position.
000026r 2  xx           dispy:	.res 1			; cursor y position.
000027r 2               
000027r 2  xx xx xx xx  dummy:  .res 5
00002Br 2  xx           
00002Cr 2               
00002Cr 2  xx           contrl:	.res 1			; control 0 = keyboard, 1 = Joystick.
00002Dr 2  xx           joyval:	.res 1			; joystick reading.
00002Er 2  xx           frmno:	.res 1			; selected frame.
00002Fr 2               
00002Fr 2               ;----------------------------------------------------
00002Fr 2               ; Missing vars
00002Fr 2               ;----------------------------------------------------
00002Fr 2               
00002Fr 2  xx           loopa:	    .res 1
000030r 2  xx           loopb:	    .res 1
000031r 2  xx           loopc:	    .res 1
000032r 2  xx xx        FontPtr:    .res 2
000034r 2               
000034r 2               ; Local vars
000034r 2               
000034r 2  xx xx        scraddr:    .res 2
000036r 2  xx xx        fntaddr:    .res 2
000038r 2  xx xx        tileaddr:   .res 2
00003Ar 2  xx xx        bufaddr:    .res 2
00003Cr 2               
00003Cr 2  xx xx        tmp:        .res 2
00003Er 2               .if sflag
00003Er 2               scr_l:      .res 2
00003Er 2               scr_r:      .res 2
00003Er 2               scr_txt:    .res 2
00003Er 2               scr_tmp:    .res 2
00003Er 2               .endif
00003Er 2               
00003Er 2  xx           xtmp:	    .res 1
00003Fr 2  xx           spcnt:	    .res 1
000040r 2  xx xx        spptr:	    .res 2		; spawned sprite pointer.
000042r 2  xx           seed:	    .res 1		; seed for random numbers.
000043r 2               
000043r 2  xx           ccnt:       .res 1
000044r 2  xx           flag:	    .res 1
000045r 2  xx           rcol:	    .res 1
000046r 2  xx           rrow:	    .res 1
000047r 2               
000047r 2  xx           combyt:	    .res 1		; byte type compressed.
000048r 2  xx           comcnt:	    .res 1		; compression counter.
000049r 2  xx           prtmod:	    .res 1      ; print mode, 0 = standard, 1 = double-height.
00004Ar 2  xx           qscnt:	    .res 1
00004Br 2               
00004Br 2  xx           sprptr:	    .res 1      ; not a ptr
00004Cr 2  xx           sprcnt:	    .res 1
00004Dr 2               
00004Dr 2  xx xx        skptr:	    .res 2		; search pointer.
00004Fr 2  xx           sktptr:	    .res 1      ; not a ptr
000050r 2  xx           tmproom:    .res 1
000051r 2  xx xx        ogptr:	    .res 2		; original sprite pointer.
000053r 2               
000053r 2  xx xx xx     spr:	    .res 3      ; static sprite data
000056r 2  xx           vsync_count:.res 1
000057r 2  xx           colpatt:    .res 1
000058r 2  xx           sprtmp:     .res 1
000059r 2  xx           sprtmp2:    .res 1
00005Ar 2  xx           sprshft:    .res 1
00005Br 2               
00005Br 2  xx           spriteink:  .res 1
00005Cr 2  xx           colour_byte:.res 1
00005Dr 2  xx           colour_xor: .res 1
00005Er 2  xx           objcol:	    .res 1
00005Fr 2               
00005Fr 2               .if mflag
00005Fr 2               TmpAddr:    .res 2
00005Fr 2               bwid:	    .res 1     ; box/menu width.
00005Fr 2               blen:	    .res 1     ; box/menu height.
00005Fr 2               btop:	    .res 1     ; box coordinates.
00005Fr 2               blft:	    .res 1
00005Fr 2               .endif
00005Fr 2               
00005Fr 2               .if pflag
00005Fr 2               shrctr:	    .res 1
00005Fr 2               explcnt:    .res 1
00005Fr 2               seed3:	    .res 1
00005Fr 2               .endif
00005Fr 2               
00005Fr 2               .if aflag
00005Fr 2               pbbuf:      .res 2
00005Fr 2               pbptr:      .res 2
00005Fr 2               .endif
00005Fr 2               
00005Fr 2  xx           tmp1:       .res 1
000060r 2  xx           tmp2:       .res 1
000061r 2               
000061r 2  xx           SOUNDS_STATUS:      .res 1
000062r 2               
000062r 2               ;----------------------------------------------------
000062r 2               ; Music player variables
000062r 2               ;----------------------------------------------------
000062r 2               
000062r 2               ;SONG_POS:		.res 1	; = $90
000062r 2               ;PATTERN_POS:		.res 1	; = $91
000062r 2               ;FRAME_COUNT:		.res 1	; = $92
000062r 2               ;FRAME_LENGTH:		.res 1	; = $93
000062r 2               ;SONG_NEXT_TRUE:		.res 1	; = $94
000062r 2               ;SONG_END_TRUE:		.res 1	; = $95
000062r 2               
000062r 2               ; 2 byte address of pattern data
000062r 2               ;CH1_PATTERN_POS:	.res 2	; = $96
000062r 2               ;CH2_PATTERN_POS:	.res 2	; = $98
000062r 2               ;CH3_PATTERN_POS:	.res 2	; = $9a
000062r 2               ;CH4_PATTERN_POS:	.res 2	; = $9c
000062r 2               
000062r 2               ; #$00 == inactive mode
000062r 2               ;CH1_ACTIVE:		.res 1	; = $a0
000062r 2               ;CH2_ACTIVE:		.res 1	; = $a1
000062r 2               ;CH3_ACTIVE:		.res 1	; = $a2
000062r 2               ;CH4_ACTIVE:		.res 1	; = $a3
000062r 2               
000062r 2               ;TEMP_GUY:		.res 1	; = $a4
000062r 2               ;CHAN_NOTE_DATA:		.res 1	; = $a5
000062r 2               ;CHANS_INACTIVE:		.res 1	; = $a6
000062r 2               ;FAST_COUNTER:		.res 1	; = $a7
000062r 2               ;MEGA_COUNTER:		.res 1	; = $a8
000062r 2               
000062r 1               	.include "z80-zp.inc"
000062r 2               ;ws	 = $60
000062r 2               
000062r 2  xx           z80_f: .res 1;	 = ws+$00
000063r 2  xx           z80_a: .res 1;	 = ws+$01
000064r 2               z80_af	 = z80_f
000064r 2               
000064r 2  xx           z80_c: .res 1;	 = ws+$02
000065r 2  xx           z80_b: .res 1;	 = ws+$03
000066r 2               z80_bc	 = z80_c
000066r 2               
000066r 2  xx           z80_e: .res 1;	 = ws+$04
000067r 2  xx           z80_d: .res 1;	 = ws+$05
000068r 2               z80_de	 = z80_e
000068r 2               
000068r 2  xx           z80_l: .res 1;	 = ws+$06
000069r 2  xx           z80_h: .res 1;	 = ws+$07
00006Ar 2               z80_hl	 = z80_l
00006Ar 2               
00006Ar 2  xx           z80_x: .res 1;    = ws+$08
00006Br 2  xx           z80_i: .res 1;    = ws+$09
00006Cr 2               z80_ix	 = z80_x
00006Cr 2               
00006Cr 2  xx xx        z80_iy: .res 2;	 = ws+$0a
00006Er 2               
00006Er 2  xx           z80_fp: .res 1;	 = ws+$0c
00006Fr 2  xx           z80_ap: .res 1;	 = ws+$0d
000070r 2               
000070r 2  xx           z80_cp: .res 1;	 = ws+$0e
000071r 2  xx           z80_bp: .res 1;	 = ws+$0f
000072r 2               z80_bcp	 = z80_cp
000072r 2               
000072r 2  xx           z80_ep: .res 1;	 = ws+$10
000073r 2  xx           z80_dp: .res 1;	 = ws+$11
000074r 2               z80_dep	 = z80_ep
000074r 2               
000074r 2  xx           z80_lp: .res 1;	 = ws+$12
000075r 2  xx           z80_hp: .res 1;	 = ws+$13
000076r 2               z80_hlp	 = z80_lp
000076r 2               
000076r 2  xx xx        z80_sp: .res 2;   = ws+$14
000078r 2               
000078r 2  xx           z80_reg0: .res 1; = ws+$16
000079r 2  xx           z80_reg1: .res 1; = ws+$17
00007Ar 2  xx           z80_reg2: .res 1; = ws+$18
00007Br 2  xx           z80_reg3: .res 1; = ws+$19
00007Cr 2               
00007Cr 2               ;z80_r: .res 1;	 = ws+$1a
00007Cr 2               
00007Cr 1               
00007Cr 1               ;----------------------------------------------
00007Cr 1               ; BASIC header
00007Cr 1               ;----------------------------------------------
00007Cr 1               
00007Cr 1               .segment "BASIC"
000000r 1               
000000r 1  rr rr        	.word load
000002r 1  rr rr        load:   .word @end
000004r 1  02 00        	.word 2
000006r 1  9E           	.byte $9e
000007r 1  38           	.byte .lobyte(main/1000 .mod 10) + $30
000008r 1  31           	.byte .lobyte(main/100 .mod 10) + $30
000009r 1  39           	.byte .lobyte(main/10 .mod 10) + $30
00000Ar 1  32           	.byte .lobyte(main/1 .mod 10) + $30
00000Br 1  00           	.byte 0
00000Cr 1  00 00        @end:   .word 0
00000Er 1               
00000Er 1               ;----------------------------------------------
00000Er 1               
00000Er 1               .segment "MUSIC"
000000r 1               .org $a900
00A900  1               	.include "music/player1.inc"
00A900  2               ;---------------------------------------------------------------
00A900  2               ; Music player routine
00A900  2               ;---------------------------------------------------------------
00A900  2               ; - Music player + data should be loaded at $a900
00A900  2               ; - $a900 = jmp music_init
00A900  2               ; - $a903 = jmp music_on
00A900  2               ; - $a906 = jmp music_off
00A900  2               ; - $a909 = jmp music_play
00A900  2               ; - Zeropage variables from $90 upwards can be used
00A900  2               ;---------------------------------------------------------------
00A900  2               
00A900  2               
00A900  2               ;---------------------------------------------------------------
00A900  2               ; Zeropage variables
00A900  2               ;---------------------------------------------------------------
00A900  2               
00A900  2               	SONG_POS          = $d0
00A900  2               	PATTERN_POS       = $d1
00A900  2               	FRAME_COUNT       = $d2
00A900  2               	FRAME_LENGTH      = $d3
00A900  2               	SONG_NEXT_TRUE    = $d4
00A900  2               	SONG_END_TRUE     = $d5
00A900  2               
00A900  2               ; 2 byte address of pattern data
00A900  2               
00A900  2               	CH1_PATTERN_POS   = $d6
00A900  2               	CH2_PATTERN_POS   = $d8
00A900  2               	CH3_PATTERN_POS   = $da
00A900  2               	CH4_PATTERN_POS   = $dc
00A900  2               
00A900  2               ; #$00 == inactive mode
00A900  2               
00A900  2               	CH1_ACTIVE        = $e0
00A900  2               	CH2_ACTIVE        = $e1
00A900  2               	CH3_ACTIVE        = $e2
00A900  2               	CH4_ACTIVE        = $e3
00A900  2               
00A900  2               	TEMP_GUY          = $e4
00A900  2               	CHAN_NOTE_DATA    = $e5
00A900  2               	CHANS_INACTIVE    = $e6
00A900  2               	FAST_COUNTER      = $e7
00A900  2               	MEGA_COUNTER      = $e8
00A900  2               
00A900  2               ; Flag for enable/disable channel for music
00A900  2               
00A900  2               	CHANNEL1_ENABLED  = $ea
00A900  2               	CHANNEL2_ENABLED  = $eb
00A900  2               	CHANNEL3_ENABLED  = $ec
00A900  2               	CHANNEL4_ENABLED  = $ed
00A900  2               	MUSIC_ON	      = $ee
00A900  2               
00A900  2               ;---------------------------------------------------------------
00A900  2               ; Constants
00A900  2               ;---------------------------------------------------------------
00A900  2               
00A900  2               	TEXT_TITLE	= songpos
00A900  2               	TEXT_ARTIST	= songpos+$10
00A900  2               	TEXT_COPY	= songpos+$20
00A900  2               	TABLE_SPEED	= songpos+$30
00A900  2               	TABLE_VOLUME	= songpos+$40
00A900  2               	PATTERNS	= songpos+$50
00A900  2               	SONG_PAGE_1	= songpos+$850
00A900  2               	SONG_PAGE_2	= songpos+$950
00A900  2               
00A900  2               ; VIC-I chip audio registers
00A900  2               	VIC_CHAN_1	= $900a
00A900  2               	VIC_CHAN_2	= $900b
00A900  2               	VIC_CHAN_3	= $900c
00A900  2               	VIC_CHAN_4	= $900d
00A900  2               	VIC_VOLUME	= $900e
00A900  2               
00A900  2               
00A900  2               ; bit masks for pattern data / effects
00A900  2               	NOTE_IS		= %10000000
00A900  2               	NOTE_OFF	= %00000001
00A900  2               	NOTE_NEXT	= %00000010
00A900  2               	NOTE_END	= %00000011
00A900  2               	NOTE_NOTHING	= %00000000
00A900  2               
00A900  2               ; VIC VIA constants
00A900  2               
00A900  2               	Timer21_Low  	= $9124		; Timer 1 low byte
00A900  2               	Timer21_High 	= $9125		; Timer 1 high byte
00A900  2               	AUX2		= $912b		; Auxiliary control register
00A900  2               	IFR2		= $912d		; Interrupt Flag Register
00A900  2               	IER2		= $912e		; Interrupt Enable Register
00A900  2               ;	timerint	= 20000		; Interrupt timer 1/50 sec
00A900  2               
00A900  2               ;---------------------------------------------------------------
00A900  2               ; API calls, entry with A = API call
00A900  2               ;---------------------------------------------------------------
00A900  2               .org $a900
00A900  2  4C 0C A9     	jmp music_init
00A903  2  4C 4A A9     	jmp music_on
00A906  2  4C 65 A9     	jmp music_off
00A909  2  4C 7E A9     	jmp music_play
00A90C  2               
00A90C  2               ;---------------------------------------------------------------
00A90C  2               ; Initialisation routine
00A90C  2               ;---------------------------------------------------------------
00A90C  2               
00A90C  2               music_init:
00A90C  2               
00A90C  2               ; Init VIA2 timer21 for IRQ 1/50 sec
00A90C  2               
00A90C  2  78           	sei			; disable interrupt
00A90D  2  A9 40        	lda #$40		; T1 continuous, no square wave on PB7
00A90F  2  8D 2B 91     	sta AUX2
00A912  2  A9 C0        	lda #$c0		; int timer1
00A914  2  8D 2E 91     	sta IER2
00A917  2  A9 20        	lda #<timerint		; timer 1/50 sec
00A919  2  8D 24 91     	sta Timer21_Low
00A91C  2  A9 4E        	lda #>timerint
00A91E  2  8D 25 91     	sta Timer21_High
00A921  2  A9 3E        	lda #<int_service	; set new IRQ vector
00A923  2  8D 14 03     	sta $0314
00A926  2  A9 A9        	lda #>int_service
00A928  2  8D 15 03     	sta $0315
00A92B  2               
00A92B  2               ; Init music player
00A92B  2               
00A92B  2  A9 00        	lda #$00
00A92D  2  85 D0        	sta SONG_POS
00A92F  2  85 D1        	sta PATTERN_POS
00A931  2  85 D4        	sta SONG_NEXT_TRUE
00A933  2  85 D5        	sta SONG_END_TRUE
00A935  2  85 D2        	sta FRAME_COUNT
00A937  2  85 E8        	sta MEGA_COUNTER
00A939  2               
00A939  2  A9 01        	lda #$01		; load first frame length
00A93B  2  85 D3        	sta FRAME_LENGTH
00A93D  2  60           	rts
00A93E  2               
00A93E  2               
00A93E  2               ;---------------------------------------------------------------
00A93E  2               ; INTERRUPT SERVICE ROUTINE
00A93E  2               ;---------------------------------------------------------------
00A93E  2               
00A93E  2               int_service:
00A93E  2  AD 24 91     	lda Timer21_Low		; Clear timer1 flag
00A941  2               
00A941  2               ; Insert interrupt code here
00A941  2               
00A941  2  20 7E A9     	jsr music_play		; Cycle color topleft char
00A944  2               
00A944  2               ; End of interrupt code
00A944  2               
00A944  2  68           	pla			; Restore resgisters
00A945  2  A8           	tay
00A946  2  68           	pla
00A947  2  AA           	tax
00A948  2  68           	pla
00A949  2               
00A949  2  40           	rti			; Return from interrupt
00A94A  2               
00A94A  2               ;---------------------------------------------------------------
00A94A  2               ; Music_on, enable interrupt and play music
00A94A  2               ;---------------------------------------------------------------
00A94A  2               
00A94A  2               music_on:
00A94A  2  A9 C0        	lda #$c0		; int timer1
00A94C  2  8D 2E 91     	sta IER2
00A94F  2  AD 0E 90     	lda $900e
00A952  2  09 0F        	ora #$0f
00A954  2  8D 0E 90     	sta $900e
00A957  2               
00A957  2  A9 01        	lda #$1
00A959  2  85 EE        	sta MUSIC_ON
00A95B  2  85 EA        	sta CHANNEL1_ENABLED
00A95D  2  85 EB        	sta CHANNEL2_ENABLED
00A95F  2  85 EC        	sta CHANNEL3_ENABLED
00A961  2  85 ED        	sta CHANNEL4_ENABLED
00A963  2               
00A963  2  58           	cli			; enable interrupts
00A964  2  60           	rts
00A965  2               
00A965  2               ;---------------------------------------------------------------
00A965  2               ; Music_off, disable interrrupt and stop music
00A965  2               ;---------------------------------------------------------------
00A965  2               
00A965  2               music_off:
00A965  2               	; sei			; enable interrupts
00A965  2               	; lda #$7f		; int timer1
00A965  2               	; sta IFR2
00A965  2               	; sta IER2
00A965  2               	; lda #$00
00A965  2               	; sta $900e
00A965  2               
00A965  2  A9 00        	lda #$0
00A967  2  85 EE        	sta MUSIC_ON
00A969  2  85 EA        	sta CHANNEL1_ENABLED
00A96B  2  85 EB        	sta CHANNEL2_ENABLED
00A96D  2  85 EC        	sta CHANNEL3_ENABLED
00A96F  2  85 ED        	sta CHANNEL4_ENABLED
00A971  2  8D 0A 90     	sta VIC_CHAN_1
00A974  2  8D 0B 90     	sta VIC_CHAN_2
00A977  2  8D 0C 90     	sta VIC_CHAN_3
00A97A  2  8D 0D 90     	sta VIC_CHAN_4
00A97D  2               
00A97D  2  60           	rts
00A97E  2               
00A97E  2               ;---------------------------------------------------------------
00A97E  2               ; Mainloop
00A97E  2               ;---------------------------------------------------------------
00A97E  2               
00A97E  2               music_play:
00A97E  2               main_loop_skip_raster:
00A97E  2               
00A97E  2               ; load them patterns
00A97E  2               ; resets song position if 4 empty patterns
00A97E  2  20 56 AA     	jsr SONG_POS_UPDATE
00A981  2               
00A981  2               ; update song stuff
00A981  2  20 BC A9     	jsr AUDIO_UPDATE
00A984  2               
00A984  2               ; check if NeXT was called
00A984  2  A5 D4        	lda SONG_NEXT_TRUE
00A986  2  C9 00        	cmp #$00
00A988  2  F0 11        	beq not_next_effect_called
00A98A  2  A9 00        	lda #$00
00A98C  2  85 D1        	sta PATTERN_POS
00A98E  2  85 D4        	sta SONG_NEXT_TRUE
00A990  2  E6 D0        	inc SONG_POS
00A992  2  20 56 AA     	jsr SONG_POS_UPDATE
00A995  2  20 1C AA     	jsr AUDIO_PROCESS_CHANNEL
00A998  2  4C 7E A9     	jmp main_loop_skip_raster
00A99B  2               
00A99B  2               ; ready for next music frame?
00A99B  2               not_next_effect_called:
00A99B  2  E6 D2        	inc FRAME_COUNT
00A99D  2  A5 D2        	lda FRAME_COUNT
00A99F  2  C5 D3        	cmp FRAME_LENGTH
00A9A1  2  D0 18        	bne endmusicplayfunc
00A9A3  2               
00A9A3  2               ; reset frame counter
00A9A3  2  A9 00        	lda #$00
00A9A5  2  85 D2        	sta FRAME_COUNT
00A9A7  2               
00A9A7  2               ; increase pattern position
00A9A7  2  E6 D1        	inc PATTERN_POS
00A9A9  2  A5 D1        	lda PATTERN_POS
00A9AB  2  C9 10        	cmp #$10
00A9AD  2  D0 08        	bne not_next_pattern
00A9AF  2               
00A9AF  2               next_pattern:
00A9AF  2  A9 00        	lda #$00
00A9B1  2  85 D1        	sta PATTERN_POS
00A9B3  2  E6 D0        	inc SONG_POS
00A9B5  2  A5 D0        	lda SONG_POS
00A9B7  2               
00A9B7  2               not_next_pattern:
00A9B7  2               
00A9B7  2               ; done
00A9B7  2  E6 E8        	inc MEGA_COUNTER
00A9B9  2  A5 E8        	lda MEGA_COUNTER
00A9BB  2               
00A9BB  2               endmusicplayfunc:
00A9BB  2  60           	rts
00A9BC  2               
00A9BC  2               ;---------------------------------------------------------------
00A9BC  2               ;---------------------------------------------------------------
00A9BC  2               
00A9BC  2               ; grab current playback data and push to VIC
00A9BC  2               
00A9BC  2               AUDIO_UPDATE:
00A9BC  2               
00A9BC  2               ; y = pattern position
00A9BC  2  A4 D1        	ldy PATTERN_POS
00A9BE  2  B9 30 AB     	lda TABLE_SPEED,y
00A9C1  2  85 D3        	sta FRAME_LENGTH
00A9C3  2  B9 40 AB     	lda TABLE_VOLUME,y
00A9C6  2  29 F0        	and #$f0
00A9C8  2  0D 0E 90     	ora VIC_VOLUME
00A9CB  2  8D 0E 90     	sta VIC_VOLUME
00A9CE  2               
00A9CE  2               ; x = channel counter
00A9CE  2  A2 00        	ldx #$00
00A9D0  2               
00A9D0  2               ; CHANNEL 1
00A9D0  2  A5 E0        	lda CH1_ACTIVE
00A9D2  2  C9 00        	cmp #$00
00A9D4  2  D0 05        	bne channel1_active
00A9D6  2               
00A9D6  2  A9 20        	lda #$20
00A9D8  2  4C E2 A9     	jmp channel1_done
00A9DB  2               
00A9DB  2               channel1_active:
00A9DB  2  B1 D6        	lda (CH1_PATTERN_POS),y
00A9DD  2  20 1C AA     	jsr AUDIO_PROCESS_CHANNEL
00A9E0  2  69 20        	adc #$20
00A9E2  2               
00A9E2  2               channel1_done:
00A9E2  2               
00A9E2  2               ; CHANNEL 2
00A9E2  2  E8           	inx
00A9E3  2  A5 E1        	lda CH2_ACTIVE
00A9E5  2  C9 00        	cmp #$00
00A9E7  2  D0 05        	bne channel2_active
00A9E9  2               
00A9E9  2  A9 20        	lda #$20
00A9EB  2  4C F5 A9     	jmp channel2_done
00A9EE  2               
00A9EE  2               channel2_active:
00A9EE  2  B1 D8        	lda (CH2_PATTERN_POS),y
00A9F0  2  20 1C AA     	jsr AUDIO_PROCESS_CHANNEL
00A9F3  2  69 20        	adc #$20
00A9F5  2               
00A9F5  2               channel2_done:
00A9F5  2               
00A9F5  2               ; CHANNEL 3
00A9F5  2  E8           	inx
00A9F6  2  A5 E2        	lda CH3_ACTIVE
00A9F8  2  C9 00        	cmp #$00
00A9FA  2  D0 05        	bne channel3_active
00A9FC  2  A9 20        	lda #$20
00A9FE  2  4C 08 AA     	jmp channel3_done
00AA01  2               
00AA01  2               channel3_active:
00AA01  2  B1 DA        	lda (CH3_PATTERN_POS),y
00AA03  2  20 1C AA     	jsr AUDIO_PROCESS_CHANNEL
00AA06  2  69 20        	adc #$20
00AA08  2               
00AA08  2               channel3_done:
00AA08  2               
00AA08  2               ; CHANNEL 4
00AA08  2  E8           	inx
00AA09  2  A5 E3        	lda CH4_ACTIVE
00AA0B  2  C9 00        	cmp #$00
00AA0D  2  D0 05        	bne channel4_active
00AA0F  2               
00AA0F  2  A9 20        	lda #$20
00AA11  2  4C 1B AA     	jmp channel4_done
00AA14  2               
00AA14  2               channel4_active:
00AA14  2  B1 DC        	lda (CH4_PATTERN_POS),y
00AA16  2  20 1C AA     	jsr AUDIO_PROCESS_CHANNEL
00AA19  2  69 20        	adc #$20
00AA1B  2               
00AA1B  2               channel4_done:
00AA1B  2  60           	rts
00AA1C  2               
00AA1C  2               ;---------------------------------------------------------------
00AA1C  2               ;---------------------------------------------------------------
00AA1C  2               
00AA1C  2               AUDIO_PROCESS_CHANNEL:
00AA1C  2  85 E5        	sta CHAN_NOTE_DATA
00AA1E  2  29 80        	and #%10000000
00AA20  2  C9 80        	cmp #%10000000
00AA22  2  D0 0A        	bne not_note
00AA24  2               
00AA24  2               is_note:
00AA24  2  B5 EA        	lda CHANNEL1_ENABLED,x
00AA26  2  F0 05        	beq channel_disabled_is_note
00AA28  2  A5 E5        	lda CHAN_NOTE_DATA
00AA2A  2  9D 0A 90     	sta VIC_CHAN_1,x
00AA2D  2               channel_disabled_is_note:
00AA2D  2  60           	rts
00AA2E  2               
00AA2E  2               not_note:
00AA2E  2  A5 E5        	lda CHAN_NOTE_DATA
00AA30  2  C9 01        	cmp #%00000001
00AA32  2  D0 0A        	bne not_note_off
00AA34  2               
00AA34  2  B5 EA        	lda CHANNEL1_ENABLED,x
00AA36  2  F0 05        	beq channel_disabled_not_note
00AA38  2  A9 00        	lda #$00
00AA3A  2  9D 0A 90     	sta VIC_CHAN_1,x
00AA3D  2               channel_disabled_not_note:
00AA3D  2  60           	rts
00AA3E  2               
00AA3E  2               not_note_off:
00AA3E  2  A5 E5        	lda CHAN_NOTE_DATA
00AA40  2  C9 02        	cmp #%00000010
00AA42  2  D0 03        	bne not_note_next
00AA44  2               
00AA44  2               ; move song to next song row
00AA44  2  E6 D4        	inc SONG_NEXT_TRUE
00AA46  2               
00AA46  2               ; XXX do what here?
00AA46  2               ; will update correctly on next frame
00AA46  2               ; if we move where this subroutine gets called
00AA46  2               
00AA46  2               ;	lda #$00
00AA46  2  60           	rts
00AA47  2               
00AA47  2               not_note_next:
00AA47  2  A5 E5        	lda CHAN_NOTE_DATA
00AA49  2  C9 03        	cmp #NOTE_END
00AA4B  2  D0 08        	bne not_end_of_song
00AA4D  2               
00AA4D  2               ; turn the sound off cheaply :D/
00AA4D  2  AD 0E 90     	lda VIC_VOLUME
00AA50  2  29 F0        	and #$f0
00AA52  2  8D 0E 90     	sta VIC_VOLUME
00AA55  2               
00AA55  2               ;-----BUG----------
00AA55  2               ; soft reset the machine!
00AA55  2               ; solution from https://www.c64-wiki.com/wiki/Reset_(Process)
00AA55  2               ;	jmp $fd22
00AA55  2               ;-----BUG----------
00AA55  2               
00AA55  2               not_end_of_song:
00AA55  2  60           	rts
00AA56  2               
00AA56  2               ;---------------------------------------------------------------
00AA56  2               ;---------------------------------------------------------------
00AA56  2               
00AA56  2               ; put pattern addresses in zero page
00AA56  2               ; SONG_POS should be set before calling
00AA56  2               
00AA56  2               SONG_POS_UPDATE:
00AA56  2               
00AA56  2               ; x = channel pattern position offset
00AA56  2  A2 00        	ldx #$00
00AA58  2  86 E6        	stx CHANS_INACTIVE
00AA5A  2  A9 FF        	lda #$ff
00AA5C  2  85 E0        	sta CH1_ACTIVE
00AA5E  2  85 E1        	sta CH2_ACTIVE
00AA60  2  85 E2        	sta CH3_ACTIVE
00AA62  2  85 E3        	sta CH4_ACTIVE
00AA64  2               
00AA64  2               song_pos_loop:
00AA64  2  A5 D0        	lda SONG_POS
00AA66  2  38           	sec
00AA67  2  E9 40        	sbc #$40
00AA69  2  10 10        	bpl song_page_2
00AA6B  2               
00AA6B  2               song_page_1:
00AA6B  2  0A           	asl
00AA6C  2  0A           	asl
00AA6D  2  85 E4        	sta TEMP_GUY
00AA6F  2  8A           	txa
00AA70  2  4A           	lsr
00AA71  2  18           	clc
00AA72  2  65 E4        	adc TEMP_GUY
00AA74  2  A8           	tay
00AA75  2  B9 50 B3     	lda SONG_PAGE_1,y
00AA78  2  4C 88 AA     	jmp pattern_found
00AA7B  2               
00AA7B  2               song_page_2:
00AA7B  2  0A           	asl
00AA7C  2  0A           	asl
00AA7D  2  85 E4        	sta TEMP_GUY
00AA7F  2  8A           	txa
00AA80  2  4A           	lsr
00AA81  2  18           	clc
00AA82  2  65 E4        	adc TEMP_GUY
00AA84  2  A8           	tay
00AA85  2  B9 50 B4     	lda SONG_PAGE_2,y
00AA88  2               
00AA88  2               pattern_found:
00AA88  2  85 E4        	sta TEMP_GUY
00AA8A  2               
00AA8A  2               ; lets make sure its not an empty pattern
00AA8A  2  C9 FF        	cmp #$ff
00AA8C  2  D0 17        	bne dont_reset
00AA8E  2               
00AA8E  2               ; set channel to inactive mode
00AA8E  2  8A           	txa
00AA8F  2  4A           	lsr
00AA90  2  A8           	tay
00AA91  2  A9 00        	lda #$00
00AA93  2  99 E0 00     	sta CH1_ACTIVE,y
00AA96  2               
00AA96  2               ; reset song if there are 4 empty patterns
00AA96  2  E6 E6        	inc CHANS_INACTIVE
00AA98  2  A5 E6        	lda CHANS_INACTIVE
00AA9A  2  C9 04        	cmp #$04
00AA9C  2  D0 07        	bne dont_reset
00AA9E  2               
00AA9E  2               song_reset:
00AA9E  2  A9 00        	lda #$00
00AAA0  2  85 D0        	sta SONG_POS
00AAA2  2  4C 56 AA     	jmp SONG_POS_UPDATE
00AAA5  2               
00AAA5  2               dont_reset:
00AAA5  2  A5 E4        	lda TEMP_GUY
00AAA7  2               
00AAA7  2               ; LSB
00AAA7  2  0A           	asl
00AAA8  2  0A           	asl
00AAA9  2  0A           	asl
00AAAA  2  0A           	asl
00AAAB  2  18           	clc
00AAAC  2  69 50        	adc #<PATTERNS	;$50
00AAAE  2  95 D6        	sta CH1_PATTERN_POS,x
00AAB0  2  E8           	inx
00AAB1  2               
00AAB1  2               ; MSB11
00AAB1  2  A5 E4        	lda TEMP_GUY
00AAB3  2  4A           	lsr
00AAB4  2  4A           	lsr
00AAB5  2  4A           	lsr
00AAB6  2  4A           	lsr
00AAB7  2  18           	clc
00AAB8  2  69 AB        	adc #>PATTERNS
00AABA  2  95 D6        	sta CH1_PATTERN_POS,x
00AABC  2  E8           	inx
00AABD  2  E0 08        	cpx #$08
00AABF  2  D0 A3        	bne song_pos_loop
00AAC1  2  60           	rts
00AAC2  2               
00AAC2  2               
00AAC2  1  xx xx xx xx  	.align $100
00AAC6  1  xx xx xx xx  
00AACA  1  xx xx xx xx  
00AB00  1               songpos:
00AB00  1  48 01 0C 0C  	.incbin "music/songdata_pal.bin"
00AB04  1  0F 17 05 27  
00AB08  1  05 0E 20 20  
00B550  1               
00B550  1               .segment "CODE"
00B550  1               .org $2000
002000  1               main:
002000  1               	.include "game.inc"
002000  2               .include "testsound.inc"
002000  3               ; Game engine code --------------------------------------------------------------
002000  3               
002000  3               ; Arcade Game Designer.
002000  3               ; (C) 2008 Jonathan Cauldwell.
002000  3               ; ZX Spectrum Next Engine v0.1.
002000  3               
002000  3               ; Conditional compilation flags
002000  3               ; Code is installed if flag is set
002000  3               ; Flags are set in commandline assembly or by the compiler
002000  3               
002000  3               ; Flags set by AGD compiler
002000  3               ;	mflag  			; MENU + INV
002000  3               ;	pflag 			; particle engine
002000  3               ;	sflag 			; scrollytext
002000  3               ;	dflag 			; digging mode
002000  3               ;	cflag			; collectable blocks
002000  3               ;	oflag			; objects
002000  3               ;	lflag			; ladders
002000  3               ;	bflag			; big sprites (16x24)
002000  3               ;	rflag			; Pre-shifted byte tables
002000  3               ;
002000  3               ; Flags set manually
002000  3               ;	aflag			; adventure mode
002000  3               ;	iflag			; invert mode
002000  3               
002000  3               .if mflag
002000  3               	.out "- MEN/INV enabled"
002000  3               .endif
002000  3               .if pflag
002000  3               	.out "- Particles enabled"
002000  3               .endif
002000  3               .if sflag
002000  3               	.out "- Scrolling enabled"
002000  3               .endif
002000  3               .if dflag
002000  3               	.out "- Digging enabled"
002000  3               .endif
002000  3               .if cflag
002000  3               	.out "- Collectable blocks enabled"
002000  3               .endif
002000  3               .if oflag
002000  3               	.out "- Objects enabled"
002000  3               .endif
002000  3               .if lflag
002000  3               	.out "- Ladders enabled"
002000  3               .endif
002000  3               .if aflag
002000  3               	.out "- Adventure mode enabled"
002000  3               .endif
002000  3               .if bflag
002000  3               	.out "- Big Sprites (16x24) enabled"
002000  3               .endif
002000  3               .if iflag
002000  3               	.out "- Invert mode enabled"
002000  3               .endif
002000  3               .if rflag
002000  3               	.out "- Pre-shifted byte tables enabled"
002000  3               .endif
002000  3               
002000  3               ;------------------------------------------------------------
002000  3               ; VIC20 check for PAL or NTSC
002000  3               ;------------------------------------------------------------
002000  3               
002000  3               .if modelflag
002000  3               	ScrWidth	= 22	; PAL settings
002000  3               	ScrHeight	= 22
002000  3               	CentreX		= 12
002000  3               	CentreY		= 38
002000  3               	CentreXMP   = 14
002000  3               	CentreYMP   = 36
002000  3               	timervalue	= 24000
002000  3               	timerint	= 24000			; Interrupt timer 1/50 sec
002000  3               	.out "- Starting vide in PAL mode"
002000  3               .else
002000  3               	ScrWidth	= 22	; NTSC settings
002000  3               	ScrHeight	= 22
002000  3               	CentreX		= 4
002000  3               	CentreY		= 27
002000  3               	CentreXMP   = 6
002000  3               	CentreYMP   = 24
002000  3               	timervalue	= 20000
002000  3               	timerint	= 20000			; Interrupt timer 1/50 sec
002000  3                	.out "- Starting vide in NTSC mode"
002000  3               .endif
002000  3               .out ""
002000  3               
002000  3               ;------------------------------------------------------------
002000  3               ; Constants MPAGD
002000  3               ;------------------------------------------------------------
002000  3               
002000  3               ; Global definitions
002000  3               
002000  3               	FONT 		= font
002000  3               	MAP 		= MapAddr		; properties map buffer (3x256 bytes)
002000  3               	SCADTB_lb	= MAP + $300		; Screen address table
002000  3               	SCADTB_hb	= SCADTB_lb + $100
002000  3               	SHRAPN 		= SCADTB_hb + $100	; shrapnel table (55x6 bytes)
002000  3               	COLATTTB_lb	= SHRAPN + 55*6		; Colour attribute address table
002000  3               	COLATTTB_hb	= COLATTTB_lb + 11
002000  3               
002000  3               ; Block characteristics.
002000  3               
002000  3               	PLATFM	= 1		; platform.
002000  3               	WALL	= PLATFM + 1	; solid wall.
002000  3               	LADDER	= WALL + 1	; ladder.
002000  3               	FODDER	= LADDER + 1	; fodder block.
002000  3               	DEADLY	= FODDER + 1	; deadly block.
002000  3               	CUSTOM	= DEADLY + 1	; custom block.
002000  3               	WATER	= CUSTOM + 1	; water block.
002000  3                       COLECT	= WATER + 1	; collectable block.
002000  3                       NUMTYP	= COLECT + 1	; number of types.
002000  3               
002000  3               ; Sprites.
002000  3               
002000  3               .if bflag
002000  3               	SPR_HGT	= 24		; Sprite height
002000  3               	SPR_WID = 16		; Sprite width
002000  3               	NUMSPR	= 8		; number of sprites.
002000  3               .else				; 16x16 sprites
002000  3               	SPR_HGT = 16		; Sprite height
002000  3               	SPR_WID = 16		; Sprite width
002000  3               	NUMSPR	= 12		; number of sprites.
002000  3               .endif
002000  3               	TABSIZ = 17			; size of each entry.
002000  3               	SPRBUF = NUMSPR * TABSIZ; size of entire table.
002000  3               	NMESIZ = 4			; bytes stored in nmetab for each sprite.
002000  3               
002000  3               ; Sprite table variable offsets.
002000  3               
002000  3               	var_Type = 0		; sprite type
002000  3               	var_Image = 1		; sprite time number
002000  3               	var_Frame = 2		; sprite frame
002000  3               	var_Y = 3			; sprite y coordinate
002000  3               	var_X = 4			; sprite X coordinate
002000  3               
002000  3               	var_newType = 5		; sprite new type
002000  3               	var_newImage = 6	; sprite new image number
002000  3               	var_newFrame = 7	; sprite new frame
002000  3               	var_newY = 8		; sprite new y coordinate
002000  3               	var_newX = 9		; sprite new x coordinate
002000  3               
002000  3               	var_Direction = 10	; sprite direction
002000  3               	var_Param1 = 11		; sprite parameter 1
002000  3               	var_Param2 = 12		; sprite parameter 2
002000  3               
002000  3               	var_jumpLo = 13		; sprite jump ptr low
002000  3               	var_jumpHi = 14		; sprite jump ptr high
002000  3               	var_dataLo = 15		; sprite data ptr low
002000  3               	var_dataHi = 16		; sprite data ptr high
002000  3               
002000  3               ; Particle engine.
002000  3               
002000  3               	NUMSHR = 55			; pieces of shrapnel.
002000  3               	SHRSIZ = 6			; bytes per particle.
002000  3               
002000  3               .if iflag
002000  3               	TxtInvert   = $ff	; Invert byte for character printing
002000  3               	ScrFillByte = $ff	; Screen fill byte for CLS
002000  3               .else
002000  3               	TxtInvert   = $00	; Invert byte for character printing
002000  3               	ScrFillByte = $00	; Screen fill byte for CLS
002000  3               .endif
002000  3               
002000  3               	ASCII_NEWLINE = 13
002000  3               
002000  3               ;===============================================================
002000  3               ; Game starts here
002000  3               ;===============================================================
002000  3               
002000  3               ;--------------------------------------------------------------
002000  3               ; If a font is required...
002000  3               ;--------------------------------------------------------------
002000  3               
002000  3               start:
002000  3               
002000  3               ; Clear variables
002000  3               
002000  3  A9 00        	lda #0
002002  3  AA           	tax
002003  3               clrloop:
002003  3  95 00        	sta 0,x
002005  3  E8           	inx
002006  3  D0 FB        	bne clrloop
002008  3               
002008  3  20 99 20     	jsr game	 		; start the game.
00200B  3  4C 00 20     	jmp start
00200E  3               
00200E  3               ; Don't change the order of these four.
00200E  3               ; Menu routine relies on winlft following wintop.
00200E  3               
00200E  3  08           wintop:	.byte WINDOWTOP		; top of window.
00200F  3  00           winlft:	.byte WINDOWLFT		; left edge.
002010  3  0E           winhgt:	.byte WINDOWHGT		; window height.
002011  3  16           winwid:	.byte WINDOWWID		; window width.
002012  3  01           numob:	.byte NUMOBJ		; number of objects in game.
002013  3               
002013  3               ; Pixel versions of wintop, winlft, winhgt, winwid.
002013  3               
002013  3  40           wntopx:	.byte (8 * WINDOWTOP)
002014  3  00           wnlftx:	.byte (8 * WINDOWLFT)
002015  3  A0           wnbotx:	.byte ((WINDOWTOP * 8) + (WINDOWHGT * 8) - 16)
002016  3  A0           wnrgtx:	.byte ((WINDOWLFT * 8) + (WINDOWWID * 8) - 16)
002017  3               
002017  3               ; Make sure pointers are arranged in the same order as the data itself.
002017  3               
002017  3  0E 33        frmptr:	.word frmlst        ; sprite frames.
002019  3               
002019  3               ; Assorted game routines which can go in contended memory.
002019  3               
002019  3               ;--------------------------------------------------------------
002019  3               ; Modify for inventory.
002019  3               ; called by the INV command
002019  3               ;
002019  3               ; Input:
002019  3               ;  X   = message nr with objects seperated with ,
002019  3               ;
002019  3               ; Output:
002019  3               ;  OPT = selected line nr of INV menu
002019  3               ;--------------------------------------------------------------
002019  3               
002019  3               .if mflag
002019  3               minve:
002019  3               .if xflag
002019  3               	lda #WINDOWHGT
002019  3               	asl a
002019  3               	sta winhgt
002019  3               	lda #WINDOWWID
002019  3               	asl a
002019  3               	sta winwid
002019  3               .endif
002019  3               	lda #<(invdis)		; routine address.
002019  3               	sta mod0+1		; set up menu routine.
002019  3               	sta mod2+1		; set up count routine.
002019  3               	lda #>(invdis)
002019  3               	sta mod0+2
002019  3               	sta mod2+2
002019  3               	lda #<(fopt)		; find option from available objects.
002019  3               	sta mod1+1		; set up routine.
002019  3               	lda #>(fopt)
002019  3               	sta mod1+1+1
002019  3               	jmp dbox		; do menu routine.
002019  3               
002019  3               ;--------------------------------------------------------------
002019  3               ; Modify for menu.
002019  3               ; called by the MENU command
002019  3               ;
002019  3               ; Input:
002019  3               ;  X   = message nr with menu items seperated with ,
002019  3               ;
002019  3               ; Output:
002019  3               ;  OPT = selected line nr of MENU menu
002019  3               ;--------------------------------------------------------------
002019  3               
002019  3               mmenu:
002019  3               	lda #<(always)		; routine address.
002019  3               	sta mod0+1		; set up routine.
002019  3               	sta mod2+1		; set up count routine.
002019  3               	lda #>(always)
002019  3               	sta mod0+2
002019  3               	sta mod2+2
002019  3               
002019  3               	lda #<(fstd)		; standard option selection.
002019  3               	sta mod1+1		; set up routine.
002019  3               	lda #>(fstd)
002019  3               	sta mod1+2
002019  3               
002019  3               ; Drop through into box routine.
002019  3               
002019  3               ;--------------------------------------------------------------
002019  3               ; Work out size of box for message or menu.
002019  3               ;--------------------------------------------------------------
002019  3               
002019  3               dbox:
002019  3               	lda #<msgdat		; pointer to messages.
002019  3               	sta z80_l
002019  3               	lda #>msgdat
002019  3               	sta z80_h
002019  3               
002019  3               	jsr getwrd		; get message number.
002019  3               
002019  3               	lda z80_h		; store pointer to message.
002019  3               	sta TmpAddr
002019  3               	lda z80_l
002019  3               	sta TmpAddr+1
002019  3               
002019  3               	lda #1			; height.
002019  3               	sta z80_d
002019  3               	lda #0			; start at object zero.
002019  3               	sta combyt		; store number of object in combyt.
002019  3               	sta z80_e		; maximum width.
002019  3               dbox5:
002019  3               	lda #0			; this line"s width.
002019  3               	sta z80_b
002019  3               mod2:
002019  3               	jsr always		; item in player"s possession?
002019  3               	cmp #255
002019  3               	bne dbox6		; not in inventory, skip this line.
002019  3               	inc z80_d		; add to tally.
002019  3               dbox6:
002019  3               	ldy #0			; get character.
002019  3               	lda (z80_hl),y
002019  3               	sta z80_a
002019  3               	inc z80_l		; next character.
002019  3               	bne :+
002019  3               	inc z80_h
002019  3               :
002019  3               	lda z80_a		; reached end of line?
002019  3               	cmp #','
002019  3               	beq dbox3		; yes.
002019  3               	cmp #ASCII_NEWLINE
002019  3               	beq dbox3		; yes.
002019  3               	inc z80_b		; add to this line"s width.
002019  3               	lda z80_a
002019  3               	bmi dbox4		; end of message? yes, end count.
002019  3               	jmp dbox6		; repeat until we find the end.
002019  3               dbox3:
002019  3               	lda z80_e		; maximum line width.
002019  3               	cmp z80_b		; have we exceeded longest so far?
002019  3               	bpl dbox5		; no, carry on looking.
002019  3               	lda z80_b		; make this the widest so far.
002019  3               	sta z80_e
002019  3               	jmp dbox5		; keep looking.
002019  3               dbox4:
002019  3               	lda z80_e		; maximum line width.
002019  3               	cmp z80_b		; have we exceeded longest so far?
002019  3               	bpl dbox8		; no, carry on looking.
002019  3               	lda z80_b		; final line is the longest so far.
002019  3               	sta z80_e
002019  3               dbox8:
002019  3               	dec z80_d		; decrement items found.
002019  3               	bne :+			; total was zero.
002019  3               	lda #255
002019  3               	sta varopt
002019  3               	jmp dbox15
002019  3               :
002019  3               	lda z80_e		; longest line.
002019  3               	bne :+			; was it zero?
002019  3               	jmp dbox15		; total was zero.
002019  3               :
002019  3               	sta bwid		; set up size.
002019  3               	lda z80_d
002019  3               	sta blen
002019  3               
002019  3               ;--------------------------------------------------------------
002019  3               ; That's set up our box size.
002019  3               ;--------------------------------------------------------------
002019  3               
002019  3               	lda winhgt		; window height in characters.
002019  3               	sec
002019  3               	sbc z80_d		; subtract height of box.
002019  3               	lsr a			; divide by 2.
002019  3               	clc
002019  3               	adc wintop		; add top edge of window.
002019  3               	sta btop		; set up box top.
002019  3               
002019  3               	lda winwid		; window width in characters.
002019  3               	sec
002019  3               	sbc z80_e		; subtract box width.
002019  3               	lsr a			; divide by 2.
002019  3               	clc
002019  3               	adc winlft		; add left edge of window.
002019  3               	sta blft		; box left.
002019  3               
002019  3               	lda #<(FONT-256)		; font.
002019  3               	sta grbase		; set up for text display.
002019  3               	lda #>(FONT-256)
002019  3               	sta grbase+1
002019  3               
002019  3               	lda TmpAddr+1		; restore message pointer.
002019  3               	sta z80_l
002019  3               	lda TmpAddr
002019  3               	sta z80_h
002019  3               
002019  3               	lda btop		; box top.
002019  3               	sta dispy		; set display coordinate.
002019  3               	lda #0			; start at object zero.
002019  3               	sta combyt		; store number of object in combyt.
002019  3               dbox2:
002019  3               	lda combyt		; get object number.
002019  3               	sta z80_a
002019  3               mod0:
002019  3               	jsr always		; check inventory for display.
002019  3               	cmp #255
002019  3               	beq :+
002019  3               	jmp dbox13		; not in inventory, skip this line.
002019  3               :
002019  3               	lda blft		; box left.
002019  3               	sta dispx		; set left display position.
002019  3               	lda bwid		; box width.
002019  3               	sta z80_b		; store width.
002019  3               dbox0:
002019  3               	ldy #0			; get character.
002019  3               	lda (z80_hl),y
002019  3               	cmp #','		; end of line?
002019  3               	beq dbox1		; yes, next one.
002019  3               	cmp #ASCII_NEWLINE			; end of line?
002019  3               	beq dbox1		; yes, next one.
002019  3               
002019  3               	cmp #141			; end of line?
002019  3               	bne :+
002019  3               	dec bwid
002019  3               	jmp dbox7		; yes, next one.
002019  3               :
002019  3               	dec z80_b		; one less to display.
002019  3               	and #127		; remove terminator.
002019  3               
002019  3               	jsr pchr		; display on screen.
002019  3               
002019  3               	ldy #0
002019  3               	lda (z80_hl),y		; get character.
002019  3               	sta z80_a
002019  3               	inc z80_l		; next character.
002019  3               	bne :+
002019  3               	inc z80_h
002019  3               :
002019  3               	lda z80_a
002019  3               	cmp #128		; end of message?
002019  3               	bmi :+
002019  3               	jmp dbox7		; yes, job done.
002019  3               :
002019  3               	lda z80_b		; chars remaining.
002019  3               	beq :+			; are any left?
002019  3               	jmp dbox0		; yes, continue.
002019  3               :
002019  3               ;---------------------------------------------------
002019  3               ; Reached limit of characters per line.
002019  3               ;---------------------------------------------------
002019  3               
002019  3               dbox9:
002019  3               	ldy #0
002019  3               	lda (z80_hl),y		; get character.
002019  3               	inc z80_l		; next one.
002019  3               	bne :+
002019  3               	inc z80_h
002019  3               :
002019  3               	cmp #','		; another line?
002019  3               	beq dbox10		; yes, do next line.
002019  3               	cmp #ASCII_NEWLINE	; another line?
002019  3               	beq dbox10		; yes, do next line.
002019  3               	cmp #128		; end of message?
002019  3               	bcs :+
002019  3               	jmp dbox11		; yes, finish message.
002019  3               :
002019  3               	jmp dbox9
002019  3               
002019  3               ;---------------------------------------------------
002019  3               ; Fill box to end of line.
002019  3               ;---------------------------------------------------
002019  3               
002019  3               dboxf:
002019  3               	lda #32			; space character.
002019  3               	jsr pchr		; display character.
002019  3               	dec z80_b
002019  3               	beq :+
002019  3               	jmp dboxf		; repeat for remaining chars on line.
002019  3               :
002019  3               	rts
002019  3               dbox1:
002019  3               	inc z80_l		; skip character.
002019  3               	bne :+
002019  3               	inc z80_h
002019  3               :
002019  3               	jsr dboxf		; fill box out to right side.
002019  3               dbox10:
002019  3               	inc dispy		; y coordinate down a line next position.
002019  3               	jmp dbox2		; next line.
002019  3               dbox7:
002019  3               	lda z80_b		; chars remaining.
002019  3               	bne :+			; are any left?
002019  3               	jmp dbox11		; no, nothing to draw.
002019  3               :
002019  3               	jsr dboxf		; fill message to line.
002019  3               
002019  3               ;------------------------------------------------------
002019  3               ; Drawn the box menu, now select option.
002019  3               ;------------------------------------------------------
002019  3               
002019  3               dbox11:
002019  3               	lda btop		; box top.
002019  3               	sta dispy		; set bar position.
002019  3               dbox14:
002019  3               	jsr joykey		; get controls.
002019  3               	cmp #$7f		; anything pressed?
002019  3               	bne dbox14		; yes, debounce it.
002019  3               	jsr dbar		; draw bar.
002019  3               dbox12:
002019  3               	jsr joykey		; get controls.
002019  3               	cmp #$7f		; anything pressed?
002019  3               	beq dbox12		; no, nothing.
002019  3               	and #16			; fire button pressed?
002019  3               	bne :+
002019  3               mod1:
002019  3               	jmp fstd		; yes, job done.
002019  3               :
002019  3               	jsr dbar		; delete bar.
002019  3               
002019  3               	lda joyval		; joystick reading.
002019  3               	and #8			; going up?
002019  3               	beq dboxu		; yes, go up.
002019  3               
002019  3               	ldx dispy		; vertical position of bar.
002019  3               	inx			; look down.
002019  3               	txa
002019  3               	sec
002019  3               	sbc btop		; find distance from top.
002019  3               	cmp blen		; top of box.
002019  3               	bne :+
002019  3               	jmp dbox14		; yes, go no further.
002019  3               :
002019  3               	inc dispy		; move bar.
002019  3               	jmp dbox14		; continue.
002019  3               dboxu:
002019  3               	lda dispy		; vertical position of bar.
002019  3               	cmp btop		; are we at the top?
002019  3               	bne :+
002019  3               	jmp dbox14		; yes, go no further.
002019  3               :
002019  3               	dec dispy		; move bar.
002019  3               	jmp dbox14		; continue.
002019  3               fstd:
002019  3               	lda dispy		; bar position.
002019  3               	sec
002019  3               	sbc btop		; find selected option.
002019  3               	sta varopt		; store the option.
002019  3               	jmp redraw		; redraw the screen.
002019  3               
002019  3               ;------------------------------------------------------
002019  3               ; Option not available.  Skip this line.
002019  3               ;------------------------------------------------------
002019  3               
002019  3               dbox13:
002019  3               	ldy #0
002019  3               	lda (z80_hl),y		; get character.
002019  3               	inc z80_l		; next one.
002019  3               
002019  3               	bne :+
002019  3               	inc z80_h
002019  3               :
002019  3               	cmp #','		; another line?
002019  3               	bne :+
002019  3               	jmp dbox2		; yes, do next line.
002019  3               :
002019  3               	cmp #ASCII_NEWLINE			; another line?
002019  3               	bne :+
002019  3               	jmp dbox2		; yes, do next line.
002019  3               :
002019  3               
002019  3               	bpl :+			; end of message?
002019  3               	jmp dbox11		; yes, finish message.
002019  3               :
002019  3               	jmp dbox13
002019  3               dbox15:
002019  3               .if xflag
002019  3               	lda #WINDOWWID
002019  3               	sta winwid
002019  3               	lda #WINDOWHGT
002019  3               	sta winhgt
002019  3               .endif
002019  3               	lda TmpAddr		; pop message pointer from the stack.
002019  3               	sta z80_h
002019  3               	lda TmpAddr+1
002019  3               	sta z80_l
002019  3               	rts
002019  3               
002019  3               ;------------------------------------------------------
002019  3               ; Invert bar
002019  3               ;------------------------------------------------------
002019  3               
002019  3               dbar:
002019  3               	lda blft		; box left.
002019  3               	sta dispx		; set display coordinate.
002019  3               	jsr gprad		; get printing address.
002019  3               
002019  3               	lda bwid		; box width.
002019  3               	sta z80_c		; loop counter in c.
002019  3               	lda z80_h
002019  3               	sta z80_d		; store screen address high byte.
002019  3               dbar1:
002019  3               	ldx #7			; pixel height in b.
002019  3               dbar0:
002019  3               	ldy scrtab,x
002019  3               	lda (scraddr),y		; get screen byte.
002019  3               	eor #255		; reverse all bits.
002019  3               	sta (scraddr),y		; write back to screen.
002019  3               	dex			; next line down.
002019  3               	bpl dbar0		; draw rest of character.
002019  3               
002019  3               	lda scraddr
002019  3               	adc #16
002019  3               	sta scraddr
002019  3               	bcc :+
002019  3               	inc scraddr+1
002019  3               :
002019  3               	dec z80_c		; decrement character counter.
002019  3               	bne dbar1		; repeat for whole line.
002019  3               	rts
002019  3               
002019  3               ;------------------------------------------------------
002019  3               ; Point to object
002019  3               ;
002019  3               ; Input:
002019  3               ;  -
002019  3               ;
002019  3               ; Output:
002019  3               ;  A = object number, A=255 if already in possession
002019  3               ;------------------------------------------------------
002019  3               
002019  3               invdis:
002019  3               	lda z80_l		; store message text pointer.
002019  3               	pha
002019  3               	lda z80_h
002019  3               	pha
002019  3               	lda combyt		; object number.
002019  3               	inc combyt		; ready for next one.
002019  3               	jsr gotob		; check if we have object.
002019  3               	tay
002019  3               	pla
002019  3               	sta z80_h
002019  3               	pla
002019  3               	sta z80_l
002019  3               	tya
002019  3               	rts
002019  3               
002019  3               ;------------------------------------------------------
002019  3               ; Find option selected.
002019  3               ;
002019  3               ; Input:
002019  3               ;  -
002019  3               ;
002019  3               ; Output:
002019  3               ;  OPT = selected object
002019  3               ;------------------------------------------------------
002019  3               
002019  3               fopt:
002019  3               	lda dispy
002019  3               	sec
002019  3               	sbc btop		; find selected option.
002019  3               	sta tmp+2		; option selected in b register.
002019  3               	inc tmp+2
002019  3               
002019  3               	lda #0			; set to first item.
002019  3               	sta combyt		; object number.
002019  3               fopt0:
002019  3               	jsr fobj		; find next object in inventory.
002019  3               	dec tmp+2
002019  3               	bne fopt0		; repeat for relevant steps down the list.
002019  3               
002019  3               	lda combyt		; get option.
002019  3               	sta varopt		; store the option.
002019  3               	dec varopt		; one less, due to where we increment combyt.
002019  3               	jmp redraw		; redraw the screen.
002019  3               fobj:
002019  3               	ldy combyt		; object number.
002019  3               	inc combyt		; ready for next item.
002019  3               	tya
002019  3               	jsr gotob		; do we have this item?
002019  3               	cmp #255
002019  3               	bne :+
002019  3               	rts
002019  3               :
002019  3               	jmp fobj		; yes, it's on the list.
002019  3               .endif
002019  3               
002019  3               ;----------------------------------------------------
002019  3               ; Clear sprite table.
002019  3               ;
002019  3               ; sprtab[0] - sprtab[SPRBUF-1] = 255
002019  3               ;----------------------------------------------------
002019  3               
002019  3               xspr:
002019  3  A9 FF        	lda #255		; clear byte.
00201B  3  A2 00        	ldx #0			; length of table.
00201D  3               xspr0:
00201D  3  9D 07 30     	sta sprtab,x		; sprite table.
002020  3  E8           	inx			; move to next byte.
002021  3  E0 CC        	cpx #SPRBUF
002023  3  D0 F8        	bne xspr0		; repeat for rest of table.
002025  3  60           	rts
002026  3               
002026  3               ;-------------------------------------------------------------
002026  3               ; Initialise all objects.
002026  3               ;
002026  3               ; Reset current room,y,x to start room,y,x for all objects
002026  3               ;-------------------------------------------------------------
002026  3               
002026  3               .if oflag
002026  3               iniob:
002026  3               	lda #<objdta		; objects table.
002026  3               	sta z80_x
002026  3               	lda #>objdta
002026  3               	sta z80_i
002026  3               
002026  3               	ldx numob 		; number of objects in the game.
002026  3               iniob0:
002026  3               	ldy #36
002026  3               	lda (z80_ix),y 		; start screen.
002026  3               	ldy #33
002026  3               	sta (z80_ix),y 		; set start screen.
002026  3               
002026  3               	ldy #37
002026  3               	lda (z80_ix),y 		; find start y.
002026  3               	ldy #34
002026  3               	sta (z80_ix),y 		; set start y.
002026  3               
002026  3               	ldy #38
002026  3               	lda (z80_ix),y 		; get initial x.
002026  3               	ldy #35
002026  3               	sta (z80_ix),y 		; set x coord.
002026  3               
002026  3               	clc 			; point to next object.
002026  3               	lda z80_x
002026  3               	adc #39			; distance between objects.
002026  3               	sta z80_x
002026  3               	bcc :+
002026  3               	inc z80_i
002026  3               :
002026  3               	dex 			; repeat.
002026  3               	bne iniob0
002026  3               
002026  3               	rts
002026  3               .endif
002026  3               
002026  3               ;-----------------------------------------------
002026  3               ; Redraw the screen.
002026  3               ;
002026  3               ; Remove old copy of all sprites for redraw.
002026  3               ;-----------------------------------------------
002026  3               
002026  3               redraw:
002026  3               .if xflag
002026  3               	lda #WINDOWWID
002026  3               	sta winwid
002026  3               	lda #WINDOWHGT
002026  3               	sta winhgt
002026  3               .endif
002026  3  A5 rr        	lda z80_i 		; place sprite pointer on stack.
002028  3  48           	pha
002029  3  A5 rr        	lda z80_x
00202B  3  48           	pha
00202C  3               
00202C  3  20 C6 25     	jsr droom		; show screen layout.
00202F  3               .if oflag
00202F  3               	jsr shwob		; draw objects.
00202F  3               .endif
00202F  3               numsp0:
00202F  3  A9 0C        	lda #NUMSPR		; sprites to draw.
002031  3  85 rr        	sta tmp
002033  3               
002033  3  A9 07        	lda #<sprtab		; sprite table.
002035  3  85 rr        	sta z80_x
002037  3  A9 30        	lda #>sprtab
002039  3  85 rr        	sta z80_i
00203B  3               redrw0:
00203B  3  A0 00        	ldy #0
00203D  3  B1 rr        	lda (z80_ix),y		; old sprite type.
00203F  3  C9 FF        	cmp #255		; is it enabled?
002041  3  F0 0B        	beq redrw1 		; no, find next one.
002043  3               
002043  3  A0 03        	ldy #var_Y
002045  3  B1 rr        	lda (z80_ix),y 		; sprite y.
002047  3  C9 A1        	cmp #SpriteMaxY		; beyond maximum?
002049  3  B0 03        	bcs redrw1		; yes, nothing to draw.
00204B  3               
00204B  3  20 FC 38     	jsr sspria		; show single sprite.
00204E  3               
00204E  3               redrw1:
00204E  3  18           	clc			; next sprite.
00204F  3  A5 rr        	lda z80_x
002051  3  69 11        	adc #TABSIZ		; distance to next odd/even entry.
002053  3  85 rr        	sta z80_x
002055  3  90 02        	bcc :+
002057  3  E6 rr        	inc z80_i
002059  3               :
002059  3  C6 rr        	dec tmp			; repeat for remaining sprites.
00205B  3  D0 DE        	bne redrw0
00205D  3               
00205D  3               rpblc1:
00205D  3               ;	jsr dshrp		; redraw shrapnel.
00205D  3               
00205D  3               .if aflag
00205D  3               	jsr rbloc		; draw blocks for this screen
00205D  3               .endif
00205D  3  68           	pla			; retrieve sprite pointer.
00205E  3  85 rr        	sta z80_x
002060  3  68           	pla
002061  3  85 rr        	sta z80_i
002063  3               
002063  3  60           	rts
002064  3               
002064  3               ;----------------------------------------------------------------------
002064  3               ; Clear screen routine.
002064  3               ;
002064  3               ; Fill screenmem $9400-$97ff with ScrFillByte
002064  3               ;----------------------------------------------------------------------
002064  3               
002064  3               cls:
002064  3  A9 10        	lda #>CharAddress	; Character RAM address.
002066  3  8D 71 20     	sta clrdata+2
002069  3               
002069  3               ; Clear bitmap data
002069  3               
002069  3  A9 00        	lda #ScrFillByte	; Clear screen
00206B  3  A0 00        	ldy #0
00206D  3  A2 10        	ldx #16
00206F  3               clrdata:
00206F  3  99 00 10     	sta CharAddress,y
002072  3  C8           	iny
002073  3  D0 FA        	bne clrdata
002075  3  EE 71 20     	inc clrdata+2
002078  3  CA           	dex
002079  3  D0 F4        	bne clrdata
00207B  3               
00207B  3               ; Clear colour attributes
00207B  3               
00207B  3  AD 8D 36     	lda fontcol
00207E  3  A2 00        	ldx #0
002080  3               clrcolour:
002080  3  9D 00 94     	sta ColorAttr-$200,x
002083  3  9D 00 96     	sta ColorAttr,x
002086  3  E8           	inx
002087  3  D0 F7        	bne clrcolour
002089  3  60           	rts
00208A  3               
00208A  3               ;----------------------------------------------------------------------
00208A  3               ; Clear colour attributes
00208A  3               ;
00208A  3               ; Reset colour attributes to fontcol
00208A  3               ;----------------------------------------------------------------------
00208A  3               
00208A  3               clrcol:
00208A  3  AD 8D 36     	lda fontcol		; Clear colour attributes
00208D  3  A2 00        	ldx #0
00208F  3               clscol:
00208F  3  9D 00 96     	sta ColorAttr,x
002092  3  E8           	inx
002093  3  E0 F2        	cpx #242
002095  3  D0 F8        	bne clscol
002097  3               
002097  3  60           	rts
002098  3               
002098  3               ;----------------------------------------------------------------------
002098  3               ; FODDER check
002098  3               ;----------------------------------------------------------------------
002098  3               
002098  3               .if pflag .or dflag
002098  3               fdchk:
002098  3               	cmp #FODDER 		; is it fodder?
002098  3               	beq :+
002098  3               	rts 			; no.
002098  3               :
002098  3               	lda #0			; wipe fodder in MAP
002098  3               	ldy #0
002098  3               	sta (bufaddr),y 	; rewrite block type.
002098  3               
002098  3               	lda dispx		; x=x/8
002098  3               	pha
002098  3               	lsr a
002098  3               	lsr a
002098  3               	lsr a
002098  3               	sta dispx
002098  3               
002098  3               	lda dispy		; y=y/8
002098  3               	pha
002098  3               	lsr a
002098  3               	lsr a
002098  3               	lsr a
002098  3               	sta dispy
002098  3               
002098  3               	lda #0 			; block to write.
002098  3               	jsr pattr 		; write block.
002098  3               
002098  3               	pla
002098  3               	sta dispy
002098  3               	pla
002098  3               	sta dispx
002098  3               	rts
002098  3               .endif
002098  3               
002098  3               ;----------------------------------------------------
002098  3               ; Scrolly text and puzzle variables.
002098  3               ;----------------------------------------------------
002098  3               
002098  3               .if sflag
002098  3               txtbit:	.byte 128		; bit to write.
002098  3               txtwid:	.byte 16		; width of ticker message.
002098  3               txtpos:	.word msgdat
002098  3               txtini:	.word msgdat
002098  3               txtscr:	.word ScreenAddr
002098  3               .endif
002098  3               
002098  3               ;----------------------------------------------------
002098  3               ; Specialist routines.
002098  3               ; Process shrapnel.
002098  3               ;----------------------------------------------------
002098  3               proshr:
002098  3               .if pflag
002098  3               	lda #<SHRAPN		; table.
002098  3               	sta z80_x
002098  3               	lda #>SHRAPN
002098  3               	sta z80_i
002098  3               
002098  3               	lda #NUMSHR		; shrapnel pieces to process.
002098  3               	sta shrctr
002098  3               prosh0:
002098  3               	ldy #0
002098  3               	lda (z80_ix),y		; on/off marker.
002098  3               	asl a
002098  3               proshx:
002098  3               	bcs :+
002098  3               	jsr prosh1 		; on, so process it.
002098  3               :
002098  3               	clc
002098  3               	lda z80_x
002098  3               	adc #SHRSIZ
002098  3               	sta z80_x
002098  3               	bcc :+
002098  3               	inc z80_i
002098  3               :
002098  3               	dec shrctr		; round again.
002098  3               	bne prosh0
002098  3               .endif
002098  3               .if sflag
002098  3               	jsr scrly
002098  3               .endif
002098  3  60           	rts
002099  3               
002099  3               .if pflag
002099  3               ;----------------------------------------------------
002099  3               ; Proces shrapnel piece
002099  3               ;----------------------------------------------------
002099  3               
002099  3               prosh1:
002099  3               	jsr plot 		; delete the pixel.
002099  3               
002099  3               	lda #<shrptr		; shrapnel routine pointers.
002099  3               	sta z80_l
002099  3               	lda #>shrptr
002099  3               	sta z80_h
002099  3               
002099  3               	ldy #0
002099  3               	lda (z80_ix),y		; restore shrapnel type.
002099  3               	jsr prosh2 		; run the routine.
002099  3               	jsr chkxy		; check x and y are good before we redisplay.
002099  3               
002099  3               	lda #<SHRSIZ 		; distance to next.
002099  3               	sta z80_e
002099  3               	lda #>SHRSIZ
002099  3               	sta z80_d
002099  3               	rts
002099  3               
002099  3               ;----------------------------------------------------
002099  3               ; Run the routine
002099  3               ;----------------------------------------------------
002099  3               
002099  3               prosh2:
002099  3               	asl a 			; 2 bytes per address.
002099  3               	tay
002099  3               	lda shrptr,y
002099  3               	sta z80_l
002099  3               	lda shrptr+1,y 		; fetch high byte from table.
002099  3               	sta z80_h
002099  3               	jmp (z80_hl) 		; jump to routine.
002099  3               
002099  3               ;----------------------------------------------------
002099  3               ; Paricle routine table
002099  3               ;----------------------------------------------------
002099  3               
002099  3               shrptr:	.word laser		; laser.
002099  3               	.word trail		; vapour trail.
002099  3               	.word shrap		; shrapnel from explosion.
002099  3               	.word dotl		; horizontal starfield left.
002099  3               	.word dotr		; horizontal starfield right.
002099  3               	.word dotu		; vertical starfield up.
002099  3               	.word dotd		; vertical starfield down.
002099  3               	.word ptcusr		; user particle.
002099  3               
002099  3               ;----------------------------------------------------
002099  3               ; Explosion shrapnel.
002099  3               ;----------------------------------------------------
002099  3               
002099  3               shrap:
002099  3               	ldy #1
002099  3               	lda (z80_ix),y 		; get the angle.
002099  3               	clc
002099  3               	adc #<shrsin		; shrapnel sine table.
002099  3               	sta z80_l
002099  3               	lda #>shrsin
002099  3               	adc #0
002099  3               	sta z80_h
002099  3               
002099  3               	ldy #0
002099  3               	lda (z80_hl),y 		; fetch value from table.
002099  3               	sta z80_e
002099  3               	inc z80_l 		; next byte of table.
002099  3               	bne :+
002099  3               	inc z80_h
002099  3               :
002099  3               	ldy #0
002099  3               	lda (z80_hl),y		; fetch value from table.
002099  3               	sta z80_d
002099  3               	inc z80_l		; next byte of table.
002099  3               	bne :+
002099  3               	inc z80_h
002099  3               :
002099  3               	ldy #0
002099  3               	lda (z80_hl),y 		; fetch value from table.
002099  3               	sta z80_c
002099  3               	inc z80_l 		; next byte of table.
002099  3               	bne :+
002099  3               	inc z80_h
002099  3               :
002099  3               	ldy #0
002099  3               	lda (z80_hl),y 		; fetch value from table.
002099  3               	sta z80_b
002099  3               
002099  3               	ldy #2
002099  3               	lda (z80_ix),y 		; x coordinate in hl.
002099  3               	clc
002099  3               	adc z80_e		; add sine lb
002099  3               	sta (z80_ix),y		; store new coordinate lb.
002099  3               	ldy #3
002099  3               	lda (z80_ix),y
002099  3               	adc z80_d		; add sine hb
002099  3               	sta (z80_ix),y		; store new coordinate hb.
002099  3               
002099  3               	ldy #4
002099  3               	lda (z80_ix),y	 	; y coordinate in hl.
002099  3               	clc
002099  3               	adc z80_c		; add cosine lb
002099  3               	sta (z80_ix),y		; store new coordinate lb.
002099  3               	ldy #5
002099  3               	lda (z80_ix),y
002099  3               	adc z80_b		; add cosine lb
002099  3               	sta (z80_ix),y		; store new coordinate hb.
002099  3               
002099  3               	rts
002099  3               
002099  3               ;----------------------------------------------------
002099  3               ; Move dots
002099  3               ;----------------------------------------------------
002099  3               
002099  3               dotl:
002099  3               	ldy #5
002099  3               	lda (z80_ix),y
002099  3               	sec
002099  3               	sbc #1		 	; move left.
002099  3               	sta (z80_ix),y
002099  3               	rts
002099  3               dotr:
002099  3               	ldy #5
002099  3               	lda (z80_ix),y
002099  3               	clc
002099  3               	adc #1		 	; move left.
002099  3               	sta (z80_ix),y
002099  3               	rts
002099  3               dotu:
002099  3               	ldy #3
002099  3               	lda (z80_ix),y
002099  3               	sec
002099  3               	sbc #1		 	; move up.
002099  3               	sta (z80_ix),y
002099  3               	rts
002099  3               dotd:
002099  3               	ldy #3
002099  3               	lda (z80_ix),y
002099  3               	clc
002099  3               	adc #1			; move down.
002099  3               	sta (z80_ix),y
002099  3               	rts
002099  3               
002099  3               ;----------------------------------------------------
002099  3               ; Check if coordinates are ok before redrawing at new position.
002099  3               ;
002099  3               ; left:   X>L		X=L	Ok
002099  3               ; right:  R+15>X	X=R	Ok
002099  3               ; top:    Y>T		Y=T	Ok
002099  3               ; bottom: B+15>Y	Y=B	Ok
002099  3               ;----------------------------------------------------
002099  3               
002099  3               chkxy:
002099  3               
002099  3               ; top:    Y>T		Y=T	Ok
002099  3               
002099  3               	ldy #3
002099  3               	lda (z80_ix),y	 	; fetch shrapnel coordinate.
002099  3               	cmp wntopx		; window top.
002099  3               	bcs :+			; compare with top window limit.
002099  3               	jmp kilshr		; out of window, kill shrapnel.
002099  3               :
002099  3               ; left:   X>L		X=L	Ok
002099  3               
002099  3               	ldy #5
002099  3               	lda (z80_ix),y	 	; fetch shrapnel coordinate.
002099  3               	cmp wnlftx		; left edge.
002099  3               	bcs :+			; compare with left window limit.
002099  3               	jmp kilshr		; out of window, kill shrapnel.
002099  3               :
002099  3               ; bottom: B+15>Y	Y=B	Ok
002099  3               
002099  3               	lda wnbotx		; point to bottom.
002099  3               	clc
002099  3               	adc #15
002099  3               	ldy #3
002099  3               	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
002099  3               	bcs :+			; compare with shrapnel x coordinate.
002099  3               	jmp kilshr		; off screen, kill shrapnel..
002099  3               :
002099  3               ; right:  R+15>X	X=R	Ok
002099  3               
002099  3               	lda wnrgtx		; point to right edge.
002099  3               	clc
002099  3               	adc #15
002099  3               	ldy #5
002099  3               	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
002099  3               	bcs :+			; compare with window limit.
002099  3               	jmp kilshr		; off screen, kill shrapnel.
002099  3               :
002099  3               
002099  3               ;----------------------------------------------------
002099  3               ; Drop through.
002099  3               ; Display shrapnel.
002099  3               ;----------------------------------------------------
002099  3               
002099  3               plot:
002099  3               	ldy #3
002099  3               	lda (z80_ix),y		; y integer.
002099  3               	sta dispy	 	; workspace coordinates.
002099  3               	ldy #5
002099  3               	lda (z80_ix),y	 	; x integer.
002099  3               	sta dispx 		; workspace coordinates.
002099  3               
002099  3               	ldy #0
002099  3               	lda (z80_ix),y 		; type.
002099  3               	bne :+			; is it a laser?
002099  3               	jmp plot1 		; yes, draw laser instead.
002099  3               :
002099  3               plot0:
002099  3               	lda dispx		; which pixel within byte do we
002099  3               	and #7			; want to set first?
002099  3               	tay
002099  3               	lda dots,y 		; table of small pixel positions.
002099  3               	sta z80_e 		; get value.
002099  3               
002099  3               	jsr scadd 		; screen address.
002099  3               	ldy #0
002099  3               	lda (scraddr),y		; see what's already there.
002099  3               	eor z80_e
002099  3               	sta (scraddr),y 	; put back on screen.
002099  3               	rts
002099  3               
002099  3               plot1:
002099  3               	jsr scadd 		; screen address.
002099  3               	ldy #0
002099  3               	lda (scraddr),y 	; fetch byte there.
002099  3               	eor #255 		; toggle all bits.
002099  3               	sta (scraddr),y 	; new byte.
002099  3               	rts
002099  3               
002099  3               ;----------------------------------------------------
002099  3               ; Switch off shrapnel
002099  3               ;----------------------------------------------------
002099  3               
002099  3               kilshr:
002099  3               	lda #128
002099  3               	ldy #0
002099  3               	sta (z80_ix),y	; switch off shrapnel.
002099  3               	rts
002099  3               
002099  3               ;----------------------------------------------------
002099  3               ; Sine/cosine table
002099  3               ;----------------------------------------------------
002099  3               
002099  3               shrsin:	.word 0,1024,391,946,724,724,946,391
002099  3               	.word 1024,0,946,65144,724,64811,391,64589
002099  3               	.word 0,64512,65144,64589,64811,64811,64589,65144
002099  3               	.word 64512,0,64589,391,64811,724,65144,946
002099  3               
002099  3               ;----------------------------------------------------
002099  3               ; Create trail
002099  3               ;----------------------------------------------------
002099  3               
002099  3               trail:
002099  3               	ldy #1
002099  3               	lda (z80_ix),y 	; time remaining.
002099  3               	sec
002099  3               	sbc #1
002099  3               	sta (z80_ix),y
002099  3               	bne :+
002099  3               	jmp trailk		; time to switch it off.
002099  3               :
002099  3               	jsr qrand		; get a random number.
002099  3               	lsr a 			; x or y axis?
002099  3               	bcc :+
002099  3               	jmp trailv		; use y.
002099  3               :
002099  3               ; Trail horizontal
002099  3               
002099  3               	lsr a 			; which direction?
002099  3               	bcc :+
002099  3               	jmp traill		; go left.
002099  3               :
002099  3               ; Trail right
002099  3               
002099  3               	ldy #5
002099  3               	lda (z80_ix),y
002099  3               	clc
002099  3               	adc #1	 		; go right.
002099  3               	sta (z80_ix),y
002099  3               	rts
002099  3               
002099  3               ; Trail left
002099  3               
002099  3               traill:
002099  3               	ldy #5
002099  3               	lda (z80_ix),y
002099  3               	sec
002099  3               	sbc #1 			; go left.
002099  3               	sta (z80_ix),y
002099  3               	rts
002099  3               
002099  3               ; Trail vertical
002099  3               
002099  3               trailv:
002099  3               	lsr a		 	; which direction?
002099  3               	bcc :+
002099  3               	jmp trailu		; go up.
002099  3               :
002099  3               ; Trail down
002099  3               
002099  3               	ldy #3
002099  3               	lda (z80_ix),y
002099  3               	clc
002099  3               	adc #1 			; go down.
002099  3               	sta (z80_ix),y
002099  3               	rts
002099  3               
002099  3               ; Trail up
002099  3               
002099  3               trailu:
002099  3               	ldy #3
002099  3               	lda (z80_ix),y
002099  3               	sec
002099  3               	sbc #1 			; go up.
002099  3               	sta (z80_ix),y
002099  3               	rts
002099  3               
002099  3               ; Kill trail
002099  3               
002099  3               trailk:
002099  3               	lda #200		; set off-screen to kill vapour trail.
002099  3               	ldy #3
002099  3               	sta (z80_ix),y
002099  3               	rts
002099  3               
002099  3               ;----------------------------------------------------
002099  3               ; Create laser beam
002099  3               ;----------------------------------------------------
002099  3               
002099  3               laser:
002099  3               	ldy #1
002099  3               	lda (z80_ix),y 		; direction.
002099  3               	ror a 			; left or right?
002099  3               	bcs :+
002099  3               	jmp laserl		; move left.
002099  3               :
002099  3               ; Laser right
002099  3               
002099  3               	lda #8			; distance to travel.
002099  3               	sta z80_b
002099  3               	jmp laserm		; move laser.
002099  3               
002099  3               ; Laser left
002099  3               
002099  3               laserl:
002099  3               	lda #248		; distance to travel.
002099  3               	sta z80_b
002099  3               laserm:
002099  3               	ldy #5
002099  3               	lda (z80_ix),y		; x position.
002099  3               	clc
002099  3               	adc z80_b		; add distance.
002099  3               	sta (z80_ix),y		; set new x coordinate.
002099  3               
002099  3               ; Test new block.
002099  3               
002099  3               	sta dispx 		; set x for block collision detection purposes.
002099  3               	ldy #3
002099  3               	lda (z80_ix),y 		; get y.
002099  3               	sta dispy		; set coordinate for collision test.
002099  3               	jsr tstbl 		; get block type there.
002099  3               	cmp #WALL		; is it solid?
002099  3               	bne :+
002099  3               	jmp trailk		; yes, it cannot pass.
002099  3               :
002099  3               .if pflag .or dflag
002099  3                       cmp #FODDER             ; is it fodder?
002099  3                       bne :+
002099  3                       jsr fdchk               ; remove fodder block.
002099  3                       jmp trailk              ; destroy laser.
002099  3               :
002099  3               .endif
002099  3               	rts
002099  3               
002099  3               ;----------------------------------------------------
002099  3               ; Dots mask
002099  3               ;----------------------------------------------------
002099  3               
002099  3               dots:	.byte 128,64,32,16,8,4,2,1
002099  3               
002099  3               
002099  3               ;----------------------------------------------------
002099  3               ; Plot, preserving de.
002099  3               ;----------------------------------------------------
002099  3               
002099  3               plotde:
002099  3               	lda z80_d 		; put de on stack.
002099  3               	pha
002099  3               	lda z80_e
002099  3               	pha
002099  3               
002099  3               	jsr plot 		; plot pixel.
002099  3               
002099  3               	pla			; restore de from stack.
002099  3               	sta z80_e
002099  3               	pla
002099  3               	sta z80_d
002099  3               
002099  3               	rts
002099  3               
002099  3               ;----------------------------------------------------
002099  3               ; Shoot a laser.
002099  3               ;----------------------------------------------------
002099  3               
002099  3               shoot:
002099  3               	sta z80_c		; store direction in c register.
002099  3               	ldy #8
002099  3               	lda (z80_ix),y 		; y coordinate.
002099  3               	clc
002099  3               shoot1:
002099  3               	adc #(SPR_HGT/2-1)	; down 7 pixels.
002099  3               	sta z80_l 		; puty y coordinate in l.
002099  3               
002099  3               	ldy #9
002099  3               	lda (z80_ix),y 		; x coordinate in h.
002099  3               	sta z80_h
002099  3               
002099  3               	lda z80_i		; store pointer to sprite.
002099  3               	pha
002099  3               	lda z80_x
002099  3               	pha
002099  3               
002099  3               	jsr fpslot 		; find particle slot.
002099  3               	bcs :+
002099  3               	jmp vapou2		; failed, restore ix.
002099  3               :
002099  3               	lda #0
002099  3               	ldy #0
002099  3               	sta (z80_ix),y 		; set up a laser.
002099  3               
002099  3               	lda z80_c
002099  3               	ldy #1
002099  3               	sta (z80_ix),y 		; set the direction.
002099  3               
002099  3               	lda z80_l
002099  3               	ldy #3
002099  3               	sta (z80_ix),y		; set y coordinate.
002099  3               
002099  3               	ror z80_c		; check direction we want.
002099  3               	bcc :+
002099  3               	jmp shootr		; shoot right.
002099  3               :
002099  3               	lda z80_h		; X position.
002099  3               shoot0:
002099  3               	and #248		; align on character boundary.
002099  3               	ldy #5
002099  3               	sta (z80_ix),y		; set x coordinate.
002099  3               	jmp vapou0 		; draw first image.
002099  3               shootr:
002099  3               	lda z80_h		; x position.
002099  3               	clc
002099  3               	adc #15			; look right.
002099  3               	jmp shoot0		; align and continue.
002099  3               
002099  3               ;----------------------------------------------------
002099  3               ; Create a bit of vapour trail.
002099  3               ;----------------------------------------------------
002099  3               
002099  3               vapour:
002099  3               	lda z80_i		; store pointer to sprite.
002099  3               	pha
002099  3               	lda z80_x
002099  3               	pha
002099  3               
002099  3               	ldy #8
002099  3               	lda (z80_ix),y 		; y coordinate.
002099  3               	clc
002099  3               vapou3:
002099  3               	adc #(SPR_HGT/2-1)	; mid-point of sprite.
002099  3               	sta z80_l
002099  3               
002099  3               	ldy #9
002099  3               	lda (z80_ix),y 		; x coordinate.
002099  3               	adc #7
002099  3               	sta z80_h
002099  3               
002099  3               	jsr fpslot 		; find particle slot.
002099  3               	bcc :+
002099  3               	jmp vapou1		; no, we can use it.
002099  3               :
002099  3               vapou2:
002099  3               	pla
002099  3               	sta z80_x
002099  3               	pla
002099  3               	sta z80_i
002099  3               	rts
002099  3               vapou1:
002099  3               	lda z80_l
002099  3               	ldy #3
002099  3               	sta (z80_ix),y		; set up y.
002099  3               
002099  3               	lda z80_h
002099  3               	ldy #5
002099  3               	sta (z80_ix),y 		; set up x coordinate.
002099  3               
002099  3               	jsr qrand		; get quick random number.
002099  3               	and #15			; random time.
002099  3               	clc
002099  3               	adc #15			; minimum time on screen.
002099  3               	ldy #1
002099  3               	sta (z80_ix),y		; set time on screen.
002099  3               
002099  3               	lda #1
002099  3               	ldy #0
002099  3               	sta (z80_ix),y		; define particle as vapour trail.
002099  3               vapou0:
002099  3               	jsr chkxy		; plot first position.
002099  3               	jmp vapou2
002099  3               
002099  3               ;----------------------------------------------------
002099  3               ; Create a user particle.
002099  3               ;----------------------------------------------------
002099  3               
002099  3               ptusr:
002099  3               	sta z80_f		; store timer.
002099  3               
002099  3               	ldy #8
002099  3               	lda (z80_ix),y 		; y coordinate.
002099  3               	clc
002099  3               	adc #7			; mid-point of sprite.
002099  3               	sta z80_l
002099  3               
002099  3               	ldy #9
002099  3               	lda (z80_ix),y 		; x coordinate.
002099  3               	clc
002099  3               	adc #7			; mid-point of sprite.
002099  3               	sta z80_h
002099  3               
002099  3               	jsr fpslot 		; find particle slot.
002099  3               	bcs ptusr1
002099  3               	rts 			; out of slots, can't generate anything.
002099  3               ptusr1:
002099  3               	lda z80_l
002099  3               	ldy #3
002099  3               	sta (z80_ix),y 		; set up y.
002099  3               
002099  3               	lda z80_h
002099  3               	ldy #5
002099  3               	sta (z80_ix),y		; set up x coordinate.
002099  3               
002099  3               	lda z80_f 		; restore timer.
002099  3               	ldy #1
002099  3               	sta (z80_ix),y		; set time on screen.
002099  3               
002099  3               	lda #7
002099  3               	ldy #0
002099  3               	sta (z80_ix),y		; define particle as user particle.
002099  3               
002099  3               	jmp chkxy		; plot first position.
002099  3               
002099  3               ;----------------------------------------------------
002099  3               ; Create a vertical or horizontal star.
002099  3               ;----------------------------------------------------
002099  3               
002099  3               star:
002099  3               	lda z80_i		; store pointer to sprite.
002099  3               	pha
002099  3               	lda z80_x
002099  3               	pha
002099  3               
002099  3               	jsr fpslot 		; find particle slot.
002099  3               	bcs star7		; found one we can use.
002099  3               star0:
002099  3               	pla 			; restore sprite pointer.
002099  3               	sta z80_x
002099  3               	pla
002099  3               	sta z80_i
002099  3               	rts 			; out of slots, can't generate anything.
002099  3               star7:
002099  3               	lda z80_c		; direction.
002099  3               	and #3 			; is it left?
002099  3               	bne :+
002099  3               	jmp star1 		; yes, it's left.
002099  3               :
002099  3               	cmp #1 			; is it right?
002099  3               	bne :+
002099  3               	jmp star2 		; yes, it's right.
002099  3               :
002099  3               	cmp #2 			; is it up?
002099  3               	bne :+
002099  3               	jmp star3 		; yes, it's up.
002099  3               :
002099  3               	ldy wntopx 		; get edge of screen.
002099  3               	iny			; down one pixel.
002099  3               	tya
002099  3               star8:
002099  3               	ldy #3
002099  3               	sta (z80_ix),y 		; set y coord.
002099  3               	jsr qrand 		; get quick random number.
002099  3               star9:
002099  3               	ldy #5
002099  3               	sta (z80_ix),y		; set x position.
002099  3               
002099  3               	lda z80_c		; direction.
002099  3               	and #3			; zero to three.
002099  3               	clc
002099  3               	adc #3			; 3 to 6 for starfield.
002099  3               	ldy #0
002099  3               	sta (z80_ix),y		; define particle as star.
002099  3               	jsr chkxy		; plot first position.
002099  3               	jmp star0
002099  3               star1:
002099  3               	jsr qrand		; get quick random number.
002099  3               	ldy #3
002099  3               	sta (z80_ix),y 		; set y coord.
002099  3               
002099  3               	lda wnrgtx 		; get edge of screen.
002099  3               	clc
002099  3               	adc #15			; add width of sprite minus 1.
002099  3               	jmp star9
002099  3               star2:
002099  3               	jsr qrand 		; get quick random number.
002099  3               	ldy #3
002099  3               	sta (z80_ix),y		; set y coord.
002099  3               
002099  3               	lda wnlftx		; get edge of screen.
002099  3               	jmp star9
002099  3               star3:
002099  3               	lda wnbotx 		; get edge of screen.
002099  3               	clc
002099  3               	adc #15 		; height of sprite minus one pixel.
002099  3               	jmp star8
002099  3               
002099  3               ;----------------------------------------------------
002099  3               ; Find particle slot for lasers or vapour trail.
002099  3               ; can't use alternate accumulator.
002099  3               ;----------------------------------------------------
002099  3               
002099  3               fpslot:
002099  3               	lda #<SHRAPN 		; shrapnel table.
002099  3               	sta z80_x
002099  3               	lda #>SHRAPN
002099  3               	sta z80_i
002099  3               
002099  3               	lda #NUMSHR		; number of pieces in table.
002099  3               	sta z80_b
002099  3               fpslt0:
002099  3               	ldy #0
002099  3               	lda (z80_ix),y		; get type.
002099  3               	asl a  			; is this slot in use?
002099  3               	bcc :+
002099  3               	rts			; no, we can use it.
002099  3               :
002099  3               	clc			; point to more shrapnel.
002099  3               	lda z80_x
002099  3               	adc #SHRSIZ
002099  3               	sta z80_x
002099  3               	bcc :+
002099  3               	inc z80_i
002099  3               :
002099  3               	dec z80_b		; repeat for all shrapnel.
002099  3               	bne fpslt0
002099  3               
002099  3               	clc
002099  3               	rts 			; out of slots, can't generate anything.
002099  3               
002099  3               ;----------------------------------------------------
002099  3               ; Create an explosion at sprite position.
002099  3               ;----------------------------------------------------
002099  3               
002099  3               explod:
002099  3               	sta z80_c 		; particles to create.
002099  3               
002099  3               	lda z80_i 		; store pointer to sprite.
002099  3               	pha
002099  3               	lda z80_x
002099  3               	pha
002099  3               
002099  3               	ldy #8
002099  3               	lda (z80_ix),y 		; y coordinate.
002099  3               	sta z80_l
002099  3               	ldy #9
002099  3               	lda (z80_ix),y		; x coordinate.
002099  3               	sta z80_h
002099  3               
002099  3               	lda #<SHRAPN		; shrapnel table.
002099  3               	sta z80_x
002099  3               	lda #>SHRAPN
002099  3               	sta z80_i
002099  3               
002099  3               	lda #NUMSHR		; number of pieces in table.
002099  3               	sta explcnt
002099  3               expld0:
002099  3               	ldy #0
002099  3               	lda (z80_ix),y		; get type.
002099  3               	asl a 			; is this slot in use?
002099  3               	bcs expld1		; no, we can use it.
002099  3               expld2:
002099  3               	clc
002099  3               	lda z80_x
002099  3               	adc #SHRSIZ
002099  3               	sta z80_x
002099  3               	bcc :+
002099  3               	inc z80_i
002099  3               :
002099  3               	dec explcnt		; repeat for all shrapnel.
002099  3               	bne expld0
002099  3               expld3:
002099  3               	pla			; restore sprite pointer.
002099  3               	sta z80_x
002099  3               	pla
002099  3               	sta z80_i
002099  3               	rts 			; out of slots, can't generate any more.
002099  3               
002099  3               expld1:
002099  3               	lda z80_c		; shrapnel counter.
002099  3               	and #15			; 0 to 15.
002099  3               	clc			; add to x.
002099  3               	adc z80_l
002099  3               	ldy #3
002099  3               	sta (z80_ix),y		; y coord.
002099  3               
002099  3               	lda seed3 		; crap random number.
002099  3               	and #15			; 0 to 15.
002099  3               	clc 			; add to y.
002099  3               	adc z80_h
002099  3               	ldy #5
002099  3               	sta (z80_ix),y		; x coord.
002099  3               
002099  3               	lda #2
002099  3               	ldy #0
002099  3               	sta (z80_ix),y		; switch it on.
002099  3               
002099  3               	jsr chkxy		; plot first position.
002099  3               	jsr qrand		; quick random angle.
002099  3               	and #60 		; keep within range.
002099  3               	ldy #1
002099  3               	sta (z80_ix),y		; angle.
002099  3               
002099  3               	dec z80_c		; one less piece of shrapnel to generate.
002099  3               	bne expld2 		; back to main explosion loop.
002099  3               	jmp expld3 		; restore sprite pointer and exit.
002099  3               
002099  3               ;----------------------------------------------------
002099  3               ; Quick random
002099  3               ;----------------------------------------------------
002099  3               
002099  3               qrand:
002099  3               	jsr random		; r register.
002099  3               	eor seed3		; combine with seed.
002099  3               	sta seed3 		; new seed.
002099  3               	rts
002099  3               
002099  3               ;----------------------------------------------------
002099  3               ; Display all shrapnel.
002099  3               ;----------------------------------------------------
002099  3               
002099  3               dshrp:
002099  3               	lda #<plotde		; display routine.
002099  3               	sta proshx+1
002099  3               	lda #>plotde
002099  3               	sta proshx+2
002099  3               	jsr proshr		; process shrapnel.
002099  3               
002099  3               	lda #<prosh1		; processing routine.
002099  3               	sta proshx+1
002099  3               	lda #>prosh1
002099  3               	sta proshx+2
002099  3               	rts
002099  3               
002099  3               ;------------------------------------------------------
002099  3               ; Particle engine.
002099  3               ;
002099  3               ; Init particle data for 55 particles in SHRAPN table.
002099  3               ; Every particle has 6 bytes.
002099  3               ;
002099  3               ; global:	-
002099  3               ; local:	x,y,hl
002099  3               ; calls:	-
002099  3               ;------------------------------------------------------
002099  3               
002099  3               inishr:
002099  3               	lda #<SHRAPN 		; table.
002099  3               	sta z80_l
002099  3               	lda #>SHRAPN
002099  3               	sta z80_h
002099  3               
002099  3               	ldy #0
002099  3               	ldx #NUMSHR		; shrapnel pieces to process.
002099  3               inish0:
002099  3               	lda #255 		; kill the shrapnel.
002099  3               	sta (z80_hl),y
002099  3               
002099  3               	clc 			; point there.
002099  3               	lda z80_l
002099  3               	adc #SHRSIZ		; distance to next.
002099  3               	sta z80_l
002099  3               	bcc :+
002099  3               	inc z80_h
002099  3               :
002099  3               	dex
002099  3               	bne inish0 		; round again.
002099  3               	rts
002099  3               
002099  3               ;------------------------------------------------------
002099  3               ; Check for collision between laser and sprite.
002099  3               ;------------------------------------------------------
002099  3               
002099  3               lcol:
002099  3               	lda #<SHRAPN		; shrapnel table.
002099  3               	sta z80_l
002099  3               	lda #>SHRAPN
002099  3               	sta z80_h
002099  3               
002099  3               	lda #NUMSHR		; number of pieces in table.
002099  3               	sta z80_b
002099  3               lcol0:
002099  3               	ldy #0
002099  3               	lda (z80_hl),y 		; get type.
002099  3               	beq lcol1		; yes, check collision.
002099  3               lcol3:
002099  3               	clc			; point to more shrapnel.
002099  3               	lda z80_l
002099  3               	adc #SHRSIZ
002099  3               	sta z80_l
002099  3               	bcc :+
002099  3               	inc z80_h
002099  3               :
002099  3               	dec z80_b		; repeat for all shrapnel.
002099  3               	bne lcol0
002099  3               	clc
002099  3               	rts 			; no collision, carry not set.
002099  3               lcol1:
002099  3               	ldy #3
002099  3               	lda (z80_hl),y		; get y.
002099  3               	sec
002099  3               	ldy #8
002099  3               	sbc (z80_ix),y		; subtract sprite y.
002099  3               lcolh:
002099  3               	cmp #SPR_HGT 		; within range?
002099  3               	bcc :+
002099  3               	jmp lcol2		; no, missed.
002099  3               :
002099  3               	ldy #5
002099  3               	lda (z80_hl),y 		; get x.
002099  3               	sec
002099  3               	ldy #9
002099  3               	sbc (z80_ix),y 		; subtract sprite y.
002099  3               	cmp #16			; within range?
002099  3               	bcs :+
002099  3               	jmp lcol4 		; yes, collision occurred.
002099  3               :
002099  3               lcol2:
002099  3               	jmp lcol3
002099  3               lcol4:
002099  3               	sec
002099  3               	rts 			; return with carry set for collision.
002099  3               .endif
002099  3               
002099  3               ;------------------------------------------------------
002099  3               ; Main game engine code starts here.
002099  3               ; After initialisation, mloop is the main loop
002099  3               ;------------------------------------------------------
002099  3               
002099  3               game:
002099  3               
002099  3               ; Set up screen address table.
002099  3               
002099  3               setsat:
002099  3  A9 00        	lda #<CharAddress	; start of screen.
00209B  3  85 rr        	sta scraddr
00209D  3  A9 10        	lda #>CharAddress
00209F  3  85 rr        	sta scraddr+1
0020A1  3               
0020A1  3  A0 00        	ldy #0			; vertical lines on screen.
0020A3  3               setsa0:
0020A3  3  A5 rr        	lda scraddr
0020A5  3  99 00 07     	sta SCADTB_lb,y		; write low byte.
0020A8  3  A5 rr        	lda scraddr+1
0020AA  3  99 00 08     	sta SCADTB_hb,y		; write high byte.
0020AD  3  20 61 39     	jsr nline		; next line down.
0020B0  3  C8           	iny			; next position in table.
0020B1  3  D0 F0        	bne setsa0
0020B3  3               
0020B3  3               ; Set up colour address table
0020B3  3               
0020B3  3               setsof:
0020B3  3  A9 00        	lda #<ColorAttr		; start of colour attributes
0020B5  3  85 rr        	sta bufaddr
0020B7  3  A9 96        	lda #>ColorAttr
0020B9  3  85 rr        	sta bufaddr+1
0020BB  3               
0020BB  3  A0 00        	ldy #0			; vertical lines on screen.
0020BD  3               setof0:
0020BD  3  A5 rr        	lda bufaddr
0020BF  3  99 4A 0A     	sta COLATTTB_lb,y	; write low byte.
0020C2  3  A5 rr        	lda bufaddr+1
0020C4  3  99 55 0A     	sta COLATTTB_hb,y	; write high byte.
0020C7  3  18           	clc			; next line down.
0020C8  3  A5 rr        	lda bufaddr
0020CA  3  69 16        	adc #ScrWidth
0020CC  3  85 rr        	sta bufaddr
0020CE  3  90 02        	bcc :+
0020D0  3  E6 rr        	inc bufaddr+1
0020D2  3               :
0020D2  3  C8           	iny			; next position in table.
0020D3  3  C0 0B        	cpy #ScrHeight/2
0020D5  3  D0 E6        	bne setof0
0020D7  3               
0020D7  3               ; Init graphics mode
0020D7  3               
0020D7  3  20 90 36     	jsr init
0020DA  3               
0020DA  3               ; Init joysticks
0020DA  3  20 E1 37     	jsr joyinit		; VIC20 joystick
0020DD  3               
0020DD  3               rpblc2:
0020DD  3               .if pflag
0020DD  3               	jsr inishr 		; initialise particle engine.
0020DD  3               .endif
0020DD  3               evintr:
0020DD  3  20 5E 31     	jsr evnt12 		; call intro/menu event.
0020E0  3               
0020E0  3  A9 02        	lda #WALL 		; write default property.
0020E2  3  A2 00        	ldx #0
0020E4  3               clrmap:
0020E4  3  9D 00 04     	sta MAP,x 		; block properties.
0020E7  3  9D 00 05     	sta MAP+256,x
0020EA  3  E8           	inx
0020EB  3  D0 F7        	bne clrmap
0020ED  3               
0020ED  3               .if oflag
0020ED  3               	jsr iniob 		; initialise objects.
0020ED  3               .endif
0020ED  3  A9 00        	lda #0			; put zero in accumulator.
0020EF  3  85 rr        	sta gamwon		; reset game won flag.
0020F1  3               
0020F1  3  20 56 22     	jsr inisc 		; init the score.
0020F4  3               mapst:
0020F4  3  AD F1 30     	lda stmap 		; start position on map.
0020F7  3  8D E4 30     	sta roomtb		; set up position in table, if there is one.
0020FA  3               
0020FA  3               inipbl:
0020FA  3               .if aflag
0020FA  3               	lda #<eop		; reset blockpointer
0020FA  3               	sta pbptr
0020FA  3               	lda #>eop
0020FA  3               	sta pbptr+1
0020FA  3               .endif
0020FA  3  20 D3 2C     	jsr initsc 		; set up first screen.
0020FD  3               
0020FD  3  A9 D3        	lda #<ssprit 		; default to spare sprite in table.
0020FF  3  85 rr        	sta z80_x
002101  3  A9 30        	lda #>ssprit
002103  3  85 rr        	sta z80_i
002105  3               evini:
002105  3  20 DC 31     	jsr evnt13 		; initialisation.
002108  3               
002108  3               ; Two restarts.
002108  3               ; First restart - clear all sprites and initialise everything.
002108  3               
002108  3               rstrt:
002108  3  20 F6 21     	jsr rsevt 		; restart events.
00210B  3  20 19 20     	jsr xspr 		; clear sprite table.
00210E  3  20 3F 2E     	jsr sprlst 		; fetch pointer to screen sprites.
002111  3  20 C8 2E     	jsr ispr 		; initialise sprite table.
002114  3  4C 23 21     	jmp rstrt0
002117  3               
002117  3               ; Second restart - clear all but player, and don't initialise him.
002117  3               
002117  3               rstrtn:
002117  3  20 F6 21     	jsr rsevt		; restart events.
00211A  3  20 6C 2E     	jsr nspr 		; clear all non-player sprites.
00211D  3  20 3F 2E     	jsr sprlst 		; fetch pointer to screen sprites.
002120  3  20 05 2F     	jsr kspr 		; initialise sprite table, no more players.
002123  3               
002123  3               ; Set up the player and/or enemy sprites.
002123  3               
002123  3               rstrt0:
002123  3  A9 00        	lda #0 			; zero in accumulator.
002125  3  85 rr        	sta nexlev 		; reset next level flag.
002127  3  85 rr        	sta restfl 		; reset restart flag.
002129  3  85 rr        	sta deadf 		; reset dead flag.
00212B  3               
00212B  3  20 C6 25     	jsr droom 		; show screen layout.
00212E  3               rpblc0:
00212E  3               .if pflag
00212E  3               	jsr inishr 		; initialise particle engine.
00212E  3               .endif
00212E  3               .if aflag
00212E  3               	jsr rbloc		; draw blocks for this screen
00212E  3               .endif
00212E  3               .if oflag
00212E  3               	jsr shwob		; draw objects.
00212E  3               .endif
00212E  3               
00212E  3  A9 07        	lda #<sprtab 		; address of sprite table, even sprites.
002130  3  85 rr        	sta z80_x
002132  3  A9 30        	lda #>sprtab
002134  3  85 rr        	sta z80_i
002136  3  20 9C 2A     	jsr dspr 		; display sprites.
002139  3  A9 18        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
00213B  3  85 rr        	sta z80_x
00213D  3  A9 30        	lda #>(sprtab+TABSIZ)
00213F  3  85 rr        	sta z80_i
002141  3  20 9C 2A     	jsr dspr 		; display sprites.
002144  3               mloop:
002144  3  20 46 38     	jsr vsync 		; synchronise with display.
002147  3               
002147  3  A9 07        	lda #<sprtab 		; address of sprite table, even sprites.
002149  3  85 rr        	sta z80_x
00214B  3  A9 30        	lda #>sprtab
00214D  3  85 rr        	sta z80_i
00214F  3  20 9C 2A     	jsr dspr 		; display even sprites.
002152  3               
002152  3               ;	jsr plsnd 		; play sounds.
002152  3  20 46 38     	jsr vsync 		; synchronise with display.
002155  3  20 98 20     	jsr proshr
002158  3               
002158  3  A9 18        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
00215A  3  85 rr        	sta z80_x
00215C  3  A9 30        	lda #>(sprtab+TABSIZ)
00215E  3  85 rr        	sta z80_i
002160  3  20 9C 2A     	jsr dspr 		; display odd sprites.
002163  3               
002163  3  A9 D3        	lda #<(ssprit) 		; point to spare sprite for spawning purposes.
002165  3  85 rr        	sta z80_x
002167  3  A9 30        	lda #>(ssprit)
002169  3  85 rr        	sta z80_i
00216B  3               evlp1:
00216B  3  20 FC 30     	jsr evnt10 		; called once per main loop.
00216E  3  20 1A 2A     	jsr pspr 		; process sprites.
002171  3               
002171  3               ; Main loop events.
002171  3               
002171  3  A9 D3        	lda #<ssprit 		; point to spare sprite for spawning purposes.
002173  3  85 rr        	sta z80_x
002175  3  A9 30        	lda #>ssprit
002177  3  85 rr        	sta z80_i
002179  3               evlp2:
002179  3  20 5D 31     	jsr evnt11 		; called once per main loop.
00217C  3               bsortx:
00217C  3  20 90 29     	jsr bsort 		; sort sprites.
00217F  3               
00217F  3  A5 rr        	lda nexlev		; finished level flag.
002181  3  D0 1F        	bne newlev		; is set, go to next level.
002183  3  A5 rr        	lda gamwon		; finished game flag.
002185  3  D0 2A        	bne evwon		; is set, finish the game.
002187  3  A5 rr        	lda restfl 		; finished level flag.
002189  3  C9 01        	cmp #1			; has it been set?
00218B  3  D0 03        	bne :+
00218D  3  4C 08 21     	jmp rstrt		; yes, go to next level.
002190  3               :
002190  3  C9 02        	cmp #2			; has it been set?
002192  3  D0 03        	bne :+
002194  3  4C 17 21     	jmp rstrtn		; yes, go to next level.
002197  3               :
002197  3  A5 rr        	lda deadf 		; dead flag.
002199  3  D0 1C        	bne pdead		; yes, player dead.
00219B  3               
00219B  3               ; back to start of main loop.
00219B  3               
00219B  3  E6 rr        	inc frmno
00219D  3  E6 rr        	inc clock
00219F  3  4C 44 21     	jmp mloop		; switched to a jmp mloop during test mode.
0021A2  3               
0021A2  3               ;----------------------------------------------------------
0021A2  3               ; Read blocks from list and update screen accordingly.
0021A2  3               ;----------------------------------------------------------
0021A2  3               
0021A2  3               .if aflag
0021A2  3               rbloc:
0021A2  3               	lda #<eop		; reset blockpointer
0021A2  3               	sta pbbuf
0021A2  3               	lda #>eop
0021A2  3               	sta pbbuf+1
0021A2  3               
0021A2  3               rbloc2:
0021A2  3               	lda pbbuf			; check for last block
0021A2  3               	cmp pbptr
0021A2  3               	bne rbloc1
0021A2  3               	lda pbbuf+1
0021A2  3               	cmp pbptr+1
0021A2  3               	bne rbloc1
0021A2  3               	rts
0021A2  3               rbloc1:
0021A2  3               	ldy #0
0021A2  3               	lda (pbbuf),y		; check if block for this scno
0021A2  3               	cmp scno
0021A2  3               	bne rbloc0		; if not, skip
0021A2  3               	iny
0021A2  3               	lda (pbbuf),y		; get y
0021A2  3               	sta dispy
0021A2  3               	iny
0021A2  3               	lda (pbbuf),y		; get x
0021A2  3               	sta dispx
0021A2  3               	iny
0021A2  3               	lda (pbbuf),y		; get blocknr
0021A2  3               	jsr pattr2		; draw block
0021A2  3               rbloc0:
0021A2  3               	clc			; point to next block
0021A2  3               	lda pbbuf
0021A2  3               	adc #4
0021A2  3               	sta pbbuf
0021A2  3               	bcc rbloc2
0021A2  3               	inc pbbuf+1
0021A2  3               	jmp rbloc2
0021A2  3               .endif
0021A2  3               
0021A2  3               ;----------------------------------------------------------
0021A2  3               ; New level
0021A2  3               ;----------------------------------------------------------
0021A2  3               
0021A2  3               newlev:
0021A2  3  A5 rr        	lda scno 			; current screen.
0021A4  3  18           	clc
0021A5  3  69 01        	adc #1				; next screen.
0021A7  3  CD 54 33     	cmp numsc 			; total number of screens.
0021AA  3  B0 05        	bcs evwon			; yes, game finished.
0021AC  3  85 rr        	sta scno			; set new level number.
0021AE  3  4C 08 21     	jmp rstrt			; restart, clearing all aliens.
0021B1  3               
0021B1  3               evwon:
0021B1  3  20 03 32     	jsr evnt18		 	; game completed.
0021B4  3  4C CB 21     	jmp tidyup			; tidy up and return to BASIC/calling routine.
0021B7  3               
0021B7  3               ;----------------------------------------------------------
0021B7  3               ; Player dead.
0021B7  3               ;----------------------------------------------------------
0021B7  3               
0021B7  3               pdead:
0021B7  3  A9 00        	lda #0				; zeroise accumulator.
0021B9  3  85 rr        	sta deadf			; reset dead flag.
0021BB  3               evdie:
0021BB  3  20 01 32     	jsr evnt16 			; death subroutine.
0021BE  3  A5 rr        	lda numlif			; number of lives.
0021C0  3  F0 03        	beq :+
0021C2  3  4C 08 21     	jmp rstrt 			; restart game.
0021C5  3               :
0021C5  3               evfail:
0021C5  3  20 02 32     	jsr evnt17 			; failure event.
0021C8  3  4C 99 20     	jmp game			; restart game
0021CB  3               
0021CB  3               ;----------------------------------------------------------
0021CB  3               ; Tidy things up
0021CB  3               ;----------------------------------------------------------
0021CB  3               
0021CB  3               tidyup:
0021CB  3  A0 00        	ldy #0				; digits to check.
0021CD  3               tidyu2:
0021CD  3  B9 47 23     	lda score,y 			; get score digit.
0021D0  3  CD 4D 23     	cmp hiscor 			; are we larger than high score digit?
0021D3  3  90 07        	bcc tidyu0			; high score is bigger.
0021D5  3  D0 0E        	bne tidyu1			; score is greater, record new high score.
0021D7  3  C8           	iny				; next digit of high score.
0021D8  3  C0 06        	cpy #6
0021DA  3  D0 F1        	bne tidyu2			; repeat for all digits
0021DC  3               tidyu0:
0021DC  3  A9 47        	lda #<score			; return pointing to score.
0021DE  3  85 rr        	sta z80_c
0021E0  3  A9 23        	lda #>score
0021E2  3  85 rr        	sta z80_b
0021E4  3  60           	rts
0021E5  3               tidyu1:
0021E5  3  A0 05        	ldy #5
0021E7  3               tidyu3:
0021E7  3  B9 47 23     	lda score,y			; score.
0021EA  3  99 4D 23     	sta hiscor,y			; high score.
0021ED  3  88           	dey
0021EE  3  10 F7        	bpl tidyu3 			; copy score to high score.
0021F0  3               evnewh:
0021F0  3  20 04 32     	jsr evnt19			; new high score event.
0021F3  3  4C DC 21     	jmp tidyu0			; tidy up.
0021F6  3               
0021F6  3               ;--------------------------------------------------
0021F6  3               ; Restart event.
0021F6  3               ;--------------------------------------------------
0021F6  3               
0021F6  3               rsevt:
0021F6  3  A9 D3        	lda #<ssprit 			; default to spare element in table.
0021F8  3  85 rr        	sta z80_x
0021FA  3  A9 30        	lda #>ssprit
0021FC  3  85 rr        	sta z80_i
0021FE  3               
0021FE  3               evrs:
0021FE  3  4C FF 31     	jmp evnt14	 		; call restart event.
002201  3               
002201  3               ;------------------------------------------------------------------
002201  3               ; Copy number passed in a to string position bc, right-justified.
002201  3               ;
002201  3               ; Input:
002201  3               ;  A  = number
002201  3               ;  BC = string address
002201  3               ;
002201  3               ; Output:
002201  3               ;  BC = string with number
002201  3               ;-----------------------------------------------------------------
002201  3               
002201  3               num2ch:
002201  3  85 rr        	sta z80_d		; Save number
002203  3               
002203  3  A9 00        	lda #0
002205  3  85 rr        	sta flag
002207  3               numdg3:
002207  3  A2 64        	ldx #100		; hundreds column.
002209  3  86 rr        	stx z80_e
00220B  3  20 1B 22     	jsr numdg		; show digit.
00220E  3               numdg2:
00220E  3  A2 0A        	ldx #10			; tens column.
002210  3  86 rr        	stx z80_e
002212  3  20 1B 22     	jsr numdg		; show digit.
002215  3               
002215  3  E6 rr        	inc flag
002217  3  A2 01        	ldx #1			; units column.
002219  3  86 rr        	stx z80_e
00221B  3               numdg:
00221B  3  A9 30        	lda #48			; clear digit.
00221D  3  85 rr        	sta z80_a
00221F  3               numdg1:
00221F  3  A5 rr        	lda z80_d
002221  3  C5 rr        	cmp z80_e
002223  3  90 0E        	bcc numdg0		; nothing to show.
002225  3  38           	sec
002226  3  A5 rr        	lda z80_d
002228  3  E5 rr        	sbc z80_e		; subtract from column.
00222A  3  85 rr        	sta z80_d
00222C  3  E6 rr        	inc z80_a		; increment digit.
00222E  3  E6 rr        	inc flag
002230  3  4C 1F 22     	jmp numdg1		; repeat until column is zero.
002233  3               numdg0:
002233  3  A0 00        	ldy #0
002235  3  A5 rr        	lda z80_a
002237  3  91 rr        	sta (z80_bc),y		; write digit to buffer.
002239  3  A5 rr        	lda flag
00223B  3  F0 06        	beq :+
00223D  3  E6 rr        	inc z80_c		; next buffer position.
00223F  3  D0 02        	bne :+
002241  3  E6 rr        	inc z80_b
002243  3               :
002243  3  60           	rts
002244  3               num2dd:
002244  3  85 rr        	sta z80_d		; Save number
002246  3               
002246  3  A9 01        	lda #1
002248  3  85 rr        	sta flag
00224A  3               
00224A  3  4C 0E 22     	jmp numdg2
00224D  3               num2td:
00224D  3  85 rr        	sta z80_d		; Save number
00224F  3               
00224F  3  A9 01        	lda #1
002251  3  85 rr        	sta flag
002253  3  4C 07 22     	jmp numdg3
002256  3               
002256  3               ;---------------------------------------------------------
002256  3               ; Reset score to "000000"
002256  3               ;---------------------------------------------------------
002256  3               
002256  3               inisc:
002256  3  A9 30        	lda #'0'
002258  3  A2 05        	ldx #5			; digits to initialise.
00225A  3               inisc0:
00225A  3  9D 47 23     	sta score,x 		; write zero digit.
00225D  3  CA           	dex			; next column.
00225E  3  10 FA        	bpl inisc0		; repeat for all digits.
002260  3               
002260  3  60           	rts
002261  3               
002261  3               ;-----------------------------------------------------
002261  3               ; Multiply h by d and return in hl.
002261  3               ;
002261  3               ; Input:
002261  3               ;  H = first number
002261  3               ;  D = second number
002261  3               ;
002261  3               ; Output:
002261  3               ;  HL = result H x D
002261  3               ;-----------------------------------------------------
002261  3               
002261  3               imul:
002261  3  A5 rr        	lda z80_d		; HL = H * D
002263  3  85 rr        	sta z80_e
002265  3  A5 rr        	lda z80_h
002267  3  85 rr        	sta z80_c		; make c first multiplier.
002269  3               imul0:
002269  3  A9 00        	lda #0			; zeroise total.
00226B  3  85 rr        	sta z80_l
00226D  3  85 rr        	sta z80_h
00226F  3               
00226F  3  A5 rr        	lda z80_h
002271  3  85 rr        	sta z80_d		; zeroise high byte.
002273  3               
002273  3  A9 08        	lda #8			; repeat 8 times.
002275  3  85 rr        	sta z80_b
002277  3               imul1:
002277  3  46 rr        	lsr z80_c		; rotate rightmost bit into carry.
002279  3  90 0E        	bcc imul2		; wasn't set.
00227B  3  18           	clc			; bit was set, so add de.
00227C  3  A5 rr        	lda z80_l
00227E  3  65 rr        	adc z80_e
002280  3  85 rr        	sta z80_l
002282  3  A5 rr        	lda z80_h
002284  3  65 rr        	adc z80_d
002286  3  85 rr        	sta z80_h
002288  3  18           	clc 			; reset carry.
002289  3               imul2:
002289  3  26 rr        	rol z80_e 		; shift de 1 bit left.
00228B  3  26 rr        	rol z80_d
00228D  3  C6 rr        	dec z80_b
00228F  3  D0 E6        	bne imul1		; repeat 8 times.
002291  3               
002291  3  60           	rts
002292  3               
002292  3               ;-----------------------------------------------
002292  3               ; Divide d by e and return in d, remainder in a.
002292  3               ;
002292  3               ; Input:
002292  3               ;  D = first number
002292  3               ;  E = second number
002292  3               ;
002292  3               ; Output:
002292  3               ;  D = result D/E
002292  3               ;  A = remainder
002292  3               ;-----------------------------------------------
002292  3               
002292  3               idiv:
002292  3  A9 00        	lda #0
002294  3  A0 08        	ldy #8		 	; bits to shift.
002296  3  06 rr        	asl z80_d
002298  3               idiv0:
002298  3  2A           	rol a 			; multiply d by 2.
002299  3  C5 rr        	cmp z80_e 		; test if e is smaller.
00229B  3  90 02        	bcc idiv1		; e is greater, no division this time.
00229D  3  E5 rr        	sbc z80_e		; subtract it.
00229F  3               idiv1:
00229F  3  26 rr        	rol z80_d		; rotate into d.
0022A1  3  88           	dey
0022A2  3  D0 F4        	bne idiv0		; repeat
0022A4  3  60           	rts
0022A5  3               
0022A5  3               ;---------------------------------------------------
0022A5  3               ; Play AY sound effect
0022A5  3               ;---------------------------------------------------
0022A5  3               
0022A5  3               plsnd:
0022A5  3  60           	rts
0022A6  3               
0022A6  3               ;---------------------------------------------------
0022A6  3               ; Objects handling.
0022A6  3               ; 32 bytes for image
0022A6  3               ; 1 for colour
0022A6  3               ; 3 for room, y and x
0022A6  3               ; 3 for starting room, y and x.
0022A6  3               ; 254 = disabled.
0022A6  3               ; 255 = object in player"s pockets.
0022A6  3               ;---------------------------------------------------
0022A6  3               
0022A6  3               ;---------------------------------------------------
0022A6  3               ; Show items present.
0022A6  3               ;---------------------------------------------------
0022A6  3               
0022A6  3               .if oflag
0022A6  3               shwob:
0022A6  3               	lda #<objdta			; objects table.
0022A6  3               	sta z80_l
0022A6  3               	lda #>objdta
0022A6  3               	sta z80_h
0022A6  3               	lda numob 			; number of objects in the game.
0022A6  3               	sta sprcnt
0022A6  3               shwob0:
0022A6  3               	ldy #33 			; distance to room number.
0022A6  3               	lda (z80_hl),y 			; same as an item?
0022A6  3               	cmp scno 			; current location.
0022A6  3               	bne :+
0022A6  3               	jsr dobj 			; yes, display object.
0022A6  3               :
0022A6  3               	clc
0022A6  3               	lda z80_l
0022A6  3               	adc #39 			; distance to next item.
0022A6  3               	sta z80_l
0022A6  3               	lda z80_h
0022A6  3               	adc #0
0022A6  3               	sta z80_h	 		; point to it.
0022A6  3               	dec sprcnt
0022A6  3               	bne shwob0 			; repeat for others.
0022A6  3               	rts
0022A6  3               
0022A6  3               ;---------------------------------------------------
0022A6  3               ; Display object.
0022A6  3               ; hl must point to object's start address.
0022A6  3               ;
0022A6  3               ; Input:
0022A6  3               ;  HL = object address
0022A6  3               ;---------------------------------------------------
0022A6  3               
0022A6  3               dobj:
0022A6  3               	ldy #32
0022A6  3               	lda (z80_hl),y 			; point to y.
0022A6  3               	sta objcol
0022A6  3               	ldy #34
0022A6  3               	lda (z80_hl),y 			; point to y.
0022A6  3               	sta dispy
0022A6  3               	iny
0022A6  3               	lda (z80_hl),y 			; point to x.
0022A6  3               	sta dispx
0022A6  3               dobj1:
0022A6  3               	jmp sprite 			; draw this sprite.
0022A6  3               
0022A6  3               ;--------------------------------------
0022A6  3               ; Remove an object.
0022A6  3               ;
0022A6  3               ; Input:
0022A6  3               ;  A = object number
0022A6  3               ;--------------------------------------
0022A6  3               
0022A6  3               remob:
0022A6  3               	cmp numob			; number of objects in game.
0022A6  3               	bcc :+				; are we checking past the end?
0022A6  3               	rts				; yes, can't get non-existent item.
0022A6  3               :
0022A6  3               	pha				; remember object.
0022A6  3               	jsr getob			; pick it up if we haven't already got it.
0022A6  3               	pla				; retrieve object number.
0022A6  3               	jsr gotob			; get its address.
0022A6  3               	lda #254
0022A6  3               	ldy #33
0022A6  3               	sta (z80_hl),y			; remove it.
0022A6  3               	rts
0022A6  3               
0022A6  3               ;---------------------------------------------------
0022A6  3               ; Pick up object number held in the accumulator.
0022A6  3               ;
0022A6  3               ; Input:
0022A6  3               ;  A = object number
0022A6  3               ;---------------------------------------------------
0022A6  3               
0022A6  3               getob:
0022A6  3               	cmp numob 		; number of objects in game.
0022A6  3               	bcc :+			; are we checking past the end?
0022A6  3               	rts			; yes, can't get non-existent item.
0022A6  3               :
0022A6  3               	jsr gotob 		; check if we already have it.
0022A6  3               	cmp #255
0022A6  3               	bne :+
0022A6  3               	rts			; we already do.
0022A6  3               :
0022A6  3               	ldy #33
0022A6  3               	lda (z80_hl),y		; is it on this screen?
0022A6  3               	cmp scno 		; current screen.
0022A6  3               	bne getob0		; not on screen, so nothing to delete.
0022A6  3               
0022A6  3               	lda #255
0022A6  3               	sta (z80_hl),y		; pick it up.
0022A6  3               	iny 			; point to y coord.
0022A6  3               getob1:
0022A6  3               	ldy #34
0022A6  3               	lda (z80_hl),y		; y coord.
0022A6  3               	sta dispy
0022A6  3               	ldy #35
0022A6  3               	lda (z80_hl),y 		; x coord.
0022A6  3               	sta dispx
0022A6  3               	jmp dobj1 		; delete object sprite.
0022A6  3               getob0:
0022A6  3               	lda #255
0022A6  3               	sta (z80_hl),y 		; pick it up.
0022A6  3               	rts
0022A6  3               .endif
0022A6  3               
0022A6  3               ;-----------------------------------------------------------------
0022A6  3               ; Got object check.
0022A6  3               ; Call with object in accumulator, returns zero set if in pockets.
0022A6  3               ;
0022A6  3               ; Input:
0022A6  3               ;  A = object number
0022A6  3               ;-----------------------------------------------------------------
0022A6  3               .if oflag .or mflag
0022A6  3               gotob:
0022A6  3               	cmp numob 		; number of objects in game.
0022A6  3               	bcc :+ 			; are we checking past the end?
0022A6  3               	jmp gotob0 		; yes, we can't have a non-existent object.
0022A6  3               :
0022A6  3               	jsr findob		; find the object.
0022A6  3               gotob1:
0022A6  3               	rts
0022A6  3               
0022A6  3               gotob0:
0022A6  3               	lda #254 		; missing.
0022A6  3               	jmp gotob1
0022A6  3               
0022A6  3               findob:
0022A6  3               	pha			; save object number
0022A6  3               	lda #<objdta 		; objects.
0022A6  3               	sta z80_l
0022A6  3               	lda #>objdta
0022A6  3               	sta z80_h
0022A6  3               	pla			; retreive object number
0022A6  3               	beq fndob1 		; is it zero? yes, skip loop.
0022A6  3               	tax 			; loop counter
0022A6  3               fndob2:
0022A6  3               	clc
0022A6  3               	lda z80_l
0022A6  3               	adc #39 		; size of each object.
0022A6  3               	sta z80_l
0022A6  3               	bcc :+
0022A6  3               	inc z80_h
0022A6  3               :
0022A6  3               	dex 			; repeat until we find address.
0022A6  3               	bne fndob2
0022A6  3               fndob1:
0022A6  3               	ldy #33			; distance to room it's in.
0022A6  3               	lda (z80_hl),y		; fetch status.
0022A6  3               	rts
0022A6  3               .endif
0022A6  3               
0022A6  3               ;---------------------------------------------
0022A6  3               ; Drop object number at (dispx, dispy).
0022A6  3               ;
0022A6  3               ; Input:
0022A6  3               ;  A = object number
0022A6  3               ;---------------------------------------------
0022A6  3               
0022A6  3               .if oflag
0022A6  3               drpob:
0022A6  3               	cmp numob 		; are we checking past the end?
0022A6  3               	bcc :+
0022A6  3               	rts			; yes, can't drop non-existent item.
0022A6  3               :
0022A6  3               	jsr gotob		; make sure object is in inventory.
0022A6  3               	cmp scno		; already on this screen?
0022A6  3               	bne :+
0022A6  3               	rts			; yes, nothing to do.
0022A6  3               :
0022A6  3               	ldy #33
0022A6  3               	lda scno
0022A6  3               	sta (z80_hl),y		; bring onto screen.
0022A6  3               	lda dispy		; sprite y coordinate.
0022A6  3               	iny
0022A6  3               	sta (z80_hl),y		; point to object y.
0022A6  3               	lda dispx 		; sprite x coordinate.
0022A6  3               	iny
0022A6  3               	sta (z80_hl),y 		; point to object x
0022A6  3               	jmp dobj		; draw the object sprite.
0022A6  3               
0022A6  3               ;-----------------------------------------------
0022A6  3               ; Seek objects at sprite position.
0022A6  3               ;
0022A6  3               ; Output:
0022A6  3               ;  A = object number, if not found A=255
0022A6  3               ;-----------------------------------------------
0022A6  3               
0022A6  3               skobj:
0022A6  3               	lda #<objdta 		; pointer to objects.
0022A6  3               	sta z80_l
0022A6  3               	lda #>objdta
0022A6  3               	sta z80_h
0022A6  3               
0022A6  3               	lda numob 		; number of objects in game.
0022A6  3               	sta z80_b 		; set up the loop counter.
0022A6  3               skobj0:
0022A6  3               	lda scno		; current room number.
0022A6  3               	ldy #33
0022A6  3               	cmp (z80_hl),y		; is object in here?
0022A6  3               	bne :+
0022A6  3               	jsr skobj1		; yes, check coordinates.
0022A6  3               :
0022A6  3               	clc			; point to next object in table.
0022A6  3               	lda z80_l
0022A6  3               	adc #39			; size of each object.
0022A6  3               	sta z80_l
0022A6  3               	bcc :+
0022A6  3               	inc z80_h
0022A6  3               :
0022A6  3               	dec z80_b
0022A6  3               	bne skobj0		; repeat for all objects.
0022A6  3               
0022A6  3               	lda #255		; end of list and nothing found, return 255.
0022A6  3               	rts
0022A6  3               
0022A6  3               skobj1:
0022A6  3               	ldy #34			; point to y coordinate.
0022A6  3               	lda (z80_hl),y		; point to y coordinate.
0022A6  3               	sec
0022A6  3               	ldy #var_newY
0022A6  3               	sbc (z80_ix),y 		; subtract sprite y.
0022A6  3               	clc
0022A6  3               	adc #15			; add sprite height minus one.
0022A6  3               	cmp #31			; within range?
0022A6  3               	bcs skobj2		; no, ignore object.
0022A6  3               
0022A6  3               	ldy #35			; point to x coordinate now.
0022A6  3               	lda (z80_hl),y 		; get coordinate.
0022A6  3               	sec
0022A6  3               	ldy #var_newX
0022A6  3               	sbc (z80_ix),y 		; subtract the sprite x.
0022A6  3               	clc			; add sprite width minus one.
0022A6  3               	adc #15
0022A6  3               	cmp #31			; within range?
0022A6  3               	bcs skobj2		; no, ignore object.
0022A6  3               
0022A6  3               	pla			; remove return address from stack.
0022A6  3               	pla
0022A6  3               
0022A6  3               	lda numob 		; objects in game.
0022A6  3               	sec
0022A6  3               	sbc z80_b		; subtract loop counter.
0022A6  3               skobj2:
0022A6  3               	rts			; accumulator now points to object.
0022A6  3               .endif
0022A6  3               
0022A6  3               ;---------------------------------------------------------------------
0022A6  3               ; Spawn a new sprite.
0022A6  3               ;---------------------------------------------------------------------
0022A6  3               
0022A6  3               spawn:
0022A6  3  A9 07        	lda #<sprtab		; sprite table.
0022A8  3  85 rr        	sta z80_l
0022AA  3  A9 30        	lda #>sprtab
0022AC  3  85 rr        	sta z80_h
0022AE  3               numsp1:
0022AE  3  A9 0C        	lda #NUMSPR		; number of sprites.
0022B0  3  85 rr        	sta spcnt
0022B2  3               spaw0:
0022B2  3  A0 00        	ldy #var_Type
0022B4  3  B1 rr        	lda (z80_hl),y		; get sprite type.
0022B6  3  C9 FF        	cmp #255		; is it an unused slot?
0022B8  3  F0 0F        	beq spaw1 		; yes, we can use this one.
0022BA  3               
0022BA  3  18           	clc 			; point to next sprite in table.
0022BB  3  A5 rr        	lda z80_l
0022BD  3  69 11        	adc #TABSIZ		; size of each entry.
0022BF  3  85 rr        	sta z80_l
0022C1  3  90 02        	bcc :+
0022C3  3  E6 rr        	inc z80_h
0022C5  3               :
0022C5  3  C6 rr        	dec spcnt		; one less iteration.
0022C7  3  D0 E9        	bne spaw0		; keep going until we find a slot.
0022C9  3               
0022C9  3               ; Didn't find one but drop through and set up a dummy sprite instead.
0022C9  3               
0022C9  3               spaw1:
0022C9  3  A5 rr        	lda z80_i		; address of original sprite.
0022CB  3  48           	pha
0022CC  3  A5 rr        	lda z80_x
0022CE  3  48           	pha
0022CF  3               
0022CF  3  A5 rr        	lda z80_l		; store spawned sprite address.
0022D1  3  85 rr        	sta spptr
0022D3  3  A5 rr        	lda z80_h
0022D5  3  85 rr        	sta spptr+1
0022D7  3               
0022D7  3  A5 rr        	lda z80_c
0022D9  3  A0 00        	ldy #var_Type
0022DB  3  91 rr        	sta (z80_hl),y 		; set the type.
0022DD  3  A0 05        	ldy #var_newType
0022DF  3  91 rr        	sta (z80_hl),y		; copy
0022E1  3               
0022E1  3  A5 rr        	lda z80_b
0022E3  3  A0 01        	ldy #var_Image
0022E5  3  91 rr        	sta (z80_hl),y		; set the image.
0022E7  3  A0 06        	ldy #var_newImage
0022E9  3  91 rr        	sta (z80_hl),y		; copy
0022EB  3               
0022EB  3  A9 00        	lda #0 				; frame zero.
0022ED  3  A0 02        	ldy #var_Frame
0022EF  3  91 rr        	sta (z80_hl),y		; set frame.
0022F1  3  A0 07        	ldy #var_newFrame
0022F3  3  91 rr        	sta (z80_hl),y		; copy
0022F5  3               
0022F5  3  A0 08        	ldy #8
0022F7  3  B1 rr        	lda (z80_ix),y 		; x coordinate.
0022F9  3  A0 03        	ldy #3
0022FB  3  91 rr        	sta (z80_hl),y		; set sprite coordinate.
0022FD  3  A0 08        	ldy #8
0022FF  3  91 rr        	sta (z80_hl),y		; copy
002301  3               
002301  3  A0 09        	ldy #9
002303  3  B1 rr        	lda (z80_ix),y 		; y coordinate.
002305  3  A0 04        	ldy #4
002307  3  91 rr        	sta (z80_hl),y		; set sprite coordinate.
002309  3  A0 09        	ldy #9
00230B  3  91 rr        	sta (z80_hl),y		; copy
00230D  3               
00230D  3  A0 0A        	ldy #10				; direction of original.
00230F  3  B1 rr        	lda (z80_ix),y
002311  3  91 rr        	sta (z80_hl),y		; direction
002313  3               
002313  3  A9 00        	lda #0
002315  3  A0 0D        	ldy #var_jumpLo
002317  3  91 rr        	sta (z80_hl),y		; reset parameter.
002319  3  C8           	iny
00231A  3  91 rr        	sta (z80_hl),y		; reset parameter.
00231C  3  C8           	iny
00231D  3  91 rr        	sta (z80_hl),y		; reset parameter.
00231F  3  C8           	iny
002320  3  91 rr        	sta (z80_hl),y		; reset parameter.
002322  3               rtssp:
002322  3  A5 rr        	lda spptr			; address of new sprite.
002324  3  85 rr        	sta z80_x
002326  3  A5 rr        	lda spptr+1
002328  3  85 rr        	sta z80_i
00232A  3               evis1:
00232A  3  20 FB 30     	jsr evnt09 			; call sprite initialisation event.
00232D  3               
00232D  3  A5 rr        	lda spptr 			; address of new sprite.
00232F  3  85 rr        	sta z80_x
002331  3  A5 rr        	lda spptr+1
002333  3  85 rr        	sta z80_i
002335  3               
002335  3               	; _BEEB clipping code copied from CPC Engine - MISSING?!
002335  3  A0 03        	ldy #var_Y
002337  3  B1 rr        	lda (z80_hl), y		; old x coord
002339  3  C9 A1        	cmp #SpriteMaxY     ; beyond maximum?
00233B  3  B0 03        	bcs :+				; yes, don't draw it.
00233D  3               
00233D  3  20 FC 38     	jsr sspria 			; display the new sprite.
002340  3               :
002340  3  68           	pla					; address of original sprite.
002341  3  85 rr        	sta z80_x
002343  3  68           	pla
002344  3  85 rr        	sta z80_i
002346  3               
002346  3  60           	rts
002347  3               
002347  3  30 30 30 30  score:	.byte "000000"		; player"s score.
00234B  3  30 30        
00234D  3  30 30 30 30  hiscor:	.byte "000000"		; high score.
002351  3  30 30        
002353  3  30 30 30 30  bonus:	.byte "000000"		; bonus.
002357  3  30 30        
002359  3  00 02        grbase:	.word ScreenAddr	; graphics base address.
00235B  3               
00235B  3               ;----------------------------------------------------
00235B  3               ; Check y-pos
00235B  3               ;----------------------------------------------------
00235B  3               
00235B  3               checkx:
00235B  3  A5 rr        	lda dispy		; y position.
00235D  3  C9 16        	cmp #22			; off screen?
00235F  3  B0 01        	bcs :+
002361  3  60           	rts			; no, it's okay.
002362  3               :
002362  3  68           	pla			; remove return address from stack.
002363  3  85 rr        	sta z80_l
002365  3  68           	pla
002366  3  85 rr        	sta z80_h
002368  3  60           	rts
002369  3               
002369  3               ;-----------------------------------------------
002369  3               ; Displays the current high score.
002369  3               ;-----------------------------------------------
002369  3               
002369  3               dhisc:
002369  3  A9 4D        	lda #<hiscor 		; high score text.
00236B  3  8D A0 23     	sta dscor3+1
00236E  3  8D BB 23     	sta bscor3+1
002371  3  A9 23        	lda #>hiscor
002373  3  8D A1 23     	sta dscor3+2
002376  3  8D BC 23     	sta bscor3+2
002379  3  4C 8C 23     	jmp dscor1		; check in printable range then show 6 digits.
00237C  3               
00237C  3               ;------------------------------------------------------
00237C  3               ; Displays the current score.
00237C  3               ;------------------------------------------------------
00237C  3               
00237C  3               dscor:
00237C  3  A9 47        	lda #<score		; score text.
00237E  3  8D A0 23     	sta dscor3+1
002381  3  8D BB 23     	sta bscor3+1
002384  3  A9 23        	lda #>score
002386  3  8D A1 23     	sta dscor3+2
002389  3  8D BC 23     	sta bscor3+2
00238C  3               dscor1:
00238C  3  8C B7 23     	sty tmpscr
00238F  3  20 64 29     	jsr preprt		; set up font and print position.
002392  3  20 5B 23     	jsr checkx		; make sure we're in a printable range.
002395  3               
002395  3               ;	lda #6			; digits to display.
002395  3               ;	sta z80_b
002395  3  A5 rr        	lda prtmod		; get print mode.
002397  3  F0 03        	beq :+			; standard size text?
002399  3  4C B8 23     	jmp bscor0		; no, show double-height.
00239C  3               :
00239C  3               dscor0:
00239C  3               ;	ldy #0
00239C  3               ;	lda (z80_hl),y 		; fetch character.
00239C  3  AC B7 23     	ldy tmpscr
00239F  3               dscor3:
00239F  3  B9 47 23     	lda score,y
0023A2  3  20 7A 39     	jsr pchar 		; display character.
0023A5  3  E6 rr        	inc dispx		; move along x coordinate
0023A7  3               
0023A7  3               ;	inc z80_l		; next score column.
0023A7  3               ;	bne :+
0023A7  3               ;	inc z80_h
0023A7  3               ;:
0023A7  3  EE B7 23     	inc tmpscr
0023AA  3  C6 rr        	dec z80_b
0023AC  3  D0 EE        	bne dscor0 		; repeat for all digits.
0023AE  3               dscor2:
0023AE  3  A5 rr        	lda dispx 		; set up display coordinates.
0023B0  3  85 rr        	sta charx
0023B2  3  A5 rr        	lda dispy
0023B4  3  85 rr        	sta chary
0023B6  3  60           	rts
0023B7  3               
0023B7  3  00           tmpscr:	.byte 0
0023B8  3               ;------------------------------------------------------
0023B8  3               ; Displays the current score in double-height characters.
0023B8  3               ;
0023B8  3               ; Input:
0023B8  3               ;  B  = digit number
0023B8  3               ;  HL = score string
0023B8  3               ;------------------------------------------------------
0023B8  3               
0023B8  3               bscor0:
0023B8  3               ;	ldy #0
0023B8  3               
0023B8  3               ;	lda (z80_hl),y 		; fetch character.
0023B8  3  A4 rr        	ldy tmp
0023BA  3               bscor3:
0023BA  3  B9 47 23     	lda score,y
0023BD  3  20 CF 28     	jsr bchar 		; display big char.
0023C0  3               
0023C0  3               ;	inc z80_l 		; next score column.
0023C0  3               ;	bne :+
0023C0  3               ;	inc z80_h
0023C0  3               ;:
0023C0  3  E6 rr        	inc tmp
0023C2  3  C6 rr        	dec z80_b
0023C4  3  F0 03        	beq :+
0023C6  3  4C B8 23     	jmp bscor0 		; repeat for all digits.
0023C9  3               :
0023C9  3  4C AE 23     	jmp dscor2 		; tidy up line and column variables.
0023CC  3               
0023CC  3               ;-----------------------------------------------------
0023CC  3               ; Adds number in the hl pair to the score.
0023CC  3               ;-----------------------------------------------------
0023CC  3               
0023CC  3               addsc:
0023CC  3  A9 48        	lda #<(score+1) 	; ten thousands column.
0023CE  3  85 rr        	sta z80_e
0023D0  3  A9 23        	lda #>(score+1)
0023D2  3  85 rr        	sta z80_d
0023D4  3  A9 10        	lda #<10000		; amount to add each time.
0023D6  3  85 rr        	sta z80_c
0023D8  3  A9 27        	lda #>10000
0023DA  3  85 rr        	sta z80_b
0023DC  3  20 20 24     	jsr incsc		; add to score.
0023DF  3               
0023DF  3  E6 rr        	inc z80_e		; thousands column.
0023E1  3  D0 02        	bne :+
0023E3  3  E6 rr        	inc z80_d
0023E5  3               :
0023E5  3  A9 E8        	lda #<1000		; amount to add each time.
0023E7  3  85 rr        	sta z80_c
0023E9  3  A9 03        	lda #>1000
0023EB  3  85 rr        	sta z80_b
0023ED  3  20 20 24     	jsr incsc 		; add to score.
0023F0  3               
0023F0  3  E6 rr        	inc z80_e		; hundreds column.
0023F2  3  D0 02        	bne :+
0023F4  3  E6 rr        	inc z80_d
0023F6  3               :
0023F6  3  A9 64        	lda #<100		; amount to add each time.
0023F8  3  85 rr        	sta z80_c
0023FA  3  A9 00        	lda #>100
0023FC  3  85 rr        	sta z80_b
0023FE  3  20 20 24     	jsr incsc		; add to score.
002401  3               
002401  3  E6 rr        	inc z80_e 		; tens column.
002403  3  D0 02        	bne :+
002405  3  E6 rr        	inc z80_d
002407  3               :
002407  3  A9 0A        	lda #<10		; amount to add each time.
002409  3  85 rr        	sta z80_c
00240B  3  A9 00        	lda #>10
00240D  3  85 rr        	sta z80_b
00240F  3  20 20 24     	jsr incsc 		; add to score.
002412  3               
002412  3  E6 rr        	inc z80_e		; units column.
002414  3  D0 02        	bne :+
002416  3  E6 rr        	inc z80_d
002418  3               :
002418  3  A9 01        	lda #<1			; units.
00241A  3  85 rr        	sta z80_c
00241C  3  A9 00        	lda #>1
00241E  3  85 rr        	sta z80_b
002420  3               incsc:
002420  3  A5 rr        	lda z80_h		; store amount to add.
002422  3  48           	pha
002423  3  A5 rr        	lda z80_l
002425  3  48           	pha
002426  3               
002426  3  38           	sec			; subtract from amount to add.
002427  3  A5 rr        	lda z80_l
002429  3  E5 rr        	sbc z80_c
00242B  3  85 rr        	sta z80_l
00242D  3  A5 rr        	lda z80_h
00242F  3  E5 rr        	sbc z80_b
002431  3  85 rr        	sta z80_h
002433  3  90 14        	bcc incsc0		; too much, restore value.
002435  3               
002435  3  68           	pla			; delete the previous amount from the stack.
002436  3  68           	pla
002437  3               
002437  3  A5 rr        	lda z80_d 		; store column position.
002439  3  48           	pha
00243A  3  A5 rr        	lda z80_e
00243C  3  48           	pha
00243D  3  20 50 24     	jsr incsc2		; do the increment.
002440  3               
002440  3  68           	pla			; restore column.
002441  3  85 rr        	sta z80_e
002443  3  68           	pla
002444  3  85 rr        	sta z80_d
002446  3  4C 20 24     	jmp incsc		; repeat until all added.
002449  3               
002449  3               incsc0:
002449  3  68           	pla			; restore previous value.
00244A  3  85 rr        	sta z80_l
00244C  3  68           	pla
00244D  3  85 rr        	sta z80_h
00244F  3  60           	rts
002450  3               incsc2:
002450  3  A0 00        	ldy #0
002452  3  B1 rr        	lda (z80_de),y 		; get amount.
002454  3  18           	clc
002455  3  69 01        	adc #1			; add one to column.
002457  3  91 rr        	sta (z80_de),y		; write new column total.
002459  3  C9 3A        	cmp #'9'+1		; gone beyond range of digits?
00245B  3  B0 01        	bcs :+
00245D  3  60           	rts			; no, carry on.
00245E  3               :
00245E  3  A9 30        	lda #'0'		; make it zero.
002460  3  91 rr        	sta (z80_de),y		; write new column total.
002462  3  C6 rr        	dec z80_e		; back one column.
002464  3  D0 02        	bne :+
002466  3  C6 rr        	dec z80_d
002468  3               :
002468  3  4C 50 24     	jmp incsc2
00246B  3               
00246B  3               ;------------------------------------
00246B  3               ; Add bonus to score and reset bonus
00246B  3               ;------------------------------------
00246B  3               
00246B  3               addbo:
00246B  3  A2 05        	ldx #5			; last digit.
00246D  3  18           	clc
00246E  3               addbo0:
00246E  3  BD 47 23     	lda score,x		; get score.
002471  3  7D 53 23     	adc bonus,x		; add bonus.
002474  3  38           	sec			; 0 to 18.
002475  3  E9 30        	sbc #48
002477  3  48           	pha
002478  3  A9 30        	lda #'0'
00247A  3  9D 53 23     	sta bonus,x
00247D  3  68           	pla
00247E  3  C9 3A        	cmp #58
002480  3  90 03        	bcc addbo1
002482  3  38           	sec
002483  3  E9 0A        	sbc #10
002485  3               addbo1:
002485  3  9D 47 23     	sta score,x		; zeroise bonus.
002488  3  CA           	dex			; next digit.
002489  3  10 E3        	bpl addbo0		; repeat for all 6 digits.
00248B  3  60           	rts
00248C  3               
00248C  3               ;------------------------------------
00248C  3               ; Swap score and bonus.
00248C  3               ;------------------------------------
00248C  3               
00248C  3               swpsb:
00248C  3  A2 05        	ldx #5			; digits to add.
00248E  3               swpsb0:
00248E  3  BD 47 23     	lda score,x 		; get score digits.
002491  3  48           	pha			; save digit
002492  3  BD 53 23     	lda bonus,x 		; get bonus digits.
002495  3  9D 47 23     	sta score,x		; switch score-bonus
002498  3  68           	pla
002499  3  9D 53 23     	sta bonus,x
00249C  3  CA           	dex 			; repeat for all 6 digits.
00249D  3  10 EF        	bpl swpsb0
00249F  3  60           	rts
0024A0  3               
0024A0  3               ;----------------------------------------------------
0024A0  3               ; Get print address.
0024A0  3               ;----------------------------------------------------
0024A0  3               
0024A0  3               gprad:
0024A0  3  98           	tya
0024A1  3  48           	pha
0024A2  3               
0024A2  3  A5 rr        	lda dispx 		; x coordinate.
0024A4  3  85 rr        	sta scraddr
0024A6  3  A9 00        	lda #0
0024A8  3  85 rr        	sta scraddr+1
0024AA  3  06 rr        	asl scraddr  		; multiply char by 16
0024AC  3  26 rr        	rol scraddr+1
0024AE  3  06 rr        	asl scraddr
0024B0  3  26 rr        	rol scraddr+1
0024B2  3  06 rr        	asl scraddr
0024B4  3  26 rr        	rol scraddr+1
0024B6  3  06 rr        	asl scraddr
0024B8  3  26 rr        	rol scraddr+1
0024BA  3               
0024BA  3  A5 rr        	lda dispy		; y coordinate.
0024BC  3  0A           	asl a
0024BD  3  0A           	asl a
0024BE  3  0A           	asl a			; multiply char by 8
0024BF  3  A8           	tay
0024C0  3               
0024C0  3  18           	clc
0024C1  3  A5 rr        	lda scraddr
0024C3  3  79 00 07     	adc SCADTB_lb,y
0024C6  3  85 rr        	sta scraddr
0024C8  3  A5 rr        	lda scraddr+1
0024CA  3  79 00 08     	adc SCADTB_hb,y
0024CD  3  85 rr        	sta scraddr+1
0024CF  3               
0024CF  3  A5 rr        	lda prtmod		; Double line if bigtxt
0024D1  3  F0 08        	beq noskip
0024D3  3  A5 rr        	lda dispx
0024D5  3  29 E0        	and #$e0
0024D7  3  F0 02        	beq noskip
0024D9  3  E6 rr        	inc scraddr+1
0024DB  3               noskip:
0024DB  3               
0024DB  3  68           	pla
0024DC  3  A8           	tay
0024DD  3  60           	rts
0024DE  3               ;--------------------------------------------------------------
0024DE  3               ; Get property buffer address of char at (dispx, dispy) in hl.
0024DE  3               ;
0024DE  3               ; Output:
0024DE  3               ;  buffaddr = bufaddr = MAP + dispy*22 + dispx
0024DE  3               ;--------------------------------------------------------------
0024DE  3               
0024DE  3               pradd:
0024DE  3  A5 rr        	lda dispy 		; y coordinate.
0024E0  3  85 rr        	sta bufaddr
0024E2  3  A9 00        	lda #0
0024E4  3  85 rr        	sta bufaddr+1
0024E6  3  06 rr        	asl bufaddr  		; multiply char by 32
0024E8  3  26 rr        	rol bufaddr+1
0024EA  3  06 rr        	asl bufaddr
0024EC  3  26 rr        	rol bufaddr+1
0024EE  3  06 rr        	asl bufaddr
0024F0  3  26 rr        	rol bufaddr+1
0024F2  3  06 rr        	asl bufaddr
0024F4  3  26 rr        	rol bufaddr+1
0024F6  3  06 rr        	asl bufaddr
0024F8  3  26 rr        	rol bufaddr+1
0024FA  3  18           	clc			; add address of MAP graphics.
0024FB  3  A5 rr        	lda bufaddr
0024FD  3  65 rr        	adc dispx
0024FF  3  69 00        	adc #<MAP
002501  3  85 rr        	sta bufaddr
002503  3  A5 rr        	lda bufaddr+1
002505  3  69 04        	adc #>MAP
002507  3  85 rr        	sta bufaddr+1
002509  3  60           	rts
00250A  3               
00250A  3               ;--------------------------------------------------------------
00250A  3               ; Get attribute address at (dispx, dispy).
00250A  3               ;
00250A  3               ; Output:
00250A  3               ;  bufaddr = COLOR + dispy*22 + dispx
00250A  3               ;--------------------------------------------------------------
00250A  3               
00250A  3               gaadd:
00250A  3  A5 rr        	lda dispy
00250C  3  4A           	lsr a
00250D  3  A8           	tay
00250E  3  B9 55 0A     	lda COLATTTB_hb,y
002511  3  85 rr        	sta bufaddr+1
002513  3  B9 4A 0A     	lda COLATTTB_lb,y
002516  3  18           	clc
002517  3  65 rr        	adc dispx
002519  3  85 rr        	sta bufaddr
00251B  3  60           	rts
00251C  3               
00251C  3               ;----------------------------------------------
00251C  3               ; Print attributes, properties and pixels.
00251C  3               ;
00251C  3               ; Input:
00251C  3               ;  A	= tile number
00251C  3               ;----------------------------------------------
00251C  3               
00251C  3               pbpattr:			; entry PUTBLOCK command
00251C  3  A4 rr        	ldy charx
00251E  3  84 rr        	sty dispx
002520  3  A4 rr        	ldy chary
002522  3  84 rr        	sty dispy
002524  3               pattr:
002524  3               .if aflag
002524  3               	pha
002524  3               	jsr wbloc		; save blockinfo
002524  3               	pla
002524  3               .endif
002524  3               
002524  3               pattr2:
002524  3  85 rr        	sta z80_b		; store cell in b register for now.
002526  3  AA           	tax
002527  3  BD 8C 32     	lda bprop,x 		; block properties.
00252A  3  85 rr        	sta z80_c
00252C  3  C9 08        	cmp #COLECT
00252E  3  D0 04        	bne :+
002530  3  A5 rr        	lda z80_b
002532  3  85 rr        	sta colpatt
002534  3               :
002534  3  20 DE 24     	jsr pradd 		; get property buffer address.
002537  3  A5 rr        	lda z80_c
002539  3  A0 00        	ldy #0
00253B  3  91 rr        	sta (bufaddr),y 	; write property.
00253D  3  A5 rr        	lda z80_b 		; restore cell.
00253F  3  4C 42 25     	jmp panp
002542  3               ; Print attributes, no properties.
002542  3               
002542  3               ;colpatt:	.byte 0
002542  3               
002542  3               panp:
002542  3  85 rr        	sta z80_e		; displacement in e.
002544  3  A9 00        	lda #0
002546  3  85 rr        	sta z80_d		; no high byte.
002548  3  06 rr        	asl z80_e  		; multiply char by 8.
00254A  3  26 rr        	rol z80_d
00254C  3  06 rr        	asl z80_e
00254E  3  26 rr        	rol z80_d
002550  3  06 rr        	asl z80_e
002552  3  26 rr        	rol z80_d
002554  3  18           	clc
002555  3  A5 rr        	lda z80_e
002557  3  69 7A        	adc #<chgfx 		; address of graphics.
002559  3  85 rr        	sta tileaddr
00255B  3  A5 rr        	lda z80_d
00255D  3  69 32        	adc #>chgfx
00255F  3  85 rr        	sta tileaddr+1
002561  3               
002561  3  A6 rr        	ldx z80_b		; set colour attribute
002563  3  BD 8A 32     	lda bCol,x
002566  3  48           	pha
002567  3  20 0A 25     	jsr gaadd
00256A  3  A0 00        	ldy #0
00256C  3  68           	pla
00256D  3  91 rr        	sta (bufaddr),y
00256F  3               
00256F  3  20 A0 24     	jsr gprad 		; get screen address.
002572  3  A2 07        	ldx #7			; number of pixel rows to write.
002574  3               panp0:
002574  3  A0 00        	ldy #0
002576  3  B1 rr        	lda (tileaddr),y 	; get image byte.
002578  3               .if iflag
002578  3               	eor #$ff		; Invert
002578  3               .endif
002578  3  BC BB 39     	ldy scrtab,x
00257B  3  91 rr        	sta (scraddr),y 	; copy to screen.
00257D  3  E6 rr        	inc tileaddr 		; next image byte.
00257F  3  D0 02        	bne :+
002581  3  E6 rr        	inc tileaddr+1
002583  3               :
002583  3  CA           	dex	 		; repeat for 8 pixel rows.
002584  3  10 EE        	bpl panp0
002586  3  E6 rr        	inc dispx 		; move along one.
002588  3  E6 rr        	inc charx
00258A  3  60           	rts
00258B  3               
00258B  3               ;----------------------------------------------
00258B  3               ; Write block
00258B  3               ;----------------------------------------------
00258B  3               
00258B  3               .if aflag
00258B  3               wbloc:
00258B  3               	ldy #3
00258B  3               	sta (pbptr),y		; store block number
00258B  3               	dey
00258B  3               	lda dispx
00258B  3               	sta (pbptr),y		; write x position of block.
00258B  3               	dey
00258B  3               	lda dispy
00258B  3               	sta (pbptr),y		; write y position of block.
00258B  3               	dey
00258B  3               	lda scno
00258B  3               	sta (pbptr),y		; write screen.
00258B  3               	clc			; point to next free location
00258B  3               	lda pbptr
00258B  3               	adc #4
00258B  3               	sta pbptr
00258B  3               	bcc :+
00258B  3               	inc pbptr+1
00258B  3               :
00258B  3               	rts
00258B  3               .endif
00258B  3               
00258B  3               ;.if kflag
00258B  3               ;panp:
00258B  3               ;.endif
00258B  3               
00258B  3               ;----------------------------------------------
00258B  3               ; Print character pixels, no more.
00258B  3               ;
00258B  3               ; Input:
00258B  3               ;  A	= character to print
00258B  3               ;----------------------------------------------
00258B  3               
00258B  3               pchr:
00258B  3  20 7A 39     	jsr pchar 		; show character in accumulator.
00258E  3  E6 rr        	inc dispx		; move along one.
002590  3  60           	rts
002591  3               
002591  3               ;----------------------------------------------------
002591  3               ; Shifter sprite routine for objects.
002591  3               ;----------------------------------------------------
002591  3               
002591  3               .if oflag
002591  3               sprit7:
002591  3               	lda z80_b
002591  3               	beq sprit0
002591  3               	sta z80_a
002591  3               sprit3:
002591  3               	lsr spr			; shift into position.
002591  3               	ror spr+1
002591  3               	ror spr+2
002591  3               	dec z80_a		; one less iteration.
002591  3               	bne sprit3
002591  3               sprit0:
002591  3               	rts 			; now apply to screen.
002591  3               .endif
002591  3               
002591  3               ;-----------------------------------------------------------
002591  3               ; Get room address.
002591  3               ;-----------------------------------------------------------
002591  3               
002591  3               groom:
002591  3  A6 rr        	ldx scno 		; screen number.
002593  3  A0 00        	ldy #0
002595  3               groomx:
002595  3  A9 12        	lda #<scdat 		; pointer to screens.
002597  3  85 rr        	sta z80_l
002599  3  A9 33        	lda #>scdat
00259B  3  85 rr        	sta z80_h
00259D  3               groom1:
00259D  3  E0 00        	cpx #0			; is it the first one?
00259F  3  F0 15        	beq groom0 		; no more screens to skip.
0025A1  3               
0025A1  3  18           	clc
0025A2  3  A5 rr        	lda z80_l
0025A4  3  79 12 33     	adc scdat,y 		; low byte of screen size.
0025A7  3  85 rr        	sta z80_l
0025A9  3  C8           	iny			; point to high byte.
0025AA  3  A5 rr        	lda z80_h
0025AC  3  79 12 33     	adc scdat,y 		; high byte of screen size.
0025AF  3  85 rr        	sta z80_h
0025B1  3  C8           	iny			; next address.
0025B2  3               
0025B2  3  CA           	dex 			; one less iteration.
0025B3  3  4C 9D 25     	jmp groom1 		; loop until we reach the end.
0025B6  3               groom0:
0025B6  3  AD 54 33     	lda numsc		; add displacement.
0025B9  3  0A           	asl a
0025BA  3  18           	clc			; add double displacement to address.
0025BB  3  65 rr        	adc z80_l
0025BD  3  85 rr        	sta z80_l
0025BF  3  A5 rr        	lda z80_h
0025C1  3  69 00        	adc #0
0025C3  3  85 rr        	sta z80_h
0025C5  3  60           	rts
0025C6  3               
0025C6  3               ;-----------------------------------------------------------
0025C6  3               ; Draw present room.
0025C6  3               ;-----------------------------------------------------------
0025C6  3               
0025C6  3               droom:
0025C6  3  AD 0E 20     	lda wintop 		; window top.
0025C9  3  85 rr        	sta dispy		; set cursor y position.
0025CB  3               droom2:
0025CB  3  20 91 25     	jsr groom 		; get address of current room.
0025CE  3  A9 00        	lda #0	 		; zero in accumulator.
0025D0  3  85 rr        	sta comcnt 		; reset compression counter.
0025D2  3  AD 10 20     	lda winhgt 		; height of window.
0025D5  3  85 rr        	sta rrow		; set row counter
0025D7  3               droom0:
0025D7  3  AD 0F 20     	lda winlft 		; window left edge.
0025DA  3  85 rr        	sta dispx 		; set cursor x position.
0025DC  3  AD 11 20     	lda winwid 		; width of window.
0025DF  3  85 rr        	sta rcol		; set column counter
0025E1  3               droom1:
0025E1  3  20 F2 25     	jsr flbyt 		; decompress next byte on the fly.
0025E4  3               .if xflag
0025E4  3               	jsr drwmeta
0025E4  3               .else
0025E4  3  20 24 25     	jsr pattr2 		; show attributes and block.
0025E7  3               .endif
0025E7  3  C6 rr        	dec rcol		; one less column.
0025E9  3  D0 F6        	bne droom1 		; repeat for entire line.
0025EB  3  E6 rr        	inc dispy		; move down one line.
0025ED  3               .if xflag
0025ED  3               	inc dispy		; move down one line.
0025ED  3               .endif
0025ED  3  C6 rr        	dec rrow 		; one less row.
0025EF  3  D0 E6        	bne droom0 		; repeat for all rows.
0025F1  3  60           	rts
0025F2  3               
0025F2  3               ;----------------------------------------------
0025F2  3               ; Decompress bytes on-the-fly.
0025F2  3               ;----------------------------------------------
0025F2  3               
0025F2  3               flbyt:
0025F2  3  A5 rr        	lda comcnt 		; compression counter.
0025F4  3  D0 21        	bne flbyt1		; any more to decompress?  yes.
0025F6  3               
0025F6  3  A0 00        	ldy #0
0025F8  3  B1 rr        	lda (z80_hl),y 		; fetch next byte.
0025FA  3  E6 rr        	inc z80_l 		; point to next cell.
0025FC  3  D0 02        	bne :+
0025FE  3  E6 rr        	inc z80_h
002600  3               :
002600  3  C9 FF        	cmp #255 		; is this byte a control code?
002602  3  F0 01        	beq :+
002604  3  60           	rts 			; no, this byte is uncompressed.
002605  3               :
002605  3  B1 rr        	lda (z80_hl),y 		; fetch byte type.
002607  3  85 rr        	sta combyt 		; set up the type.
002609  3  E6 rr        	inc z80_l 		; point to quantity.
00260B  3  D0 02        	bne :+
00260D  3  E6 rr        	inc z80_h
00260F  3               :
00260F  3  B1 rr        	lda (z80_hl),y 		; get quantity.
002611  3  E6 rr        	inc z80_l 		; point to next byte.
002613  3  D0 02        	bne :+
002615  3  E6 rr        	inc z80_h
002617  3               :
002617  3               flbyt1:
002617  3  85 rr        	sta comcnt 		; store new quantity.
002619  3  C6 rr        	dec comcnt		; one less.
00261B  3  A5 rr        	lda combyt 		; byte to expand.
00261D  3  60           	rts
00261E  3               
00261E  3               ; ------------------------------------------------------------------------------------------------------------------------------------------
00261E  3               ; Drawing a MetaBlock (4 tiles 8x8 => 16x16)
00261E  3               ; param in regA tells the block number to use, if 0 use 0,0,0,0  else use N,N+2 || N+1,N+3
00261E  3               ; ------------------------------------------------------------------------------------------------------------------------------------------
00261E  3               .if xflag
00261E  3               drwmeta:
00261E  3               	sta tmpblk
00261E  3               	jsr pattr2
00261E  3               
00261E  3               	inc dispy
00261E  3               	dec dispx
00261E  3               	ldx tmpblk
00261E  3               	beq :+
00261E  3               	inx
00261E  3               :
00261E  3               	txa
00261E  3               	jsr pattr2
00261E  3               
00261E  3               	ldx tmpblk
00261E  3               	beq :+
00261E  3               	inx
00261E  3               	inx
00261E  3               	inx
00261E  3               :
00261E  3               	txa
00261E  3               	jsr pattr2
00261E  3               
00261E  3               	dec dispy
00261E  3               	dec dispx
00261E  3               	ldx tmpblk
00261E  3               	beq :+
00261E  3               	inx
00261E  3               	inx
00261E  3               :
00261E  3               	txa
00261E  3               	jsr pattr2
00261E  3               	rts
00261E  3               
00261E  3               tmpblk:	.byte 0
00261E  3               
00261E  3               .endif
00261E  3               
00261E  3               ;------------------------------------------
00261E  3               ; Ladder down check.
00261E  3               ;
00261E  3               ; Input:
00261E  3               ;  IX = sprite pointer
00261E  3               ;------------------------------------------
00261E  3               
00261E  3               .if lflag
00261E  3               laddd:
00261E  3               	ldy #9
00261E  3               	lda (z80_ix),y		; x coordinate.
00261E  3               	sta dispx
00261E  3               
00261E  3               	ldy #8
00261E  3               	lda (z80_ix),y		; y coordinate.
00261E  3               	and #254		; make it even.
00261E  3               	sta (z80_ix),y 		; reset it.
00261E  3               	clc 			; look down 16 pixels.
00261E  3               numsp5:
00261E  3               	adc #SPR_HGT
00261E  3               	sta dispy		; coords in dispx,dispy.
00261E  3               	jmp laddv
00261E  3               
00261E  3               ;------------------------------------------
00261E  3               ; Ladder up check.
00261E  3               ;
00261E  3               ; Input:
00261E  3               ;  IX = sprite pointer
00261E  3               ;
00261E  3               ; Output:
00261E  3               ;  A  = 0 is ok, A <>0 is not ok
00261E  3               ;------------------------------------------
00261E  3               
00261E  3               laddu:
00261E  3               	ldy #9
00261E  3               	lda (z80_ix),y		; x coordinate.
00261E  3               	sta dispx
00261E  3               
00261E  3               	ldy #8
00261E  3               	lda (z80_ix),y		; y coordinate.
00261E  3               	and #254 		; make it even.
00261E  3               	sta (z80_ix),y		; reset it.
00261E  3               	clc 			; look 2 pixels above feet.
00261E  3               numsp6:
00261E  3               	adc #SPR_HGT-2
00261E  3               	sta dispy		; coords in dispx,dispy.
00261E  3               laddv:
00261E  3               	jsr tstbl 		; get map address.
00261E  3               	jsr ldchk 		; standard ladder check.
00261E  3               	beq :+
00261E  3               	rts 			; no way through.
00261E  3               :
00261E  3               	inc bufaddr 		; look right one cell.
00261E  3               	bne :+
00261E  3               	inc bufaddr+1
00261E  3               :
00261E  3               	jsr ldchk 		; do the check.
00261E  3               	beq :+
00261E  3               	rts 			; impassable.
00261E  3               :
00261E  3               	lda dispx 		; y coordinate.
00261E  3               	and #7 			; position straddling block cells.
00261E  3               	bne :+
00261E  3               	rts 			; no more checks needed.
00261E  3               :
00261E  3               	inc bufaddr 		; look to third cell.
00261E  3               	bne :+
00261E  3               	inc bufaddr+1
00261E  3               :
00261E  3               	jsr ldchk 		; do the check.
00261E  3               	rts  			; return with zero flag set accordingly.
00261E  3               .endif
00261E  3               
00261E  3               ;---------------------------------------------------------
00261E  3               ; Can go up check.
00261E  3               ;
00261E  3               ; Input:
00261E  3               ;  IX = sprite pointer
00261E  3               ;
00261E  3               ; Output:
00261E  3               ;  A  = 0 is ok, A <>0 is not ok
00261E  3               ;---------------------------------------------------------
00261E  3               
00261E  3               cangu:
00261E  3  A0 09        	ldy #9
002620  3  B1 rr        	lda (z80_ix),y		; x coordinate.
002622  3  85 rr        	sta dispx
002624  3  A0 08        	ldy #8
002626  3  B1 rr        	lda (z80_ix),y 		; y coordinate.
002628  3  38           	sec
002629  3  E9 02        	sbc #2
00262B  3  85 rr        	sta dispy		; coords in dispx,dispy.
00262D  3  20 B8 27     	jsr tstbl 		; get map address.
002630  3  20 D0 26     	jsr lrchk 		; standard left/right check.
002633  3  F0 01        	beq :+
002635  3  60           	rts			; no way through.
002636  3               :
002636  3  E6 rr        	inc bufaddr		; look right one cell.
002638  3  D0 02        	bne :+
00263A  3  E6 rr        	inc bufaddr+1
00263C  3               :
00263C  3  20 D0 26     	jsr lrchk 		; do the check.
00263F  3  F0 01        	beq :+
002641  3  60           	rts			; impassable.
002642  3               :
002642  3  A5 rr        	lda dispx		; x coordinate.
002644  3  29 07        	and #7			; position straddling block cells.
002646  3  D0 01        	bne :+
002648  3  60           	rts			; no more checks needed.
002649  3               :
002649  3  E6 rr        	inc bufaddr		; look to third cell.
00264B  3  D0 02        	bne :+
00264D  3  E6 rr        	inc bufaddr+1
00264F  3               :
00264F  3  20 D0 26     	jsr lrchk		; do the check.
002652  3  60           	rts 			; return with zero flag set accordingly.
002653  3               
002653  3               ;---------------------------------------------------------
002653  3               ; Can go down check.
002653  3               ;
002653  3               ; Input:
002653  3               ;  IX = sprite pointer
002653  3               ;
002653  3               ; Output:
002653  3               ;  A  = 0 is ok, A <>0 is not ok
002653  3               ;---------------------------------------------------------
002653  3               
002653  3               cangd:
002653  3  A0 09        	ldy #9
002655  3  B1 rr        	lda (z80_ix),y 		; x coordinate.
002657  3  85 rr        	sta dispx
002659  3  A0 08        	ldy #8
00265B  3  B1 rr        	lda (z80_ix),y		; y coordinate.
00265D  3  18           	clc
00265E  3               numsp3:
00265E  3  69 10        	adc #SPR_HGT 		; look down 16 pixels.
002660  3  85 rr        	sta dispy		; coords in dispx,dispy.
002662  3  20 B8 27     	jsr tstbl 		; get map address.
002665  3  20 E5 26     	jsr plchk 		; block, platform check.
002668  3  F0 01        	beq :+
00266A  3  60           	rts			; no way through.
00266B  3               :
00266B  3  E6 rr        	inc bufaddr		; look right one cell.
00266D  3  D0 02        	bne :+
00266F  3  E6 rr        	inc bufaddr+1
002671  3               :
002671  3  20 E5 26     	jsr plchk		; block, platform check.
002674  3  F0 01        	beq :+
002676  3  60           	rts			; impassable.
002677  3               :
002677  3  A5 rr        	lda dispx		; x coordinate.
002679  3  29 07        	and #7			; position straddling block cells.
00267B  3  D0 01        	bne :+
00267D  3  60           	rts			; no more checks needed.
00267E  3               :
00267E  3  E6 rr        	inc bufaddr		; look to third cell.
002680  3  D0 02        	bne :+
002682  3  E6 rr        	inc bufaddr+1
002684  3               :
002684  3  20 E5 26     	jsr plchk		; block, platform check.
002687  3  60           	rts			; return with zero flag set accordingly.
002688  3               
002688  3               ;---------------------------------------------------------
002688  3               ; Can go left check.
002688  3               ;
002688  3               ; Input:
002688  3               ;  IX = sprite pointer
002688  3               ;
002688  3               ; Output:
002688  3               ;  A  = 0 is ok, A <>0 is not ok
002688  3               ;---------------------------------------------------------
002688  3               
002688  3               cangl:
002688  3  A0 08        	ldy #8
00268A  3  B1 rr        	lda (z80_ix),y 		; y coordinate.
00268C  3  85 rr        	sta dispy
00268E  3  A0 09        	ldy #9
002690  3  B1 rr        	lda (z80_ix),y 		; x coordinate.
002692  3  38           	sec
002693  3  E9 02        	sbc #2			; look left 2 pixels.
002695  3  85 rr        	sta dispx		; coords in dispx,dispy.
002697  3  4C A9 26     	jmp cangh		; test if we can go there.
00269A  3               
00269A  3               ;---------------------------------------------------------
00269A  3               ; Can go right check.
00269A  3               ;
00269A  3               ; Input:
00269A  3               ;  IX = sprite pointer
00269A  3               ;
00269A  3               ; Output:
00269A  3               ;  A  = 0 is ok, A <>0 is not ok
00269A  3               ;---------------------------------------------------------
00269A  3               
00269A  3               cangr:
00269A  3  A0 08        	ldy #8
00269C  3  B1 rr        	lda (z80_ix),y		; y coordinate.
00269E  3  85 rr        	sta dispy
0026A0  3  A0 09        	ldy #9
0026A2  3  B1 rr        	lda (z80_ix),y		; x coordinate.
0026A4  3  18           	clc
0026A5  3  69 10        	adc #16			; look right 16 pixels.
0026A7  3  85 rr        	sta dispx		; coords in dispx,dispy.
0026A9  3               cangh:
0026A9  3               cangh2:
0026A9  3  A9 03        	lda #(SPR_HGT/8+1)	; default rows to write.
0026AB  3  85 rr        	sta z80_b
0026AD  3  A5 rr        	lda dispy		; y position.
0026AF  3  29 07        	and #7			; does x straddle cells?
0026B1  3  D0 02        	bne cangh0		; yes, loop counter is good.
0026B3  3  C6 rr        	dec z80_b		; one less row to write.
0026B5  3               cangh0:
0026B5  3  20 B8 27     	jsr tstbl		; get map address.
0026B8  3               cangh1:
0026B8  3  20 D0 26     	jsr lrchk		; standard left/right check.
0026BB  3  F0 01        	beq :+
0026BD  3  60           	rts			; no way through.
0026BE  3               :
0026BE  3  48           	pha
0026BF  3  18           	clc
0026C0  3  A5 rr        	lda bufaddr
0026C2  3  69 20        	adc #32		; look down.
0026C4  3  85 rr        	sta bufaddr
0026C6  3  90 02        	bcc :+
0026C8  3  E6 rr        	inc bufaddr+1
0026CA  3               :
0026CA  3  68           	pla
0026CB  3               
0026CB  3  C6 rr        	dec z80_b
0026CD  3  D0 E9        	bne cangh1
0026CF  3  60           	rts
0026D0  3               
0026D0  3               ;-------------------------------------
0026D0  3               ; Check left/right movement is okay.
0026D0  3               ;
0026D0  3               ; Input:
0026D0  3               ;  bufaddr = MAP + x/8 + y/8*32
0026D0  3               ;
0026D0  3               ; Output:
0026D0  3               ;  A  = 0 is ok, A <>0 is not ok
0026D0  3               ;-------------------------------------
0026D0  3               
0026D0  3               lrchk:
0026D0  3  A0 00        	ldy #0
0026D2  3  B1 rr        	lda (bufaddr),y		; fetch map cell.
0026D4  3  C9 02        	cmp #WALL 		; is it passable?
0026D6  3  F0 0A        	beq lrchkx		; no.
0026D8  3               
0026D8  3  C9 04        	cmp #FODDER		; fodder has to be dug.
0026DA  3  F0 06        	beq lrchkx		; not passable.
0026DC  3  A9 00        	lda #0
0026DE  3  60           	rts
0026DF  3               
0026DF  3               ;--------------------------------------------------------------
0026DF  3               ; Called by mmenu
0026DF  3               ;--------------------------------------------------------------
0026DF  3               
0026DF  3               always:
0026DF  3  A9 FF        	lda #255		; report it as okay.
0026E1  3  60           	rts
0026E2  3               
0026E2  3               lrchkx:
0026E2  3  A9 01        	lda #1 			; reset all bits.
0026E4  3  60           	rts
0026E5  3               
0026E5  3               
0026E5  3               ;--------------------------------------------------------------
0026E5  3               ; Check platform or solid item is not in way.
0026E5  3               ;
0026E5  3               ; Input:
0026E5  3               ;  bufaddr = MAP + x/8 + y/8*32
0026E5  3               ;
0026E5  3               ; Output:
0026E5  3               ;  A  = 0 is ok, A <>0 is not ok
0026E5  3               ;--------------------------------------------------------------
0026E5  3               
0026E5  3               plchk:
0026E5  3  A0 00        	ldy #0
0026E7  3  B1 rr        	lda (bufaddr),y 	; fetch map cell.
0026E9  3  C9 02        	cmp #WALL 		; is it passable?
0026EB  3  F0 F5        	beq lrchkx		; no.
0026ED  3               .if pflag .or dflag
0026ED  3               	cmp #FODDER		; fodder has to be dug.
0026ED  3               	beq lrchkx		; not passable.
0026ED  3               .endif
0026ED  3  C9 01        	cmp #PLATFM		; platform is solid.
0026EF  3  F0 03        	beq plchkx		; not passable.
0026F1  3               .if lflag
0026F1  3               	cmp #LADDER		; is it a ladder?
0026F1  3               	beq lrchkx		; on ladder, deny movement.
0026F1  3               .endif
0026F1  3               plchk0:
0026F1  3  A9 00        	lda #0			; report as ok
0026F3  3  60           	rts
0026F4  3               plchkx:
0026F4  3  A5 rr        	lda dispy		; x coordinate.
0026F6  3  29 07        	and #7			; position straddling blocks.
0026F8  3  F0 E8        	beq lrchkx		; on platform, deny movement.
0026FA  3  4C F1 26     	jmp plchk0
0026FD  3               
0026FD  3               ;--------------------------------------------------------------
0026FD  3               ; Check ladder is available.
0026FD  3               ;
0026FD  3               ; Input:
0026FD  3               ;  bufaddr = MAP + x/8 + y/8*32
0026FD  3               ;
0026FD  3               ; Output:
0026FD  3               ;  A  = 0 is ok, A <>0 is not ok
0026FD  3               ;--------------------------------------------------------------
0026FD  3               
0026FD  3               .if lflag
0026FD  3               ldchk:
0026FD  3               	ldy #0
0026FD  3               	lda (bufaddr),y 	; fetch cell.
0026FD  3               	cmp #LADDER 		; is it a ladder?
0026FD  3               	beq ldchk1
0026FD  3               	lda #1
0026FD  3               	rts  			; return with zero flag set accordingly.
0026FD  3               ldchk1:
0026FD  3               	lda #0
0026FD  3               	rts
0026FD  3               .endif
0026FD  3               
0026FD  3               ;--------------------------------------------------------------
0026FD  3               ; Get collectables.
0026FD  3               ;--------------------------------------------------------------
0026FD  3               
0026FD  3               .if cflag
0026FD  3               getcol:
0026FD  3                       lda #COLECT             ; collectable blocks.
0026FD  3                       sta z80_b
0026FD  3                       jsr tded                ; test for collectable blocks.
0026FD  3                       cmp z80_b               ; did we find one?
0026FD  3                       beq :+
0026FD  3                       rts                     ; none were found, job done.
0026FD  3               :
0026FD  3                       jsr gtblk               ; get block.
0026FD  3                       jsr evnt20              ; collected block event.
0026FD  3                       jmp getcol              ; repeat until none left.
0026FD  3               
0026FD  3               ; Get collectable block.
0026FD  3               
0026FD  3               gtblk:
0026FD  3               	ldy #0
0026FD  3               	lda (bufaddr),y
0026FD  3               	sta z80_a
0026FD  3                       lda #0
0026FD  3                       sta (bufaddr),y		; make it empty now.
0026FD  3               
0026FD  3               	lda bufaddr		; set dispx
0026FD  3               	and #31
0026FD  3               	sta dispx
0026FD  3               
0026FD  3               	lda bufaddr+1		; Set dispy
0026FD  3               	sec
0026FD  3               	sbc #>MAP
0026FD  3               	sta bufaddr+1
0026FD  3               	asl bufaddr
0026FD  3               	rol bufaddr+1
0026FD  3               	asl bufaddr
0026FD  3               	rol bufaddr+1
0026FD  3               	asl bufaddr
0026FD  3               	rol bufaddr+1
0026FD  3               	lda bufaddr+1
0026FD  3               	sta dispy
0026FD  3               
0026FD  3               	lda colpatt		; get blocknr
0026FD  3               	sta z80_e		; displacement in e.
0026FD  3               	lda #0
0026FD  3               	sta z80_d		; no high byte.
0026FD  3               	asl z80_e  		; multiply char by 8.
0026FD  3               	rol z80_d
0026FD  3               	asl z80_e
0026FD  3               	rol z80_d
0026FD  3               	asl z80_e
0026FD  3               	rol z80_d
0026FD  3               	clc
0026FD  3               	lda z80_e
0026FD  3               	adc #<chgfx 		; address of graphics.
0026FD  3               	sta tileaddr
0026FD  3               	lda z80_d
0026FD  3               	adc #>chgfx
0026FD  3               	sta tileaddr+1
0026FD  3               
0026FD  3               	jsr gprad 		; get screen address.
0026FD  3               	ldx #7			; number of pixel rows to write.
0026FD  3               gtblk0:
0026FD  3               	ldy #0
0026FD  3               	lda (tileaddr),y 	; get image byte.
0026FD  3               	ldy scrtab,x
0026FD  3               	eor (scraddr),y 	; XOR tile on screen
0026FD  3               	sta (scraddr),y 	; copy to screen.
0026FD  3               	inc tileaddr 		; next image byte.
0026FD  3               	bne :+
0026FD  3               	inc tileaddr+1
0026FD  3               :
0026FD  3               	dex	 		; repeat for 8 pixel rows.
0026FD  3               	bpl gtblk0
0026FD  3               	rts
0026FD  3               .endif
0026FD  3               
0026FD  3               ;--------------------------------------------------------------
0026FD  3               ; Touched deadly block check.
0026FD  3               ; returns with DEADLY (must be non-zero) in accumulator if true.
0026FD  3               ;
0026FD  3               ; Input:
0026FD  3               ;  IX = sprite address
0026FD  3               ;
0026FD  3               ; Output:
0026FD  3               ;  A  = 0 is ok, A=5 is not ok
0026FD  3               ;--------------------------------------------------------------
0026FD  3               
0026FD  3               tded:
0026FD  3  A0 08        	ldy #8
0026FF  3  B1 rr        	lda (z80_ix),y 		; y coordinate.
002701  3  85 rr        	sta dispy
002703  3  C8           	iny
002704  3  B1 rr        	lda (z80_ix),y 		; x coordinate.
002706  3  85 rr        	sta dispx		; coords in dispx,dispy.
002708  3  20 B8 27     	jsr tstbl		; get map address.
00270B  3  48           	pha
00270C  3  A9 1F        	lda #31			; default distance to next line down.
00270E  3  85 rr        	sta z80_e
002710  3  68           	pla
002711  3  C5 rr        	cmp z80_b		; is this the required block?
002713  3  D0 01        	bne :+
002715  3  60           	rts			; yes.
002716  3               :
002716  3  E6 rr        	inc bufaddr 		; next cell.
002718  3  D0 02        	bne :+
00271A  3  E6 rr        	inc bufaddr+1
00271C  3               :
00271C  3  A0 00        	ldy #0
00271E  3  B1 rr        	lda (bufaddr),y		; fetch type.
002720  3  C5 rr        	cmp z80_b 		; is this deadly/custom?
002722  3  D0 01        	bne :+
002724  3  60           	rts			; yes.
002725  3               :
002725  3  A5 rr        	lda dispx		; horizontal position.
002727  3  85 rr        	sta z80_c 		; store column in c register.
002729  3  29 07        	and #7			; is it straddling cells?
00272B  3  D0 03        	bne :+
00272D  3  4C 41 27     	jmp tded0		; no.
002730  3               :
002730  3  E6 rr        	inc bufaddr 		; last cell.
002732  3  D0 02        	bne :+
002734  3  E6 rr        	inc bufaddr+1
002736  3               :
002736  3  A0 00        	ldy #0
002738  3  B1 rr        	lda (bufaddr),y 	; fetch type.
00273A  3  C5 rr        	cmp z80_b		; is this the block?
00273C  3  D0 01        	bne :+
00273E  3  60           	rts			; yes.
00273F  3               :
00273F  3  C6 rr        	dec z80_e		; one less cell to next row down.
002741  3               tded0:
002741  3  18           	clc 			; point to next row.
002742  3  A5 rr        	lda bufaddr
002744  3  65 rr        	adc z80_e
002746  3  85 rr        	sta bufaddr
002748  3  90 02        	bcc :+
00274A  3  E6 rr        	inc bufaddr+1
00274C  3               :
00274C  3  A0 00        	ldy #0
00274E  3  B1 rr        	lda (bufaddr),y		; fetch left cell block.
002750  3  C5 rr        	cmp z80_b		; is this fatal?
002752  3  D0 01        	bne :+
002754  3  60           	rts			; yes.
002755  3               :
002755  3  E6 rr        	inc bufaddr 		; next cell.
002757  3  D0 02        	bne :+
002759  3  E6 rr        	inc bufaddr+1
00275B  3               :
00275B  3  A0 00        	ldy #0
00275D  3  B1 rr        	lda (bufaddr),y 	; fetch type.
00275F  3  C5 rr        	cmp z80_b		; is this fatal?
002761  3  D0 01        	bne :+
002763  3  60           	rts			; yes.
002764  3               :
002764  3  A5 rr        	lda z80_c		; horizontal position.
002766  3  29 07        	and #7			; is it straddling cells?
002768  3  D0 03        	bne :+
00276A  3  4C 7C 27     	jmp tded1 		; no.
00276D  3               :
00276D  3  E6 rr        	inc bufaddr		; last cell.
00276F  3  D0 02        	bne :+
002771  3  E6 rr        	inc bufaddr+1
002773  3               :
002773  3  A0 00        	ldy #0
002775  3  B1 rr        	lda (bufaddr),y		; fetch type.
002777  3  C5 rr        	cmp z80_b		; is this fatal?
002779  3  D0 01        	bne :+
00277B  3  60           	rts			; yes.
00277C  3               :
00277C  3               tded1:
00277C  3  A5 rr        	lda dispy		; vertical position.
00277E  3  29 07        	and #7 			; is it straddling cells?
002780  3  D0 01        	bne :+
002782  3  60           	rts			; no, job done.
002783  3               :
002783  3  18           	clc			; point to next row.
002784  3  A5 rr        	lda bufaddr
002786  3  65 rr        	adc z80_e
002788  3  85 rr        	sta bufaddr
00278A  3  90 02        	bcc :+
00278C  3  E6 rr        	inc bufaddr+1
00278E  3               :
00278E  3  A0 00        	ldy #0
002790  3  B1 rr        	lda (bufaddr),y 	; fetch left cell block.
002792  3  C5 rr        	cmp z80_b		; is this fatal?
002794  3  D0 01        	bne :+
002796  3  60           	rts			; yes.
002797  3               :
002797  3  E6 rr        	inc bufaddr		; next cell.
002799  3  D0 02        	bne :+
00279B  3  E6 rr        	inc bufaddr+1
00279D  3               :
00279D  3  A0 00        	ldy #0
00279F  3  B1 rr        	lda (bufaddr),y 	; fetch type.
0027A1  3  C5 rr        	cmp z80_b		; is this fatal?
0027A3  3  D0 01        	bne :+
0027A5  3  60           	rts			; yes.
0027A6  3               :
0027A6  3  A5 rr        	lda z80_c		; horizontal position.
0027A8  3  29 07        	and #7			; is it straddling cells?
0027AA  3  D0 01        	bne :+
0027AC  3  60           	rts			; no.
0027AD  3               :
0027AD  3  E6 rr        	inc bufaddr		; last cell.
0027AF  3  D0 02        	bne :+
0027B1  3  E6 rr        	inc bufaddr+1
0027B3  3               :
0027B3  3  A0 00        	ldy #0
0027B5  3  B1 rr        	lda (bufaddr),y		; fetch final type.
0027B7  3  60           	rts 			; return with final type in accumulator.
0027B8  3               
0027B8  3               ;---------------------------------------------------
0027B8  3               ; Fetch block type at (dispx, dispy).
0027B8  3               ;
0027B8  3               ; Output:
0027B8  3               ;  A = block type
0027B8  3               ;---------------------------------------------------
0027B8  3               
0027B8  3               tstbl:
0027B8  3  A5 rr        	lda dispy 		; fetch y coord.
0027BA  3  4A           	lsr a			; bufaddr = y/8
0027BB  3  4A           	lsr a
0027BC  3  4A           	lsr a
0027BD  3               ;	sta chary
0027BD  3               
0027BD  3  85 rr        	sta bufaddr
0027BF  3  A9 00        	lda #0
0027C1  3  85 rr        	sta bufaddr+1
0027C3  3               
0027C3  3  06 rr        	asl bufaddr  		; bufaddr = y/8 * 32
0027C5  3  26 rr        	rol bufaddr+1
0027C7  3  06 rr        	asl bufaddr
0027C9  3  26 rr        	rol bufaddr+1
0027CB  3  06 rr        	asl bufaddr
0027CD  3  26 rr        	rol bufaddr+1
0027CF  3  06 rr        	asl bufaddr
0027D1  3  26 rr        	rol bufaddr+1
0027D3  3  06 rr        	asl bufaddr
0027D5  3  26 rr        	rol bufaddr+1
0027D7  3               
0027D7  3  A5 rr        	lda dispx		; x/8
0027D9  3  4A           	lsr a
0027DA  3  4A           	lsr a
0027DB  3  4A           	lsr a
0027DC  3               ;	sta charx
0027DC  3               
0027DC  3  18           	clc			; bufaddr = MAP + x/8 + y/8*32
0027DD  3  65 rr        	adc bufaddr
0027DF  3  69 00        	adc #<MAP
0027E1  3  85 rr        	sta bufaddr
0027E3  3  A5 rr        	lda bufaddr+1
0027E5  3  69 04        	adc #>MAP
0027E7  3  85 rr        	sta bufaddr+1
0027E9  3               
0027E9  3  A0 00        	ldy #0
0027EB  3  B1 rr        	lda (bufaddr),y 	; fetch byte there.
0027ED  3  60           	rts
0027EE  3               
0027EE  3               ;-------------------------------------------------------------------
0027EE  3               ; Jump - if we can.
0027EE  3               ; Requires initial speed to be set up in accumulator prior to call.
0027EE  3               ;
0027EE  3               ; Input:
0027EE  3               ;  IX = sprite address
0027EE  3               ;-------------------------------------------------------------------
0027EE  3               
0027EE  3               jump:
0027EE  3  A0 0D        	ldy #var_jumpLo
0027F0  3  B1 rr        	lda (z80_ix),y		; jump table low.
0027F2  3  A0 0E        	ldy #var_jumpHi
0027F4  3  11 rr        	ora (z80_ix),y		; jump table high.
0027F6  3  F0 01        	beq :+
0027F8  3  60           	rts			; already in the air.
0027F9  3               :
0027F9  3  A9 36        	lda #>jtab
0027FB  3  A0 0E        	ldy #var_jumpHi
0027FD  3  91 rr        	sta (z80_ix),y		; set jump high.
0027FF  3  A9 81        	lda #<jtab		; jump table start.
002801  3  A0 0D        	ldy #var_jumpLo
002803  3  91 rr        	sta (z80_ix),y		; set jump low.
002805  3  60           	rts
002806  3               
002806  3               ; Jump table.
002806  3               ; _BEEB - jump table must reside entirely in a page otherwise grav fn breaks
002806  3               ;.align 32
002806  3               ;jtab:
002806  3               ;	.byte 248,250,252
002806  3               ;	.byte 254,254,255
002806  3               ;	.byte 255,255,0,0
002806  3               ;	.byte 0,1,1,1,2,2
002806  3               ;	.byte 4,6,8,8,8,99
002806  3               
002806  3               ;------------------------------------------------
002806  3               ; Random numbers code.
002806  3               ; Pseudo-random number generator, 8-bit.
002806  3               ;
002806  3               ; Output:
002806  3               ;  RND = random number
002806  3               ;------------------------------------------------
002806  3               
002806  3               random:
002806  3  A5 rr        	lda seed
002808  3  F0 05        	beq doEor
00280A  3  0A           	asl a
00280B  3  F0 04        	beq noEor
00280D  3  90 02        	bcc noEor
00280F  3  49 1D        doEor:	eor #$1d
002811  3  85 rr        noEor:	sta seed
002813  3  60           	rts
002814  3               
002814  3               ;	lda seed		; get last random number.
002814  3               ;	asl a
002814  3               ;	asl a
002814  3               ;	clc
002814  3               ;	adc seed
002814  3               ;	clc
002814  3               ;	adc #$45
002814  3               ;	sta seed		; store new seed.
002814  3               ;	sta varrnd		; return number in variable.
002814  3               ;	rts
002814  3               
002814  3               ;-------------------------------------------------------
002814  3               ; Joystick and keyboard reading routines.
002814  3               ;
002814  3               ; contrl = 0, Keyboard
002814  3               ;          1, JoyKeyb
002814  3               ;          2, JoyMMC
002814  3               ;
002814  3               ;      joyval=x65FUDLR (bit cleared if key pressed)
002814  3               ;             ||||||||
002814  3               ;             |||||||+> Right    KEY 0  - X
002814  3               ;             ||||||+-> Left     KEY 1  - Z
002814  3               ;             |||||+--> Down     KEY 2  - .
002814  3               ;             ||||+---> Up       KEY 3  - ;
002814  3               ;             |||+----> Fire1    KEY 4  - SPC
002814  3               ;             ||+-----> Fire2    KEY 5  - Q
002814  3               ;             |+------> Fire3    KEY 6  - P
002814  3               ;             +-------> Not used
002814  3               ;
002814  3               ;                       Option1  KEY 7  - 1
002814  3               ;                       Option2  KEY 8  - 2
002814  3               ;                       Option3  KEY 9  - 3
002814  3               ;                       Option4  KEY 10 - 4
002814  3               ;-------------------------------------------------------
002814  3               
002814  3               joykey:
002814  3  A5 rr        	lda contrl 		; control flag.
002816  3  C9 01        	cmp #1
002818  3  F0 1A        	beq joy1 		; scan joystick1
00281A  3  C9 02        	cmp #2
00281C  3  F0 1C        	beq joy2 		; scan joystick2
00281E  3               
00281E  3               ; Scan keyboard
00281E  3               
00281E  3  A9 00        	lda #0		 	; zero reading.
002820  3  85 rr        	sta z80_e
002822  3               
002822  3  A0 06        	ldy #6	 		; address of last key.
002824  3               joyke0:
002824  3  B9 82 36     	lda keys,y 		; get key from table.
002827  3  20 58 37     	jsr ktest		; being pressed?
00282A  3  26 rr        	rol z80_e 		; rotate into reading.
00282C  3               
00282C  3  88           	dey		 	; next key.
00282D  3  10 F5        	bpl joyke0 		; repeat for all keys.
00282F  3               joyret:
00282F  3  A5 rr        	lda z80_e
002831  3  85 rr        	sta joyval
002833  3  60           	rts
002834  3               
002834  3               ; Scan joystick 1
002834  3               
002834  3               joy1:
002834  3  20 E2 37     	jsr joy1scan
002837  3  4C 2F 28     	jmp joyret 		; store the value.
00283A  3               
00283A  3               ; Scan joystick 2
00283A  3               
00283A  3               joy2:
00283A  3  20 2E 38     	jsr joy2scan
00283D  3  4C 2F 28     	jmp joyret 		; store the value.
002840  3               
002840  3               ;---------------------------------------------------------------
002840  3               ; Display message.
002840  3               ;
002840  3               ; Input:
002840  3               ;  A = message number
002840  3               ;---------------------------------------------------------------
002840  3               
002840  3               dmsg:
002840  3  AA           	tax
002841  3  A9 07        	lda #<msgdat		; pointer to messages.
002843  3  85 rr        	sta z80_l
002845  3  A9 32        	lda #>msgdat
002847  3  85 rr        	sta z80_h
002849  3  20 77 29     	jsr getwrd		; get message number.
00284C  3               dmsg3:
00284C  3  20 64 29     	jsr preprt		; pre-printing stuff.
00284F  3  20 5B 23     	jsr checkx		; make sure we"re in a printable range.
002852  3  A5 rr        	lda prtmod		; print mode.
002854  3  D0 47        	bne bmsg1		; no, double-height text.
002856  3               dmsg0:
002856  3  A5 rr        	lda z80_h		; store string pointer.
002858  3  48           	pha
002859  3  A5 rr        	lda z80_l
00285B  3  48           	pha
00285C  3               
00285C  3  A0 00        	ldy #0
00285E  3  B1 rr        	lda (z80_hl),y		; fetch byte to display.
002860  3  29 7F        	and #127		; remove any end marker.
002862  3  C9 0D        	cmp #ASCII_NEWLINE
002864  3  F0 24        	beq dmsg1
002866  3  20 7A 39     	jsr pchar		; display character.
002869  3  20 3F 29     	jsr nexpos 		; display position.
00286C  3  D0 03        	bne dmsg2		; not on a new line.
00286E  3  20 56 29     	jsr nexlin		; next line down.
002871  3               dmsg2:
002871  3  68           	pla			; retrieve string pointer
002872  3  85 rr        	sta z80_l
002874  3  68           	pla
002875  3  85 rr        	sta z80_h
002877  3               
002877  3  A0 00        	ldy #0
002879  3  B1 rr        	lda (z80_hl),y		; fetch last character.
00287B  3  0A           	asl a  			; was it the end?
00287C  3  90 03        	bcc :+
00287E  3  4C AE 23     	jmp dscor2		; yes, job done.
002881  3               :
002881  3  E6 rr        	inc z80_l		; next character to display.
002883  3  D0 02        	bne :+
002885  3  E6 rr        	inc z80_h
002887  3               :
002887  3  4C 56 28     	jmp dmsg0
00288A  3               dmsg1:
00288A  3  E6 rr        	inc dispy
00288C  3  A5 rr        	lda dispy
00288E  3  C9 18        	cmp #24
002890  3  90 04        	bcc dmsg4
002892  3  A9 00        	lda #0
002894  3  85 rr        	sta dispy
002896  3               dmsg4:
002896  3  A9 00        	lda #0
002898  3  85 rr        	sta dispx
00289A  3  4C 71 28     	jmp dmsg2
00289D  3               
00289D  3               
00289D  3               ;----------------------------------------------------------
00289D  3               ; Display message in big text.
00289D  3               ;
00289D  3               ; Input:
00289D  3               ;  HL = string pointer
00289D  3               ;----------------------------------------------------------
00289D  3               
00289D  3               bmsg1:
00289D  3  A0 00        	ldy #0
00289F  3  B1 rr        	lda (z80_hl),y 		; get character to display.
0028A1  3  29 7F        	and #127		; only want 7 bits.
0028A3  3  C9 0D        	cmp #ASCII_NEWLINE
0028A5  3  F0 13        	beq bmsg2
0028A7  3  20 CF 28     	jsr bchar 		; display big char.
0028AA  3               bmsg3:
0028AA  3  A0 00        	ldy #0
0028AC  3  B1 rr        	lda (z80_hl),y 		; look at last character.
0028AE  3  48           	pha
0028AF  3  E6 rr        	inc z80_l 		; next character in list.
0028B1  3  D0 02        	bne :+
0028B3  3  E6 rr        	inc z80_h
0028B5  3               :
0028B5  3  68           	pla
0028B6  3  0A           	asl a  			; was terminator flag set?
0028B7  3  90 E4        	bcc bmsg1		; no, keep going.
0028B9  3               
0028B9  3  60           	rts
0028BA  3               bmsg2:
0028BA  3  A9 00        	lda #0
0028BC  3  85 rr        	sta dispx
0028BE  3  E6 rr        	inc dispy
0028C0  3  E6 rr        	inc dispy
0028C2  3  A5 rr        	lda dispy
0028C4  3  C9 17        	cmp #23
0028C6  3  90 E2        	bcc bmsg3
0028C8  3  A9 00        	lda #0
0028CA  3  85 rr        	sta dispy
0028CC  3  4C AA 28     	jmp bmsg3
0028CF  3               
0028CF  3               ;----------------------------------------------------------
0028CF  3               ; Big character display.
0028CF  3               ;
0028CF  3               ; Input:
0028CF  3               ;  A = character
0028CF  3               ;----------------------------------------------------------
0028CF  3               
0028CF  3               bchar:
0028CF  3  85 rr        	sta z80_e		; save char in lb
0028D1  3  A9 00        	lda #0
0028D3  3  85 rr        	sta z80_d		; reset hb
0028D5  3               
0028D5  3  06 rr        	asl z80_e 		; multiply char by 8.
0028D7  3  26 rr        	rol z80_d
0028D9  3  06 rr        	asl z80_e
0028DB  3  26 rr        	rol z80_d
0028DD  3  06 rr        	asl z80_e
0028DF  3  26 rr        	rol z80_d		; de = a*8
0028E1  3               
0028E1  3  18           	clc			; de = #<(FONT-256) + a*8
0028E2  3  A5 rr        	lda z80_e
0028E4  3  69 81        	adc #<(FONT-256) 		; address of font.
0028E6  3  85 rr        	sta z80_e
0028E8  3  A5 rr        	lda z80_d
0028EA  3  69 32        	adc #>(FONT-256)
0028EC  3  85 rr        	sta z80_d
0028EE  3               
0028EE  3  20 0A 25     	jsr gaadd		; set colour attribute
0028F1  3  AD 8D 36     	lda fontcol
0028F4  3  A0 00        	ldy #0
0028F6  3  91 rr        	sta (bufaddr),y
0028F8  3               
0028F8  3  20 A0 24     	jsr gprad 		; get screen address.
0028FB  3               
0028FB  3  A2 00        	ldx #0			; height of character in font.
0028FD  3               bchar0:
0028FD  3  A0 00        	ldy #0
0028FF  3  B1 rr        	lda (z80_de),y 		; get a bit of the font.
002901  3               
002901  3               .if iflag
002901  3               	eor #$ff
002901  3               .endif
002901  3               
002901  3  91 rr        	sta (scraddr),y
002903  3  48           	pha
002904  3  20 61 39     	jsr nline 		; next line down.
002907  3  68           	pla
002908  3  91 rr        	sta (scraddr),y
00290A  3  20 61 39     	jsr nline 		; next line down.
00290D  3               
00290D  3  18           	clc
00290E  3  E6 rr        	inc z80_e 		; next line of font.
002910  3  D0 02        	bne :+
002912  3  E6 rr        	inc z80_d
002914  3               :
002914  3  E8           	inx
002915  3  E0 08        	cpx #8
002917  3  D0 E4        	bne bchar0
002919  3               
002919  3  20 3F 29     	jsr nexpos		; display position.
00291C  3  D0 05        	bne bchar2 		; not on a new line.
00291E  3               bchar3:
00291E  3  E6 rr        	inc dispy
002920  3  20 56 29     	jsr nexlin 		; next line check.
002923  3               bchar2:
002923  3  4C AE 23     	jmp dscor2		; tidy up line and column variables.
002926  3               
002926  3               
002926  3               ;-------------------------------------------------
002926  3               ; Display a character.
002926  3               ;
002926  3               ; Input:
002926  3               ;  A = character
002926  3               ;-------------------------------------------------
002926  3               
002926  3               achar:
002926  3  85 rr        	sta z80_b 		; copy to b.
002928  3  20 64 29     	jsr preprt 		; get ready to print.
00292B  3  A5 rr        	lda z80_b		; character in accumulator.
00292D  3  A6 rr        	ldx prtmod 		; print mode.
00292F  3  F0 03        	beq :+
002931  3  4C CF 28     	jmp bchar 		; no, double-height text.
002934  3               :
002934  3  20 7A 39     	jsr pchar 		; display character.
002937  3  20 3F 29     	jsr nexpos 		; display position.
00293A  3  F0 E2        	beq bchar3		; next line down.
00293C  3  4C 23 29     	jmp bchar2 		; tidy up.
00293F  3               
00293F  3               
00293F  3               ;-------------------------------------------------
00293F  3               ; Get next print column position.
00293F  3               ;-------------------------------------------------
00293F  3               
00293F  3               nexpos:
00293F  3  E6 rr        	inc dispx		; move along one position.
002941  3  A5 rr        	lda dispx 		; get coordinate.
002943  3  C9 16        	cmp #22
002945  3  D0 0E        	bne :+
002947  3  A9 00        	lda #0
002949  3  85 rr        	sta dispx
00294B  3  A5 rr        	lda prtmod
00294D  3  F0 06        	beq :+
00294F  3  20 56 29     	jsr nexlin
002952  3  4C 56 29     	jmp nexlin
002955  3               :
002955  3  60           	rts
002956  3               
002956  3               ;-------------------------------------------------
002956  3               ; Get next print line position.
002956  3               ;-------------------------------------------------
002956  3               
002956  3               nexlin:
002956  3  E6 rr        	inc dispy 		; newline.
002958  3  A5 rr        	lda dispy		; vertical position.
00295A  3  C9 16        	cmp #22			; past screen edge?
00295C  3  B0 01        	bcs :+
00295E  3  60           	rts			; no, still okay.
00295F  3               :
00295F  3  A9 00        	lda #0			; restart at top.
002961  3  85 rr        	sta dispy
002963  3  60           	rts
002964  3               
002964  3               ;--------------------------------------------------------
002964  3               ; Pre-print preliminaries.
002964  3               ;--------------------------------------------------------
002964  3               
002964  3               preprt:
002964  3  A9 81        	lda #<(FONT-256)		; font pointer.
002966  3  8D 59 23     	sta grbase		; set up graphics base.
002969  3  A9 32        	lda #>(FONT-256)
00296B  3  8D 5A 23     	sta grbase+1
00296E  3               prescr:
00296E  3  A5 rr        	lda charx 		; display coordinates.
002970  3  85 rr        	sta dispx		; set up general coordinates.
002972  3  A5 rr        	lda chary
002974  3  85 rr        	sta dispy
002976  3  60           	rts
002977  3               
002977  3               ;--------------------------------------------------------------
002977  3               ; Get messagenr x in hl
002977  3               ;
002977  3               ; Input:
002977  3               ;  HL = pointer to message list
002977  3               ;  X  = message number.
002977  3               ;--------------------------------------------------------------
002977  3               
002977  3               getwrd:
002977  3  E0 00        	cpx #0
002979  3  D0 01        	bne:+ 			; first word in list?
00297B  3  60           	rts 			; yep, don't search.
00297C  3               :
00297C  3  A0 00        	ldy #0
00297E  3               getwd0:
00297E  3  B1 rr        	lda (z80_hl),y
002980  3  48           	pha
002981  3  E6 rr        	inc z80_l
002983  3  D0 02        	bne :+
002985  3  E6 rr        	inc z80_h
002987  3               :
002987  3  68           	pla
002988  3  C9 80        	cmp #128		; found end?
00298A  3  30 F2        	bmi getwd0		; no, carry on.
00298C  3  CA           	dex			; until we have right number.
00298D  3  D0 EF        	bne getwd0
00298F  3  60           	rts
002990  3               
002990  3               ;-----------------------------------------------------------
002990  3               ; Bubble sort.
002990  3               ;-----------------------------------------------------------
002990  3               
002990  3               bsort:
002990  3  A9 0B        	lda #NUMSPR - 1		; sprites to swap.
002992  3  85 rr        	sta qscnt
002994  3               
002994  3  A9 07        	lda #<sprtab 		; sprite table.
002996  3  85 rr        	sta z80_x
002998  3  A9 30        	lda #>sprtab
00299A  3  85 rr        	sta z80_i
00299C  3               bsort0:
00299C  3  A0 00        	ldy #0
00299E  3  B1 rr        	lda (z80_ix),y 		; first sprite type.
0029A0  3  C9 FF        	cmp #255 		; is it switched off?
0029A2  3  F0 30        	beq swemp		; yes, may need to switch another in here.
0029A4  3               
0029A4  3  A0 11        	ldy #TABSIZ
0029A6  3  B1 rr        	lda (z80_ix),y 		; check next slot exists.
0029A8  3  C9 FF        	cmp #255 		; is it enabled?
0029AA  3  F0 0A        	beq bsort2 		; no, nothing to swap.
0029AC  3               
0029AC  3  A0 14        	ldy #TABSIZ+3
0029AE  3  B1 rr        	lda (z80_ix),y 		; fetch next sprite's coordinate.
0029B0  3  A0 03        	ldy #3
0029B2  3  D1 rr        	cmp (z80_ix),y 		; compare with this x coordinate.
0029B4  3  90 10        	bcc bsort1		; next sprite is higher - may need to switch.
0029B6  3               bsort2:
0029B6  3  18           	clc
0029B7  3  A5 rr        	lda z80_x
0029B9  3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
0029BB  3  85 rr        	sta z80_x
0029BD  3  90 02        	bcc :+
0029BF  3  E6 rr        	inc z80_i
0029C1  3               :
0029C1  3  C6 rr        	dec qscnt
0029C3  3  D0 D7        	bne bsort0		; repeat for remaining sprites.
0029C5  3  60           	rts
0029C6  3               
0029C6  3               bsort1:
0029C6  3  A0 11        	ldy #TABSIZ
0029C8  3  B1 rr        	lda (z80_ix),y		; sprite on/off flag.
0029CA  3  C9 FF        	cmp #255		; is it enabled?
0029CC  3  F0 E8        	beq bsort2		; no, nothing to swap.
0029CE  3  20 E2 29     	jsr swspr		; swap positions.
0029D1  3  4C B6 29     	jmp bsort2
0029D4  3               swemp:
0029D4  3  A0 11        	ldy #TABSIZ
0029D6  3  B1 rr        	lda (z80_ix),y		; next table entry.
0029D8  3  C9 FF        	cmp #255		; is that one on?
0029DA  3  F0 DA        	beq bsort2		; no, nothing to swap.
0029DC  3  20 E2 29     	jsr swspr		; swap positions.
0029DF  3  4C B6 29     	jmp bsort2
0029E2  3               
0029E2  3               ; Swap sprites.
0029E2  3               
0029E2  3               swspr:
0029E2  3  A5 rr        	lda z80_x		; table address
0029E4  3  85 rr        	sta z80_e		; copy to de pair.
0029E6  3  85 rr        	sta z80_l		; copy to hl pair.
0029E8  3  A5 rr        	lda z80_i
0029EA  3  85 rr        	sta z80_h
0029EC  3  85 rr        	sta z80_d
0029EE  3               
0029EE  3  18           	clc
0029EF  3  A5 rr        	lda z80_l
0029F1  3  69 11        	adc #TABSIZ		; distance to second entry.
0029F3  3  85 rr        	sta z80_l
0029F5  3  90 02        	bcc :+
0029F7  3  E6 rr        	inc z80_h
0029F9  3               :
0029F9  3  A9 11        	lda #TABSIZ		; bytes to swap.
0029FB  3  85 rr        	sta z80_b
0029FD  3  A0 00        	ldy #0
0029FF  3               swspr0:
0029FF  3  B1 rr        	lda (z80_hl),y		; fetch second byte.
002A01  3  48           	pha
002A02  3  B1 rr        	lda (z80_de),y 		; fetch first byte.
002A04  3  91 rr        	sta (z80_hl),y 		; copy to second.
002A06  3  68           	pla
002A07  3  91 rr        	sta (z80_de),y 		; copy to first sprite entry.
002A09  3               
002A09  3  E6 rr        	inc z80_e 		; next byte.
002A0B  3  D0 02        	bne :+
002A0D  3  E6 rr        	inc z80_d
002A0F  3               :
002A0F  3  E6 rr        	inc z80_l 		; next byte.
002A11  3  D0 02        	bne :+
002A13  3  E6 rr        	inc z80_h
002A15  3               :
002A15  3  C6 rr        	dec z80_b
002A17  3  D0 E6        	bne swspr0 		; swap all bytes in table entry.
002A19  3  60           	rts
002A1A  3               
002A1A  3               ;----------------------------------------------------
002A1A  3               ; Process sprites.
002A1A  3               ;----------------------------------------------------
002A1A  3               
002A1A  3               pspr:
002A1A  3  A9 0C        	lda #NUMSPR		; sprites to process.
002A1C  3  85 rr        	sta sprptr
002A1E  3               
002A1E  3  A9 07        	lda #<sprtab 		; sprite table.
002A20  3  85 rr        	sta z80_x
002A22  3  A9 30        	lda #>sprtab
002A24  3  85 rr        	sta z80_i
002A26  3               pspr1:
002A26  3  A0 00        	ldy #0
002A28  3  B1 rr        	lda (z80_ix),y		; fetch sprite type.
002A2A  3  C9 09        	cmp #9 			; within range of sprite types?
002A2C  3  B0 03        	bcs :+
002A2E  3  20 41 2A     	jsr pspr2 		; yes, process this one.
002A31  3               :
002A31  3  18           	clc
002A32  3  A5 rr        	lda z80_x
002A34  3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
002A36  3  85 rr        	sta z80_x
002A38  3  90 02        	bcc :+
002A3A  3  E6 rr        	inc z80_i		; next sprite.
002A3C  3               :
002A3C  3  C6 rr        	dec sprptr 		; repeat for remaining sprites.
002A3E  3  D0 E6        	bne pspr1
002A40  3  60           	rts
002A41  3               
002A41  3               pspr2:
002A41  3  A5 rr        	lda z80_x 		; store original sprite pointer.
002A43  3  85 rr        	sta ogptr
002A45  3  A5 rr        	lda z80_i
002A47  3  85 rr        	sta ogptr+1
002A49  3  20 55 2A     	jsr pspr3		; do the routine.
002A4C  3               rtorg:
002A4C  3  A5 rr        	lda ogptr 		; restore original pointer to sprite.
002A4E  3  85 rr        	sta z80_x
002A50  3  A5 rr        	lda ogptr+1
002A52  3  85 rr        	sta z80_i
002A54  3               rtorg0:
002A54  3  60           	rts
002A55  3               
002A55  3               pspr3:
002A55  3  A9 8A        	lda #<evtyp0		; sprite type events list.
002A57  3  85 rr        	sta z80_l
002A59  3  A9 2A        	lda #>evtyp0
002A5B  3  85 rr        	sta z80_h
002A5D  3               pspr4:
002A5D  3  B1 rr        	lda (z80_ix),y
002A5F  3  0A           	asl a			; double accumulator.
002A60  3  18           	clc
002A61  3  65 rr        	adc z80_l
002A63  3  85 rr        	sta z80_l
002A65  3  90 02        	bcc :+
002A67  3  E6 rr        	inc z80_h
002A69  3               :
002A69  3  B1 rr        	lda (z80_hl),y
002A6B  3  85 rr        	sta z80_e 		; copy to de.
002A6D  3  48           	pha
002A6E  3               
002A6E  3  E6 rr        	inc z80_l 		; next byte of address.
002A70  3  D0 02        	bne :+
002A72  3  E6 rr        	inc z80_h
002A74  3               :
002A74  3  B1 rr        	lda (z80_hl),y 		; address high.
002A76  3  85 rr        	sta z80_d
002A78  3               
002A78  3  48           	pha	 		; swap address into hl.
002A79  3  A5 rr        	lda z80_h
002A7B  3  85 rr        	sta z80_d
002A7D  3  68           	pla
002A7E  3  85 rr        	sta z80_h
002A80  3  68           	pla
002A81  3  85 rr        	sta z80_l
002A83  3  A5 rr        	lda z80_l
002A85  3  85 rr        	sta z80_e
002A87  3               
002A87  3  6C rr rr     	jmp (z80_hl) 		; go there.
002A8A  3               
002A8A  3               ; Address of each sprite type's routine.
002A8A  3               
002A8A  3  F2 30        evtyp0:	.word evnt00
002A8C  3  F3 30        evtyp1:	.word evnt01
002A8E  3  F4 30        evtyp2:	.word evnt02
002A90  3  F5 30        evtyp3:	.word evnt03
002A92  3  F6 30        evtyp4:	.word evnt04
002A94  3  F7 30        evtyp5:	.word evnt05
002A96  3  F8 30        evtyp6:	.word evnt06
002A98  3  F9 30        evtyp7:	.word evnt07
002A9A  3  FA 30        evtyp8:	.word evnt08
002A9C  3               
002A9C  3               ;--------------------------------------------------------------
002A9C  3               ; Display sprites.
002A9C  3               ;
002A9C  3               ; Input:
002A9C  3               ;  IX = sprite table
002A9C  3               ;--------------------------------------------------------------
002A9C  3               
002A9C  3               dspr:
002A9C  3  A9 06        	lda #(NUMSPR/2)		; number of sprites to display.
002A9E  3  85 rr        	sta sprcnt
002AA0  3               
002AA0  3               dspr0:
002AA0  3  A0 00        	ldy #var_Type
002AA2  3  B1 rr        	lda (z80_ix),y 		; get sprite type.
002AA4  3  C9 FF        	cmp #255 		; is it enabled?
002AA6  3  D0 45        	bne dspr1 		; yes, it needs deleting.
002AA8  3               dspr5:
002AA8  3  A0 05        	ldy #var_newType
002AAA  3  B1 rr        	lda (z80_ix),y 		; new type.
002AAC  3  C9 FF        	cmp #255		; is it enabled?
002AAE  3  F0 03        	beq dspr2
002AB0  3  4C 3C 2B     	jmp dspr3 		; yes, it needs drawing.
002AB3  3               dspr2:
002AB3  3  A0 05        	ldy #var_newType
002AB5  3  B1 rr        	lda (z80_ix),y 		; copy new type.
002AB7  3  A0 00        	ldy #var_Type
002AB9  3  91 rr        	sta (z80_ix),y
002ABB  3  A0 06        	ldy #var_newImage
002ABD  3  B1 rr        	lda (z80_ix),y 		; copy new image number.
002ABF  3  A0 01        	ldy #var_Image
002AC1  3  91 rr        	sta (z80_ix),y
002AC3  3  A0 07        	ldy #var_newFrame
002AC5  3  B1 rr        	lda (z80_ix),y 		; copy new frame.
002AC7  3  A0 02        	ldy #var_Frame
002AC9  3  91 rr        	sta (z80_ix),y
002ACB  3  A0 08        	ldy #var_newY
002ACD  3  B1 rr        	lda (z80_ix),y 		; copy new y.
002ACF  3  A0 03        	ldy #var_Y
002AD1  3  91 rr        	sta (z80_ix),y
002AD3  3  A0 09        	ldy #var_newX
002AD5  3  B1 rr        	lda (z80_ix),y 		; copy new x.
002AD7  3  A0 04        	ldy #var_X
002AD9  3  91 rr        	sta (z80_ix),y
002ADB  3               
002ADB  3  18           	clc
002ADC  3  A5 rr        	lda z80_x
002ADE  3  69 22        	adc #(TABSIZ*2)		; distance to next odd/even entry.
002AE0  3  85 rr        	sta z80_x
002AE2  3  A5 rr        	lda z80_i
002AE4  3  69 00        	adc #0
002AE6  3  85 rr        	sta z80_i 		; next sprite.
002AE8  3  C6 rr        	dec sprcnt
002AEA  3  D0 B4        	bne dspr0		; repeat for remaining sprites.
002AEC  3  60           	rts
002AED  3               
002AED  3               dspr1:
002AED  3               	; _BEEB clipping code copied from CPC Engine
002AED  3  A0 03        	ldy #var_Y
002AEF  3  B1 rr        	lda (z80_ix), y		; old x coord
002AF1  3  C9 A1        	cmp #SpriteMaxY     	; beyond maximum?
002AF3  3  B0 B3        	bcs dspr5		; yes, don't delete it.
002AF5  3               
002AF5  3  A0 05        	ldy #var_newType
002AF7  3  B1 rr        	lda (z80_ix),y 		; type of new sprite.
002AF9  3  C9 FF        	cmp #255		; is this enabled?
002AFB  3  D0 06        	bne dspr4 		; yes, display both.
002AFD  3               
002AFD  3               dspr6:
002AFD  3  20 FC 38     	jsr sspria 		; show single sprite.
002B00  3  4C B3 2A     	jmp dspr2
002B03  3               
002B03  3               ; Displaying two sprites.  Don't bother redrawing if nothing has changed.
002B03  3               
002B03  3               dspr4:
002B03  3               	; _BEEB clipping code copied from CPC Engine
002B03  3  A0 08        	ldy #var_newY
002B05  3  B1 rr        	lda (z80_ix), y		; old x coord
002B07  3  C9 A1        	cmp #SpriteMaxY     	; beyond maximum?
002B09  3  B0 F2        	bcs dspr6		; yes, don't display it.
002B0B  3               
002B0B  3  A0 04        	ldy #var_X
002B0D  3  B1 rr        	lda (z80_ix),y		; old x.
002B0F  3  A0 09        	ldy #var_newX
002B11  3  D1 rr        	cmp (z80_ix),y 		; compare with new value.
002B13  3  D0 21        	bne dspr7 		; they differ, need to redraw.
002B15  3               
002B15  3  A0 03        	ldy #var_Y
002B17  3  B1 rr        	lda (z80_ix),y		; old y.
002B19  3  A0 08        	ldy #var_newY
002B1B  3  D1 rr        	cmp (z80_ix),y 		; compare against new value.
002B1D  3  D0 17        	bne dspr7		; they differ, need to redraw.
002B1F  3               
002B1F  3  A0 02        	ldy #var_Frame
002B21  3  B1 rr        	lda (z80_ix),y 		; old frame.
002B23  3  A0 07        	ldy #var_newFrame
002B25  3  D1 rr        	cmp (z80_ix),y 		; compare against new value.
002B27  3  D0 0D        	bne dspr7 		; they differ, need to redraw.
002B29  3               
002B29  3  A0 01        	ldy #var_Image
002B2B  3  B1 rr        	lda (z80_ix),y 		; old image.
002B2D  3  A0 06        	ldy #var_newImage
002B2F  3  D1 rr        	cmp (z80_ix),y 		; compare against new value.
002B31  3  D0 03        	bne dspr7 		; they differ, need to redraw.
002B33  3  4C B3 2A     	jmp dspr2		; everything is the same, don't redraw.
002B36  3               dspr7:
002B36  3  20 14 39     	jsr sspric 		; delete old sprite, draw new one simultaneously.
002B39  3  4C B3 2A     	jmp dspr2
002B3C  3               dspr3:
002B3C  3               	; _BEEB clipping code copied from CPC Engine
002B3C  3  A0 08        	ldy #var_newY
002B3E  3  B1 rr        	lda (z80_ix), y		; old x coord
002B40  3  C9 A1        	cmp #SpriteMaxY     	; beyond maximum?
002B42  3  90 03        	bcc :+			; no, continue
002B44  3  4C B3 2A     	jmp dspr2		; yes, don't display it.
002B47  3               :
002B47  3  20 0E 39     	jsr ssprib 		; show single sprite.
002B4A  3  4C B3 2A     	jmp dspr2
002B4D  3               
002B4D  3               ;-----------------------------------------
002B4D  3               ; Get sprite address calculations.
002B4D  3               ; gspran = new sprite, gsprad = old sprite.
002B4D  3               ;
002B4D  3               ; Input:
002B4D  3               ;  IX = sprite address
002B4D  3               ;-----------------------------------------
002B4D  3               
002B4D  3               gspran:
002B4D  3  A0 08        	ldy #var_newY
002B4F  3  B1 rr        	lda (z80_ix),y 		; new y coordinate.
002B51  3  85 rr        	sta dispy
002B53  3  A0 09        	ldy #var_newX
002B55  3  B1 rr        	lda (z80_ix),y 		; new x coordinate.
002B57  3  85 rr        	sta dispx
002B59  3  A0 06        	ldy #var_newImage
002B5B  3  B1 rr        	lda (z80_ix),y 		; new sprite image.
002B5D  3  20 30 2E     	jsr gfrm		; fetch start frame for this sprite.
002B60  3               
002B60  3  A0 00        	ldy #0
002B62  3  B1 rr        	lda (z80_hl),y 		; frame in accumulator.
002B64  3  A0 07        	ldy #var_newFrame
002B66  3  18           	clc
002B67  3  71 rr        	adc (z80_ix),y 		; new add frame number.
002B69  3  4C 88 2B     	jmp gspra0
002B6C  3               
002B6C  3               ;-----------------------------------------
002B6C  3               ; Calculate old sprite address
002B6C  3               ;
002B6C  3               ; Input:
002B6C  3               ;  IX = sprite address
002B6C  3               ;
002B6C  3               ; Output:
002B6C  3               ;  B  = right byte mask
002B6C  3               ;  C  = left byte mask
002B6C  3               ;  DE = spriteframe address
002B6C  3               ;  scraddr = screenaddress(dispx,dispy)
002B6C  3               ;-----------------------------------------
002B6C  3               
002B6C  3               gsprad:
002B6C  3  A0 03        	ldy #var_Y
002B6E  3  B1 rr        	lda (z80_ix),y		; y coordinate.
002B70  3  85 rr        	sta dispy
002B72  3  A0 04        	ldy #var_X
002B74  3  B1 rr        	lda (z80_ix),y		; x coordinate.
002B76  3  85 rr        	sta dispx
002B78  3  A0 01        	ldy #var_Image
002B7A  3  B1 rr        	lda (z80_ix),y 		; sprite image.
002B7C  3  20 30 2E     	jsr gfrm 		; fetch start frame for this sprite.
002B7F  3               
002B7F  3  A0 00        	ldy #0
002B81  3  B1 rr        	lda (z80_hl),y 		; frame in accumulator.
002B83  3  A0 02        	ldy #var_Frame
002B85  3  18           	clc
002B86  3  71 rr        	adc (z80_ix),y 		; add frame number.
002B88  3               
002B88  3               gspra0:
002B88  3               .if rflag
002B88  3               	sta z80_e		; multiply by 32.
002B88  3               	lda #0
002B88  3               	sta z80_d
002B88  3               
002B88  3               	asl z80_e
002B88  3               	rol z80_d
002B88  3               	asl z80_e
002B88  3               	rol z80_d
002B88  3               	asl z80_e
002B88  3               	rol z80_d
002B88  3               	asl z80_e
002B88  3               	rol z80_d
002B88  3               .if bflag
002B88  3               	lda z80_e		; multiply by 48
002B88  3               	sta tmp1
002B88  3               	lda z80_d
002B88  3               	sta tmp2
002B88  3               .endif
002B88  3               	asl z80_e
002B88  3               	rol z80_d
002B88  3               .if bflag
002B88  3               	clc
002B88  3               	lda z80_e
002B88  3               	adc tmp1
002B88  3               	sta z80_e
002B88  3               	lda z80_d
002B88  3               	adc tmp2
002B88  3               	sta z80_d
002B88  3               .endif
002B88  3               .else
002B88  3  4A           	lsr a	  		; multiply by 128.
002B89  3  85 rr        	sta z80_d 		; store in d.
002B8B  3  85 rr        	sta tmp1
002B8D  3  A9 00        	lda #0
002B8F  3  6A           	ror a
002B90  3  85 rr        	sta z80_e 		; got low byte.
002B92  3  85 rr        	sta tmp2
002B94  3               .if bflag
002B94  3               	lsr tmp1		; multiply by 192
002B94  3               	ror tmp2
002B94  3               	clc
002B94  3               	lda tmp2
002B94  3               	adc z80_e
002B94  3               	sta z80_e
002B94  3               	lda tmp1
002B94  3               	adc z80_d
002B94  3               	sta z80_d
002B94  3               .endif
002B94  3               .endif
002B94  3  18           	clc 			; address of play sprites.
002B95  3  A5 rr        	lda z80_e
002B97  3  69 8E        	adc #<sprgfx
002B99  3  85 rr        	sta z80_e
002B9B  3  A5 rr        	lda z80_d
002B9D  3  69 32        	adc #>sprgfx
002B9F  3  85 rr        	sta z80_d
002BA1  3               
002BA1  3  A5 rr        	lda dispx 		; y coordinate.
002BA3  3  29 06        	and #6 			; position within byte boundary.
002BA5  3  AA           	tax	 		; low byte of table displacement.
002BA6  3               .if rflag
002BA6  3               	stx sprshft
002BA6  3               .else
002BA6  3  0A           	asl a	  		; multiply by 32.
002BA7  3  0A           	asl a  			; already a multiple
002BA8  3  0A           	asl a  			; of 2, so just 4
002BA9  3               .if bflag
002BA9  3               	sta tmp1
002BA9  3               	asl a  			; shifts needed.
002BA9  3               	clc
002BA9  3               	adc tmp1
002BA9  3               .else
002BA9  3  0A           	asl a  			; shifts needed.
002BAA  3               .endif
002BAA  3  18           	clc 			; add to sprite address.
002BAB  3  65 rr        	adc z80_e
002BAD  3  85 rr        	sta z80_e
002BAF  3  90 02        	bcc :+
002BB1  3  E6 rr        	inc z80_d
002BB3  3               :
002BB3  3               .endif
002BB3  3  BD C0 2B     	lda spmask,x		 ; pointer to mask table.
002BB6  3  85 rr        	sta z80_c 		; left mask.
002BB8  3  BD C1 2B     	lda spmask+1,x
002BBB  3  85 rr        	sta z80_b 		; right mask.
002BBD  3               ; Drop into screen address routine.
002BBD  3  4C DC 38     	jmp scadd
002BC0  3               
002BC0  3  FF 00 3F C0  spmask:	.byte 255,0,63,192,15,240,3,252
002BC4  3  0F F0 03 FC  
002BC8  3               
002BC8  3               
002BC8  3               ;-----------------------------------------------------------
002BC8  3               ; Animates a sprite.
002BC8  3               ;
002BC8  3               ; Input:
002BC8  3               ;  IX = sprite address
002BC8  3               ;  HL = last sprite address
002BC8  3               ;-----------------------------------------------------------
002BC8  3               
002BC8  3               animsp:
002BC8  3  25 rr        	and frmno
002BCA  3  F0 01        	beq :+
002BCC  3  60           	rts
002BCD  3               :
002BCD  3  A0 06        	ldy #var_newImage
002BCF  3  B1 rr        	lda (z80_ix),y		; sprite image
002BD1  3  20 30 2E     	jsr gfrm		; get frame data.
002BD4  3               
002BD4  3  E6 rr        	inc z80_l		; point to frames.
002BD6  3  D0 02        	bne :+
002BD8  3  E6 rr        	inc z80_h
002BDA  3               :
002BDA  3  A0 07        	ldy #var_newFrame
002BDC  3  B1 rr        	lda (z80_ix),y		; sprite frame.
002BDE  3  18           	clc
002BDF  3  69 01        	adc #1			; next one along.
002BE1  3  A0 00        	ldy #0
002BE3  3  D1 rr        	cmp (z80_hl),y		; reached the last frame?
002BE5  3  90 02        	bcc anims0		; no, not yet.
002BE7  3  A9 00        	lda #0			; start at first frame.
002BE9  3               anims0:
002BE9  3  A0 07        	ldy #var_newFrame
002BEB  3  91 rr        	sta (z80_ix),y		; new frame.
002BED  3  60           	rts
002BEE  3               
002BEE  3               ;--------------------------------------------------------------
002BEE  3               ; Animate back
002BEE  3               ;
002BEE  3               ; Input:
002BEE  3               ;  IX = sprite address
002BEE  3               ;  HL = last sprite address
002BEE  3               ;--------------------------------------------------------------
002BEE  3               
002BEE  3               animbk:
002BEE  3  25 rr        	and frmno
002BF0  3  F0 01        	beq :+
002BF2  3  60           	rts
002BF3  3               :
002BF3  3  A0 06        	ldy #var_newImage
002BF5  3  B1 rr        	lda (z80_ix),y		; sprite image.
002BF7  3  20 30 2E     	jsr gfrm		; get frame data.
002BFA  3               
002BFA  3  E6 rr        	inc z80_l 		; point to frames.
002BFC  3  D0 02        	bne :+
002BFE  3  E6 rr        	inc z80_h
002C00  3               :
002C00  3  A0 07        	ldy #var_newFrame
002C02  3  B1 rr        	lda (z80_ix),y 		; sprite frame.
002C04  3  F0 03        	beq :+
002C06  3  4C 0D 2C     	jmp rtanb0 		; yes, start at end.
002C09  3               :
002C09  3  A0 00        	ldy #0
002C0B  3  B1 rr        	lda (z80_hl),y 		; last sprite.
002C0D  3               rtanb0:
002C0D  3  38           	sec
002C0E  3  E9 01        	sbc #1			; next one along.
002C10  3  4C E9 2B     	jmp anims0		; set new frame.
002C13  3               
002C13  3               ;--------------------------------------------------------------
002C13  3               ; Check for collision with other sprite, strict enforcement.
002C13  3               ;
002C13  3               ; Input:
002C13  3               ;  b		= sprite to test for
002C13  3               ;  ix		= current sprite pointer
002C13  3               ;
002C13  3               ; global:	b
002C13  3               ; local:	x,y,hl,de,skptr
002C13  3               ; calls:	-
002C13  3               ;--------------------------------------------------------------
002C13  3               
002C13  3               sktyp:
002C13  3  A9 07        	lda #<sprtab				; sprite table.
002C15  3  85 rr        	sta z80_l
002C17  3  A9 30        	lda #>sprtab
002C19  3  85 rr        	sta z80_h
002C1B  3               numsp2:
002C1B  3  A9 0C        	lda #NUMSPR				; number of sprites.
002C1D  3  85 rr        	sta sktptr
002C1F  3               sktyp0:
002C1F  3  A5 rr        	lda z80_l 				; store pointer to sprite.
002C21  3  85 rr        	sta skptr
002C23  3  A5 rr        	lda z80_h
002C25  3  85 rr        	sta skptr+1
002C27  3               
002C27  3  A0 00        	ldy #0
002C29  3  B1 rr        	lda (z80_hl),y 				; get sprite type.
002C2B  3  C5 rr        	cmp z80_b				; is it the type we seek?
002C2D  3  F0 1D        	beq coltyp				; yes, we can use this one.
002C2F  3               sktyp1:
002C2F  3  18           	clc
002C30  3  A5 rr        	lda skptr				; retrieve sprite pointer.
002C32  3  69 11        	adc #TABSIZ				; size of each entry.
002C34  3  85 rr        	sta z80_l
002C36  3  A5 rr        	lda skptr+1
002C38  3  69 00        	adc #0
002C3A  3  85 rr        	sta z80_h
002C3C  3  C6 rr        	dec sktptr					; one less iteration.
002C3E  3  D0 DF        	bne sktyp0				; keep going until we find a slot.
002C40  3  A9 00        	lda #0					; default to ROM address - no sprite.
002C42  3  85 rr        	sta z80_l
002C44  3  85 rr        	sta z80_h
002C46  3  85 rr        	sta skptr				; store pointer to sprite.
002C48  3  85 rr        	sta skptr+1
002C4A  3               
002C4A  3  18           	clc					; don't return with zero flag set.
002C4B  3  60           	rts 					; didn't find one.
002C4C  3               
002C4C  3               coltyp:
002C4C  3  A0 00        	ldy #0
002C4E  3  B1 rr        	lda (z80_ix),y				; current sprite type.
002C50  3  C5 rr        	cmp z80_b				; seeking sprite of same type?
002C52  3  F0 3D        	beq colty1				; yes, need to check we're not detecting ourselves.
002C54  3               colty0:
002C54  3  A0 09        	ldy #9					; distance to x position in table.
002C56  3  B1 rr        	lda (z80_hl),y				; fetch x coordinate.
002C58  3  85 rr        	sta z80_e
002C5A  3  88           	dey
002C5B  3  B1 rr        	lda (z80_hl),y				; fetch y coordinate.
002C5D  3  85 rr        	sta z80_d
002C5F  3               
002C5F  3               ; Drop into collision detection.
002C5F  3               
002C5F  3               colc16:
002C5F  3  A0 09        	ldy #9
002C61  3  B1 rr        	lda (z80_ix),y			 	; x coord.
002C63  3  38           	sec					; subtract x.
002C64  3  E5 rr        	sbc z80_e
002C66  3  B0 05        	bcs  colc1a 				; result is positive.
002C68  3  49 FF        	eor #$ff				; make negative positive.
002C6A  3  18           	clc
002C6B  3  69 01        	adc #1
002C6D  3               colc1a:
002C6D  3  C9 10        	cmp #16 				; within x range?
002C6F  3  B0 BE        	bcs sktyp1				; no - they"ve missed.
002C71  3  85 rr        	sta z80_c				; store difference.
002C73  3               
002C73  3  A0 08        	ldy #8
002C75  3  B1 rr        	lda (z80_ix),y				; y coord.
002C77  3  38           	sec
002C78  3  E5 rr        	sbc z80_d				; subtract y.
002C7A  3  B0 05        	bcs colc1b				; result is positive.
002C7C  3  49 FF        	eor #$ff				; make negative positive.
002C7E  3  18           	clc
002C7F  3  69 01        	adc #1
002C81  3               colc1b:
002C81  3  C9 10        	cmp #16					; within y range?
002C83  3  B0 AA        	bcs sktyp1 				; no - they've missed.
002C85  3  18           	clc					; add x difference.
002C86  3  65 rr        	adc z80_c
002C88  3  C9 1A        	cmp #26					; only 5 corner pixels touching?
002C8A  3  B0 02        	bcs :+
002C8C  3  38           	sec
002C8D  3  60           	rts 					; carry set if there's a collision.
002C8E  3               :
002C8E  3  4C 2F 2C     	jmp sktyp1				; try next sprite in table.
002C91  3               colty1:
002C91  3  A5 rr        	lda z80_x  				; compare the two.
002C93  3  C5 rr        	cmp z80_l
002C95  3  D0 09        	bne end_col
002C97  3  A5 rr        	lda z80_i
002C99  3  C5 rr        	cmp z80_h
002C9B  3  D0 03        	bne end_col
002C9D  3  4C 2F 2C     	jmp sktyp1 				; addresses are identical.
002CA0  3               end_col:
002CA0  3  4C 54 2C     	jmp colty0
002CA3  3               
002CA3  3               ;-----------------------------------------------------------
002CA3  3               ; Display number, left aligned
002CA3  3               ;
002CA3  3               ; Input:
002CA3  3               ;  a		= number
002CA3  3               ;
002CA3  3               ; global:	-
002CA3  3               ; local:	a,y,bc,hl,displ0
002CA3  3               ; calls:	num2ch,dmsg3
002CA3  3               ;-----------------------------------------------------------
002CA3  3               
002CA3  3               disply:
002CA3  3  85 rr        	sta z80_a
002CA5  3  A9 CF        	lda #<displ0				; display workspace.
002CA7  3  85 rr        	sta z80_c
002CA9  3  A9 2C        	lda #>displ0
002CAB  3  85 rr        	sta z80_b
002CAD  3  A5 rr        	lda z80_a
002CAF  3  20 01 22     	jsr num2ch				; convert accumulator to string.
002CB2  3               displ1:
002CB2  3  C6 rr        	dec z80_c				; back one character.
002CB4  3  A5 rr        	lda z80_c
002CB6  3  C9 FF        	cmp #$ff
002CB8  3  D0 02        	bne :+
002CBA  3  C6 rr        	dec z80_b
002CBC  3               :
002CBC  3  A0 00        	ldy #0
002CBE  3  B1 rr        	lda (z80_bc),y				; fetch digit.
002CC0  3  09 80        	ora #128				; insert end marker.
002CC2  3  91 rr        	sta (z80_bc),y				; new value.
002CC4  3               
002CC4  3  A9 CF        	lda #<displ0				; display space.
002CC6  3  85 rr        	sta z80_l
002CC8  3  A9 2C        	lda #>displ0
002CCA  3  85 rr        	sta z80_h
002CCC  3  4C 4C 28     	jmp dmsg3				; display the string.
002CCF  3               
002CCF  3  00 00 00 8D  displ0:	.byte 0,0,0,13+128
002CD3  3               
002CD3  3               ;----------------------------------------------------------------
002CD3  3               ; Initialise screen.
002CD3  3               ;
002CD3  3               ; global:	roomtb,scno
002CD3  3               ; local:	-
002CD3  3               ; calls:	tstcs
002CD3  3               ;----------------------------------------------------------------
002CD3  3               
002CD3  3               initsc:
002CD3  3  AD E4 30     	lda roomtb 			; whereabouts in the map are we?
002CD6  3  20 E0 2C     	jsr tstsc 			; find displacement.
002CD9  3  C9 FF        	cmp #255 			; is it valid?
002CDB  3  F0 02        	beq init_end 			; no, it's rubbish.
002CDD  3  85 rr        	sta scno			; store new room number.
002CDF  3               init_end:
002CDF  3  60           	rts
002CE0  3               
002CE0  3               ;----------------------------------------------------------------
002CE0  3               ; Test screen.
002CE0  3               ;
002CE0  3               ; global:	-
002CE0  3               ; local:	x
002CE0  3               ; calls:	-
002CE0  3               ;----------------------------------------------------------------
002CE0  3               
002CE0  3               tstsc:
002CE0  3  85 rr        	sta tmproom
002CE2  3  18           	clc
002CE3  3  69 03        	adc #MAPWID 			; add width in case we"re negative.
002CE5  3  AA           	tax 				; add displacement to map data.
002CE6  3  BD E8 30     	lda mapdat-MAPWID,x 		; find room number there.
002CE9  3  60           	rts
002CEA  3               
002CEA  3               ;--------------------------
002CEA  3               ; Screen left.
002CEA  3               ;--------------------------
002CEA  3               
002CEA  3               scrl:
002CEA  3  AD E4 30     	lda roomtb 			; present room table pointer.
002CED  3  38           	sec
002CEE  3  E9 01        	sbc #1				; room left.
002CF0  3               scrl0:
002CF0  3  20 E0 2C     	jsr tstsc			; test screen.
002CF3  3  C9 FF        	cmp #255			; is there a screen this way?
002CF5  3  D0 01        	bne :+
002CF7  3  60           	rts				; no, return to loop.
002CF8  3               :
002CF8  3  A5 rr        	lda tmproom			; restore room displacement.
002CFA  3  8D E4 30     	sta roomtb			; new room table position.
002CFD  3               scrl1:
002CFD  3  20 D3 2C     	jsr initsc 			; set new screen.
002D00  3  A9 02        	lda #2
002D02  3  85 rr        	sta restfl 			; set it.
002D04  3  60           	rts
002D05  3               scrr:
002D05  3  AD E4 30     	lda roomtb 			; room table pointer.
002D08  3  18           	clc
002D09  3  69 01        	adc #1				; room right.
002D0B  3  4C F0 2C     	jmp scrl0
002D0E  3               scru:
002D0E  3  AD E4 30     	lda roomtb 			; room table pointer.
002D11  3  38           	sec
002D12  3  E9 03        	sbc #MAPWID 			; room up.
002D14  3  4C F0 2C     	jmp scrl0
002D17  3               scrd:
002D17  3  AD E4 30     	lda roomtb 			; room table pointer.
002D1A  3  18           	clc
002D1B  3  69 03        	adc #MAPWID 			; room down.
002D1D  3  4C F0 2C     	jmp scrl0
002D20  3               
002D20  3               ;-----------------------------------------
002D20  3               ; Jump to new screen.
002D20  3               ;-----------------------------------------
002D20  3               
002D20  3               nwscr:
002D20  3  A2 00        	ldx #0				; start of map data.
002D22  3               nwscr0:
002D22  3  DD EB 30     	cmp mapdat,x
002D25  3  F0 06        	beq nwscr1			; have we found a match for screen?
002D27  3  E8           	inx 				; next room.
002D28  3  E0 50        	cpx #80				; zero room count, 80 to search.
002D2A  3  D0 F6        	bne nwscr0			; keep looking.
002D2C  3  60           	rts
002D2D  3               nwscr1:
002D2D  3  8E E4 30     	stx roomtb			; set the map position.
002D30  3  4C FD 2C     	jmp scrl1			; draw new room.
002D33  3               
002D33  3               
002D33  3               ;----------------------------------------------------------
002D33  3               ; Gravity processing.
002D33  3               ;----------------------------------------------------------
002D33  3               
002D33  3               grav:
002D33  3  A0 0D        	ldy #13
002D35  3  B1 rr        	lda (z80_ix),y			; jump pointer low.
002D37  3  85 rr        	sta z80_l
002D39  3  A0 0E        	ldy #14
002D3B  3  B1 rr        	lda (z80_ix),y			; jump pointer high.
002D3D  3  85 rr        	sta z80_h
002D3F  3  05 rr        	ora z80_l			; merge in low byte.
002D41  3  D0 01        	bne :+
002D43  3  60           	rts				; if neither is set, we're not in the air.
002D44  3               :
002D44  3  A0 00        	ldy #0
002D46  3  B1 rr        	lda (z80_hl),y			; pixels to move.
002D48  3  85 rr        	sta z80_a
002D4A  3  C9 63        	cmp #99				; reached the end?
002D4C  3  D0 0C        	bne grav0			; no, continue.
002D4E  3               grav2:
002D4E  3  C6 rr        	dec z80_l			; go back to previous value.
002D50  3  C9 FF        	cmp #$ff
002D52  3  D0 02        	bne :+
002D54  3  C6 rr        	dec z80_h
002D56  3               :
002D56  3  B1 rr        	lda (z80_hl),y			; fetch that from table.
002D58  3  85 rr        	sta z80_a
002D5A  3               grav0:
002D5A  3  E6 rr        	inc z80_l			; point to next table entry.
002D5C  3  D0 02        	bne :+
002D5E  3  E6 rr        	inc z80_h
002D60  3               :
002D60  3  A5 rr        	lda z80_l
002D62  3  A0 0D        	ldy #13
002D64  3  91 rr        	sta (z80_ix),y			; store new pointer low.
002D66  3  A5 rr        	lda z80_h
002D68  3  A0 0E        	ldy #14
002D6A  3  91 rr        	sta (z80_ix),y			; store new pointer high.
002D6C  3               grav1:
002D6C  3  A5 rr        	lda z80_a
002D6E  3  D0 01        	bne :+				; any movement required?
002D70  3  60           	rts				; no, not this time.
002D71  3               :
002D71  3  A5 rr        	lda z80_a
002D73  3  C9 80        	cmp #128			; is it up or down?
002D75  3  B0 15        	bcs gravu			; it's up.
002D77  3               gravd:
002D77  3  85 rr        	sta z80_b			; set pixels to move.
002D79  3               gravd0:
002D79  3  20 53 26     	jsr cangd			; can we go down?
002D7C  3  D0 28        	bne gravst			; can't move down, so stop.
002D7E  3  A0 08        	ldy #8
002D80  3  B1 rr        	lda (z80_ix),y			; adjust new x coord.
002D82  3  18           	clc
002D83  3  69 01        	adc #1
002D85  3  91 rr        	sta (z80_ix),y
002D87  3  C6 rr        	dec z80_b
002D89  3  D0 EE        	bne gravd0
002D8B  3  60           	rts
002D8C  3               gravu:
002D8C  3  49 FF        	eor #$ff			; flip the sign so it's positive.
002D8E  3  18           	clc
002D8F  3  69 01        	adc #1
002D91  3  85 rr        	sta z80_b			; set pixels to move.
002D93  3               gravu0:
002D93  3  20 1E 26     	jsr cangu			; can we go up?
002D96  3  D0 6E        	bne ifalls			; can't move up, go down next.
002D98  3  A0 08        	ldy #8
002D9A  3  B1 rr        	lda (z80_ix),y
002D9C  3  38           	sec
002D9D  3  E9 01        	sbc #1
002D9F  3  91 rr        	sta (z80_ix),y			; adjust new x coord.
002DA1  3  C6 rr        	dec z80_b
002DA3  3  D0 EE        	bne gravu0
002DA5  3  60           	rts
002DA6  3               gravst:
002DA6  3  A0 0D        	ldy #var_jumpLo
002DA8  3  B1 rr        	lda (z80_ix),y			; jump pointer low.
002DAA  3  85 rr        	sta z80_l
002DAC  3  A0 0E        	ldy #var_jumpHi
002DAE  3  B1 rr        	lda (z80_ix),y			; jump pointer high.
002DB0  3  85 rr        	sta z80_h
002DB2  3               
002DB2  3  A9 00        	lda #0				; null value in pointer.
002DB4  3  A0 0D        	ldy #var_jumpLo
002DB6  3  91 rr        	sta (z80_ix),y			; store new pointer low.
002DB8  3  C8           	iny
002DB9  3  91 rr        	sta (z80_ix),y			; store new pointer high.
002DBB  3               
002DBB  3  A0 00        	ldy #0
002DBD  3  B1 rr        	lda (z80_hl),y			; fetch byte from table.
002DBF  3  C9 63        	cmp #99				; is it the end marker?
002DC1  3               evftf:
002DC1  3  F0 01        	beq :+				; yes, fallen too far.
002DC3  3  60           	rts
002DC4  3               :
002DC4  3  4C 00 32     	jmp evnt15			; EVENT FELLTOOFAR
002DC7  3               
002DC7  3               ;------------------------------------------------
002DC7  3               ; Initiate fall check.
002DC7  3               ;------------------------------------------------
002DC7  3               
002DC7  3               ifall:
002DC7  3  A0 0D        	ldy #var_jumpLo
002DC9  3  B1 rr        	lda (z80_ix),y 			; jump pointer low.
002DCB  3  85 rr        	sta z80_l
002DCD  3  A0 0E        	ldy #var_jumpHi
002DCF  3  B1 rr        	lda (z80_ix),y 			; jump pointer high.
002DD1  3  85 rr        	sta z80_h			; high byte in accumulator.
002DD3  3  05 rr        	ora z80_l			; merge in low byte.
002DD5  3  F0 01        	beq :+
002DD7  3  60           	rts				; if either is set, we're already in the air.
002DD8  3               :
002DD8  3  A0 09        	ldy #9
002DDA  3  B1 rr        	lda (z80_ix),y			; y coordinate.
002DDC  3  85 rr        	sta dispx
002DDE  3  A0 08        	ldy #8
002DE0  3  B1 rr        	lda (z80_ix),y			; look x coordinate.
002DE2  3  18           	clc
002DE3  3               numsp7:
002DE3  3  69 10        	adc #SPR_HGT			; add 16 pixels.
002DE5  3  85 rr        	sta dispy			; set up test coordinates.
002DE7  3  20 B8 27     	jsr tstbl			; get map address.
002DEA  3  20 E5 26     	jsr plchk			; block, platform check.
002DED  3  F0 01        	beq :+
002DEF  3  60           	rts				; it's solid, don't fall.
002DF0  3               :
002DF0  3  E6 rr        	inc bufaddr			; look right one cell.
002DF2  3  20 E5 26     	jsr plchk			; block, platform check.
002DF5  3  F0 01        	beq :+
002DF7  3  60           	rts				; it's solid, don't fall.
002DF8  3               :
002DF8  3  A5 rr        	lda dispx			; y coordinate.
002DFA  3  29 07        	and #7				; position straddling block cells.
002DFC  3  F0 08        	beq ifalls			; no more checks needed.
002DFE  3  E6 rr        	inc bufaddr			; look to third cell.
002E00  3  20 E5 26     	jsr plchk			; block, platform check.
002E03  3  F0 01        	beq :+
002E05  3  60           	rts				; it's solid, don't fall.
002E06  3               :
002E06  3               ifalls:
002E06  3  A9 81        	lda #<jtab			; jump table start.
002E08  3  85 rr        	sta z80_l
002E0A  3  A9 36        	lda #>jtab
002E0C  3  85 rr        	sta z80_h
002E0E  3               ifal0:
002E0E  3  E6 rr        	inc z80_l			; point to next value.
002E10  3  D0 02        	bne :+
002E12  3  E6 rr        	inc z80_h
002E14  3               :
002E14  3  A0 00        	ldy #0
002E16  3  B1 rr        	lda (z80_hl),y			; fetch value.
002E18  3  F0 F4        	beq ifal0			; no, get next value.
002E1A  3  C9 63        	cmp #99				; reached end of table?
002E1C  3  D0 01        	bne :+
002E1E  3  60           	rts				; yes, don't fall.
002E1F  3               :
002E1F  3  C9 80        	cmp #128			; is it going up?
002E21  3  B0 EB        	bcs ifal0			; yes, looking for first movement down.
002E23  3               
002E23  3  A0 0D        	ldy #13
002E25  3  A5 rr        	lda z80_l
002E27  3  91 rr        	sta (z80_ix),y 			; set jump low.
002E29  3  A0 0E        	ldy #14
002E2B  3  A5 rr        	lda z80_h
002E2D  3  91 rr        	sta (z80_ix),y 			; set jump high.
002E2F  3  60           	rts
002E30  3               
002E30  3               
002E30  3               ;----------------------------------------------------
002E30  3               ; Get frame data for a particular sprite.
002E30  3               ; Input:
002E30  3               ;  a		= framenumer
002E30  3               ; Output:
002E30  3               ;  hl		= frame address
002E30  3               ;
002E30  3               ; global:	hl,frmptr
002E30  3               ; local:	-
002E30  3               ; calls:	-
002E30  3               ;----------------------------------------------------
002E30  3               
002E30  3               gfrm:
002E30  3  0A           	asl a	 		 	; multiple of 2.
002E31  3  18           	clc
002E32  3  6D 17 20     	adc frmptr 			; frames used by game.
002E35  3  85 rr        	sta z80_l
002E37  3  AD 18 20     	lda frmptr+1
002E3A  3  69 00        	adc #0
002E3C  3  85 rr        	sta z80_h 			; point to frame start.
002E3E  3  60           	rts
002E3F  3               
002E3F  3               ;----------------------------------------------------
002E3F  3               ; Find sprite list for current room.
002E3F  3               ;
002E3F  3               ; global:	hl
002E3F  3               ; local:	x,y
002E3F  3               ; calls:	-
002E3F  3               ;----------------------------------------------------
002E3F  3               
002E3F  3               sprlst:
002E3F  3  A9 55        	lda #<nmedat 			; list of enemy sprites.
002E41  3  85 rr        	sta z80_l
002E43  3  A9 33        	lda #>nmedat
002E45  3  85 rr        	sta z80_h
002E47  3  A6 rr        	ldx scno 			; screen number.
002E49  3  D0 01        	bne sprls2 			; is it the first screen?
002E4B  3  60           	rts 				; yes, don't need to search data.
002E4C  3               sprls2:
002E4C  3  A0 00        	ldy #0
002E4E  3               sprls1:
002E4E  3  B1 rr        	lda (z80_hl),y 			; fetch type of sprite.
002E50  3  C9 FF        	cmp #255			; is it an end marker?
002E52  3  F0 0E        	beq sprls0 			; yes, end of this room.
002E54  3               
002E54  3  18           	clc 				; point to next sprite in list.
002E55  3  A5 rr        	lda z80_l
002E57  3  69 04        	adc #NMESIZ
002E59  3  85 rr        	sta z80_l
002E5B  3  90 02        	bcc :+
002E5D  3  E6 rr        	inc z80_h
002E5F  3               :
002E5F  3  4C 4E 2E     	jmp sprls1 			; continue until end of room.
002E62  3               sprls0:
002E62  3  E6 rr        	inc z80_l 			; point to start of next screen.s
002E64  3  D0 02        	bne :+
002E66  3  E6 rr        	inc z80_h
002E68  3               :
002E68  3  CA           	dex
002E69  3  D0 E3        	bne sprls1 			; continue until room found.
002E6B  3  60           	rts
002E6C  3               
002E6C  3               
002E6C  3               ;----------------------------------------------------
002E6C  3               ; Clear all but a single player sprite.
002E6C  3               ;
002E6C  3               ; global:	-
002E6C  3               ; local:	x,y,ix
002E6C  3               ; calls:	-
002E6C  3               ;----------------------------------------------------
002E6C  3               
002E6C  3               nspr:
002E6C  3  A9 0C        	lda #NUMSPR			; sprite slots in table.
002E6E  3  85 rr        	sta sprcnt
002E70  3  A9 07        	lda #<sprtab 			; sprite table.
002E72  3  85 rr        	sta z80_x
002E74  3  A9 30        	lda #>sprtab
002E76  3  85 rr        	sta z80_i
002E78  3               nspr0:
002E78  3  A0 00        	ldy #0 				; fetch sprite type.
002E7A  3  B1 rr        	lda (z80_ix),y 			; is it a player?
002E7C  3  F0 1A        	beq nspr1 			; yes, keep this one.
002E7E  3               
002E7E  3  A9 FF        	lda #255
002E80  3  A0 00        	ldy #0 				; fetch sprite type.
002E82  3  91 rr        	sta (z80_ix),y 			; delete sprite.
002E84  3  A0 05        	ldy #5
002E86  3  91 rr        	sta (z80_ix),y 			; remove next type.
002E88  3               
002E88  3  18           	clc	 			; next sprite.
002E89  3  A5 rr        	lda z80_x
002E8B  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
002E8D  3  85 rr        	sta z80_x
002E8F  3  90 02        	bcc :+
002E91  3  E6 rr        	inc z80_i
002E93  3               :
002E93  3  C6 rr        	dec sprcnt	 			; one less space in the table.
002E95  3  D0 E1        	bne nspr0
002E97  3  60           	rts
002E98  3               nspr1:
002E98  3  A9 FF        	lda #255
002E9A  3  A0 00        	ldy #0
002E9C  3  91 rr        	sta (z80_ix),y 			; delete sprite.
002E9E  3               
002E9E  3  18           	clc	 			; point to next sprite.
002E9F  3  A5 rr        	lda z80_x
002EA1  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
002EA3  3  85 rr        	sta z80_x
002EA5  3  90 02        	bcc :+
002EA7  3  E6 rr        	inc z80_i
002EA9  3               :
002EA9  3  C6 rr        	dec sprcnt	 			; one less to do.
002EAB  3  D0 01        	bne nspr2
002EAD  3  60           	rts
002EAE  3               nspr2:
002EAE  3  A9 FF        	lda #255
002EB0  3  A0 00        	ldy #0
002EB2  3  91 rr        	sta (z80_ix),y 			; delete sprite.
002EB4  3  A0 05        	ldy #5
002EB6  3  91 rr        	sta (z80_ix),y 			; remove next type.
002EB8  3               
002EB8  3  18           	clc	 			; next sprite.
002EB9  3  A5 rr        	lda z80_x
002EBB  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
002EBD  3  85 rr        	sta z80_x
002EBF  3  90 02        	bcc :+
002EC1  3  E6 rr        	inc z80_i
002EC3  3               :
002EC3  3  C6 rr        	dec sprcnt	 			; one less space in table.
002EC5  3  D0 E7        	bne nspr2
002EC7  3  60           	rts
002EC8  3               
002EC8  3               ;----------------------------------------------------------
002EC8  3               ; Two initialisation routines.
002EC8  3               ; Initialise sprites - copy everything from list to table.
002EC8  3               ;
002EC8  3               ; global:	-
002EC8  3               ; local:	x,y,ix
002EC8  3               ; calls:	cpsp
002EC8  3               ;----------------------------------------------------------
002EC8  3               
002EC8  3               ispr:
002EC8  3  A9 0C        	lda #NUMSPR			; sprite slots in table.
002ECA  3  85 rr        	sta sprcnt
002ECC  3  A9 07        	lda #<sprtab			; sprite table.
002ECE  3  85 rr        	sta z80_x
002ED0  3  A9 30        	lda #>sprtab
002ED2  3  85 rr        	sta z80_i
002ED4  3               ispr2:
002ED4  3  A0 00        	ldy #0
002ED6  3  B1 rr        	lda (z80_hl),y 			; fetch byte.
002ED8  3  C9 FF        	cmp #255 			; is it an end marker?
002EDA  3  D0 01        	bne :+
002EDC  3  60           	rts 				; yes, no more to do.
002EDD  3               :
002EDD  3               ispr1:
002EDD  3  A0 00        	ldy #0
002EDF  3  B1 rr        	lda (z80_ix),y 			; fetch sprite type.
002EE1  3  C9 FF        	cmp #255 			; is it enabled yet?
002EE3  3  D0 08        	bne ispr4			; yes, try another slot.
002EE5  3               
002EE5  3  A0 05        	ldy #5
002EE7  3  B1 rr        	lda (z80_ix),y		 	; next type.
002EE9  3  C9 FF        	cmp #255 			; is it enabled yet?
002EEB  3  F0 10        	beq ispr3 			; no, process this one.
002EED  3               ispr4:
002EED  3  18           	clc 				; next sprite.
002EEE  3  A5 rr        	lda z80_x
002EF0  3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
002EF2  3  85 rr        	sta z80_x
002EF4  3  90 02        	bcc :+
002EF6  3  E6 rr        	inc z80_i
002EF8  3               :
002EF8  3  C6 rr        	dec sprcnt
002EFA  3  D0 E1        	bne ispr1 			; repeat for remaining sprites.
002EFC  3  60           	rts  				; no more room in table.
002EFD  3               ispr3:
002EFD  3  20 50 2F     	jsr cpsp			; initialise a sprite.
002F00  3  C6 rr        	dec sprcnt			; one less space in the table.
002F02  3  D0 D0        	bne ispr2
002F04  3  60           	rts
002F05  3               
002F05  3               
002F05  3               ;-----------------------------------------------------------------------
002F05  3               ; Initialise sprites - but not player, we're keeping the old one.
002F05  3               ;
002F05  3               ; global:	-
002F05  3               ; local:	x,y,ix
002F05  3               ; calls:	cpsp
002F05  3               ;-----------------------------------------------------------------------
002F05  3               
002F05  3               kspr:
002F05  3  A2 0C        	ldx #NUMSPR			; sprite slots in table.
002F07  3  A9 07        	lda #<sprtab 			; sprite table.
002F09  3  85 rr        	sta z80_x
002F0B  3  A9 30        	lda #>sprtab
002F0D  3  85 rr        	sta z80_i
002F0F  3               kspr2:
002F0F  3  A0 00        	ldy #0
002F11  3  B1 rr        	lda (z80_hl),y 			; fetch byte.
002F13  3  C9 FF        	cmp #255 			; is it an end marker?
002F15  3  D0 01        	bne :+
002F17  3  60           	rts 				; yes, no more to do.
002F18  3               :
002F18  3  C9 00        	cmp #0
002F1A  3  D0 0E        	bne kspr1 			; no, add to table as normal.
002F1C  3               
002F1C  3  18           	clc 				; next sprite.
002F1D  3  A5 rr        	lda z80_l
002F1F  3  69 04        	adc #NMESIZ		 	; distance to next odd/even entry.
002F21  3  85 rr        	sta z80_l
002F23  3  90 02        	bcc :+
002F25  3  E6 rr        	inc z80_h
002F27  3               :
002F27  3  4C 0F 2F     	jmp kspr2
002F2A  3               kspr1:
002F2A  3  A0 00        	ldy #0 				; fetch sprite type.
002F2C  3  B1 rr        	lda (z80_ix),y
002F2E  3  C9 FF        	cmp #255 			; is it enabled yet?
002F30  3  D0 08        	bne kspr4 			; yes, try another slot.
002F32  3               
002F32  3  A0 05        	ldy #5 				; next type.
002F34  3  B1 rr        	lda (z80_ix),y
002F36  3  C9 FF        	cmp #255 			; is it enabled yet?
002F38  3  F0 0F        	beq kspr3 			; no, process this one.
002F3A  3               kspr4:
002F3A  3  18           	clc 				; next sprite.
002F3B  3  A5 rr        	lda z80_x
002F3D  3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
002F3F  3  85 rr        	sta z80_x
002F41  3  90 02        	bcc :+
002F43  3  E6 rr        	inc z80_i
002F45  3               :
002F45  3  CA           	dex	 			; repeat for remaining sprites.
002F46  3  D0 E2        	bne kspr1
002F48  3  60           	rts  				; no more room in table.
002F49  3               kspr3:
002F49  3  20 50 2F     	jsr cpsp 			; copy sprite to table.
002F4C  3  CA           	dex	 			; one less space in the table.
002F4D  3  D0 C0        	bne kspr2
002F4F  3  60           	rts
002F50  3               
002F50  3               ;----------------------------------------------
002F50  3               ; Copy sprite from list to table.
002F50  3               ;
002F50  3               ; global:	hl,ix
002F50  3               ; local:	y
002F50  3               ; calls:	evnt09
002F50  3               ;----------------------------------------------
002F50  3               
002F50  3               cpsp:
002F50  3  A0 00        	ldy #0					; fetch byte from table.
002F52  3  B1 rr        	lda (z80_hl),y
002F54  3               	; y=var_Type
002F54  3  91 rr        	sta (z80_ix),y			; set up type.
002F56  3  A0 05        	ldy #var_newType
002F58  3  91 rr        	sta (z80_ix),y 			; set up type.
002F5A  3               
002F5A  3  E6 rr        	inc z80_l 				; move to next byte.
002F5C  3  D0 02        	bne :+
002F5E  3  E6 rr        	inc z80_h
002F60  3               :
002F60  3  A0 00        	ldy #0 					; fetch byte from table.
002F62  3  B1 rr        	lda (z80_hl),y
002F64  3  A0 06        	ldy #var_newImage
002F66  3  91 rr        	sta (z80_ix),y			; set up image.
002F68  3               
002F68  3  E6 rr        	inc z80_l 				; move to next byte.
002F6A  3  D0 02        	bne :+
002F6C  3  E6 rr        	inc z80_h
002F6E  3               :
002F6E  3  A0 00        	ldy #0
002F70  3  B1 rr        	lda (z80_hl),y 			; fetch byte from table.
002F72  3  A0 08        	ldy #var_newY
002F74  3  91 rr        	sta (z80_ix),y 			; set up coordinate.
002F76  3               
002F76  3  A9 C8        	lda #200 				; set initial coordinate off screen.
002F78  3  A0 03        	ldy #var_Y
002F7A  3  91 rr        	sta (z80_ix),y
002F7C  3               
002F7C  3  E6 rr        	inc z80_l 				; move to next byte.
002F7E  3  D0 02        	bne :+
002F80  3  E6 rr        	inc z80_h
002F82  3               :
002F82  3  A0 00        	ldy #0 					; fetch byte from table.
002F84  3  B1 rr        	lda (z80_hl),y
002F86  3  A0 09        	ldy #var_newX
002F88  3  91 rr        	sta (z80_ix),y 			; set up coordinate.
002F8A  3               
002F8A  3  E6 rr        	inc z80_l 				; move to next byte.
002F8C  3  D0 02        	bne :+
002F8E  3  E6 rr        	inc z80_h
002F90  3               :
002F90  3  A9 00        	lda #0					; zeroes in accumulator.
002F92  3  A0 07        	ldy #var_newFrame 		; reset frame number.
002F94  3  91 rr        	sta (z80_ix),y
002F96  3  A0 0A        	ldy #var_Direction 		; reset direction.
002F98  3  91 rr        	sta (z80_ix),y
002F9A  3  A0 0D        	ldy #var_jumpLo			; reset jump pointer low.
002F9C  3  91 rr        	sta (z80_ix),y
002F9E  3  A0 0E        	ldy #var_jumpHi	 		; reset jump pointer high.
002FA0  3  91 rr        	sta (z80_ix),y
002FA2  3               
002FA2  3  A9 FF        	lda #255 				; reset data pointer to auto-restore.
002FA4  3  A0 10        	ldy #var_dataHi
002FA6  3  91 rr        	sta (z80_ix),y
002FA8  3               evis0:
002FA8  3  A5 rr        	lda z80_i
002FAA  3  48           	pha
002FAB  3  A5 rr        	lda z80_x
002FAD  3  48           	pha
002FAE  3  A5 rr        	lda z80_h
002FB0  3  48           	pha
002FB1  3  A5 rr        	lda z80_l
002FB3  3  48           	pha
002FB4  3               
002FB4  3  20 FB 30     	jsr evnt09 				; perform event.
002FB7  3               
002FB7  3  68           	pla
002FB8  3  85 rr        	sta z80_l
002FBA  3  68           	pla
002FBB  3  85 rr        	sta z80_h
002FBD  3  68           	pla
002FBE  3  85 rr        	sta z80_x
002FC0  3  68           	pla
002FC1  3  85 rr        	sta z80_i
002FC3  3               
002FC3  3  18           	clc
002FC4  3  A5 rr        	lda z80_x 			; distance to next odd/even entry.
002FC6  3  69 11        	adc #TABSIZ		 	; next sprite.
002FC8  3  85 rr        	sta z80_x
002FCA  3  90 02        	bcc :+
002FCC  3  E6 rr        	inc z80_i
002FCE  3               :
002FCE  3  60           	rts
002FCF  3               
002FCF  3               
002FCF  3               ;-------------------------------------
002FCF  3               ; Clear the play area window.
002FCF  3               ;-------------------------------------
002FCF  3               
002FCF  3               clw:
002FCF  3  AD 0E 20     	lda wintop			; get coordinates of window.
002FD2  3  85 rr        	sta dispy			; put into dispx for calculation.
002FD4  3  AD 0F 20     	lda winlft
002FD7  3  85 rr        	sta dispx
002FD9  3               
002FD9  3  AD 10 20     	lda winhgt			; height of window.
002FDC  3  85 rr        	sta rrow			; copy to b register.
002FDE  3               clw3:
002FDE  3  AD 11 20     	lda winwid 			; width of window.
002FE1  3  85 rr        	sta rcol
002FE3  3               clw2:
002FE3  3  20 A0 24     	jsr gprad 			; get print address.
002FE6  3  A9 20        	lda #32
002FE8  3  20 7A 39     	jsr pchar
002FEB  3  E6 rr        	inc dispx			; next column.
002FED  3  C6 rr        	dec rcol			; one less to do.
002FEF  3  D0 F2        	bne clw2			; repeat for remaining columns.
002FF1  3               
002FF1  3  AD 0F 20     	lda winlft			; get left edge.
002FF4  3  85 rr        	sta dispx 			; reset x.
002FF6  3  E6 rr        	inc dispy 			; next line down.
002FF8  3               
002FF8  3  C6 rr        	dec rrow
002FFA  3  D0 E2        	bne clw3			; repeat down the screen.
002FFC  3               
002FFC  3  AD 0E 20     	lda wintop			; get coordinates of window.
002FFF  3  85 rr        	sta chary			; put into display position.
003001  3  AD 0F 20     	lda winlft
003004  3  85 rr        	sta charx
003006  3  60           	rts
003007  3               
003007  3               
003007  3               ;----------------------------------------------------------
003007  3               ; Effects code.
003007  3               ; Ticker routine is called 25 times per second.
003007  3               ;
003007  3               ; txtini = text scroller address
003007  3               ; txtscr = left text screen address
003007  3               ; txtwid = scroller width
003007  3               ; txtbit = 128
003007  3               ; X      = message nr
003007  3               ;----------------------------------------------------------
003007  3               
003007  3               .if sflag
003007  3               
003007  3               scrollpos_lb:	.byte $00,$10,$20,$30,$40,$50,$60,$70
003007  3               		.byte $80,$90,$a0,$b0,$c0,$d0,$e0,$f0
003007  3               		.byte $00,$10,$20,$30,$40,$50
003007  3               scrollpos_hb:	.byte $00,$00,$00,$00,$00,$00,$00,$00
003007  3               		.byte $00,$00,$00,$00,$00,$00,$00,$00
003007  3               		.byte $01,$01,$01,$01,$01,$01
003007  3               
003007  3               scrly:
003007  3               
003007  3               ; Set scr_l = txtscr
003007  3               
003007  3               	rts
003007  3               	.word txtscr         	; set scr_l = left screen address.
003007  3               	sta scr_l
003007  3               	sta scr_r
003007  3               	lda txtscr+1
003007  3               	sta scr_l+1
003007  3               	sta scr_r+1
003007  3               
003007  3               	stx xtmp		; save x
003007  3               
003007  3               ; Calculate scr_r = scr_l + 16*(txtwid -1)
003007  3               
003007  3               	ldx txtwid
003007  3               	dex
003007  3               	lda scrollpos_lb,x
003007  3               	clc
003007  3               	adc scr_r
003007  3               	sta scr_r		; set lb scr_r = scr_l + (txtwid - 1) * 8
003007  3               	bcc :+
003007  3               	inc scr_r+1
003007  3               :
003007  3               	clc
003007  3               	lda scrollpos_hb,x
003007  3               	adc scr_r+1
003007  3               	sta scr_r+1
003007  3               
003007  3               ; Scroll string
003007  3               
003007  3               	lda #0
003007  3               	sta line_cnt		; Set line counter
003007  3               scrly1:
003007  3               	clc
003007  3               	lda scr_r
003007  3               	adc line_cnt
003007  3               	sta scr_tmp
003007  3               	lda scr_r+1
003007  3               	sta scr_tmp+1
003007  3               
003007  3               	ldx txtwid		; set column counter
003007  3               	dex
003007  3               	ldy #0
003007  3               	clc			; Reset pixel to be shifted in
003007  3               scrly0:
003007  3               	lda (scr_tmp),y
003007  3               	rol a			; Shift screenbyte
003007  3               	sta (scr_tmp),y		; store screenbyte
003007  3               	php			; save carry
003007  3               
003007  3               	sec			; subtract 16 form screenaddress
003007  3               	lda scr_tmp
003007  3               	sbc #$10
003007  3               	sta scr_tmp
003007  3               	bcs :+
003007  3               	dec scr_tmp+1
003007  3               :
003007  3               	plp			; restore carry
003007  3               	dex			; previous column
003007  3               	bpl scrly0		; repeat for all columns
003007  3               
003007  3               	inc line_cnt		; next line
003007  3               	lda line_cnt
003007  3               	cmp #8
003007  3               	bne scrly1		; repeat for 8 lines
003007  3               
003007  3               ; Get next character in string
003007  3               
003007  3               	lda txtpos 		; get text pointer.
003007  3               	sta scr_txt
003007  3               	lda txtpos+1
003007  3               	sta scr_txt+1
003007  3               
003007  3               	ldy #0
003007  3               	lda (scr_txt),y 	; find character we're displaying.
003007  3               	and #127 		; remove end marker bit if applicable.
003007  3               	cmp #13			; is it newline?
003007  3               	bne scrly5 		; no, it's okay.
003007  3               	lda #32			; convert to a space instead.
003007  3               scrly5:
003007  3               	sta fntaddr		; calculate char address
003007  3               	lda #0
003007  3               	sta fntaddr+1
003007  3               	asl fntaddr  		; multiply char by 8.
003007  3               	rol fntaddr+1
003007  3               	asl fntaddr
003007  3               	rol fntaddr+1
003007  3               	asl fntaddr
003007  3               	rol fntaddr+1
003007  3               	lda fntaddr
003007  3               	clc
003007  3               	adc #<(FONT-256)
003007  3               	sta scrly3+1		; that's the low byte.
003007  3               	lda fntaddr+1
003007  3               	adc #>(FONT-256)
003007  3               	sta scrly3+2		; add displacement.
003007  3               
003007  3               	ldy #0
003007  3               scrly3:
003007  3               	lda $3333,y		; get image of char line.
003007  3               	and txtbit
003007  3               	beq scrly2		; don't plot pixel
003007  3               	lda (scr_r),y
003007  3               	clc
003007  3               	ora #1
003007  3               	sta (scr_r),y		; plot pixel
003007  3               scrly2:
003007  3               	iny			; next line of char.
003007  3               	cpy #8
003007  3               	bne scrly3
003007  3               
003007  3               	lsr txtbit		; bit of text to display.
003007  3               	bcs :+
003007  3               	rts
003007  3               :
003007  3               	ldy #0
003007  3               	lda (scr_txt),y 	; what was the character?
003007  3               	asl a	  		; end of message?
003007  3               	bcs scrly4
003007  3               	inc txtpos
003007  3               	bne :+
003007  3               	inc txtpos+1
003007  3               :
003007  3               	jmp scrly6 		; not yet - continue.
003007  3               scrly4:
003007  3               	lda txtini 		; start of scrolling message.
003007  3               	sta txtpos
003007  3               	lda txtini+1
003007  3               	sta txtpos+1
003007  3               scrly6:
003007  3               	lda #128
003007  3               	sta txtbit
003007  3               	ldx xtmp
003007  3               	rts
003007  3               
003007  3               tmp_byte:	.byte 0
003007  3               line_cnt:	.byte 0
003007  3               
003007  3               ;-------------------------------------------------------
003007  3               ; Entry TICKER command
003007  3               ;
003007  3               ; Entry:
003007  3               ;  z80_b = message nr
003007  3               ;  z80_c = width
003007  3               ;-------------------------------------------------------
003007  3               
003007  3               iscrly:
003007  3               	jsr prescr 		; set up display position.
003007  3               	lda #<msgdat 		; text messages.
003007  3               	sta z80_l
003007  3               	lda #>msgdat
003007  3               	sta z80_h
003007  3               	lda z80_c 		; width.
003007  3               	sec
003007  3               	sbc #1			; subtract one.
003007  3               	cmp #32 		; is it between 1 and 32?
003007  3               	bcc :+
003007  3               	lda #$60
003007  3               	jmp iscrl0		; no, disable messages.
003007  3               :
003007  3               	ldx z80_b		; message number.
003007  3               	jsr getwrd 		; find message start.
003007  3               
003007  3               	lda z80_l		; set initial text position.
003007  3               	sta txtini
003007  3               	lda z80_h
003007  3               	sta txtini+1
003007  3               
003007  3               	lda #$ad		; code for lda adrr
003007  3               iscrl0:
003007  3               	sta scrly		; enable/disable scrolling routine.
003007  3               
003007  3               	jsr prescr 		; set up display position.
003007  3               	jsr gprad 		; get print address.
003007  3               
003007  3               	lda scraddr 		; set text screen address.
003007  3               	sta txtscr
003007  3               	lda scraddr+1
003007  3               	sta txtscr+1
003007  3               
003007  3               	lda z80_c		; width.
003007  3               	sta txtwid		; set width in working storage.
003007  3               
003007  3               	lda #128 		; start with leftmost bit.
003007  3               	sta txtbit
003007  3               
003007  3               	jmp scrly4
003007  3               .endif
003007  3               
003007  3               ;------------------------------------------------------------------
003007  3               ; Dig routine, conditional assembly depending on dflag
003007  3               ;------------------------------------------------------------------
003007  3               .if dflag
003007  3               dig:
003007  3               	and #3
003007  3               	beq digr		; dig right
003007  3               	cmp #1
003007  3               	beq digl		; dig left
003007  3               	cmp #2
003007  3               	beq digd		; dig down
003007  3               
003007  3               ; Dig up.
003007  3               
003007  3               digu:				; dig up
003007  3               	ldy #8
003007  3               	lda (z80_ix),y
003007  3               	sec
003007  3               	sbc #2
003007  3               	sta dispy		; set y
003007  3               
003007  3               	iny
003007  3               	lda (z80_ix),y
003007  3               	sta dispx		; set x
003007  3               	jmp digv
003007  3               
003007  3               ; Dig down.
003007  3               
003007  3               digd:
003007  3               	ldy #9
003007  3               	lda (z80_ix),y
003007  3               	sta dispx		; set y
003007  3               
003007  3               	dey
003007  3               	clc
003007  3               	lda (z80_ix),y
003007  3               	adc #16
003007  3               	sta dispy		; set y
003007  3               	jmp digv
003007  3               
003007  3               ; Dig left.
003007  3               
003007  3               digl:
003007  3               	ldy #8
003007  3               	lda (z80_ix),y
003007  3               	sta dispy		; set y
003007  3               
003007  3               	iny
003007  3               	lda (z80_ix),y
003007  3               	sec
003007  3               	sbc #2			; x=x-2
003007  3               	sta dispx		; set x
003007  3               	jmp digh
003007  3               
003007  3               ; Dig right.
003007  3               
003007  3               digr:
003007  3               	ldy #8
003007  3               	lda (z80_ix),y
003007  3               	sta dispy		; set y
003007  3               
003007  3               	iny
003007  3               	lda (z80_ix),y
003007  3               	clc
003007  3               	adc #16
003007  3               	sta dispx		; set x+16
003007  3               	jmp digh
003007  3               
003007  3               ; Vertical digging
003007  3               
003007  3               digv:
003007  3               	jsr tstbl		; check blocktype in MAP
003007  3               	jsr fdchk		; test if FODDER
003007  3               
003007  3               	clc
003007  3               	lda dispx		; look 1 cell down
003007  3               	adc #8
003007  3               	sta dispx
003007  3               	jsr tstbl		; check blocktype in MAP
003007  3               	jsr fdchk
003007  3               	lda dispx
003007  3               	and #7
003007  3               	bne :+
003007  3               	rts
003007  3               :
003007  3               	clc
003007  3               	lda dispx		; look 1 cell down
003007  3               	adc #8
003007  3               	sta dispx
003007  3               	jsr tstbl		; check blocktype in MAP
003007  3               	jmp fdchk
003007  3               
003007  3               ; Horizontal digging
003007  3               
003007  3               digh:
003007  3               	jsr tstbl		; check blocktype in MAP
003007  3               	jsr fdchk		; test if FODDER
003007  3               
003007  3               	clc
003007  3               	lda dispy		; look 1 cell down
003007  3               	adc #8
003007  3               	sta dispy
003007  3               	jsr tstbl		; check blocktype in MAP
003007  3               	jsr fdchk
003007  3               	lda dispy
003007  3               	and #7
003007  3               	bne :+
003007  3               	rts
003007  3               :
003007  3               	clc
003007  3               	lda dispy		; look 1 cell down
003007  3               	adc #8
003007  3               	sta dispy
003007  3               	jsr tstbl		; check blocktype in MAP
003007  3               	jmp fdchk
003007  3               
003007  3               digcnt:	.byte 0
003007  3               
003007  3               .endif
003007  3               
003007  3               ;------------------------------------------------------------------
003007  3               ; Sprite table
003007  3               ;------------------------------------------------------------------
003007  3               
003007  3               
003007  3               ; ix+0  = type.
003007  3               ; ix+1  = sprite image number.
003007  3               ; ix+2  = frame.
003007  3               ; ix+3  = y coord.
003007  3               ; ix+4  = x coord.
003007  3               
003007  3               ; ix+5  = new type.
003007  3               ; ix+6  = new image number.
003007  3               ; ix+7  = new frame.
003007  3               ; ix+8  = new y coord.
003007  3               ; ix+9  = new x coord.
003007  3               
003007  3               ; ix+10 = direction.
003007  3               ; ix+11 = parameter 1.
003007  3               ; ix+12 = parameter 2.
003007  3               ; ix+13 = jump pointer low.
003007  3               ; ix+14 = jump pointer high.
003007  3               ; ix+15 = data pointer low.
003007  3               ; ix+16 = data pointer high.
003007  3               
003007  3               ; block NUMSPR * TABSIZ,255
003007  3               
003007  3  FF FF FF FF  sprtab:	.res NUMSPR*TABSIZ,255
00300B  3  FF FF FF FF  
00300F  3  FF FF FF FF  
0030D3  3  FF FF FF FF  ssprit:	.byte 255,255,255,255,255,255,255,0,192,120,0,0,0,255,255,255,255
0030D7  3  FF FF FF 00  
0030DB  3  C0 78 00 00  
0030E4  3  07           roomtb:	.byte 7                      ; start room map offset.
0030E5  3               
0030E5  3               setfgcol:
0030E5  3               setbgcol:
0030E5  3  60           	rts
0030E6  3               
0030E6  3               ; User routine.  Put your own code in here to be called with USER instruction.
0030E6  3               ; if USER has an argument it will be passed in the accumulator.
0030E6  3               
0030E6  3               user:
0030E6  3               	.include "user.inc"
0030E6  4  60           	rts
0030E7  4               
0030E7  3               
0030E7  3               ; Everything below here will be generated by the editors.
0030E7  3               
0030E7  3               
0030E7  3  60                   rts
0030E8  3               WINDOWTOP = 8
0030E8  3               WINDOWLFT = 0
0030E8  3               WINDOWHGT = 14
0030E8  3               WINDOWWID = 22 ;a
0030E8  3               MAPWID = 3
0030E8  3  FF FF FF             .byte 255,255,255
0030EB  3               mapdat:
0030EB  3  FF 00 FF             .byte 255,0,255
0030EE  3  FF FF FF             .byte 255,255,255
0030F1  3  01           stmap:  .byte 1
0030F2  3               
0030F2  3               evnt00:
0030F2  3  60                   rts
0030F3  3               evnt01:
0030F3  3  60                   rts
0030F4  3               evnt02:
0030F4  3  60                   rts
0030F5  3               evnt03:
0030F5  3  60                   rts
0030F6  3               evnt04:
0030F6  3  60                   rts
0030F7  3               evnt05:
0030F7  3  60                   rts
0030F8  3               evnt06:
0030F8  3  60                   rts
0030F9  3               evnt07:
0030F9  3  60                   rts
0030FA  3               evnt08:
0030FA  3  60                   rts
0030FB  3               evnt09:
0030FB  3  60                   rts
0030FC  3               evnt10:
0030FC  3  A0 07                ldy #7 	; KEY
0030FE  3  B9 82 36             lda keys,y
003101  3  20 58 37             jsr ktest
003104  3  90 03                bcc :+
003106  3  4C 0C 31             jmp k00033
003109  3               :
003109  3  20 03 A9             jsr $a903		; MUSICON
00310C  3  A0 08        k00033: ldy #8 	; KEY
00310E  3  B9 82 36             lda keys,y
003111  3  20 58 37             jsr ktest
003114  3  90 03                bcc :+
003116  3  4C 1C 31             jmp k00064
003119  3               :
003119  3  20 06 A9             jsr $a906		; MUSICOFF
00311C  3  A0 09        k00064: ldy #9 	; KEY
00311E  3  B9 82 36             lda keys,y
003121  3  20 58 37             jsr ktest
003124  3  90 03                bcc :+
003126  3  4C 2E 31             jmp k00101
003129  3               :
003129  3  A9 00                lda #0;		SOUND command
00312B  3  20 3D 3A             jsr playsound
00312E  3  A0 0A        k00101: ldy #10 	; KEY
003130  3  B9 82 36             lda keys,y
003133  3  20 58 37             jsr ktest
003136  3  90 03                bcc :+
003138  3  4C 40 31             jmp k00138
00313B  3               :
00313B  3  A9 01                lda #1;		SOUND command
00313D  3  20 3D 3A             jsr playsound
003140  3  A5 rr        k00138: lda joyval	; KEY
003142  3  29 20                and #32
003144  3  F0 03                beq :+
003146  3  4C 4E 31             jmp k00171
003149  3               :
003149  3  A9 02                lda #2;		SOUND command
00314B  3  20 3D 3A             jsr playsound
00314E  3  A5 rr        k00171: lda joyval	; KEY
003150  3  29 40                and #64
003152  3  F0 03                beq :+
003154  3  4C 5C 31             jmp k00203
003157  3               :
003157  3  A9 03                lda #3;		SOUND command
003159  3  20 3D 3A             jsr playsound
00315C  3  60           k00203: rts
00315D  3               evnt11:
00315D  3  60                   rts
00315E  3               evnt12:
00315E  3  A9 00                lda #0 	; PAPER
003160  3  0A                   asl a
003161  3  0A                   asl a
003162  3  0A                   asl a
003163  3  0A                   asl a
003164  3  85 rr                sta tmp
003166  3  AD 0F 90             lda RegF
003169  3  29 0F                and #%00001111
00316B  3  05 rr                ora tmp
00316D  3  8D 0F 90             sta RegF
003170  3  A9 01                lda #1 	; INK
003172  3  8D 8D 36             sta fontcol
003175  3  20 64 20             jsr cls		; CLS
003178  3  A9 00                lda #0		; AT
00317A  3  85 rr                sta chary
00317C  3  A9 00                lda #0
00317E  3  85 rr                sta charx
003180  3  A9 01                lda #1		; PRINTMODE
003182  3  85 rr                sta prtmod
003184  3  A9 00                lda #0		; PRINT
003186  3  20 40 28             jsr dmsg
003189  3  A9 00                lda #0		; PRINTMODE
00318B  3  85 rr                sta prtmod
00318D  3  A9 02                lda #2		; AT
00318F  3  85 rr                sta chary
003191  3  A9 03                lda #3
003193  3  85 rr                sta charx
003195  3  A9 01                lda #1		; PRINT
003197  3  20 40 28             jsr dmsg
00319A  3  A9 03                lda #3		; AT
00319C  3  85 rr                sta chary
00319E  3  A9 03                lda #3
0031A0  3  85 rr                sta charx
0031A2  3  A9 02                lda #2		; PRINT
0031A4  3  20 40 28             jsr dmsg
0031A7  3  A9 04                lda #4		; AT
0031A9  3  85 rr                sta chary
0031AB  3  A9 03                lda #3
0031AD  3  85 rr                sta charx
0031AF  3  A9 03                lda #3		; PRINT
0031B1  3  20 40 28             jsr dmsg
0031B4  3  A9 05                lda #5		; AT
0031B6  3  85 rr                sta chary
0031B8  3  A9 03                lda #3
0031BA  3  85 rr                sta charx
0031BC  3  A9 04                lda #4		; PRINT
0031BE  3  20 40 28             jsr dmsg
0031C1  3  A9 06                lda #6		; AT
0031C3  3  85 rr                sta chary
0031C5  3  A9 03                lda #3
0031C7  3  85 rr                sta charx
0031C9  3  A9 05                lda #5		; PRINT
0031CB  3  20 40 28             jsr dmsg
0031CE  3  A9 07                lda #7		; AT
0031D0  3  85 rr                sta chary
0031D2  3  A9 03                lda #3
0031D4  3  85 rr                sta charx
0031D6  3  A9 06                lda #6		; PRINT
0031D8  3  20 40 28             jsr dmsg
0031DB  3  60                   rts
0031DC  3               evnt13:
0031DC  3  A9 0B                lda #11		; AT
0031DE  3  85 rr                sta chary
0031E0  3  A9 05                lda #5
0031E2  3  85 rr                sta charx
0031E4  3  A9 07                lda #7		; PRINT
0031E6  3  20 40 28             jsr dmsg
0031E9  3  A9 08                lda #8		; LOAD
0031EB  3  20 C3 39             jsr loadfile
0031EE  3  20 00 A9             jsr $a900		; MUSICINIT
0031F1  3  A9 0B                lda #11		; AT
0031F3  3  85 rr                sta chary
0031F5  3  A9 05                lda #5
0031F7  3  85 rr                sta charx
0031F9  3  A9 09                lda #9		; PRINT
0031FB  3  20 40 28             jsr dmsg
0031FE  3  60                   rts
0031FF  3               evnt14:
0031FF  3  60                   rts
003200  3               evnt15:
003200  3  60                   rts
003201  3               evnt16:
003201  3  60                   rts
003202  3               evnt17:
003202  3  60                   rts
003203  3               evnt18:
003203  3  60                   rts
003204  3               evnt19:
003204  3  60                   rts
003205  3               evnt20:
003205  3  60                   rts
003206  3  60           ptcusr: rts
003207  3               data_start:
003207  3               msgdat:
003207  3  53 4F 55 4E          .byte "SOUND TES",212
00320B  3  44 20 54 45  
00320F  3  53 D4        
003211  3  31 20 2D 20          .byte "1 - START MUSI",195
003215  3  53 54 41 52  
003219  3  54 20 4D 55  
003220  3  32 20 2D 20          .byte "2 - STOP MUSI",195
003224  3  53 54 4F 50  
003228  3  20 4D 55 53  
00322E  3  33 20 2D 20          .byte "3 - SOUND ",176
003232  3  53 4F 55 4E  
003236  3  44 20 B0     
003239  3  34 20 2D 20          .byte "4 - SOUND ",177
00323D  3  53 4F 55 4E  
003241  3  44 20 B1     
003244  3  35 20 2D 20          .byte "5 - SOUND ",178
003248  3  53 4F 55 4E  
00324C  3  44 20 B2     
00324F  3  36 20 2D 20          .byte "6 - SOUND ",179
003253  3  53 4F 55 4E  
003257  3  44 20 B3     
00325A  3  4C 4F 41 44          .byte "LOADING ...",174
00325E  3  49 4E 47 20  
003262  3  2E 2E 2E AE  
003266  3  50 4C 41 59          .byte "PLAYER",177
00326A  3  45 52 B1     
00326D  3  20 20 20 20          .byte "           ",160
003271  3  20 20 20 20  
003275  3  20 20 20 A0  
003279  3               nummsg:
003279  3  0A                   .byte 10
00327A  3               chgfx:
00327A  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
00327E  3  00 00 00 00  
003282  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
003286  3  00 00 00 00  
00328A  3               bCol:
00328A  3  01                   .byte 1
00328B  3  01                   .byte 1
00328C  3               bprop:
00328C  3  00                   .byte 0
00328D  3  02                   .byte 2
00328E  3               sprgfx:
00328E  3  00 00 03 C0          .byte 0,0,3,192,15,240,29,248,59,252,55,252,111,254,111,254,111,254,111,254,55,252,59,252,29,248,15,240,3,192,0,0
003292  3  0F F0 1D F8  
003296  3  3B FC 37 FC  
0032AE  3  00 00 00 F0          .byte 0,0,0,240,3,252,7,126,14,255,13,255,155,255,155,255,155,255,155,255,13,255,14,255,7,126,3,252,0,240,0,0
0032B2  3  03 FC 07 7E  
0032B6  3  0E FF 0D FF  
0032CE  3  00 00 00 3C          .byte 0,0,0,60,0,255,129,223,195,191,195,127,230,255,230,255,230,255,230,255,195,127,195,191,129,223,0,255,0,60,0,0
0032D2  3  00 FF 81 DF  
0032D6  3  C3 BF C3 7F  
0032EE  3  00 00 00 0F          .byte 0,0,0,15,192,63,224,119,240,239,240,223,249,191,249,191,249,191,249,191,240,223,240,239,224,119,192,63,0,15,0,0
0032F2  3  C0 3F E0 77  
0032F6  3  F0 EF F0 DF  
00330E  3               frmlst:
00330E  3  00 01 01 00          .byte 0,1,1,0
003312  3               scdat:
003312  3  40 00                .word 64
003314  3  FF 01 17 FF          .byte 255,1,23,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1
003318  3  00 14 01 01  
00331C  3  FF 00 14 01  
003335  3  FF 00 14 01          .byte 255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,255,1,23
003339  3  01 FF 00 14  
00333D  3  01 01 FF 00  
003354  3               numsc:
003354  3  01                   .byte 1
003355  3               nmedat:
003355  3  01 00 C8 40          .byte 1,0,200,64,255
003359  3  FF           
00335A  3               NUMOBJ = 1
00335A  3               objdta:
00335A  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,160,32,1,160,32
00335E  3  00 00 00 00  
003362  3  00 00 00 00  
003381  3               font:
003381  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
003385  3  00 00 00 00  
003389  3  00 30 30 30          .byte 0,48,48,48,48,0,48,0
00338D  3  30 00 30 00  
003391  3  00 6C 6C 00          .byte 0,108,108,0,0,0,0,0
003395  3  00 00 00 00  
003399  3  00 6C FE 6C          .byte 0,108,254,108,108,254,108,0
00339D  3  6C FE 6C 00  
0033A1  3  00 18 7E 78          .byte 0,24,126,120,126,30,126,24
0033A5  3  7E 1E 7E 18  
0033A9  3  00 E6 EC 18          .byte 0,230,236,24,48,110,206,0
0033AD  3  30 6E CE 00  
0033B1  3  00 30 78 30          .byte 0,48,120,48,126,204,126,0
0033B5  3  7E CC 7E 00  
0033B9  3  00 18 30 00          .byte 0,24,48,0,0,0,0,0
0033BD  3  00 00 00 00  
0033C1  3  00 0C 18 18          .byte 0,12,24,24,24,24,12,0
0033C5  3  18 18 0C 00  
0033C9  3  00 60 30 30          .byte 0,96,48,48,48,48,96,0
0033CD  3  30 30 60 00  
0033D1  3  00 00 3C 18          .byte 0,0,60,24,126,24,60,0
0033D5  3  7E 18 3C 00  
0033D9  3  00 00 18 18          .byte 0,0,24,24,126,24,24,0
0033DD  3  7E 18 18 00  
0033E1  3  00 00 00 00          .byte 0,0,0,0,0,24,24,48
0033E5  3  00 18 18 30  
0033E9  3  00 00 00 00          .byte 0,0,0,0,126,0,0,0
0033ED  3  7E 00 00 00  
0033F1  3  00 00 00 00          .byte 0,0,0,0,0,56,56,0
0033F5  3  00 38 38 00  
0033F9  3  00 00 06 0C          .byte 0,0,6,12,24,48,96,0
0033FD  3  18 30 60 00  
003401  3  00 7C CE DE          .byte 0,124,206,222,246,230,124,0
003405  3  F6 E6 7C 00  
003409  3  00 38 78 18          .byte 0,56,120,24,24,24,126,0
00340D  3  18 18 7E 00  
003411  3  00 7C C6 06          .byte 0,124,198,6,124,192,254,0
003415  3  7C C0 FE 00  
003419  3  00 7C C6 1C          .byte 0,124,198,28,6,198,124,0
00341D  3  06 C6 7C 00  
003421  3  00 18 38 78          .byte 0,24,56,120,216,254,24,0
003425  3  D8 FE 18 00  
003429  3  00 FE C0 FC          .byte 0,254,192,252,6,198,124,0
00342D  3  06 C6 7C 00  
003431  3  00 7C C0 FC          .byte 0,124,192,252,198,198,124,0
003435  3  C6 C6 7C 00  
003439  3  00 FE 06 0C          .byte 0,254,6,12,24,48,48,0
00343D  3  18 30 30 00  
003441  3  00 7C C6 7C          .byte 0,124,198,124,198,198,124,0
003445  3  C6 C6 7C 00  
003449  3  00 7C C6 C6          .byte 0,124,198,198,126,6,124,0
00344D  3  7E 06 7C 00  
003451  3  00 00 00 30          .byte 0,0,0,48,0,0,48,0
003455  3  00 00 30 00  
003459  3  00 00 30 00          .byte 0,0,48,0,0,48,48,96
00345D  3  00 30 30 60  
003461  3  00 00 0C 18          .byte 0,0,12,24,48,24,12,0
003465  3  30 18 0C 00  
003469  3  00 00 00 7E          .byte 0,0,0,126,0,126,0,0
00346D  3  00 7E 00 00  
003471  3  00 00 30 18          .byte 0,0,48,24,12,24,48,0
003475  3  0C 18 30 00  
003479  3  00 7C C6 0C          .byte 0,124,198,12,24,0,24,0
00347D  3  18 00 18 00  
003481  3  00 7C DE FE          .byte 0,124,222,254,254,192,124,0
003485  3  FE C0 7C 00  
003489  3  00 7C C6 C6          .byte 0,124,198,198,254,198,198,0
00348D  3  FE C6 C6 00  
003491  3  00 FC C6 FC          .byte 0,252,198,252,198,198,252,0
003495  3  C6 C6 FC 00  
003499  3  00 7C C6 C0          .byte 0,124,198,192,192,198,124,0
00349D  3  C0 C6 7C 00  
0034A1  3  00 F8 CC C6          .byte 0,248,204,198,198,204,248,0
0034A5  3  C6 CC F8 00  
0034A9  3  00 FE C0 FC          .byte 0,254,192,252,192,192,254,0
0034AD  3  C0 C0 FE 00  
0034B1  3  00 FE C0 FC          .byte 0,254,192,252,192,192,192,0
0034B5  3  C0 C0 C0 00  
0034B9  3  00 7C C6 C0          .byte 0,124,198,192,222,198,124,0
0034BD  3  DE C6 7C 00  
0034C1  3  00 C6 C6 FE          .byte 0,198,198,254,198,198,198,0
0034C5  3  C6 C6 C6 00  
0034C9  3  00 7E 18 18          .byte 0,126,24,24,24,24,126,0
0034CD  3  18 18 7E 00  
0034D1  3  00 06 06 06          .byte 0,6,6,6,198,198,124,0
0034D5  3  C6 C6 7C 00  
0034D9  3  00 CC D8 F0          .byte 0,204,216,240,216,204,198,0
0034DD  3  D8 CC C6 00  
0034E1  3  00 C0 C0 C0          .byte 0,192,192,192,192,192,254,0
0034E5  3  C0 C0 FE 00  
0034E9  3  00 C6 EE FE          .byte 0,198,238,254,198,198,198,0
0034ED  3  C6 C6 C6 00  
0034F1  3  00 C6 E6 F6          .byte 0,198,230,246,222,206,198,0
0034F5  3  DE CE C6 00  
0034F9  3  00 7C C6 C6          .byte 0,124,198,198,198,198,124,0
0034FD  3  C6 C6 7C 00  
003501  3  00 FC C6 C6          .byte 0,252,198,198,252,192,192,0
003505  3  FC C0 C0 00  
003509  3  00 7C C6 C6          .byte 0,124,198,198,246,222,124,0
00350D  3  F6 DE 7C 00  
003511  3  00 FC C6 C6          .byte 0,252,198,198,252,204,198,0
003515  3  FC CC C6 00  
003519  3  00 7C C0 7C          .byte 0,124,192,124,6,198,124,0
00351D  3  06 C6 7C 00  
003521  3  00 FE 30 30          .byte 0,254,48,48,48,48,48,0
003525  3  30 30 30 00  
003529  3  00 C6 C6 C6          .byte 0,198,198,198,198,198,124,0
00352D  3  C6 C6 7C 00  
003531  3  00 C6 C6 C6          .byte 0,198,198,198,198,108,56,0
003535  3  C6 6C 38 00  
003539  3  00 C6 C6 C6          .byte 0,198,198,198,198,254,108,0
00353D  3  C6 FE 6C 00  
003541  3  00 C6 6C 38          .byte 0,198,108,56,56,108,198,0
003545  3  38 6C C6 00  
003549  3  00 86 CC 78          .byte 0,134,204,120,48,48,48,0
00354D  3  30 30 30 00  
003551  3  00 FE 0C 18          .byte 0,254,12,24,48,96,254,0
003555  3  30 60 FE 00  
003559  3  00 1E 18 18          .byte 0,30,24,24,24,24,30,0
00355D  3  18 18 1E 00  
003561  3  00 00 C0 60          .byte 0,0,192,96,48,24,12,0
003565  3  30 18 0C 00  
003569  3  00 F0 30 30          .byte 0,240,48,48,48,48,240,0
00356D  3  30 30 F0 00  
003571  3  00 30 78 FC          .byte 0,48,120,252,48,48,48,0
003575  3  30 30 30 00  
003579  3  00 00 00 00          .byte 0,0,0,0,0,0,0,255
00357D  3  00 00 00 FF  
003581  3  00 3C 66 F8          .byte 0,60,102,248,96,96,254,0
003585  3  60 60 FE 00  
003589  3  00 00 78 0C          .byte 0,0,120,12,124,204,124,0
00358D  3  7C CC 7C 00  
003591  3  00 60 60 7C          .byte 0,96,96,124,102,102,124,0
003595  3  66 66 7C 00  
003599  3  00 00 3C 60          .byte 0,0,60,96,96,96,60,0
00359D  3  60 60 3C 00  
0035A1  3  00 0C 0C 7C          .byte 0,12,12,124,204,204,124,0
0035A5  3  CC CC 7C 00  
0035A9  3  00 00 78 CC          .byte 0,0,120,204,248,192,124,0
0035AD  3  F8 C0 7C 00  
0035B1  3  00 1C 30 38          .byte 0,28,48,56,48,48,48,0
0035B5  3  30 30 30 00  
0035B9  3  00 00 7C CC          .byte 0,0,124,204,204,124,12,120
0035BD  3  CC 7C 0C 78  
0035C1  3  00 C0 C0 F8          .byte 0,192,192,248,204,204,204,0
0035C5  3  CC CC CC 00  
0035C9  3  00 30 00 70          .byte 0,48,0,112,48,48,120,0
0035CD  3  30 30 78 00  
0035D1  3  00 0C 00 0C          .byte 0,12,0,12,12,12,108,56
0035D5  3  0C 0C 6C 38  
0035D9  3  00 60 78 70          .byte 0,96,120,112,112,120,108,0
0035DD  3  70 78 6C 00  
0035E1  3  00 30 30 30          .byte 0,48,48,48,48,48,28,0
0035E5  3  30 30 1C 00  
0035E9  3  00 00 F8 FC          .byte 0,0,248,252,252,252,252,0
0035ED  3  FC FC FC 00  
0035F1  3  00 00 F8 CC          .byte 0,0,248,204,204,204,204,0
0035F5  3  CC CC CC 00  
0035F9  3  00 00 78 CC          .byte 0,0,120,204,204,204,120,0
0035FD  3  CC CC 78 00  
003601  3  00 00 F8 CC          .byte 0,0,248,204,204,248,192,192
003605  3  CC F8 C0 C0  
003609  3  00 00 7C CC          .byte 0,0,124,204,204,124,12,14
00360D  3  CC 7C 0C 0E  
003611  3  00 00 3C 60          .byte 0,0,60,96,96,96,96,0
003615  3  60 60 60 00  
003619  3  00 00 78 C0          .byte 0,0,120,192,120,12,248,0
00361D  3  78 0C F8 00  
003621  3  00 30 78 30          .byte 0,48,120,48,48,48,28,0
003625  3  30 30 1C 00  
003629  3  00 00 CC CC          .byte 0,0,204,204,204,204,120,0
00362D  3  CC CC 78 00  
003631  3  00 00 CC CC          .byte 0,0,204,204,120,120,48,0
003635  3  78 78 30 00  
003639  3  00 00 CC FC          .byte 0,0,204,252,252,252,120,0
00363D  3  FC FC 78 00  
003641  3  00 00 CC 78          .byte 0,0,204,120,48,120,204,0
003645  3  30 78 CC 00  
003649  3  00 00 CC CC          .byte 0,0,204,204,204,124,12,120
00364D  3  CC 7C 0C 78  
003651  3  00 00 FC 18          .byte 0,0,252,24,48,96,252,0
003655  3  30 60 FC 00  
003659  3  00 1E 18 70          .byte 0,30,24,112,24,24,30,0
00365D  3  18 18 1E 00  
003661  3  00 18 18 18          .byte 0,24,24,24,24,24,24,0
003665  3  18 18 18 00  
003669  3  00 F0 30 1C          .byte 0,240,48,28,48,48,240,0
00366D  3  30 30 F0 00  
003671  3  00 3C 78 00          .byte 0,60,120,0,0,0,0,0
003675  3  00 00 00 00  
003679  3  7C C6 BB E3          .byte 124,198,187,227,227,187,198,124
00367D  3  E3 BB C6 7C  
003681  3               jtab:
003681  3  63                   .byte 99
003682  3  65 14 51 10  keys:   .byte 101,20,81,16,48,114,2,112,0,113,1
003686  3  30 72 02 70  
00368A  3  00 71 01     
00368D  3               
00368D  2               
00368D  1               	.include "lib.inc"
00368D  2               ;----------------------------------------------------------------------
00368D  2               ; VIC20 Platform Specific functions
00368D  2               ;----------------------------------------------------------------------
00368D  2               
00368D  2               ;============================================================
00368D  2               ; PLATFORM VARIABLES
00368D  2               ;============================================================
00368D  2               ;
00368D  2               ; Memory map:
00368D  2               ;
00368D  2               ;	$0000-$01ff	 0.5kB	CPU WS
00368D  2               ;	$0200-$03ff	 0.5kB	VIDEO RAM
00368D  2               ;	$0400-$0fff	 3,0kB	RAM
00368D  2               ;	$1000-$1fff	 4,0kB	CHAR RAM
00368D  2               ;	$2000-$7fff	24,0kB	RAM
00368D  2               ;	$8000-$8fff	 4,0kB	CHAR ROM
00368D  2               ;	$9000-$93ff	 1,0kB	VIC VIA's
00368D  2               ;	$9600-$97ff	 1,0kB	COLOUR RAM
00368D  2               ;	$9800-$9fff	 2,0kB	I/O
00368D  2               ;	$a000-$bfff	 8,0kB	RAM
00368D  2               ;	$c000-$dfff	 8,0kB	BASIC ROM
00368D  2               ;	$e000-$ffff	 8,0kB	KERNAL ROM
00368D  2               ;
00368D  2               ; Keyboard matrix:
00368D  2               ;                          	  $9121
00368D  2               ;          $9120	b7  b6  b5  b4  b3  b2  b1  b0
00368D  2               ; 	127-0111 1111 	F7  Hom  -   0   8   6   4   2
00368D  2               ;               ASCII   ??  ??  45  48  56  54  52  50
00368D  2               ;                 VIC   07  06  05  04  03  02  01  00
00368D  2               ;
00368D  2               ; 	191-1011 1111 	F5       @   O   U   T   E   Q
00368D  2               ;               ASCII   ??  ??  64  79  85  84  69  81
00368D  2               ;                 VIC   17  16  15  14  13  12  11  10
00368D  2               ;
00368D  2               ; 	223-1101 1111 	F3   =   :   K   H   F   S  Com
00368D  2               ;               ASCII   ??  61  58  75  72  70  83  ??
00368D  2               ;                 VIC   27  26  25  24  23  22  21  20
00368D  2               ;
00368D  2               ; 	239-1110 1111 	F1  RSh  .   M   B   C   Z  Spc
00368D  2               ;               ASCII   ??  ??  46  77  66  67  90  32
00368D  2               ;                 VIC   37  36  35  34  33  32  31  30
00368D  2               ;
00368D  2               ; 	247-1111 0111	Cur  /   ,   N   V   X  LSh Run
00368D  2               ;               ASCII   ??  47  44  78  86  88  ??  ??
00368D  2               ;                 VIC   47  46  45  44  43  42  41  40
00368D  2               ;
00368D  2               ; 	251-1111 1011	Cur  ;   L   J   G   D   A  Ctr
00368D  2               ;               ASCII   ??  59  76  74  71  68  65  ??
00368D  2               ;                 VIC   57  56  55  54  53  52  51  50
00368D  2               ;
00368D  2               ; 	253-1111 1101	Ret  *   P   I   Y   R   W
00368D  2               ;               ASCII   13  42  80  73  89  82  87
00368D  2               ;                 VIC   67  66  65  64  63  62  61  60
00368D  2               ;
00368D  2               ; 	254-1111 1110	Del Pnd  +   9   7   5   3   1
00368D  2               ;               ASCII   08  ??  43  57  55  53  51  49
00368D  2               ;                 VIC   77  76  75  74  73  72  71  70
00368D  2               ;
00368D  2               ;	 P =$65,O=$14,A=$51,Q=$10
00368D  2               ;	SPC=$30,N=$44,M=$34
00368D  2               ;	 1 =$70,2=$00,3=$71,4=$01
00368D  2               ;
00368D  2               ; Joysticks:
00368D  2               ;
00368D  2               ;               b7    b6    b5    b4    b3    b2    b1    b0
00368D  2               ;	$9111	-     -     Fire  Left  Down  Up    -     -
00368D  2               ;	$9120	Right -     -     -     -     -     -     -
00368D  2               ;
00368D  2               ;	$9122	DDRB = Data Direction Register port $9120
00368D  2               ;               0 = input, 1 = output
00368D  2               ;		Bit7 should be 0 to read joystick $9120
00368D  2               ;
00368D  2               ; Video registers:
00368D  2               ;
00368D  2               ;	$9000	horizontal centering
00368D  2               ;		bits 0-6 horizontal centering
00368D  2               ;		bit  7 sets interlace scan
00368D  2               ;	$9001	vertical centering
00368D  2               ;	$9002	set # of columns
00368D  2               ;		bits 0-6 set # of columns
00368D  2               ;		bit 7 is part of video matrix address
00368D  2               ;	$9003	set # of rows
00368D  2               ;		bit 0 sets 8x8 or 16x8 chars
00368D  2               ;		bits 1-6 set # of rows
00368D  2               ;	$9005	start of character memory
00368D  2               ;		bits 0-3 start of character memory (default = 0)
00368D  2               ;		bits 4-7 is rest of video address (default= F)
00368D  2               ;		BITS 3,2,1,0 CM startinq address
00368D  2               ;			     HEX   DEC
00368D  2               ;		0000   ROM   8000  32768
00368D  2               ;		0001	     8400  33792
00368D  2               ;		0010	     8800  34816
00368D  2               ;		0011	     8C00  35840
00368D  2               ;		1000   RAM   0000  0000
00368D  2               ;		1001  xxxx
00368D  2               ;		1010  xxxx   unavail.
00368D  2               ;		1011  xxxx
00368D  2               ;		1100	     1000  4096
00368D  2               ;		1101	     1400  5120
00368D  2               ;		1110	     1800  6144
00368D  2               ;		1111	     1C00  7168
00368D  2               ;
00368D  2               ; Sound registers:
00368D  2               ;
00368D  2               ;	$900a	Frequency for oscillator 1 (low)
00368D  2               ;		(on: 128-255)
00368D  2               ;	$900b	Frequency for oscillator 2 (medium)
00368D  2               ;		(on: 128-255)
00368D  2               ;	$900c	Frequency for oscillator 3 (high)
00368D  2               ;		(on: 128-255)
00368D  2               ;	$900d	Frequency of noise source
00368D  2               ;	$900e	bit 0-3 sets volume of all sound
00368D  2               ;		bits 4-7 are auxiliary color information
00368D  2               ;	$900f	Screen and border color register
00368D  2               ;		bits 4-7 select background color
00368D  2               ;		bits 0-2 select border color
00368D  2               ;		bit 3 selects inverted or normal mode
00368D  2               ;
00368D  2               ; I/O:
00368D  2               ;	VIA1 -VIA2
00368D  2               ;-----------------------------------------------------------
00368D  2               ;	$9110,$9120 	Port B output register
00368D  2               ;	$9111,$9121 	Port A output register
00368D  2               ;			(PA0) Bit 0=Serial CLK IN
00368D  2               ;			(PA1) Bit 1=Serial DATA IN
00368D  2               ;			(PA2) Bit 2=Joy 0
00368D  2               ;			(PA3) Bit 3=Joy 1
00368D  2               ;			(PA4) Bit 4=Joy 2
00368D  2               ;			(PA5) Bit 5 = Lightpen/Fire button
00368D  2               ;			(PA6) Bit 6=Cassette switch sense
00368D  2               ;			(PA7) Bit 7=Serial ATN out
00368D  2               ;	$9112,$9122	Data direction register B
00368D  2               ;	$9113,$9123	Data direction register A
00368D  2               ;	$9114,$9124	Timer 1 low byte
00368D  2               ;	$9115,$9125	Timer 1 high byte & counter
00368D  2               ;	$9116,$9126	Timer 1 low byte
00368D  2               ;	$9117,$9127	Timer 1 high byte
00368D  2               ;	$9118,$9128	Timer 2 low byte
00368D  2               ;	$9119,$9129	Timer 2 high byte
00368D  2               ;	$911A,$912A	Shift register
00368D  2               ;	$911B,$912B	Auxiliary control register
00368D  2               ;	$911C,$912C	Peripheral control register
00368D  2               ;			(CA1, CA2, CB1, CB2)
00368D  2               ;			CA1 = restore key (Bit 0)
00368D  2               ;			CA2 = cassette motor control (Bits 1-3)
00368D  2               ;			CB1 = interrupt signal for received
00368D  2               ;			RS-232 data (Bit 4)
00368D  2               ;			CB2=transmitted RS-232 data (Bits 5-7)
00368D  2               ;	$911D,$912D	Interrupt flag register
00368D  2               ;	$911E,$912E	Interrupt enable register
00368D  2               ;	$911F,$912F	Port A (Sense cassette switch)
00368D  2               
00368D  2               ; VIC constants
00368D  2               
00368D  2               	ScreenSize	= ScrWidth * ScrHeight * 8	; Screen size bytes
00368D  2               	ScreenRowBytes	= ScrWidth * 16			; bytes/line
00368D  2               	SpriteMaxY	= 161				; maxlines - 16 + 1
00368D  2               
00368D  2               ; VIC variables:
00368D  2               
00368D  2  00           	fontcol:	.byte 0		; Frontcolour text
00368E  2  00           	mode:		.byte 0		; 0=MPAGD, 1=MiniPaint
00368F  2               .if modelflag				; Set crtflag to identify machine, NTSC or PAL
00368F  2               	crtflag:	.byte 1		; PAL
00368F  2               .else
00368F  2  00           	crtflag:	.byte 0		; NTSC
003690  2               .endif
003690  2               
003690  2               ; Addresses
003690  2               
003690  2               	ScreenAddr	= $0200		; VIDEO RAM
003690  2               	MapAddr		= $0400		; RAM
003690  2               	CharAddress	= $1000		; CHAR RAM
003690  2               	Reg0		= $9000		; Horizontal centering
003690  2               	Reg1		= $9001		; Vertical centering
003690  2               	Reg2		= $9002		; Set # of columns
003690  2               	Reg3		= $9003		; Set # of rows
003690  2               	Reg4		= $9004		; Vsync signal
003690  2               	Reg5		= $9005		; Start of character memory
003690  2               	RegA		= $900a		; Colour and auxcolour register
003690  2               	RegB		= $900b		; Colour and auxcolour register
003690  2               	RegC		= $900c		; Colour and auxcolour register
003690  2               	RegD		= $900d		; Colour and auxcolour register
003690  2               	RegE		= $900e		; Colour and auxcolour register
003690  2               	RegF		= $900f		; Screen and border color register
003690  2               
003690  2               	JoyAddr1	= $9111		; Joystick address 1
003690  2               	Timer11_Low  	= $9114		; Timer 1 low byte
003690  2               	Timer11_High 	= $9115		; Timer 1 high byte
003690  2               	Timer12_Low  	= $9118		; Timer 2 low byte
003690  2               	Timer12_High 	= $9119		; Timer 2 high byte
003690  2               	AUX1		= $911b		; Auxiliary control register
003690  2               	IFR1		= $911d		; Interrupt Flag Register
003690  2               	IER1		= $911e		; Interrupt Enable Register
003690  2               
003690  2               	KeyColAddr	= $9120		; Keyboard column (write)
003690  2               	JoyAddr2	= $9120		; Joystick address 2
003690  2               	KeyRowAddr	= $9121		; Keyboard row (read)
003690  2               	DDRB		= $9122		; Bit7 must be 0 for joystick read
003690  2               	; Timer21_Low  	= $9124		; Timer 1 low byte
003690  2               	; Timer21_High 	= $9125		; Timer 1 high byte
003690  2               	; AUX2		= $912b		; Auxiliary control register
003690  2               	; IFR2		= $912d		; Interrupt Flag Register
003690  2               	; IER2		= $912e		; Interrupt Enable Register
003690  2               
003690  2               	ColorAttr	= $9600		; Color attributes
003690  2               	HiRAM		= $a000		; Hi RAM 8kB
003690  2               
003690  2               ;----------------------------------------------------------------------
003690  2               ; VIC20 video hardware fns
003690  2               ;----------------------------------------------------------------------
003690  2               
003690  2               init:
003690  2  A9 00        	lda #0
003692  2  8D 8F 36     	sta crtflag
003695  2  AD E4 ED     	lda $ede4
003698  2  C9 05        	cmp #5
00369A  2  F0 05        	beq Ntsc_System
00369C  2  A9 01        	lda #1
00369E  2  8D 8F 36     	sta crtflag
0036A1  2               Ntsc_System:
0036A1  2               
0036A1  2               ; Disable interrupts
0036A1  2               
0036A1  2  A9 00        	lda #$00
0036A3  2  85 FC        	sta $fc
0036A5  2  A9 A9        	lda #$a9
0036A7  2  85 FD        	sta $fd
0036A9  2               
0036A9  2  A9 00        	lda #$00
0036AB  2  85 FE        	sta $fe
0036AD  2  A9 13        	lda #$13
0036AF  2  85 FF        	sta $ff
0036B1  2               
0036B1  2  A2 09        	ldx #9
0036B3  2               outerloop_mus:
0036B3  2  A0 00        	ldy #0
0036B5  2               loop_mus:
0036B5  2  B1 FE        	lda ($fe),y
0036B7  2  91 FC        	sta ($fc),y
0036B9  2  C8           	iny
0036BA  2  D0 F9        	bne loop_mus
0036BC  2  E6 FD        	inc $fd
0036BE  2  E6 FF        	inc $ff
0036C0  2  CA           	dex
0036C1  2  D0 F0        	bne outerloop_mus
0036C3  2               
0036C3  2               
0036C3  2  A9 7F        	lda #$7f
0036C5  2  8D 1E 91     	sta IER1
0036C8  2  8D 2D 91     	sta IFR2
0036CB  2  8D 2E 91     	sta IER2
0036CE  2               
0036CE  2               ; Set audio volume and flag to 0 to check when disabling
0036CE  2               ; beep and crash
0036CE  2               
0036CE  2  A9 00        	lda #0
0036D0  2  8D 0A 90     	sta RegA
0036D3  2  8D 0B 90     	sta RegB
0036D6  2  8D 0C 90     	sta RegC
0036D9  2  8D 0D 90     	sta RegD
0036DC  2  A9 0F        	lda #$0f	; Max volume
0036DE  2  8D 0E 90     	sta RegE
0036E1  2  A9 00        	lda #$00
0036E3  2  85 rr        	sta SOUNDS_STATUS
0036E5  2               
0036E5  2               ; Init screen for NTSC
0036E5  2               ; this sets the background and border color of the screen
0036E5  2               ; in this case border black and background black
0036E5  2               
0036E5  2  A9 18        	lda #%00011000
0036E7  2  8D 0F 90     	sta RegF
0036EA  2               
0036EA  2               ; Reset fontcolor
0036EA  2  A9 00        	lda #0		; Black
0036EC  2  8D 8D 36     	sta fontcol
0036EF  2               
0036EF  2               
0036EF  2  A9 00        	lda #0		; Mode 0 = MPAGD
0036F1  2  20 35 3B     	jsr SetReg
0036F4  2               
0036F4  2               ; Init screencharacters
0036F4  2               ; Fill screen with characters from left to right, up to down
0036F4  2               
0036F4  2  A2 00        	ldx #0
0036F6  2  A0 00        	ldy #0
0036F8  2               scrinit:
0036F8  2  8A           	txa
0036F9  2  9D 00 02     	sta ScreenAddr,x
0036FC  2  98           	tya
0036FD  2  9D 00 96     	sta ColorAttr,x
003700  2  E8           	inx
003701  2  E0 F2        	cpx#242
003703  2  D0 F3        	bne scrinit
003705  2               
003705  2               ; Reset fontcolor
003705  2               
003705  2  A9 00        	lda #0			; Black
003707  2  8D 8D 36     	sta fontcol
00370A  2               
00370A  2               ; Init music
00370A  2               
00370A  2               ;	jsr initmusic
00370A  2               
00370A  2               ; Init VIA1 timer11 for timeout 1/25 sec
00370A  2               
00370A  2  A9 E0        	lda #$e0		; T1 continuous
00370C  2  8D 1B 91     	sta AUX1
00370F  2  A9 7F        	lda #$7f		; No int
003711  2  8D 1E 91     	sta IER1
003714  2  A9 00        	lda #0
003716  2  8D 1D 91     	sta IFR1		; Clear interrupt flags
003719  2  A9 20        	lda #<timervalue	; Timer 1/25 sec
00371B  2  8D 14 91     	sta Timer11_Low
00371E  2  A9 4E        	lda #>timervalue
003720  2  8D 15 91     	sta Timer11_High
003723  2               
003723  2               ; Pre-shifted byte tables if parameter 'r' given
003723  2               ; 4 tables are created which 0,2,4 ad 6 bits pre-shifted
003723  2               ; The bits are shifted to the right and overflow bits are
003723  2               ; inserted to the left. So 1 byte contains a left and right part
003723  2               
003723  2               .if rflag
003723  2               shift0 = HiRAM
003723  2               shift2 = HiRAM+256
003723  2               shift4 = HiRAM+512
003723  2               shift6 = HiRAM+768
003723  2               
003723  2               ; Pre-shifted table 0 pixels
003723  2               
003723  2               	ldx #0
003723  2               shf0:
003723  2               	txa
003723  2               	sta shift0,x
003723  2               	inx
003723  2               	bne shf0
003723  2               
003723  2               ; Pre-shifted table 2 pixels
003723  2               
003723  2               	ldx #0
003723  2               shf2:
003723  2               	ldy #2
003723  2               	txa
003723  2               shf2loop:
003723  2               	lsr a
003723  2               	bcc :+
003723  2               	ora #$80
003723  2               :
003723  2               	dey
003723  2               	bne shf2loop
003723  2               	sta shift2,x
003723  2               	inx
003723  2               	bne shf2
003723  2               
003723  2               ; Pre-shifted table 4 pixels
003723  2               
003723  2               	ldx #0
003723  2               shf4:
003723  2               	ldy #4
003723  2               	txa
003723  2               shf4loop:
003723  2               	lsr a
003723  2               	bcc :+
003723  2               	ora #$80
003723  2               :
003723  2               	dey
003723  2               	bne shf4loop
003723  2               	sta shift4,x
003723  2               	inx
003723  2               	bne shf4
003723  2               
003723  2               ; Pre-shifted table 6 pixels
003723  2               
003723  2               	ldx #0
003723  2               shf6:
003723  2               	ldy #6
003723  2               	txa
003723  2               shf6loop:
003723  2               	lsr a
003723  2               	bcc :+
003723  2               	ora #$80
003723  2               :
003723  2               	dey
003723  2               	bne shf6loop
003723  2               	sta shift6,x
003723  2               	inx
003723  2               	bne shf6
003723  2               .endif
003723  2               
003723  2  60           	rts
003724  2               
003724  2               ;========================================================
003724  2               ; KEY AND JOYSTICK ROUTINES
003724  2               ;--------------------------------------------------------
003724  2               ; Keys
003724  2               ;
003724  2               ; Out: joyval=x65FUDLR (bit cleared if key pressed)
003724  2               ;             ||||||||
003724  2               ;             |||||||+> Right    KEY 0  - X
003724  2               ;             ||||||+-> Left     KEY 1  - Z
003724  2               ;             |||||+--> Down     KEY 2  - .
003724  2               ;             ||||+---> Up       KEY 3  - ;
003724  2               ;             |||+----> Fire1    KEY 4  - SPC
003724  2               ;             ||+-----> Fire2    KEY 5  - Q
003724  2               ;             |+------> Fire3    KEY 6  - P
003724  2               ;             +-------> Not used
003724  2               ;
003724  2               ;                       Option1  KEY 7  - 1
003724  2               ;                       Option2  KEY 8  - 2
003724  2               ;                       Option3  KEY 9  - 3
003724  2               ;                       Option4  KEY 10 - 4
003724  2               ;--------------------------------------------------------
003724  2               
003724  2               ;----------------------------------------------------
003724  2               ; Interrupt service
003724  2               ;----------------------------------------------------
003724  2               
003724  2               intserv:
003724  2  EE 01 96     	inc $9601	; scroll colour char topleft
003727  2  68           	pla
003728  2  A8           	tay
003729  2  68           	pla
00372A  2  AA           	tax
00372B  2  68           	pla
00372C  2  40           	rti
00372D  2               
00372D  2               ;--------------------------------------------------------
00372D  2               ; PRSKEY
00372D  2               ;
00372D  2               ; Wait for keypress.
00372D  2               ;--------------------------------------------------------
00372D  2               
00372D  2               prskey:
00372D  2  98           	tya
00372E  2  48           	pha
00372F  2               prsloop:
00372F  2  20 46 38     	jsr vsync
003732  2  20 14 28     	jsr joykey
003735  2  09 80        	ora #$80
003737  2  C9 FF        	cmp #$ff
003739  2  D0 07        	bne :+
00373B  2  20 C7 37     	jsr readkey
00373E  2  C9 FF        	cmp #255
003740  2  F0 ED        	beq prsloop		; wait until key pressed
003742  2               :
003742  2               prsrelease:
003742  2  20 46 38     	jsr vsync
003745  2  20 14 28     	jsr joykey
003748  2  09 80        	ora #$80
00374A  2  C9 FF        	cmp #$ff
00374C  2  F0 07        	beq :+
00374E  2  20 C7 37     	jsr readkey
003751  2  C9 FF        	cmp #255
003753  2  D0 ED        	bne prsrelease		; wait until key released
003755  2               :
003755  2  68           	pla
003756  2  A8           	tay
003757  2  60           	rts
003758  2               
003758  2               ;--------------------------------------------------------
003758  2               ; KTEST
003758  2               ;
003758  2               ; Keyboard test routine with key in A.
003758  2               ; Scan key and clear carry if key pressed
003758  2               ;--------------------------------------------------------
003758  2               
003758  2               ktest:
003758  2  85 rr        	sta z80_a		; save key
00375A  2               
00375A  2  4A           	lsr a
00375B  2  4A           	lsr a
00375C  2  4A           	lsr a
00375D  2  4A           	lsr a
00375E  2  AA           	tax
00375F  2  BD 76 37     	lda colmask,x
003762  2  8D 20 91     	sta KeyColAddr		; set row
003765  2               
003765  2  A5 rr        	lda z80_a
003767  2  29 0F        	and #$0f
003769  2  AA           	tax			; get column
00376A  2               
00376A  2  AD 21 91     	lda KeyRowAddr		; read column
00376D  2  3D 7E 37     	and keymask,x		; check if key pressed
003770  2  F0 02        	beq pressed		; Skip if pressed
003772  2  38           	sec			; key not pressed
003773  2  60           	rts
003774  2               pressed:
003774  2  18           	clc			; key pressed
003775  2  60           	rts
003776  2               
003776  2  7F BF DF EF  colmask:	.byte 127,191,223,239,247,251,253,254
00377A  2  F7 FB FD FE  
00377E  2  01 02 04 08  keymask:	.byte $01,$02,$04,$08,$10,$20,$40,$80
003782  2  10 20 40 80  
003786  2               
003786  2               ;---------------------------------------------------------------
003786  2               ; KGET
003786  2               ;
003786  2               ; Read keyboard matrix if a key is pressed.
003786  2               ; Return A = high nibble=row and low nibble=col
003786  2               ;---------------------------------------------------------------
003786  2               
003786  2               kget:
003786  2  86 rr        	stx xtmp		; Save x-reg
003788  2               kget0:
003788  2  A2 00        	ldx #0			; reset row
00378A  2               kget1:
00378A  2  BD 76 37     	lda colmask,x		; Get mask
00378D  2  8D 20 91     	sta KeyColAddr		; Set row
003790  2  AD 21 91     	lda KeyRowAddr		; Read columns
003793  2  85 rr        	sta tmp			; Save colums
003795  2  C9 FF        	cmp #$ff		; Key pressed?
003797  2  D0 08        	bne kget2		; Yes, skip
003799  2  E8           	inx			; Next row
00379A  2  E0 08        	cpx #8			; All rows scanned?
00379C  2  D0 EC        	bne kget1		; No, repeat
00379E  2  4C 88 37     	jmp kget0		; No key pressed, a=$ff
0037A1  2               kget2:
0037A1  2  A0 00        	ldy #0			; Reset column
0037A3  2               kget3:
0037A3  2  46 rr        	lsr tmp			; Test bit
0037A5  2  90 04        	bcc kget4		; If clear, key pressed
0037A7  2  C8           	iny			; Next column
0037A8  2  4C A3 37     	jmp kget3		; Repeat
0037AB  2               kget4:
0037AB  2  86 rr        	stx tmp			; Get row
0037AD  2  06 rr        	asl tmp			; Make high nibble
0037AF  2  06 rr        	asl tmp
0037B1  2  06 rr        	asl tmp
0037B3  2  06 rr        	asl tmp
0037B5  2  98           	tya			; Get column
0037B6  2  18           	clc
0037B7  2  65 rr        	adc tmp			; Add row as low nibble
0037B9  2  85 rr        	sta tmp
0037BB  2               kget5:
0037BB  2  AD 21 91     	lda KeyRowAddr		; Read columns
0037BE  2  C9 FF        	cmp #$ff
0037C0  2  D0 F9        	bne kget5
0037C2  2               
0037C2  2  A5 rr        	lda tmp			; Return keycode
0037C4  2  A6 rr        	ldx xtmp		; Restore X-reg
0037C6  2  60           	rts			; Return
0037C7  2               
0037C7  2               ;-------------------------------------------------------------
0037C7  2               ; READKEY
0037C7  2               ;
0037C7  2               ; Check keyboard matrix if a key is pressed
0037C7  2               ; Return keymask in Y
0037C7  2               ;-------------------------------------------------------------
0037C7  2               
0037C7  2               readkey:
0037C7  2  A9 FF        	lda #$ff		; Keymask
0037C9  2  85 rr        	sta tmp
0037CB  2  A2 07        	ldx #7
0037CD  2               scanrow:
0037CD  2  BD 76 37     	lda colmask,x
0037D0  2  8D 20 91     	sta KeyColAddr		; set row
0037D3  2  AD 21 91     	lda KeyRowAddr		; read column
0037D6  2  25 rr        	and tmp			; Reset bit is key pressed
0037D8  2  85 rr        	sta tmp
0037DA  2  CA           	dex
0037DB  2  10 F0        	bpl scanrow
0037DD  2  A5 rr        	lda tmp
0037DF  2  A8           	tay
0037E0  2  60           	rts
0037E1  2               
0037E1  2               ;-------------------------------------------------------------
0037E1  2               ; JOY1SCAN
0037E1  2               ;
0037E1  2               ; Initializes joystick
0037E1  2               ;-------------------------------------------------------------
0037E1  2               
0037E1  2               joyinit:
0037E1  2  60           	rts
0037E2  2               
0037E2  2               ;-------------------------------------------------------------
0037E2  2               ; JOY1SCAN
0037E2  2               ;
0037E2  2               ; Scan joystick1 and return key in z80_e
0037E2  2               ; Up, down, left, right and fire are read from the joystick
0037E2  2               ; Fire2 and fire3 are read from the keyboard
0037E2  2               ;-------------------------------------------------------------
0037E2  2               
0037E2  2               joy1scan:
0037E2  2  A9 FF        	lda #$ff
0037E4  2  85 rr        	sta z80_e
0037E6  2               
0037E6  2  AD 11 91     	lda JoyAddr1		; Read joystick input
0037E9  2  4A           	lsr a
0037EA  2  4A           	lsr a
0037EB  2               
0037EB  2  4A           	lsr a
0037EC  2  26 rr        	rol z80_e		; Up
0037EE  2  4A           	lsr a
0037EF  2  26 rr        	rol z80_e		; Down
0037F1  2  4A           	lsr a
0037F2  2  26 rr        	rol z80_e		; Left
0037F4  2               
0037F4  2  A9 7F        	lda #%01111111
0037F6  2  8D 22 91     	sta DDRB		; Bit7 = input joystick b7
0037F9  2  AD 20 91     	lda JoyAddr2
0037FC  2  0A           	asl a
0037FD  2  26 rr        	rol z80_e		; Right
0037FF  2  A9 FF        	lda #%11111111
003801  2  8D 22 91     	sta DDRB		; Reset
003804  2               
003804  2  AD 11 91     	lda JoyAddr1
003807  2  29 20        	and #%00100000
003809  2  D0 06        	bne :+
00380B  2  A5 rr        	lda z80_e
00380D  2  29 EF        	and #%11101111		; Fire
00380F  2  85 rr        	sta z80_e
003811  2               :
003811  2  AD 88 36     	lda keys+6		; Scan keys for Fire3
003814  2  20 58 37     	jsr ktest
003817  2  B0 06        	bcs :+
003819  2  A5 rr        	lda z80_e
00381B  2  29 BF        	and #%10111111
00381D  2  85 rr        	sta z80_e
00381F  2               :
00381F  2  AD 87 36     	lda keys+5		; Scan keys for Fire2
003822  2  20 58 37     	jsr ktest
003825  2  B0 06        	bcs :+
003827  2  A5 rr        	lda z80_e
003829  2  29 DF        	and #%11011111
00382B  2  85 rr        	sta z80_e
00382D  2               :
00382D  2  60           	rts
00382E  2               
00382E  2               ;-------------------------------------------------------------
00382E  2               ; JOY2SCAN
00382E  2               ;
00382E  2               ; TODO, Scan joystick2 and return key in z80_e
00382E  2               ;-------------------------------------------------------------
00382E  2               
00382E  2               joy2scan:
00382E  2  60           	rts
00382F  2               
00382F  2               
00382F  2               
00382F  2               ;========================================================
00382F  2               ; HARDWARE DEPENDING ROUTINES
00382F  2               ;========================================================
00382F  2               
00382F  2               ;----------------------------------------------------
00382F  2               ; DELAY
00382F  2               ;
00382F  2               ; Delay routine A * 1/50 sec
00382F  2               ;----------------------------------------------------
00382F  2               
00382F  2               delay:
00382F  2  85 rr        	sta xtmp		; set delaycounter
003831  2               del_loop:
003831  2  AD 04 90     	lda Reg4
003834  2  D0 FB        	bne del_loop		; wait for flyback (1/60 sec)
003836  2               
003836  2  A0 D0        	ldy #208		; wait 208 x 16 = 3328 usec
003838  2               delay1:
003838  2  61 80        	adc ($80,x)		;	 6 usec
00383A  2  61 80        	adc ($80,x)		;	 6 usec
00383C  2  88           	dey			;	 2 usec
00383D  2  D0 F9        	bne delay1		;	 2 usec
00383F  2  EA           	nop			; 2 usec
003840  2  EA           	nop			; 2 usec
003841  2               				; tot: 20000 usec
003841  2  C6 rr        	dec xtmp		; Next 1/50 sec delay
003843  2  D0 EC        	bne del_loop
003845  2  60           	rts
003846  2               
003846  2               ;-------------------------------------------------------------
003846  2               ; VSYNC
003846  2               ;
003846  2               ; - read joystick/keyboard
003846  2               ; - sync framerate with timer 25Hz
003846  2               ; - handle shrapnel every even frame
003846  2               ; - handle sound
003846  2               ;-------------------------------------------------------------
003846  2               
003846  2               vsync:
003846  2  48           	pha			; save registers
003847  2  98           	tya
003848  2  48           	pha
003849  2  8A           	txa
00384A  2  48           	pha
00384B  2               
00384B  2               ;-------------------------------------------------------------
00384B  2               ; Read joystick/keyboard.
00384B  2               ;-------------------------------------------------------------
00384B  2               
00384B  2  20 14 28     	jsr joykey
00384E  2               
00384E  2               ;-------------------------------------------------------------
00384E  2               ; Sync framerate with timer 25Hz
00384E  2               ;-------------------------------------------------------------
00384E  2               
00384E  2  A9 40        	lda #$40		; set Timer1 expired bit
003850  2               vsync1:
003850  2  2C 1D 91     	bit IFR1		; check Interrupt Flag Register
003853  2  F0 FB        	beq vsync1		; wait if timer not expired
003855  2  AD 14 91     	lda Timer11_Low		; clear Timer interrupt
003858  2               
003858  2               ;-------------------------------------------------------------
003858  2               ; Handle sound command
003858  2               ;-------------------------------------------------------------
003858  2               
003858  2  20 54 3A     	jsr make_sound2
00385B  2               
00385B  2               ;-------------------------------------------------------------
00385B  2               ; Handle shrapnel every even frame
00385B  2               ;-------------------------------------------------------------
00385B  2               
00385B  2  A5 rr        	lda clock		; get clock
00385D  2  29 01        	and #1			; 2 frames expired
00385F  2  D0 03        	bne:+
003861  2  20 98 20     	jsr proshr		; process shrapnel
003864  2               :
003864  2               
003864  2               ;-------------------------------------------------------------
003864  2               ; Handle sound BEEP and CRASH
003864  2               ;-------------------------------------------------------------
003864  2               
003864  2  AD DB 38     	lda sndtyp
003867  2  F0 4E        	beq sndskip
003869  2               
003869  2               sndloop:
003869  2  AC DB 38     	ldy sndtyp
00386C  2               sndwait:
00386C  2  88           	dey
00386D  2  D0 FD        	bne sndwait
00386F  2               
00386F  2  AD DB 38     	lda sndtyp
003872  2  30 1E        	bmi crashaudio
003874  2               
003874  2               ; BEEP command:
003874  2               ; enable sound on channel 2
003874  2               ; range 0-127
003874  2               
003874  2               beepaudio:
003874  2  AD 0E 90     	lda RegE
003877  2  09 0F        	ora #$0f
003879  2  8D 0E 90     	sta RegE
00387C  2               
00387C  2  A5 rr        	lda SOUNDS_STATUS
00387E  2  09 40        	ora #%01000000
003880  2  85 rr        	sta SOUNDS_STATUS
003882  2  A9 FF        	lda #$ff
003884  2  38           	sec
003885  2  ED DB 38     	sbc sndtyp
003888  2  4A           	lsr
003889  2  4A           	lsr
00388A  2  09 C0        	ora #%11000000
00388C  2  8D 0C 90     	sta RegC
00388F  2  4C AB 38     	jmp endaudiotype
003892  2               
003892  2               ; CRASH command:
003892  2               ; enable sound on channel 3
003892  2               ; range 128-255
003892  2               
003892  2               crashaudio:
003892  2  AD 0E 90     	lda RegE
003895  2  09 0F        	ora #$0f
003897  2  8D 0E 90     	sta RegE
00389A  2  A5 rr        	lda SOUNDS_STATUS
00389C  2  09 80        	ora #%10000000
00389E  2  85 rr        	sta SOUNDS_STATUS
0038A0  2  A9 FF        	lda #$ff
0038A2  2  38           	sec
0038A3  2  ED DB 38     	sbc sndtyp
0038A6  2  09 80        	ora #%10000000
0038A8  2  8D 0D 90     	sta RegD
0038AB  2               
0038AB  2               endaudiotype:
0038AB  2  CE DB 38     	dec sndtyp
0038AE  2  F0 07        	beq sndskip
0038B0  2  C9 80        	cmp #128
0038B2  2  F0 03        	beq sndskip
0038B4  2  4C 69 38     	jmp sndloop
0038B7  2               
0038B7  2               ; disable sound
0038B7  2               
0038B7  2               sndskip:
0038B7  2  24 rr        	bit SOUNDS_STATUS
0038B9  2  50 0B        	bvc :+
0038BB  2  A5 rr        	lda SOUNDS_STATUS
0038BD  2  29 BF        	and #%10111111
0038BF  2  85 rr        	sta SOUNDS_STATUS
0038C1  2  A9 00        	lda #$00
0038C3  2  8D 0C 90     	sta RegC
0038C6  2               :
0038C6  2  24 rr        	bit SOUNDS_STATUS
0038C8  2  10 0B        	bpl :+
0038CA  2               
0038CA  2  A5 rr        	lda SOUNDS_STATUS
0038CC  2  29 7F        	and #%01111111
0038CE  2  85 rr        	sta SOUNDS_STATUS
0038D0  2  A9 00        	lda #$00
0038D2  2  8D 0D 90     	sta RegD
0038D5  2               :
0038D5  2  68           	pla
0038D6  2  AA           	tax
0038D7  2  68           	pla
0038D8  2  A8           	tay
0038D9  2  68           	pla
0038DA  2  60           	rts
0038DB  2               
0038DB  2  00           sndtyp:		.byte 0		; Beep sound parameter
0038DC  2               
0038DC  2               ;========================================================
0038DC  2               ; SPRITE HANDLING ROUTINES
0038DC  2               ;========================================================
0038DC  2               
0038DC  2               ;----------------------------------------------------
0038DC  2               ; SPRITE
0038DC  2               ;
0038DC  2               ; Draw object sprite
0038DC  2               ;----------------------------------------------------
0038DC  2               
0038DC  2               .if oflag
0038DC  2               sprite:
0038DC  2               	stx xtmp		; Save X-reg
0038DC  2               	jsr scadd 		; get screen address in scraddr.
0038DC  2               
0038DC  2               	lda dispx 		; x position.
0038DC  2               	and #7 			; position straddling cells.
0038DC  2               	sta z80_b		; store in b register.
0038DC  2               
0038DC  2               	lda z80_l		; store sprite graphic address.
0038DC  2               	sta sprit1+1
0038DC  2               	sta sprit2+1
0038DC  2               	lda z80_h
0038DC  2               	sta sprit1+2
0038DC  2               	sta sprit2+2
0038DC  2               
0038DC  2               	ldx #0			; pixel height.
0038DC  2               	ldy #0
0038DC  2               sprit1:
0038DC  2               	lda objdta,x		; fetch first byte.
0038DC  2               	sta spr
0038DC  2               	inx
0038DC  2               sprit2:
0038DC  2               	lda objdta,x
0038DC  2               	sta spr+1
0038DC  2               
0038DC  2               	lda #0
0038DC  2               	sta spr+2
0038DC  2               	jsr sprit7		; shift sprite
0038DC  2               
0038DC  2               	lda spr			; fetch graphic.
0038DC  2               	ldy #0			; _BEEB
0038DC  2               	eor (scraddr),y		; merge with screen image.
0038DC  2               	sta (scraddr),y		; write to screen.
0038DC  2               
0038DC  2               	lda spr+1		; fetch graphic.
0038DC  2               	ldy #16			; _BEEB
0038DC  2               	eor (scraddr),y		; merge with screen image.
0038DC  2               	sta (scraddr),y		; write to screen.
0038DC  2               
0038DC  2               	lda spr+2		; fetch graphic.
0038DC  2               	ldy #32			; _BEEB
0038DC  2               	eor (scraddr),y		; merge with screen image.
0038DC  2               	sta (scraddr),y		; write to screen.
0038DC  2               
0038DC  2               	jsr nline
0038DC  2               
0038DC  2               	inx			; next source byte.
0038DC  2               	cpx #32
0038DC  2               	bne sprit1		; repeat
0038DC  2               
0038DC  2               	ldx xtmp		; retreive X-reg
0038DC  2               	rts
0038DC  2               
0038DC  2               .endif
0038DC  2               
0038DC  2               ;------------------------------------------------------------------
0038DC  2               ; SCADD
0038DC  2               ;
0038DC  2               ; This routine returns a screen address for X,Y in scraddr.
0038DC  2               ;------------------------------------------------------------------
0038DC  2               
0038DC  2               scadd:
0038DC  2  A5 rr        	lda dispx		; get x
0038DE  2  29 F8        	and #$f8		; reset bit 0-2 for get block pos
0038E0  2  85 rr        	sta scraddr		; set lb scraddr
0038E2  2  A9 00        	lda #0
0038E4  2  85 rr        	sta scraddr+1		; set hb scraddr
0038E6  2  06 rr        	asl scraddr		; multiply X by 2
0038E8  2  26 rr        	rol scraddr+1
0038EA  2               
0038EA  2               ; Add line address Y pos to X
0038EA  2               
0038EA  2  A6 rr        	ldx dispy		; get row address Y pos
0038EC  2  18           	clc
0038ED  2  A5 rr        	lda scraddr
0038EF  2  7D 00 07     	adc SCADTB_lb,x
0038F2  2  85 rr        	sta scraddr
0038F4  2  A5 rr        	lda scraddr+1
0038F6  2  7D 00 08     	adc SCADTB_hb,x
0038F9  2  85 rr        	sta scraddr+1
0038FB  2               
0038FB  2  60           	rts
0038FC  2               
0038FC  2               ;------------------------------------------------------------------
0038FC  2               ; SSPRIA
0038FC  2               ;
0038FC  2               ; Erase single sprite, old (ix+0).
0038FC  2               ;------------------------------------------------------------------
0038FC  2               
0038FC  2               sspria:
0038FC  2  20 6C 2B     	jsr gsprad		; get old sprite address.
0038FF  2               sspri2:
0038FF  2               .if rflag
0038FF  2               	lda z80_e		; 3c
0038FF  2               	sta dline_spraddr1+1	; 4c
0038FF  2               	sta dline_spraddr2+1	; 4c
0038FF  2               	lda z80_d		; 3c
0038FF  2               	sta dline_spraddr1+2	; 4c
0038FF  2               	sta dline_spraddr2+2	; 4c
0038FF  2               
0038FF  2               	ldx sprshft
0038FF  2               	lda shift_table,x
0038FF  2               	sta dline_shift1+1
0038FF  2               	sta dline_shift2+1
0038FF  2               	lda shift_table+1,x
0038FF  2               	sta dline_shift1+2
0038FF  2               	sta dline_shift2+2
0038FF  2               
0038FF  2               	ldx #0			; byte counter.
0038FF  2               sspri0:
0038FF  2               	jsr dline		; draw a line.
0038FF  2                 .if bflag
0038FF  2               	cpx #48			; big sprites have 24 bytes
0038FF  2                 .else
0038FF  2               	cpx #32			; normal sprites have 32 bytes
0038FF  2                 .endif
0038FF  2               	bne sspri0		; repeat 16 times x 2 bytes
0038FF  2               	rts
0038FF  2               .else
0038FF  2                 .if bflag
0038FF  2               	lda #24			; big sprites have 24 lines
0038FF  2                 .else
0038FF  2  A9 10        	lda #16			; normal sprites have 16 lines.
003901  2                 .endif
003901  2  8D 0D 39     	sta acnt
003904  2               sspri0:
003904  2  20 37 39     	jsr dline		; draw a line.
003907  2  CE 0D 39     	dec acnt
00390A  2  D0 F8        	bne sspri0		; repeat 16 times
00390C  2  60           	rts
00390D  2               
00390D  2  00           acnt:	.byte 0			; line counter
00390E  2               
00390E  2               .endif
00390E  2               
00390E  2               ;------------------------------------------------------------------
00390E  2               ; SSPRIB
00390E  2               ;
00390E  2               ; Display single sprite, new (ix+5).
00390E  2               ;------------------------------------------------------------------
00390E  2               
00390E  2               ssprib:
00390E  2  20 4D 2B     	jsr gspran 		; get new sprite address.
003911  2  4C FF 38     	jmp sspri2		; Display sprite
003914  2               
003914  2               ;------------------------------------------------------------------
003914  2               ; SSPRIC
003914  2               ;
003914  2               ; Erase old (ix+0) and display new (ix+5) sprite line by line.
003914  2               ;------------------------------------------------------------------
003914  2               
003914  2               sspric:
003914  2               .if rflag
003914  2               	jsr gsprad 		; get old sprite address.
003914  2               
003914  2               	lda z80_e		; 3c
003914  2               	sta ddline_spraddr3+1	; 4c
003914  2               	sta ddline_spraddr4+1	; 4c
003914  2               
003914  2               	lda z80_d		; 3c
003914  2               	sta ddline_spraddr3+2	; 4c
003914  2               	sta ddline_spraddr4+2	; 4c
003914  2               
003914  2               	ldx sprshft		; set spriteshift table addresses
003914  2               	lda shift_table,x
003914  2               	sta ddline_shift3+1
003914  2               	sta ddline_shift4+1
003914  2               	lda shift_table+1,x
003914  2               	sta ddline_shift3+2
003914  2               	sta ddline_shift4+2
003914  2               
003914  2               	jsr exx  		; store addresses.
003914  2               	jsr gspran 		; get new sprite addresses.
003914  2               
003914  2               	lda z80_e		; 3c
003914  2               	sta ddline_spraddr1+1	; 4c
003914  2               	sta ddline_spraddr2+1	; 4c
003914  2               
003914  2               	lda z80_d		; 3c
003914  2               	sta ddline_spraddr1+2	; 4c
003914  2               	sta ddline_spraddr2+2	; 4c
003914  2               
003914  2               	ldx sprshft
003914  2               	lda shift_table,x
003914  2               	sta ddline_shift1+1
003914  2               	sta ddline_shift2+1
003914  2               	lda shift_table+1,x
003914  2               	sta ddline_shift1+2
003914  2               	sta ddline_shift2+2
003914  2               
003914  2               	ldx #0
003914  2               lloop:
003914  2               	jsr ddline 		; draw a line.
003914  2                 .if bflag
003914  2               	cpx #48
003914  2                 .else
003914  2               	cpx #32
003914  2                 .endif
003914  2               	bne lloop
003914  2               	rts
003914  2               
003914  2               shift_table:
003914  2               	.word shift0
003914  2               	.word shift2
003914  2               	.word shift4
003914  2               	.word shift6
003914  2               
003914  2               ;------------------------------------------------------------------
003914  2               ; DLINE
003914  2               ;
003914  2               ; Draw a sprite line, now work out next target address.
003914  2               ;
003914  2               ; Input:
003914  2               ;  B  = right mask
003914  2               ;  C  = left mask
003914  2               ;  DE = spriteaddress
003914  2               ;  scraddr = screen address
003914  2               ;------------------------------------------------------------------
003914  2               
003914  2               dline:
003914  2               
003914  2               dline_spraddr1:
003914  2               	ldy $ffff,x 		; get graphic data as pointer.
003914  2               dline_shift1:
003914  2               	lda $ffff,y		; get pre-shifted data
003914  2               	sta sprtmp		; save byte
003914  2               	and z80_c 		; mask right for left byte
003914  2               
003914  2               	ldy #0
003914  2               	eor (scraddr),y 	; XOR with what's there.
003914  2               	sta (scraddr),y 	; display left byte
003914  2               
003914  2               ; carry to next screen byte
003914  2               
003914  2               	lda sprtmp		; fetch data.
003914  2               	and z80_b 		; mask for left part
003914  2               	sta sprtmp
003914  2               
003914  2               ; middle screen byte
003914  2               
003914  2               	inx
003914  2               dline_spraddr2:
003914  2               	ldy $ffff,x 		; second bit of data.
003914  2               dline_shift2:
003914  2               	lda $ffff,y
003914  2               	sta sprtmp2
003914  2               	and z80_c 		; mask away what's not needed.
003914  2               	ora sprtmp
003914  2               	ldy #16
003914  2               	eor (scraddr),y 	; XOR with what's there.
003914  2               	sta (scraddr),y 	; display middle bye.
003914  2               
003914  2               ; carry to last screen byte
003914  2               
003914  2               	lda sprtmp2
003914  2               	and z80_b 		; mask away unwanted
003914  2               
003914  2               	ldy #32
003914  2               	eor (scraddr),y 	; XOR with what's there.
003914  2               	sta (scraddr),y 	; display right byte.
003914  2               
003914  2               	inx
003914  2               .else
003914  2               
003914  2  20 6C 2B     	jsr gsprad 		; get old sprite address.
003917  2  20 CD 3B     	jsr exx  		; store addresses.
00391A  2  20 4D 2B     	jsr gspran 		; get new sprite addresses.
00391D  2               
00391D  2               .if bflag
00391D  2               	lda #23
00391D  2               .else
00391D  2  A9 0F        	lda #15
00391F  2               .endif
00391F  2  85 rr        	sta ccnt
003921  2               lloop:
003921  2  20 37 39     	jsr dline 		; draw a line.
003924  2  20 CD 3B     	jsr exx  		; restore old addresses.
003927  2  20 37 39     	jsr dline 		; delete a line.
00392A  2  20 CD 3B     	jsr exx  		; flip to new sprite addresses.
00392D  2  C6 rr        	dec ccnt
00392F  2  D0 F0        	bne lloop
003931  2               
003931  2  20 37 39     	jsr dline		; draw a line.
003934  2  20 CD 3B     	jsr exx 		; restore old addresses.
003937  2               
003937  2               ;-------------------------------------------------------------
003937  2               ; Drop through.
003937  2               ; Line drawn, now work out next target address.
003937  2               ;
003937  2               ; Input:
003937  2               ;  B  = right mask
003937  2               ;  C  = left mask
003937  2               ;  DE = spriteaddress
003937  2               ;  scraddr = screen address
003937  2               ;-------------------------------------------------------------
003937  2               
003937  2               dline:
003937  2  A0 00        	ldy #0
003939  2  B1 rr        	lda (z80_de),y 		; graphic data.
00393B  2  48           	pha
00393C  2  25 rr        	and z80_c 		; mask away what's not needed.
00393E  2  51 rr        	eor (scraddr),y 	; XOR with what's there.
003940  2  91 rr        	sta (scraddr),y 	; left byte on screen.
003942  2               
003942  2  68           	pla
003943  2  25 rr        	and z80_b 		; mask away unwanted bits.
003945  2  A0 20        	ldy #32
003947  2  51 rr        	eor (scraddr),y 	; XOR with what's there.
003949  2  91 rr        	sta (scraddr),y 	; right byte on screen
00394B  2               
00394B  2  E6 rr        	inc z80_e 		; next graphic.
00394D  2  D0 02        	bne :+
00394F  2  E6 rr        	inc z80_d
003951  2               :
003951  2               ; _BEEB screen arrangement
003951  2               ;	sec
003951  2               ;	lda scraddr 		; one character cell to the left.
003951  2               ;	sbc #8
003951  2               ;	sta scraddr
003951  2               ;	lda scraddr+1
003951  2               ;	sbc #0
003951  2               ;	sta scraddr+1
003951  2  A0 00        	ldy #0
003953  2  B1 rr        	lda (z80_de),y 		; second bit of data.
003955  2  A0 10        	ldy #16
003957  2  51 rr        	eor (scraddr),y 	; XOR with what's there.
003959  2  91 rr        	sta (scraddr),y 	; middle byte on screen.
00395B  2               
00395B  2  E6 rr        	inc z80_e 		; point to next line of data.
00395D  2  D0 02        	bne :+
00395F  2  E6 rr        	inc z80_d
003961  2               :
003961  2               ; _BEEB screen arrangement
003961  2               ;	sec
003961  2               ;	lda scraddr 		; another char left.
003961  2               ;	sbc #8
003961  2               ;	sta scraddr
003961  2               ;	lda scraddr+1
003961  2               ;	sbc #0
003961  2               ;	sta scraddr+1
003961  2               .endif
003961  2               
003961  2               ;----------------------------------------------------------------------
003961  2               ; Line drawn, now work out next target address.
003961  2               ;----------------------------------------------------------------------
003961  2               
003961  2               ; _BEEB screen arrangement
003961  2               
003961  2               nline:
003961  2  A5 rr        	lda scraddr 			; get low byte of address.
003963  2  29 0F        	and #15
003965  2  C9 0F        	cmp #15				; is this last line of row?
003967  2  F0 03        	beq beeb_next_row
003969  2               
003969  2               	; within same row
003969  2  E6 rr        	inc scraddr			; new low byte of address.
00396B  2  60           	rts
00396C  2               
00396C  2               beeb_next_row:
00396C  2  18           	clc
00396D  2  A5 rr        	lda scraddr
00396F  2  69 51        	adc #<(ScreenRowBytes-15)
003971  2  85 rr        	sta scraddr			; new low byte of address.
003973  2  A5 rr        	lda scraddr+1
003975  2  69 01        	adc #>(ScreenRowBytes-15)
003977  2  85 rr        	sta scraddr+1			; new high byte of address.
003979  2  60           	rts
00397A  2               
00397A  2               .if rflag
00397A  2               ;-------------------------------------------------------------
00397A  2               ; Drop through.
00397A  2               ; Line drawn, now work out next target address.
00397A  2               ;
00397A  2               ; Input:
00397A  2               ;  B  = right mask
00397A  2               ;  C  = left mask
00397A  2               ;  DE = spriteaddress
00397A  2               ;  scraddr = screen address
00397A  2               ;-------------------------------------------------------------
00397A  2               
00397A  2               ddline:
00397A  2               
00397A  2               ; NEW SPRITE
00397A  2               
00397A  2               ; first screen byte
00397A  2               
00397A  2               ddline_spraddr1:
00397A  2               	ldy $ffff,x 		; graphic data.
00397A  2               ddline_shift1:
00397A  2               	lda $ffff,y
00397A  2               	sta sprtmp
00397A  2               	and z80_c 			; mask away what's not needed.
00397A  2               
00397A  2               	ldy #0
00397A  2               	eor (scraddr),y 	; XOR with what's there.
00397A  2               	sta (scraddr),y 	; bung it in.
00397A  2               
00397A  2               ; carry to next screen byte
00397A  2               
00397A  2               	lda sprtmp			; fetch data.
00397A  2               	and z80_b 			; mask away unwanted
00397A  2               	sta sprtmp
00397A  2               
00397A  2               ; middle screen byte
00397A  2               
00397A  2               	inx
00397A  2               ddline_spraddr2:
00397A  2               	ldy $ffff,x 		; second bit of data.
00397A  2               ddline_shift2:
00397A  2               	lda $ffff,y
00397A  2               	sta sprtmp2
00397A  2               	and z80_c 			; mask away what's not needed.
00397A  2               	ora sprtmp
00397A  2               
00397A  2               	ldy #16
00397A  2               	eor (scraddr),y 	; XOR with what's there.
00397A  2               	sta (scraddr),y 	; bung it in.
00397A  2               
00397A  2               ; carry to last screen byte
00397A  2               
00397A  2               	lda sprtmp2
00397A  2               	and z80_b 			; mask away unwanted
00397A  2               
00397A  2               	ldy #32
00397A  2               	eor (scraddr),y 	; XOR with what's there.
00397A  2               	sta (scraddr),y 	; bung it in.
00397A  2               
00397A  2               ; _BEEB next row
00397A  2               
00397A  2               	lda scraddr 		; get low byte of address.
00397A  2               	and #15
00397A  2               	cmp #15				; is this last line of row?
00397A  2               	beq :+
00397A  2               
00397A  2               	; within same row can't increment page
00397A  2               	inc scraddr			; new low byte of address.
00397A  2               	bne ddline2
00397A  2               
00397A  2               :
00397A  2               	clc
00397A  2               	lda scraddr
00397A  2               	adc #<(ScreenRowBytes-15)
00397A  2               	sta scraddr			; new low byte of address.
00397A  2               	lda scraddr+1
00397A  2               	adc #>(ScreenRowBytes-15)
00397A  2               	sta scraddr+1		; new high byte of address.
00397A  2               
00397A  2               ; OLD SPRITE
00397A  2               
00397A  2               ddline2:
00397A  2               
00397A  2               ; still first row but different data!
00397A  2               
00397A  2               	dex
00397A  2               
00397A  2               ; first screen byte
00397A  2               
00397A  2               ddline_spraddr3:
00397A  2               	ldy $ffff,x			; graphic data.
00397A  2               ddline_shift3:
00397A  2               	lda $ffff,y
00397A  2               	sta sprtmp
00397A  2               	and z80_cp 			; mask away what's not needed.
00397A  2               
00397A  2               	ldy #0
00397A  2               	eor (z80_hlp),y 	; XOR with what's there.
00397A  2               	sta (z80_hlp),y 	; bung it in.
00397A  2               
00397A  2               ; carry to next screen byte
00397A  2               
00397A  2               	lda sprtmp			; fetch data.
00397A  2               	and z80_bp 			; mask away unwanted
00397A  2               	sta sprtmp
00397A  2               
00397A  2               ; middle screen byte
00397A  2               
00397A  2               	inx
00397A  2               ddline_spraddr4:
00397A  2               	ldy $ffff,x 		; second bit of data.
00397A  2               ddline_shift4:
00397A  2               	lda $ffff,y
00397A  2               	sta sprtmp2
00397A  2               	and z80_cp 			; mask away what's not needed.
00397A  2               	ora sprtmp
00397A  2               
00397A  2               	ldy #16
00397A  2               	eor (z80_hlp),y 	; XOR with what's there.
00397A  2               	sta (z80_hlp),y 	; bung it in.
00397A  2               
00397A  2               ; last screen byte
00397A  2               
00397A  2               	lda sprtmp2			; fetch data.
00397A  2               	and z80_bp 			; mask away unwanted
00397A  2               
00397A  2               	ldy #32
00397A  2               	eor (z80_hlp),y 	; XOR with what's there.
00397A  2               	sta (z80_hlp),y 	; bung it in.
00397A  2               
00397A  2               ; next row of sprite data
00397A  2               
00397A  2               	inx
00397A  2               
00397A  2               ; _BEEB screen arrangement
00397A  2               
00397A  2               	lda z80_lp 			; get low byte of address.
00397A  2               	and #15
00397A  2               	cmp #15				; is this last line of row?
00397A  2               	beq :+
00397A  2               
00397A  2               	; within same row can't increment page
00397A  2               	inc z80_lp			; new low byte of address.
00397A  2               	rts
00397A  2               
00397A  2               :
00397A  2               	clc
00397A  2               	lda z80_lp
00397A  2               	adc #<(ScreenRowBytes-15)
00397A  2               	sta z80_lp			; new low byte of address.
00397A  2               	lda z80_lp+1
00397A  2               	adc #>(ScreenRowBytes-15)
00397A  2               	sta z80_lp+1		; new high byte of address.
00397A  2               	rts
00397A  2               .endif
00397A  2               
00397A  2               ;----------------------------------------------------
00397A  2               ; Display character in A at dispx,dispy.
00397A  2               ;
00397A  2               ; Input:
00397A  2               ;  A 	   = character to print
00397A  2               ;----------------------------------------------------
00397A  2               
00397A  2               pchar:
00397A  2  85 rr        	sta fntaddr
00397C  2  A9 00        	lda #0
00397E  2  85 rr        	sta fntaddr+1
003980  2  06 rr        	asl fntaddr  		; multiply char by 8.
003982  2  26 rr        	rol fntaddr+1
003984  2  06 rr        	asl fntaddr
003986  2  26 rr        	rol fntaddr+1
003988  2  06 rr        	asl fntaddr
00398A  2  26 rr        	rol fntaddr+1
00398C  2               
00398C  2  A5 rr        	lda fntaddr
00398E  2  18           	clc
00398F  2  69 81        	adc #<(FONT-256)
003991  2  85 rr        	sta fntaddr		; that's the low byte.
003993  2  A5 rr        	lda fntaddr+1
003995  2  69 32        	adc #>(FONT-256)
003997  2  85 rr        	sta fntaddr+1		; add displacement.
003999  2               
003999  2               pchark:
003999  2  20 0A 25     	jsr gaadd		; set colour attribute
00399C  2  AD 8D 36     	lda fontcol
00399F  2  A0 00        	ldy #0
0039A1  2  91 rr        	sta (bufaddr),y
0039A3  2               
0039A3  2  20 A0 24     	jsr gprad		; get screen address.
0039A6  2  A2 07        	ldx #7			; lines to write.
0039A8  2               pchar0:
0039A8  2  A0 00        	ldy #0
0039AA  2  B1 rr        	lda (fntaddr),y 	; get image byte.
0039AC  2  BC BB 39     	ldy scrtab,x		; Get rowoffset
0039AF  2               .if iflag
0039AF  2               	eor #TxtInvert		; Invert
0039AF  2               .endif
0039AF  2  91 rr        	sta (scraddr),y 	; copy to screen.
0039B1  2  E6 rr        	inc fntaddr		; next image byte.
0039B3  2  D0 02        	bne :+
0039B5  2  E6 rr        	inc fntaddr+1
0039B7  2               :
0039B7  2  CA           	dex			; next screen row down.
0039B8  2  10 EE        	bpl pchar0		; repeat.
0039BA  2               
0039BA  2  60           	rts
0039BB  2               
0039BB  2  07 06 05 04  scrtab:		.byte $07,$06,$05,$04,$03,$02,$01,$00
0039BF  2  03 02 01 00  
0039C3  2               
0039C3  2               ;----------------------------------------------------
0039C3  2               ; LoadFile
0039C3  2               ;----------------------------------------------------
0039C3  2               
0039C3  2               loadfile:
0039C3  2  AA           	tax
0039C4  2  A9 07        	lda #<msgdat		; pointer to messages.
0039C6  2  85 rr        	sta z80_l
0039C8  2  A9 32        	lda #>msgdat
0039CA  2  85 rr        	sta z80_h
0039CC  2  20 77 29     	jsr getwrd		; get message number.
0039CF  2               
0039CF  2               ; Init screen for NTSC
0039CF  2               ; this sets the background and border color of the screen
0039CF  2               ; in this case border black and background black
0039CF  2               
0039CF  2  A9 08        	lda #%00001000
0039D1  2  8D 0F 90     	sta RegF
0039D4  2               
0039D4  2               ; z80_hl should point to the textstring now.
0039D4  2               ; Read filename +length into buffer
0039D4  2               
0039D4  2  A0 00        	ldy #0
0039D6  2               nameloop:
0039D6  2  B1 rr        	lda (z80_hl),y
0039D8  2  30 07        	bmi lastchar
0039DA  2  99 07 3A     	sta filename,y
0039DD  2  C8           	iny
0039DE  2  4C D6 39     	jmp nameloop
0039E1  2               lastchar:
0039E1  2  29 7F        	and #$7f
0039E3  2  99 07 3A     	sta filename,y
0039E6  2  C8           	iny
0039E7  2  8C 27 3A     	sty filelen
0039EA  2               
0039EA  2               ; Which device to use (in A the file num 1 is OK - x with 8 is the type of device
0039EA  2               ;                       usually the first drive, and y set to 1 reads from the header
0039EA  2               ;                       of the file the location where to save it)
0039EA  2  A9 01        	lda #1
0039EC  2  A2 08        	ldx #8		; Disk device
0039EE  2  A0 01        	ldy #1
0039F0  2  20 BA FF     	jsr $ffba
0039F3  2               
0039F3  2               ; Load the file name (in accumulator the size of the string
0039F3  2               ;                      containing the name, x low address for FileName,
0039F3  2               ;                      y high address for FileName)
0039F3  2  AD 27 3A     	lda filelen
0039F6  2  A2 07        	ldx #<filename
0039F8  2  A0 3A        	ldy #>filename
0039FA  2  20 BD FF     	jsr $ffbd
0039FD  2               
0039FD  2               ; load from disk to ram
0039FD  2  A9 00        	lda #0		; accumulator must be set to 0 to load the image
0039FF  2  A2 FF        	ldx #<$ff	; target location low not set (got from header)
003A01  2  A0 00        	ldy #>$ff	; target location high (got from header)
003A03  2  20 D5 FF     	jsr $ffd5
003A06  2               
003A06  2  60           	rts
003A07  2               
003A07  2               filename:
003A07  2  00 00 00 00  	.byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
003A0B  2  00 00 00 00  
003A0F  2  00 00 00 00  
003A17  2  00 00 00 00  	.byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
003A1B  2  00 00 00 00  
003A1F  2  00 00 00 00  
003A27  2               filelen:
003A27  2  00           	.byte 0
003A28  2               
003A28  2               ;----------------------------------------------------
003A28  2               ; Sound
003A28  2               ;----------------------------------------------------
003A28  2               
003A28  2               ; Actual memory locations
003A28  2               
003A28  2               ; CHANNEL1_ENABLED  = $ea
003A28  2               ; CHANNEL2_ENABLED  = $eb
003A28  2               ; CHANNEL3_ENABLED  = $ec
003A28  2               ; CHANNEL4_ENABLED  = $ed
003A28  2               ; MUSIC_ON		  = $ee
003A28  2               
003A28  2  0A 19 10 40  SetSoundVars:		.byte $0a, $19, $10, $40
003A2C  2  0A 19 10 40  SetSoundDuration:	.byte $0a, $19, $10, $40
003A30  2  DE           SetSoundTone: 		.byte $de
003A31  2               
003A31  2               ;--------------------------------------------
003A31  2               ;                      SOUND    0   1   2   3
003A31  2               ;--------------------------------------------
003A31  2  C8 C8 DE DC  SndTone:		.byte 200,200,222,220
003A35  2  01 00 03 01  SndChannel:		.byte   1,  0,  3,  1
003A39  2  3C 3C 3C 28  SndDuration:		.byte  60, 60, 60, 40
003A3D  2               
003A3D  2               ;--------------------------------------------
003A3D  2               ; Called by SOUND with parameter in A
003A3D  2               ;--------------------------------------------
003A3D  2               
003A3D  2               playsound:
003A3D  2  A8           	tay
003A3E  2  B9 31 3A     	lda SndTone,y		; lda $a0
003A41  2  8D 30 3A     	sta SetSoundTone	; sta SetSoundTone
003A44  2  B9 39 3A     	lda SndDuration,y	; lda $a2
003A47  2  BE 35 3A     	ldx SndChannel,y	; ldx $a1
003A4A  2  9D 2C 3A     	sta SetSoundDuration,x	; sta SetSoundDuration,x
003A4D  2  B9 31 3A     	lda SndTone,y		; lda $a0
003A50  2  9D 28 3A     	sta SetSoundVars,x	; sta SetSoundVars,x
003A53  2  60           	rts
003A54  2               
003A54  2               ;--------------------------------------------
003A54  2               ; Make sound
003A54  2               ; Called by vsync every frame
003A54  2               ;--------------------------------------------
003A54  2               
003A54  2               make_sound2:
003A54  2  A0 00        	ldy #$00
003A56  2  AE 30 3A     	ldx SetSoundTone
003A59  2  AD 28 3A     	lda SetSoundVars
003A5C  2  CD 2C 3A     	cmp SetSoundDuration
003A5F  2  B0 1C        	bcs l0366
003A61  2               
003A61  2  AD 28 3A     	lda SetSoundVars
003A64  2  CD 2C 3A     	cmp SetSoundDuration
003A67  2  D0 07        	bne :+
003A69  2  A5 EE        	lda MUSIC_ON
003A6B  2  85 EA        	sta CHANNEL1_ENABLED	; Enable channel 1
003A6D  2  4C 8B 3A     	jmp l0374
003A70  2               :
003A70  2               
003A70  2  A9 00        	lda #$0
003A72  2  85 EA        	sta CHANNEL1_ENABLED	; Enable channel 1
003A74  2  EE 28 3A     	inc SetSoundVars
003A77  2  EE 0A 90     	inc RegA
003A7A  2  4C 8B 3A     	jmp l0374
003A7D  2               
003A7D  2  8C 0A 90     l0366:	sty RegA
003A80  2  EC 28 3A     	cpx SetSoundVars
003A83  2  D0 06        	bne l0374
003A85  2  8C 28 3A     	sty SetSoundVars
003A88  2  8E 0A 90     	stx RegA
003A8B  2               
003A8B  2  AD 29 3A     l0374:	lda SetSoundVars+1
003A8E  2  CD 2D 3A     	cmp SetSoundDuration+1
003A91  2  D0 07        	bne :+
003A93  2  A5 EE        	lda MUSIC_ON
003A95  2  85 EB        	sta CHANNEL2_ENABLED	; Enable channel 1
003A97  2  4C BD 3A     	jmp l0392
003A9A  2               :
003A9A  2  A9 00        	lda #$0
003A9C  2  85 EB        	sta CHANNEL2_ENABLED	; Enable channel 2
003A9E  2  AD 29 3A     	lda SetSoundVars+1
003AA1  2  CD 2D 3A     	cmp SetSoundDuration+1
003AA4  2  B0 09        	bcs l0384
003AA6  2  EE 29 3A     	inc SetSoundVars+1
003AA9  2  EE 0B 90     	inc RegB
003AAC  2  4C BD 3A     	jmp l0392
003AAF  2               
003AAF  2  8C 0B 90     l0384:	sty RegB
003AB2  2  EC 29 3A     	cpx SetSoundVars+1
003AB5  2  D0 06        	bne l0392
003AB7  2  8C 29 3A     	sty SetSoundVars+1
003ABA  2  8E 0B 90     	stx RegB
003ABD  2               
003ABD  2  AD 2A 3A     l0392:	lda SetSoundVars+2
003AC0  2  CD 2E 3A     	cmp SetSoundDuration+2
003AC3  2  D0 07        	bne :+
003AC5  2  A5 EE        	lda MUSIC_ON
003AC7  2  85 EC        	sta CHANNEL3_ENABLED	; Enable channel 1
003AC9  2  4C EF 3A     	jmp l03b0
003ACC  2               :
003ACC  2  A9 00        	lda #$0
003ACE  2  85 EC        	sta CHANNEL3_ENABLED	; Enable channel 3
003AD0  2  AD 2A 3A     	lda SetSoundVars+2
003AD3  2  CD 2E 3A     	cmp SetSoundDuration+2
003AD6  2  B0 09        	bcs l03a2
003AD8  2  EE 2A 3A     	inc SetSoundVars+2
003ADB  2  CE 0C 90     	dec RegC
003ADE  2  4C EF 3A     	jmp l03b0
003AE1  2               
003AE1  2  8C 0C 90     l03a2:	sty RegC
003AE4  2  EC 2A 3A     	cpx SetSoundVars+2
003AE7  2  D0 06        	bne l03b0
003AE9  2  8C 2A 3A     	sty SetSoundVars+2
003AEC  2  8E 0C 90     	stx RegC
003AEF  2               
003AEF  2  AD 2B 3A     l03b0:	lda SetSoundVars+3
003AF2  2  CD 2F 3A     	cmp SetSoundDuration+3
003AF5  2  D0 07        	bne :+
003AF7  2  A5 EE        	lda MUSIC_ON
003AF9  2  85 ED        	sta CHANNEL4_ENABLED	; Enable channel 1
003AFB  2  4C 26 3B     	jmp l03d3
003AFE  2               :
003AFE  2               
003AFE  2               	; lda SetSoundVars+3
003AFE  2               	; cmp SetSoundDuration+3
003AFE  2               	; beq l03e1
003AFE  2               
003AFE  2  A9 00        	lda #$0
003B00  2  85 ED        	sta CHANNEL4_ENABLED	; Enable channel 4
003B02  2               
003B02  2  AD 2B 3A     	lda SetSoundVars+3
003B05  2  CD 2F 3A         cmp SetSoundDuration+3 ; $03b3 $03b4
003B08  2  B0 1C            bcs l03d3
003B0A  2               
003B0A  2  EE 2B 3A     	inc SetSoundVars+3
003B0D  2  AD 2B 3A     	lda SetSoundVars+3
003B10  2  C9 16        	cmp #$16
003B12  2  D0 07        	bne l03c8
003B14  2  A9 B0        	lda #$b0
003B16  2  8D 0D 90     	sta RegD
003B19  2  F0 19        	beq l03e1
003B1B  2  C9 2B        l03c8:	cmp #$2b
003B1D  2  D0 15        	bne l03e1
003B1F  2  A9 A0        	lda #$a0
003B21  2  8D 0D 90     	sta RegD
003B24  2  F0 0E        	beq l03e1
003B26  2  8C 0D 90     l03d3:	sty RegD
003B29  2  EC 2B 3A     	cpx SetSoundVars+3
003B2C  2  D0 06        	bne l03e1
003B2E  2  8C 2B 3A     	sty SetSoundVars+3
003B31  2  8E 0D 90     	stx RegD
003B34  2               
003B34  2  60           l03e1:	rts
003B35  2               
003B35  2               ;----------------------------------------------------
003B35  2               ; Set video registers
003B35  2               ;----------------------------------------------------
003B35  2               
003B35  2               SetReg:
003B35  2  8D 8E 36     	sta mode
003B38  2  0A           	asl a
003B39  2  18           	clc
003B3A  2  6D 8F 36     	adc crtflag
003B3D  2  AA           	tax
003B3E  2  BD 5D 3B     	lda centreX,x
003B41  2  8D 00 90     	sta Reg0
003B44  2  BD 61 3B     	lda centreY,x
003B47  2  8D 01 90     	sta Reg1
003B4A  2  BD 65 3B     	lda scrW,x
003B4D  2  8D 02 90     	sta Reg2
003B50  2  BD 69 3B     	lda scrH,x
003B53  2  8D 03 90     	sta Reg3
003B56  2  BD 6D 3B     	lda RAMset,x
003B59  2  8D 05 90     	sta Reg5
003B5C  2  60           	rts
003B5D  2               
003B5D  2  04 0C 06 0E  centreX:	.byte $04,$0c,$06,$0e
003B61  2  1B 26 18 24  centreY:	.byte $1b,$26,$18,$24
003B65  2  96 96 14 14  scrW:		.byte $96,$96,$14,$14
003B69  2  17 17 19 19  scrH:		.byte $17,$17,$19,$19
003B6D  2  8C 8C CC CC  RAMset:		.byte $8c,$8c,$cc,$cc
003B71  2  84 A0 84 A0  BottomScr:	.byte $84,$a0,$84,$a0
003B75  2               
003B75  2               ;----------------------------------------------------
003B75  2               ; Display functions
003B75  2               ;
003B75  2               ; DISPLAYON   resets CentreY
003B75  2               ; DISPLAYOFF  locates screen below bottom
003B75  2               ; DISPLAYUP   scrolls screen up until default CentreY
003B75  2               ; DISPLAYDOWN scrolls screen down until below bottom
003B75  2               ;----------------------------------------------------
003B75  2               
003B75  2               dispon:
003B75  2  AD 8E 36     	lda mode
003B78  2  0A           	asl a
003B79  2  18           	clc
003B7A  2  6D 8F 36     	adc crtflag
003B7D  2  AA           	tax
003B7E  2  BD 61 3B     	lda centreY,x
003B81  2  8D 01 90     	sta Reg1
003B84  2  60           	rts
003B85  2               
003B85  2               dispoff:
003B85  2  AD 8E 36     	lda mode
003B88  2  0A           	asl a
003B89  2  18           	clc
003B8A  2  6D 8F 36     	adc crtflag
003B8D  2  AA           	tax
003B8E  2  BD 71 3B     	lda BottomScr,x
003B91  2  8D 01 90     	sta Reg1
003B94  2  60           	rts
003B95  2               
003B95  2               dispup:
003B95  2  AD 8E 36     	lda mode
003B98  2  0A           	asl a
003B99  2  18           	clc
003B9A  2  6D 8F 36     	adc crtflag
003B9D  2  AA           	tax
003B9E  2  BD 61 3B     	lda centreY,x
003BA1  2  85 rr        	sta tmp
003BA3  2               scr_down_loop:
003BA3  2  A9 01        	lda #1
003BA5  2  20 2F 38     	jsr delay
003BA8  2  CE 01 90     	dec Reg1
003BAB  2  AD 01 90     	lda Reg1
003BAE  2  C5 rr        	cmp tmp
003BB0  2  D0 F1        	bne scr_down_loop
003BB2  2  60           	rts
003BB3  2               
003BB3  2               dispdown:
003BB3  2  AD 8E 36     	lda mode
003BB6  2  0A           	asl a
003BB7  2  18           	clc
003BB8  2  6D 8F 36     	adc crtflag
003BBB  2  AA           	tax
003BBC  2  A9 01        	lda #1
003BBE  2  20 2F 38     	jsr delay
003BC1  2  EE 01 90     	inc Reg1
003BC4  2  AD 01 90     	lda Reg1
003BC7  2  DD 71 3B     	cmp BottomScr,x
003BCA  2  D0 E7        	bne dispdown
003BCC  2  60           	rts
003BCD  2               
003BCD  1               ;	.include "music.inc"
003BCD  1               ;colscr:	.incbin "..\pictures\slasher3c"
003BCD  1               ;datscr:	.incbin "..\pictures\slasher3d"
003BCD  1               
003BCD  1               	.include "z80.asm"
003BCD  2               ;------------------------------------------------------
003BCD  2               ; z80.asm
003BCD  2               ; spectrum stuff
003BCD  2               ; adresses
003BCD  2               
003BCD  2               ;ws	 = $60
003BCD  2               
003BCD  2               ;z80_f	 = ws+$00
003BCD  2               ;z80_a	 = ws+$01
003BCD  2               ;z80_af	 = z80_f
003BCD  2               
003BCD  2               ;z80_c	 = ws+$02
003BCD  2               ;z80_b	 = ws+$03
003BCD  2               ;z80_bc	 = z80_c
003BCD  2               
003BCD  2               ;z80_e	 = ws+$04
003BCD  2               ;z80_d	 = ws+$05
003BCD  2               ;z80_de	 = z80_e
003BCD  2               
003BCD  2               ;z80_l	 = ws+$06
003BCD  2               ;z80_h	 = ws+$07
003BCD  2               ;z80_hl	 = z80_l
003BCD  2               
003BCD  2               ;z80_x    = ws+$08
003BCD  2               ;z80_i    = ws+$09
003BCD  2               ;z80_ix	 = z80_x
003BCD  2               
003BCD  2               ;z80_iy	 = ws+$0a
003BCD  2               
003BCD  2               ;z80_fp	 = ws+$0c
003BCD  2               ;z80_ap	 = ws+$0d
003BCD  2               
003BCD  2               ;z80_cp	 = ws+$0e
003BCD  2               ;z80_bp	 = ws+$0f
003BCD  2               ;z80_bcp = z80_cp
003BCD  2               
003BCD  2               ;z80_ep	 = ws+$10
003BCD  2               ;z80_dp	 = ws+$11
003BCD  2               ;z80_dep = z80_ep
003BCD  2               
003BCD  2               ;z80_lp	 = ws+$12
003BCD  2               ;z80_hp	 = ws+$13
003BCD  2               ;z80_hlp = z80_lp
003BCD  2               
003BCD  2               ;z80_sp   = ws+$14
003BCD  2               
003BCD  2               ;z80_reg0 = ws+$16
003BCD  2               ;z80_reg1 = ws+$17
003BCD  2               ;z80_reg2 = ws+$18
003BCD  2               ;z80_reg3 = ws+$19
003BCD  2               
003BCD  2               ;z80_r	 = ws+$1a
003BCD  2               
003BCD  2               ; Contains seperatly 1 bit set
003BCD  2               ; _BEEB this is not safe memory to use as required by MOS
003BCD  2               
003BCD  2               _bitmem0	= $f8
003BCD  2               _bitmem1	= $f9
003BCD  2               _bitmem2	= $fa
003BCD  2               _bitmem3	= $fb
003BCD  2               _bitmem4	= $fc
003BCD  2               _bitmem5	= $fd
003BCD  2               _bitmem6	= $fe
003BCD  2               _bitmem7	= $ff
003BCD  2               
003BCD  2               ; constants
003BCD  2               _bitvalue0	= $01
003BCD  2               _bitvalue1	= $02
003BCD  2               _bitvalue2	= $04
003BCD  2               _bitvalue3	= $08
003BCD  2               _bitvalue4	= $10
003BCD  2               _bitvalue5	= $20
003BCD  2               _bitvalue6	= $40
003BCD  2               _bitvalue7	= $80
003BCD  2               
003BCD  2               _notbitvalue0	= $fe
003BCD  2               _notbitvalue1	= $fd
003BCD  2               _notbitvalue2	= $fb
003BCD  2               _notbitvalue3	= $f7
003BCD  2               _notbitvalue4	= $ef
003BCD  2               _notbitvalue5	= $df
003BCD  2               _notbitvalue6	= $bf
003BCD  2               _notbitvalue7	= $7f
003BCD  2               
003BCD  2               
003BCD  2               ;add_hl_bc:
003BCD  2               ;		lda z80_l
003BCD  2               ;		clc
003BCD  2               ;		adc z80_c
003BCD  2               ;		sta z80_l
003BCD  2               ;		lda z80_h
003BCD  2               ;		adc z80_b
003BCD  2               ;		sta z80_h
003BCD  2               ;		rts
003BCD  2               ;
003BCD  2               ;add_ix_de:
003BCD  2               ;		lda z80_ix
003BCD  2               ;		clc
003BCD  2               ;		adc z80_e
003BCD  2               ;		sta z80_ix
003BCD  2               ;		lda z80_ix+1
003BCD  2               ;		adc z80_d
003BCD  2               ;		sta z80_ix+1
003BCD  2               ;		rts
003BCD  2               ;
003BCD  2               ;add_iy_de:
003BCD  2               ;		lda z80_iy
003BCD  2               ;		clc
003BCD  2               ;		adc z80_e
003BCD  2               ;		sta z80_iy
003BCD  2               ;		lda z80_iy+1
003BCD  2               ;		adc z80_d
003BCD  2               ;		sta z80_iy+1
003BCD  2               ;		rts
003BCD  2               ;
003BCD  2               ;add_hl_de:
003BCD  2               ;		lda z80_l
003BCD  2               ;		clc
003BCD  2               ;		adc z80_e
003BCD  2               ;		sta z80_l
003BCD  2               ;		lda z80_h
003BCD  2               ;		adc z80_d
003BCD  2               ;		sta z80_h
003BCD  2               ;		rts
003BCD  2               ;
003BCD  2               ;add_ix_bc:
003BCD  2               ;		lda z80_ix
003BCD  2               ;		clc
003BCD  2               ;		adc z80_c
003BCD  2               ;		sta z80_ix
003BCD  2               ;		lda z80_ix+1
003BCD  2               ;		adc z80_b
003BCD  2               ;		sta z80_ix+1
003BCD  2               ;		rts
003BCD  2               ;
003BCD  2               ;add_iy_bc:
003BCD  2               ;		lda z80_iy
003BCD  2               ;		clc
003BCD  2               ;		adc z80_c
003BCD  2               ;		sta z80_iy
003BCD  2               ;		lda z80_iy+1
003BCD  2               ;		adc z80_b
003BCD  2               ;		sta z80_iy+1
003BCD  2               ;		rts
003BCD  2               ;
003BCD  2               ;sbc_hl_de:
003BCD  2               ;		lda z80_l
003BCD  2               ;		sbc z80_e
003BCD  2               ;		sta z80_l
003BCD  2               ;		lda z80_h
003BCD  2               ;		sbc z80_d
003BCD  2               ;		sta z80_h
003BCD  2               ;		rts
003BCD  2               ;
003BCD  2               ;sbc_hl_bc:
003BCD  2               ;		lda z80_l
003BCD  2               ;		sbc z80_c
003BCD  2               ;		sta z80_l
003BCD  2               ;		lda z80_h
003BCD  2               ;		sbc z80_b
003BCD  2               ;		sta z80_h
003BCD  2               ;		rts
003BCD  2               ;
003BCD  2               ;cmp_hl_bc:
003BCD  2               ;		lda z80_l
003BCD  2               ;		cmp z80_c
003BCD  2               ;		bne cmp_hl_bc_end
003BCD  2               ;		lda z80_h
003BCD  2               ;		cmp z80_b
003BCD  2               ;cmp_hl_bc_end:
003BCD  2               ;		rts
003BCD  2               ;
003BCD  2               ;cmp_iy_ix:
003BCD  2               ;		lda z80_iy
003BCD  2               ;		cmp z80_ix
003BCD  2               ;		bne cmp_iy_ix_end
003BCD  2               ;		lda z80_iy+1
003BCD  2               ;		cmp z80_ix+1
003BCD  2               ;cmp_iy_ix_end:
003BCD  2               ;		rts
003BCD  2               ;
003BCD  2               ;dec_hl:
003BCD  2               ;		lda z80_l
003BCD  2               ;		bne dec_hl_no_dec_h
003BCD  2               ;		dec z80_h
003BCD  2               ;dec_hl_no_dec_h:
003BCD  2               ;		dec z80_l
003BCD  2               ;		rts
003BCD  2               ;
003BCD  2               ;dec_ix:
003BCD  2               ;		lda z80_ix
003BCD  2               ;		bne dec_ix_no_dec_h
003BCD  2               ;		dec z80_ix+1
003BCD  2               ;dec_ix_no_dec_h:
003BCD  2               ;		dec z80_ix
003BCD  2               ;		rts
003BCD  2               ;
003BCD  2               ;dec_bc:
003BCD  2               ;		lda z80_c
003BCD  2               ;		bne dec_bc_no_dec_b
003BCD  2               ;		dec z80_b
003BCD  2               ;dec_bc_no_dec_b:
003BCD  2               ;		dec z80_c
003BCD  2               ;		rts
003BCD  2               ;
003BCD  2               ;dec_de:
003BCD  2               ;		lda z80_e
003BCD  2               ;		bne dec_de_no_dec_d
003BCD  2               ;		dec z80_d
003BCD  2               ;dec_de_no_dec_d:
003BCD  2               ;		dec z80_e
003BCD  2               ;		rts
003BCD  2               ;
003BCD  2               ;ex_af_afs:
003BCD  2               ;	rts
003BCD  2               ;ex_de_hl:
003BCD  2               ;		lda z80_e
003BCD  2               ;		ldx z80_l
003BCD  2               ;		stx z80_e
003BCD  2               ;		sta z80_l
003BCD  2               ;		lda z80_d
003BCD  2               ;		ldx z80_h
003BCD  2               ;		stx z80_d
003BCD  2               ;		sta z80_h
003BCD  2               ;		rts
003BCD  2               ;
003BCD  2               exx:
003BCD  2  A5 rr        		lda z80_c
003BCF  2  A4 rr        		ldy z80_cp
003BD1  2  84 rr        		sty z80_c
003BD3  2  85 rr        		sta z80_cp
003BD5  2  A5 rr        		lda z80_b
003BD7  2  A4 rr        		ldy z80_bp
003BD9  2  84 rr        		sty z80_b
003BDB  2  85 rr        		sta z80_bp
003BDD  2  A5 rr        		lda z80_e
003BDF  2  A4 rr        		ldy z80_ep
003BE1  2  84 rr        		sty z80_e
003BE3  2  85 rr        		sta z80_ep
003BE5  2  A5 rr        		lda z80_d
003BE7  2  A4 rr        		ldy z80_dp
003BE9  2  84 rr        		sty z80_d
003BEB  2  85 rr        		sta z80_dp
003BED  2  A5 rr        		lda scraddr
003BEF  2  A4 rr        		ldy z80_lp
003BF1  2  84 rr        		sty scraddr
003BF3  2  85 rr        		sta z80_lp
003BF5  2  A5 rr        		lda scraddr+1
003BF7  2  A4 rr        		ldy z80_hp
003BF9  2  84 rr        		sty scraddr+1
003BFB  2  85 rr        		sta z80_hp
003BFD  2  60           		rts
003BFE  2               
003BFE  2               ;ex_sp_hl:
003BFE  2               ;		tsx
003BFE  2               ;		lda $0103,x
003BFE  2               ;		ldy z80_h
003BFE  2               ;		sta z80_h
003BFE  2               ;		tya
003BFE  2               ;		sta $0103,x
003BFE  2               ;		lda $0104,x
003BFE  2               ;		ldy z80_l
003BFE  2               ;		sta z80_l
003BFE  2               ;		tya
003BFE  2               ;		sta $104,x
003BFE  2               ;		rts
003BFE  2               ;
003BFE  2               ;ldi:
003BFE  2               ;	rts
003BFE  2               ;ldir:
003BFE  2               ;		ldy #$00
003BFE  2               ;		ldx z80_b
003BFE  2               ;		beq ldir_last_page
003BFE  2               ;ldir_loop:
003BFE  2               ;		lda (z80_hl),y
003BFE  2               ;		sta (z80_de),y
003BFE  2               ;		iny
003BFE  2               ;		bne ldir_loop
003BFE  2               ;		inc z80_h
003BFE  2               ;		inc z80_d
003BFE  2               ;		dex
003BFE  2               ;		bne ldir_loop
003BFE  2               ;ldir_last_page:
003BFE  2               ;		lda z80_c
003BFE  2               ;		beq ldir_end
003BFE  2               ;ldir_last_page_loop:
003BFE  2               ;		lda (z80_hl),y
003BFE  2               ;		sta (z80_de),y
003BFE  2               ;		iny
003BFE  2               ;		cpy z80_c
003BFE  2               ;		bne ldir_last_page_loop
003BFE  2               ;ldir_end:
003BFE  2               ;		stx z80_c
003BFE  2               ;		stx z80_b
003BFE  2               ;		tya
003BFE  2               ;		clc
003BFE  2               ;		adc z80_l
003BFE  2               ;		sta z80_l
003BFE  2               ;		bcc *+4
003BFE  2               ;		inc z80_h
003BFE  2               ;		tya
003BFE  2               ;		clc
003BFE  2               ;		adc z80_e
003BFE  2               ;		sta z80_e
003BFE  2               ;		bcc *+4
003BFE  2               ;		inc z80_d
003BFE  2               ;		rts
003BFE  2               ;
003BFE  2               ;lddr:		ldy #$00
003BFE  2               ;lddr_loop:
003BFE  2               ;		lda (z80_hl),y
003BFE  2               ;		sta (z80_de),y
003BFE  2               ;		jsr dec_hl
003BFE  2               ;		jsr dec_de
003BFE  2               ;		jsr dec_bc
003BFE  2               ;		lda z80_b
003BFE  2               ;		ora z80_c
003BFE  2               ;		bne lddr_loop
003BFE  2               ;		rts
003BFE  2               ;ei:
003BFE  2               ;		rts
003BFE  2               ;di:
003BFE  2               ;		rts
003BFE  2               
003BFE  2               ;-------------------------------------------------------------
003BFE  2               ; Set bits in bitmem
003BFE  2               ;-------------------------------------------------------------
003BFE  2               
003BFE  2               .if 0
003BFE  2               z80_init:
003BFE  2               	ldx #$00
003BFE  2               	lda #$01
003BFE  2               z80_init_loop:
003BFE  2               	sta _bitmem0,x
003BFE  2               	inx
003BFE  2               	asl a
003BFE  2               	bne z80_init_loop
003BFE  2               	rts
003BFE  2               .endif
003BFE  2               
003BFE  2               push_af:
003BFE  2               push_bc:
003BFE  2               push_de:
003BFE  2               push_hl:
003BFE  2               
003BFE  2               pop_af:
003BFE  2               pop_bc:
003BFE  2               pop_de:
003BFE  2               pop_ix:
003BFE  2               pop_hl:
003BFE  2               
003BFE  2               add_hl_hl:
003BFE  2               
003BFE  2               inc_bc:
003BFE  2               inc_de:
003BFE  2               inc_hl:
003BFE  2               inc_ix:
003BFE  2               inc_sp:
003BFE  2               
003BFE  2               cpir:
003BFE  2               
003BFE  2               ex_af_af:
003BFE  2               ;	rts
003BFE  2               
003BFE  1               
003BFE  1               eind_asm:
003BFE  1               eop:					; End Of Program
003BFE  1               
003BFE  1               .out .sprintf("Gamecode size = %d bytes, free space = %d bytes", (eind_asm - main),(24576-eind_asm + main))
003BFE  1               
